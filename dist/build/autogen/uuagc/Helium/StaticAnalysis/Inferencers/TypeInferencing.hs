{-# LANGUAGE Rank2Types, GADTs #-}
{-# LANGUAGE BangPatterns #-}
{-# LANGUAGE ScopedTypeVariables #-}

module Helium.StaticAnalysis.Inferencers.TypeInferencing where

import Helium.Syntax.UHA_Utils



import Data.List
import Helium.StaticAnalysis.Directives.Matchers
import Helium.StaticAnalysis.Directives.TS_Apply (applyTypingStrategy, matchInformation)
import Helium.StaticAnalysis.Directives.TS_CoreSyntax
import Helium.StaticAnalysis.Directives.TS_Attributes



import Top.Constraint.Qualifier



-- types
import Top.Types
import Helium.StaticAnalysis.Miscellaneous.TypeConversion

-- error messages and warnings
import Helium.StaticAnalysis.Messages.Messages
import Helium.StaticAnalysis.Messages.TypeErrors
import Helium.StaticAnalysis.Messages.Warnings
import Helium.StaticAnalysis.Miscellaneous.ConstraintInfo
import Helium.StaticAnalysis.Miscellaneous.DoublyLinkedTree
import Helium.StaticAnalysis.Miscellaneous.UHA_Source

-- constraints and constraint trees
import Helium.StaticAnalysis.Miscellaneous.TypeConstraints
import Top.Ordering.Tree

-- constraint solving

import Helium.StaticAnalysis.Inferencers.SelectConstraintSolver (selectConstraintSolver)
import Top.Solver (SolveResult(..), LogEntries)
import Helium.StaticAnalysis.Heuristics.HeuristicsInfo (makeUnifier, skip_UHA_FB_RHS)
import Helium.StaticAnalysis.Inferencers.BindingGroupAnalysis
import Helium.StaticAnalysis.Miscellaneous.TypeConstraints()

-- UHA syntax
import Helium.Syntax.UHA_Syntax
import Helium.Syntax.UHA_Range                
         
-- other

import Helium.Utils.Utils (internalError, hole)
import Helium.Utils.QualifiedTypes
import Helium.Utils.QualifiedTypes.Constants
import Helium.ModuleSystem.ImportEnvironment  hiding (setTypeSynonyms)
import Helium.ModuleSystem.DictionaryEnvironment
import Helium.Main.Args

-- standard
import qualified Data.Map as M
import Data.Maybe 
import Control.Monad.Identity (Identity)
import qualified Control.Monad.Identity

pmError :: String -> String -> a
pmError = internalError "PatternMatchWarnings"


expandTypeFromImportEnvironment :: ImportEnvironment -> Tp -> Tp
expandTypeFromImportEnvironment env = expandType (snd $ getOrderedTypeSynonyms env)

patternMatchWarnings :: Substitution substitution
                     => ImportEnvironment          -- the importenvironment
                     -> substitution               -- substitution that contains the real types
                     -> Tp                         -- type of the patterns, unsubstituted
                     -> (Tp -> Tps)                -- how should the type be interpreted?
                     -> [([PatternElement], Bool)] -- the patterns to be processed
                     -> Range                      -- range for the missing-warnings
                     -> Maybe Name                 -- maybe the name of the function
                     -> Bool                       -- should there be parentheses around the patterns?
                     -> [Warning]                  -- list of overlap-warnings for all of the patterns  
                     -> String                     -- description of the place where the patterns are
                     -> String                     -- symbol after the patterns
                     -> [Warning]                  -- returns: list of warnings
patternMatchWarnings impenv sub tp strip elementss rng name parens unrwars place sym
  = unreachablewarnings ++ missingwarnings
    where
      env                 = importEnvironmentToEnv impenv
      exprtype            = expandTypeFromImportEnvironment impenv $ sub |-> tp
      types               = strip exprtype
      unreachables        = unreachable impenv types $ map (\((a, _), c) -> (a, c)) $ filter (not.snd.fst) $ zip elementss [0..]
      missing             = complement  impenv types $ map fst elementss
      unreachablewarnings = map (unrwars !!) unreachables
      missingwarnings
        | null $ unMissing missing = []
        | otherwise                = [MissingPatterns rng name exprtype (map (nicePattern parens env) $ missingList missing) place sym]



----------
-- misc --
----------

-- lifted or
(|^|) :: (a -> Bool) -> (a -> Bool) -> a -> Bool
(|^|) f g x = f x || g x

----------------------------------------------
--- environments and substitution of types ---
----------------------------------------------

-- environment of constructors [(type, (constructorname, arguments))]
type Env = [(Tp, (Name, [Tp]))]

importEnvironmentToEnv :: ImportEnvironment -> [(Tp, (Name, [Tp]))]
importEnvironmentToEnv = map rearrange . M.assocs .toSchemeMap . valueConstructors
  where
    toSchemeMap = M.map (\(_, scheme) -> scheme)

-- return the number of arguments of a constructor
-- tuples ar not in the Env so they require special treatment
nrOfArguments :: Env -> String -> Int
nrOfArguments env con | isTupleConstructor con = length con - 1
                      | otherwise = case lookup (nameFromString con) $ map snd env
                                    of Just args -> length args
                                       Nothing   -> 0

-- convert constructor to fit in an Env
rearrange :: (Name, TpScheme) -> (Tp, (Name, [Tp]))
rearrange (name, tpscheme) = let (args, res) = functionSpine $ unqualify $ unquantify tpscheme
                             in (res, (name, args))

-- get the constructors of a given type out of an Env
-- tuples ar not in the Env so they require special treatment
constructors :: ImportEnvironment -> Tp -> [(Name, [Tp])]
constructors _ (TVar _) = []
constructors impenv tp | isTupleConstructor name = [tupleconstructor]
                       | otherwise               = (map expand . removeDoubles . removeQual . concatMap (substitute tp) . importEnvironmentToEnv) impenv
  where
    name :: String
    name = unTCon $ fst $ leftSpine tp
    tupleconstructor :: (Name, [Tp])
    tupleconstructor = (nameFromString name, snd $ leftSpine tp)
    unTCon :: Tp -> String
    unTCon (TCon c) = c
    unTCon tp' = show tp'
    expand :: (Name, [Tp]) -> (Name, [Tp])
    expand (n, ts) = (n, map (expandTypeFromImportEnvironment impenv) ts)

    removeQual :: [(Name, [Tp])] -> [(Name, [Tp])]
    removeQual = map (\(n,tps) -> (addQualified [] n, tps))

    removeDoubles :: [(Name, [Tp])] -> [(Name, [Tp])]
    removeDoubles = nubBy (\(x,_) (y,_) -> x == y)

-- check of an entry in an Env is a constructor for the given type
-- if so, return this constructor, but with variables substituted for whatever is in the given type
-- the list returns zero or one elements
-- for example: substitute (Maybe Int) (Maybe a, (Just, [a])) will return [(Just, [Int])]
substitute :: Tp -> (Tp, (Name, [Tp])) -> [(Name, [Tp])]
substitute t1 (t2, (con, args)) = let (c1, ts1) = leftSpine t1
                                      (c2, ts2) = leftSpine t2
                                      sub = listToSubstitution $ zip (map unTVar ts2) ts1
                                  in if c1 == c2
                                     then [(con, map (sub |->) args)]
                                     else []
  where
    unTVar :: Tp -> Int
    unTVar (TVar v) = v
    unTVar _ = pmError "unTVar" "type is not a TVar"

---------------------------------------------------------------
--- datastructures and functions for the solution structure ---
---------------------------------------------------------------

-- a pattern is a list of patternelements
data PatternElement = WildcardElement | InfiniteElement String | FiniteElement String deriving Eq
isInfiniteElement :: PatternElement -> Bool
isInfiniteElement (InfiniteElement _) = True
isInfiniteElement _                   = False
elementString :: PatternElement -> String
elementString (InfiniteElement s) = s
elementString (  FiniteElement s) = s
elementString _                   = []

-- needed for Pattern_List and Literal_String occurences
listPat :: [[PatternElement]] -> [PatternElement]
listPat [] = [FiniteElement "[]"]
listPat (ps:pss) = FiniteElement ":" : ps ++ listPat pss

stringPat :: String -> [PatternElement]
stringPat [] = [FiniteElement "[]"]
stringPat (c:cs) = FiniteElement ":" : InfiniteElement [c] : stringPat cs

-- tree of missing patterns
data PatternsMissing = PatternsMissing [(PatternElement, PatternsMissing)]
unMissing :: PatternsMissing -> [(PatternElement, PatternsMissing)]
unMissing (PatternsMissing l) = l

-- create a branch consisting of only wildcards
wildMissing :: Int -> PatternsMissing
wildMissing 0 = PatternsMissing []
wildMissing n = PatternsMissing [(WildcardElement, wildMissing $ n - 1)]

-- convert a missing patterns tree to a list of seperated missing patterns
missingList :: PatternsMissing -> [[PatternElement]]
missingList (PatternsMissing []) = [[]]
missingList (PatternsMissing [(d,t)]) = map (d:) $ missingList t
missingList (PatternsMissing (d:ds)) = (missingList $ PatternsMissing [d]) ++ (missingList $ PatternsMissing ds)

-------------------------------------------------------------------
--- functions to create a UHA_Pattern out of a [PatternElement] ---
-------------------------------------------------------------------

-- nice creates the actual pattern without parentheses
-- [Just, True, True, (,), Just, Nothing, False] -> [Just True, True, (Just Nothing, False)]
nicePattern :: Bool -> Env -> [PatternElement] -> [Pattern]
nicePattern b env = map (parensPattern b) . nice
  where
    nice :: [PatternElement] -> [Pattern]
    nice []             = []
    nice (WildcardElement    :ps) = Pattern_Wildcard noRange : nice ps
    nice (InfiniteElement _  :_) = pmError "nicePattern" "InfiniteElement in pattern!"
    nice (FiniteElement con:ps) =
      let rest = nice ps
          name = nameFromString con
          n    = nrOfArguments env con
      in case name 
         of Name_Identifier _ _ _ _                          -> Pattern_Constructor noRange name (take n rest) : drop n rest -- !!!Name
            Name_Operator   _ _ _ _ | con == ":"             -> case head $ tail rest -- !!!Name
                                                                of Pattern_List _ pats -> Pattern_List noRange (head rest:pats) : (tail $ tail rest)
                                                                   _ -> Pattern_InfixConstructor noRange (head rest) name (head $ tail rest) : (tail $ tail rest)
                                    | otherwise              -> Pattern_InfixConstructor noRange (head rest) name (head $ tail rest) : (tail $ tail rest)
            Name_Special    _ _ _ _ | isTupleConstructor con -> Pattern_Tuple noRange (take n rest) : drop n rest -- !!!Name
                                    | con == "[]"            -> Pattern_List  noRange [] : rest
                                    | otherwise              -> Pattern_Constructor noRange name (take n rest) : drop n rest

-- add parentheses to a pattern in the correct places
-- bool means: if needed, should there be parenthesis around the complete pattern?
parensPattern :: Bool -> Pattern -> Pattern
parensPattern b = if b then rap . par else fst . par
  where
    par :: Pattern -> (Pattern, Bool) -- Bool means: are parentheses needed around this pattern, shoud it be used in a more complex pattern
    par p@(Pattern_Literal          _ _    ) = (p, False)
    par p@(Pattern_Variable         _ _    ) = (p, False)
    par   (Pattern_Constructor      r n ps ) = (Pattern_Constructor r n $ map (rap.par) ps, length ps > 0)
    par   (Pattern_Parenthesized    _ p    ) = par p
    par   (Pattern_InfixConstructor r l n k) = (Pattern_InfixConstructor r (rap $ par l) n (rap $ par k), True)
    par   (Pattern_List             r ps   ) = (Pattern_List r $ map (fst.par) ps, False)
    par   (Pattern_Tuple            r ps   ) = (Pattern_Tuple r $ map (fst.par) ps, False)
    par   (Pattern_Record           _ _ _  ) = pmError "parensPattern" "Records are not supported" 
    par p@(Pattern_Negate           _ _    ) = (p, True)
    par p@(Pattern_NegateFloat      _ _    ) = (p, True)
    par   (Pattern_As               r n p  ) = (Pattern_As r n (rap $ par p), False)
    par p@(Pattern_Wildcard         _      ) = (p, False)
    par   (Pattern_Irrefutable      _ _    ) = pmError "parensPattern" "Irrefutable patterns are not supported"  
    par   (Pattern_Successor        _ _ _  ) = pmError "parensPattern" "Successors are not supported" 
    par   (Pattern_Hole             _ _    ) = error "not supported"
    rap :: (Pattern, Bool) -> Pattern
    rap (p, False) = p
    rap (p, True ) = Pattern_Parenthesized noRange p

--------------------------------------
--- finally, the algorithm itself! ---
--------------------------------------

-- returns the tree of missing patterns for a given list of patterns    
complement :: ImportEnvironment -> [Tp] -> [[PatternElement]] -> PatternsMissing
complement _   []       _      = PatternsMissing []
complement _   _        ([]:_) = PatternsMissing []
complement env (tp:tps) pss    | null $ unMissing anyComplement                              = PatternsMissing []
                               | all (((== WildcardElement) |^| isInfiniteElement).head) pss = anyComplement
                               | otherwise                                                   = finComplement
  where
    patComplement :: [[PatternElement]] -> PatternElement -> [Tp] -> PatternsMissing
    patComplement []  current typs = PatternsMissing [(current, wildMissing $ length typs)]
    patComplement patss current typs = case unMissing $ complement env typs $ map tail $ patss
                                    of []   -> PatternsMissing []
                                       tegs -> PatternsMissing [(current, PatternsMissing tegs)]
    anyComplement :: PatternsMissing
    anyComplement = patComplement (filter ((== WildcardElement).head) pss) WildcardElement tps
    conComplement :: (Name, [Tp]) -> PatternsMissing
    conComplement (con, args) = patComplement (  filter ((== FiniteElement (getOnlyName con)).head) pss
                                              ++ map (\ps -> FiniteElement (getOnlyName con) : replicate (length args) WildcardElement ++ tail ps)
                                                     (filter ((== WildcardElement).head) pss)
                                              )
                                              (FiniteElement (getOnlyName con)) (args ++ tps)
    finComplement :: PatternsMissing
    finComplement = case constructors env tp
                    of []   -> wildMissing $ 1 + length tps
                       cons -> PatternsMissing $ concatMap (unMissing.conComplement) cons

----------------------------
--- unreachable patterns ---
----------------------------

-- complements the list of reachable patterns
unreachable :: ImportEnvironment -> [Tp] -> [([PatternElement], Int)] -> [Int]
unreachable env tps ps = let reach = reachable env tps ps
                         in  filter (not . flip elem reach) (map snd ps)

-- determines which patterns are reachable
-- possibly multiple occurances of indices
reachable :: ImportEnvironment -> [Tp] -> [([PatternElement], Int)] -> [Int]
reachable _   []       _  = []
reachable env (tp:tps) ps 
  | all ((== WildcardElement).head.fst) ps = conReachable ps
  | otherwise                              = concat $ map (conReachable.conPats) $ stop cons
  where
    cons :: [PatternElement]
    cons = thin $ map (head.fst) ps
    conPats :: PatternElement -> [([PatternElement], Int)]
    conPats con = map (\(es, i) -> (fill con es, i)) $ filter (((== con) |^| (== WildcardElement)).head.fst) ps
    fill :: PatternElement -> [PatternElement] -> [PatternElement]
    fill e@(FiniteElement c) (WildcardElement : es) = e : replicate (nrOfArguments (importEnvironmentToEnv env) c) WildcardElement ++ es
    fill e                   (_               : es) = e : es
    fill _                   []                     = error "Pattern match failure in StaticAnalysis.Inferencers.reachable" 
    stop :: [PatternElement] -> [PatternElement]
    stop es | length (constructors env tp) > length es = FiniteElement "[*]" : es
            | length (constructors env tp) == 0        = FiniteElement "[*]" : es
            | otherwise                                = es
    conReachable :: [([PatternElement], Int)] -> [Int]
    conReachable [] = []
    conReachable pats 
      | null.tail.fst.head $ pats = [snd.head $ pats]
      | otherwise                 = reachable env (arguments (elementString.head.fst.head $ pats) ++ tps) 
                                            $ map (\(es, i) -> (tail es, i)) pats
    arguments :: String -> [Tp]
    arguments c = maybe [] id $ lookup c $ map (\(n, typs) -> (getOnlyName n, typs)) $ constructors env tp

-- remove double occurances and wildcards
thin :: [PatternElement] -> [PatternElement]
thin []                     = []
thin (WildcardElement : es) = thin es
thin (e               : es) | elem e thines =     thines
                            | otherwise     = e : thines
  where thines = thin es                            
                       


matchConverter0 :: [([String],())] -> ()
matchConverter0 = const ()

matchConverter1 :: [([String],a)] -> [(a,[String])]
matchConverter1 = map (\(a,b) -> (b,a))  
                  
matchConverter2 :: [([String],(a,b))] -> ([(a,[String])],[(b,[String])])
matchConverter2 = let localInsert (metas,(a,b)) (as,bs) = ((a,metas):as,(b,metas):bs)
                  in foldr localInsert ([],[])                  

matchConverter3 :: [([String],(a,b,c))] -> ([(a,[String])],[(b,[String])],[(c,[String])])
matchConverter3 = let localInsert (metas,(a,b,c)) (as,bs,cs) = ((a,metas):as,(b,metas):bs,(c,metas):cs)
                  in foldr localInsert ([],[],[]) 

allMatch :: [Maybe [a]] -> Maybe [a]
allMatch = rec_ []
  where rec_ xs []             = Just xs
        rec_ _  (Nothing:_)    = Nothing
        rec_ xs (Just ys:rest) = rec_ (ys ++ xs) rest

data Match a = NoMatch | NonTerminalMatch a | MetaVariableMatch String

instance Show (Match a) where
  show (NoMatch) = "NoMatch"
  show (NonTerminalMatch _) = "NonTerminal ??"
  show (MetaVariableMatch s) = "MetaVariableMatch "++show s

expressionVariableMatcher :: Expression -> Maybe String
expressionVariableMatcher expr =
   case expr of
      Expression_Variable _ name -> Just (show name)
      _                          -> Nothing

match0 :: MetaVariableInfo -> Int -> (Expression -> Maybe ())
         -> [(Expression, [String])]
         -> [((Expression, [String]), Core_TypingStrategy)]
         -> [[Maybe MetaVariableTable]]
         -> ((), [Maybe MetaVariableTable], ConstraintSet, Assumptions, Int, IO ())      
match0 = generalMatch expressionVariableMatcher matchConverter0

match1 :: MetaVariableInfo -> Int -> (Expression -> Maybe a)
         -> [(Expression, [String])]
         -> [((Expression, [String]), Core_TypingStrategy)]
         -> [[Maybe MetaVariableTable]]
         -> ([(a, [String])], [Maybe MetaVariableTable],
             ConstraintSet, Assumptions, Int, IO ())
match1 = generalMatch expressionVariableMatcher matchConverter1

match2 :: MetaVariableInfo -> Int -> (Expression -> Maybe (a, b))
         -> [(Expression, [String])]
         -> [((Expression, [String]), Core_TypingStrategy)]
         -> [[Maybe MetaVariableTable]]
         -> (([(a, [String])], [(b, [String])]), [Maybe MetaVariableTable],
             ConstraintSet, Assumptions, Int, IO ())
match2 = generalMatch expressionVariableMatcher matchConverter2

match3 :: MetaVariableInfo -> Int -> (Expression -> Maybe (a, b, c))
        -> [(Expression, [String])]
        -> [((Expression, [String]), Core_TypingStrategy)]
        -> [[Maybe MetaVariableTable]]
        -> (([(a, [String])], [(b, [String])], [(c, [String])]),
            [Maybe MetaVariableTable], ConstraintSet,
            Assumptions, Int, IO ())
match3 = generalMatch expressionVariableMatcher matchConverter3

match0' :: (a -> Maybe ()) -> [(a, [String])]
         -> [((a, [String]), Core_TypingStrategy)]
         -> [[Maybe MetaVariableTable]]
         -> ((), [Maybe MetaVariableTable], ConstraintSet,
             Assumptions, Int, IO ())
match0' = generalMatch noMatch matchConverter0 noMetaVariableInfo 0

match1' :: (a -> Maybe b) -> [(a, [String])]
         -> [((a, [String]), Core_TypingStrategy)]
         -> [[Maybe MetaVariableTable]] -> 
            ([(b, [String])], [Maybe MetaVariableTable],
             ConstraintSet, Assumptions, Int, IO ())
match1' = generalMatch noMatch matchConverter1 noMetaVariableInfo 0

match2' :: (n -> Maybe (a, b)) -> [(n, [String])]
         -> [((n, [String]), Core_TypingStrategy)]
         -> [[Maybe MetaVariableTable]]
         -> (([(a, [String])], [(b, [String])]),
             [Maybe MetaVariableTable], ConstraintSet, Assumptions, Int, IO ())
match2' = generalMatch noMatch matchConverter2 noMetaVariableInfo 0

matchOnlyVariable :: MetaVariableInfo -> [(Expression, [String])] -> [Maybe MetaVariableTable]
matchOnlyVariable infoTuple tryPats = 
       let ((),matches,_,_,_,_) = match0 infoTuple 0 noMatch tryPats [] []
   in matches

noMatch :: a -> Maybe b
noMatch = const Nothing

noMetaVariableInfo :: a
noMetaVariableInfo = internalError "PatternMatching.ag" "noMetaVariableInfo" ""

generalMatch :: (nonTerminal -> Maybe String) 
             -> ([([String], childrenTuple)] -> childrenResult)
             -> MetaVariableInfo
             -> Int
             -> (nonTerminal -> Maybe childrenTuple) 
             -> [(nonTerminal, [String])] 
             -> [((nonTerminal, [String]), Core_TypingStrategy)] 
             -> [[Maybe MetaVariableTable]] 
             -> ( childrenResult
                , [Maybe MetaVariableTable]
                , ConstraintSet
                , Assumptions
                , Int
                , IO ()
                )

generalMatch exprVarMatcher converter metaInfo unique matcher tryPats allPats childrenResults =
   let match (expr,metas) = 
          case exprVarMatcher expr of
             Just s | s `elem` metas -> MetaVariableMatch s
             _ -> case matcher expr of
                     Just x  -> NonTerminalMatch (metas,x)
                     Nothing -> NoMatch
           
       (allPatterns, allStrategies) = unzip allPats
       matchListTry = map match tryPats
       matchListNew = map match allPatterns
       
       matchNTTry  = [ x | NonTerminalMatch x <- matchListTry ]
       matchNTNew  = [ x | NonTerminalMatch x <- matchListNew ]
       forChildren = converter (matchNTTry ++ matchNTNew)
       
       numberOfTry = length matchNTTry
       (resultTry,resultNew) = unzip . map (splitAt numberOfTry) $ 
                               if null childrenResults
                                 then [repeat (Just [])]
                                 else childrenResults
       inspectMatch m (res, nts) =
          case m of
             NoMatch             -> (Nothing:res, nts)
             NonTerminalMatch _  -> (allMatch (head nts):res, tail nts)
             MetaVariableMatch s -> (Just [(s, metaInfo)]:res, nts) --  !!!
       
       result   = fst (foldr inspectMatch ([],reverse $ transpose resultTry) matchListTry)       
       complete = let (list,_) = foldr inspectMatch ([],reverse $ transpose resultNew) matchListNew
                  in [ (x, y) | (Just x, y) <- zip list allStrategies ]

       (assumptions, constraintSet, debugIO, newUnique) = 
          case complete of
          
             [] -> (getAssumptions metaInfo, getConstraintSet metaInfo, return (), unique)
             
             (childrenInfo, typingStrategy):_ 
                -> applyTypingStrategy typingStrategy metaInfo childrenInfo unique            
   in (forChildren, result, constraintSet, assumptions, newUnique, debugIO)

                  
type ScopeInfo = ( [Names]          -- duplicated variables
                 , [Name]           -- unused variables
                 , [(Name, Name)]   -- shadowed variables
                 )

changeOfScope :: Names -> Names -> Names -> (Names, Names, ScopeInfo)
changeOfScope names unboundNames namesInScope = 
   let (uniqueNames, duplicatedNames) = uniqueAppearance names
       unusedNames   = uniqueNames \\ unboundNames
       shadowedNames = let f n = [ (n, n') | n' <- namesInScope, n == n' ]
                       in concatMap f uniqueNames
   in ( uniqueNames ++ map head duplicatedNames ++ (namesInScope \\ names)
      , unboundNames \\ names
      , (duplicatedNames, unusedNames, shadowedNames)
      )
      
uniqueAppearance :: Ord a => [a] -> ([a],[[a]])
uniqueAppearance = Prelude.foldr myInsert ([],[]) . group . sort
   where myInsert [x] (as,bs) = (x:as,bs)
         myInsert xs  (as,bs) = (as,xs:bs)

mergeSameOriginName :: [Name] -> [Name]
mergeSameOriginName = map head
                   . groupBy eq 
                   . sortBy comp
    where
        comp x y = case compare x y of
            EQ -> compare (getNameOrigin x) (getNameOrigin y)
            cp -> cp
        eq   x y = x == y && (getNameOrigin x) == (getNameOrigin y)
       
nextUnique :: Num a => a -> (a, a)         
nextUnique n = (n+1, n)

includeQualifiedName :: [String] -> Name -> [Name]
includeQualifiedName qual n = addQualified qual n : [n]

getClassMemberNames :: Name -> M.Map Name (Names, [(Name, TpScheme, Bool, HasDefault)]) -> [Name]
getClassMemberNames name env =  let err = internalError "Scope.ag" "getClassMemberNames" $ "Unknown class in environment: " ++ show name
                                in maybe err (map (\(fn, _, _, _) -> fn) . snd) (M.lookup name env)


globalInfoError :: a
globalInfoError = internalError "GlobalInfo.ag" "n/a" "global info not available"


findInferredTypes :: M.Map Int (Scheme Predicates) -> M.Map Name (Sigma Predicates) -> TypeEnvironment
findInferredTypes typeschemeMap =
   let err i = internalError "TypeInferenceCollect.ag" "findInferredTypes" ("could not find type scheme variable " ++ show (i) ++ " in " ++ show typeschemeMap)
       f :: Sigma Predicates -> TpScheme
       f (SigmaVar i)     = M.findWithDefault (err i) i typeschemeMap
       f (SigmaScheme ts) = ts
   in M.map f

missingTypeSignature :: Bool -> Names -> TypeEnvironment -> ImportEnvironment -> Warnings
missingTypeSignature topLevel simplePats typeenv importEnvironment =
   let -- for the moment, only missing type signature for top-level functions are reported (unless monomorphic).
      makeWarning (name, scheme) =
         let  fromSimple = name `elem` simplePats && isOverloaded scheme
              classFunctions = map (\(n, _, _, _)->n) $ concatMap (snd.snd) $ M.toList $ classMemberEnvironment importEnvironment
         in [ NoTypeDef name scheme topLevel fromSimple 
              | null (ftv scheme) 
              && (topLevel || fromSimple) 
              && (not topLevel || not (name `elem` classFunctions))]
   in concatMap makeWarning . M.assocs $ typeenv

restrictedNameErrors :: ImportEnvironment -> TypeEnvironment -> Names -> TypeErrors
restrictedNameErrors ienv tenv =
   let f name = case M.lookup name tenv of
                   Just scheme -> [ makeRestrictedButOverloadedError name (convertTpScheme (unQualifyName ienv) scheme) | isOverloaded scheme ]
                   Nothing     -> []
   in concatMap f

notQualifiedWarnings :: Warning -> Bool
notQualifiedWarnings (NoTypeDef name _ _ _) = (not . isQualified) name
notQualifiedWarnings _                      = True

convertWarnings :: TypeConstructorEnvironment -> Warning -> Warning
convertWarnings env (NoTypeDef name tpschem b1 b2) = NoTypeDef name (unqualifyTpScheme env tpschem) b1 b2
convertWarnings env (MissingPatterns ra na tp ps str1 str2) = MissingPatterns ra na (unqualifyTp env tp) ps str1 str2
convertWarnings env (SignatureTooSpecific na tps1 tps2) = SignatureTooSpecific na (unqualifyTpScheme env tps1) (unqualifyTpScheme env tps2)
convertWarnings _ war = war



makeLocalTypeEnv :: TypeEnvironment -> BindingGroups -> M.Map NameWithRange TpScheme
makeLocalTypeEnv local groups =
   let (environment, _, _) = concatBindingGroups groups
       names = M.keys environment
       f x   = maybe (err x) id (find (==x) names)
       err x  = internalError "TypeInferenceCollect.ag" "makeLocalTypeEnv" ("could not find name " ++ show x)
   in M.fromList [ (NameWithRange (f name), scheme) | (name, scheme) <- M.assocs local ]


isSimplePattern :: Pattern -> Bool
isSimplePattern pattern =
   case pattern of
      Pattern_Variable _ _ -> True
      Pattern_Parenthesized  _ p -> isSimplePattern p
      _ -> False


updateSuperclasses :: [(Name, Tp)] -> [(String, Name)] -> Instance -> Instance
updateSuperclasses typevars supers (prd, preds) = (prd, preds ++ superPreds)
    where
      superPreds = [Predicate s tp | (s, tpss) <- supers, let tp = fromJust $ lookup tpss typevars ]

      

getSuperClassesFromClass :: ClassEnvironment -> String -> [String]
getSuperClassesFromClass classEnv className = fst $ M.findWithDefault err className classEnv 
        where err = internalError "TypeInferenceOverloading.ag" "getSuperClassenFromClass" "Invalid class name"

getRequiredDictionaries :: OrderedTypeSynonyms -> Tp -> TpScheme -> Predicates
getRequiredDictionaries synonyms useType defType =
   expandPredicates synonyms (matchTypeWithScheme synonyms useType defType)

matchTypeWithScheme :: OrderedTypeSynonyms -> Tp -> TpScheme -> Predicates
matchTypeWithScheme synonyms tp scheme =
   let (ips, itp) = split . snd . instantiate 0 . freezeFTV $ scheme
   in case mguWithTypeSynonyms synonyms itp (freezeVariablesInType tp) of
         Left _         -> []
         Right (_, sub) -> 
            let f (Predicate s typ) = Predicate s (unfreezeVariablesInType $ sub |-> typ)
            in map f ips
            
resolveOverloading :: ClassEnvironment -> Name -> [PredicateWithSource] -> [PredicateWithSource]  -> Maybe String -> Maybe Predicate ->
                         DictionaryEnvironment -> DictionaryEnvironment
resolveOverloading classEnv name availablePredicates predicates currentClass curPred dEnv =
   let maybeTrees = map (makeDictionaryTree classEnv availablePredicates currentClass curPred) predicates
   in if all isJust maybeTrees
        then addForVariable name (map fromJust maybeTrees) dEnv
    else dEnv
   
expandPredicates :: OrderedTypeSynonyms -> Predicates -> Predicates
expandPredicates synonyms = map (expandPredicate synonyms)

expandPredicate :: OrderedTypeSynonyms -> Predicate -> Predicate
expandPredicate (_, synonyms) (Predicate className tp) = Predicate className (expandType synonyms tp)

getCurrentClassPredicate :: Maybe (Name, Names) -> Tp -> Maybe TpScheme -> [Predicate] -> Maybe Predicate
getCurrentClassPredicate Nothing _ _ _ = Nothing
getCurrentClassPredicate (Just (className, typeVars)) derivedType (Just classType) _ =
    Just (Predicate (getNameName className) $ TVar tv)
    where
        tv = maybe (error "Invalid type variable") snd (find ((getNameName (chead typeVars) ==) . fst) typeVarMapping)
        typeVarMapping :: [(String, Int)]
        typeVarMapping = map (\(orig, new) -> (fromJust $ lookup orig variables, new)) varMapping
        variables = getQuantorMap classType
        varMapping = mapping (unqualify $ unquantify classType) derivedType
        mapping :: Tp -> Tp -> [(Int, Int)]
        mapping (TVar v1) (TVar v2) = [(v1, v2)]
        mapping (TCon _) (TCon _) = []
        mapping (TApp f1 a1) (TApp f2 a2) = nub (mapping f1 f2 ++ mapping a1 a2)
        mapping _ _ = error "Invalid type scheme"
getCurrentClassPredicate _ _ Nothing _ = error "Pattern match failure in getCurrentClassPredicate"    





chead :: [a] -> a
chead [x] = x
chead _   = error "Not a singleton"

appendClasses :: [(Name, TpScheme)] -> M.Map NameWithRange TpScheme -> Maybe [(Name, TpScheme)]
appendClasses typeMemberBindings allTypeSchemes = Just (map lookupScheme typeMemberBindings)
    where
        lookupScheme :: (Name, TpScheme) -> (Name, TpScheme)
        lookupScheme (n, _) = (n, fromMaybe ((fromJust $ lookup n $ map (\(NameWithRange n', t) -> (n', t)) $ M.toList allTypeSchemes)) $ M.lookup (NameWithRange n) (allTypeSchemes))

getSuperClasses ::  ContextItems -> [(String, Name)]
getSuperClasses = map (\(ContextItem_ContextItem _ n vs) -> (getNameName n, var vs))
    where
        var [vs] = name $ namesInType vs
        var _ = error "Type variable not a single type"
        name [n] = n
        name _ = error "Type variable not a single name"


addPredicatesToTpScheme :: [(String, Name)] -> TpScheme -> TpScheme
addPredicatesToTpScheme preds (Quantification (nrs, theMap, q)) =
    Quantification (nrs, theMap, foldr addPredicate q preds)
    where
        addPredicate :: (String, Name) -> QType -> QType
        addPredicate (className, var) qtype = let
            (prds, tp) = split qtype
            prd = Predicate className (maybe (error "Undefined type variable") (TVar . fst) $ find (\n -> snd n == getNameName var) theMap)
            in (prd : prds) .=>. tp

constructDictionaryName :: Name -> String -> Name
constructDictionaryName (Name_Identifier range modules origin name) s = 
      Name_Identifier range modules origin ("($dict" ++ name ++ "$" ++ s ++ ")")    
constructDictionaryName _ _ = error "<unforseen situation in constructDictionaryName>"

classVariablesToBeta :: Int -> Names -> [(Name, Tp)]
classVariablesToBeta _ [] = []
classVariablesToBeta c (n:ns) = (n, TVar c) : classVariablesToBeta (c + 1) ns

substituteClassVariables    :: TpScheme -- ^ The type which has to substituted
                            -> Name     -- ^ The type variable of the class
                            -> Tp       -- ^ The beta which has to be placed in place
                            -> TpScheme
substituteClassVariables tps classVariable beta = ntps
    where
        unqual = unquantify tps 
        ntps = quantify (map fst nqmap) ntp
        ntp = substitution |-> unqual
        nqmap = filter (\x -> snd x /= cvString ) qmap
        qmap = getQuantorMap tps
        cvString = getNameName classVariable
        substitution = listToSubstitution [(numb, beta) | (numb, tvar) <- qmap, tvar == cvString]


matchClassDefinitionToInstanceDefinition :: [(Name, TpScheme)] -> [(Name, Tp)] -> [(Name, TpScheme, Tp)]
matchClassDefinitionToInstanceDefinition classMember insMember = catMaybes $ map combineMember insMember
    where
        combineMember :: (Name, Tp) -> Maybe (Name, TpScheme, Tp)
        combineMember (name, tp) = 
                case lookup name classMember of
                    Nothing -> Nothing
                    Just tps -> Just (name, tps, tp)

getClassTypeVariables :: (Names, a) -> Names
getClassTypeVariables = fst

getClassFunctions :: (Names, [(Name, TpScheme, Bool, HasDefault)]) -> [(Name, TpScheme, Bool, HasDefault)]
getClassFunctions = snd

selectClass :: ImportEnvironment -> Name -> (Names, [(Name, TpScheme, Bool, HasDefault)])
selectClass env name =  let err = internalError "TypeInferenceRules.ag" "selectClass" "Specified class could not be found"
                        in M.findWithDefault err name (classMemberEnvironment env)

getInstanceMembers :: ImportEnvironment -> (Name, Tp) -> (Names, [(String, String)])
getInstanceMembers env (name, instType) =   let err = internalError "TypeInferenceRules.ag" "getInstanceMembers" "Specified instance could not be found"
                                in fromMaybe err $ findInMap (\(iname, tv) _ -> name == iname && (instanceEq tv instType)) (instanceEnvironment env)

findInMap :: (k -> a -> Bool) -> M.Map k a -> Maybe a
findInMap f m = let filtered = M.filterWithKey f m
                in if length filtered == 1 then
                        Just $ snd $ chead (M.toList filtered)
                    else
                        Nothing

instanceEq :: Tp -> Tp -> Bool
instanceEq (TCon c1) (TCon c2) = c1 == c2
instanceEq (TVar _) (TVar _) = True
instanceEq (TVar _) (TCon "???") = True
instanceEq (TCon "???") (TVar _) = True
instanceEq (TApp f1 a1) (TApp f2 a2) = instanceEq f1 f2 && instanceEq a1 a2
instanceEq _            _            = False


getInstanceFunctions :: (Instance, Types, [(Name, TpScheme)]) -> [(Name, TpScheme)]
getInstanceFunctions (_, _, funcs) = funcs

convertTypeError :: (Name -> Name) -> TypeError -> TypeError
convertTypeError f (TypeError ran theLines table hints) = 
   let newtab = map (\(b, block1, block2) -> (b, changeMessageBlock f block1, changeMessageBlock f block2)) table
       newlines = map (changeMessageLine f) theLines
       newhints = map (\(str, block) -> (str, changeMessageBlock f block)) hints
   in TypeError ran newlines newtab newhints

changeMessageLine :: (Name -> Name) -> MessageLine -> MessageLine
changeMessageLine f (MessageOneLiner block) = MessageOneLiner (changeMessageBlock f block)
changeMessageLine f (MessageTable table) = MessageTable $ map (\(indent, block1, block2) -> (indent, changeMessageBlock f block1, changeMessageBlock f block2)) table
changeMessageLine f (MessageHints str blocks) = MessageHints str (map (changeMessageBlock f) blocks)

changeMessageBlock :: (Name -> Name) -> MessageBlock -> MessageBlock
changeMessageBlock f (MessageType tps) = MessageType (convertTpScheme f tps)
changeMessageBlock f (MessagePredicate (Predicate str tp)) = MessagePredicate (Predicate str (convertTp f tp))
changeMessageBlock f (MessageCompose blocks) = MessageCompose (map (changeMessageBlock f) blocks)
changeMessageBlock _ block = block


typeInferencing :: [Option] -> ImportEnvironment -> Module
                      -> (IO (), DictionaryEnvironment, TypeEnvironment, TypeErrors, Warnings)
typeInferencing options importEnv module_ =
   let res = wrap_Module (sem_Module module_) Inh_Module {
                 importEnvironment_Inh_Module = importEnv,
                 options_Inh_Module = options }
       debugIO = putStrLn (show $ logEntries_Syn_Module res)
   in (debugIO, dictionaryEnvironment_Syn_Module res, toplevelTypes_Syn_Module res, typeErrors_Syn_Module res, warnings_Syn_Module res)

proximaTypeInferencing :: [Option] -> ImportEnvironment -> Module
                      -> (TypeErrors, Warnings, TypeEnvironment, [(Range, TpScheme)])  
proximaTypeInferencing options importEnv module_ =
   let res = wrap_Module (sem_Module module_) Inh_Module {
                 importEnvironment_Inh_Module = importEnv,
                 options_Inh_Module = options }
       localTypeSchemes = typeSchemesInInfoTree (substitutionFromResult $ solveResult_Syn_Module res)
                                                (qualifiersFromResult $ solveResult_Syn_Module res) 
                                                (infoTree_Syn_Module res)
   in (typeErrors_Syn_Module res, warnings_Syn_Module res, toplevelTypes_Syn_Module res, localTypeSchemes)
-- Alternative -------------------------------------------------
-- wrapper
data Inh_Alternative  = Inh_Alternative { allPatterns_Inh_Alternative :: !([((Expression, [String]), Core_TypingStrategy)]), allTypeSchemes_Inh_Alternative :: !(M.Map NameWithRange TpScheme), ambiguousConflicts_Inh_Alternative :: !([[Name]]), availablePredicates_Inh_Alternative :: !([PredicateWithSource]), betaLeft_Inh_Alternative :: !(Tp), betaRight_Inh_Alternative :: !(Tp), betaUnique_Inh_Alternative :: !(Int), classEnvironment_Inh_Alternative :: !(ClassEnvironment), classMemberEnv_Inh_Alternative :: !(ClassMemberEnvironment), classMemberTypeSchemes_Inh_Alternative :: !(Maybe [(Name, TpScheme)]), classNamesEnv_Inh_Alternative :: !(ClassNameEnvironment), classPredicate_Inh_Alternative :: !(Maybe (Name, Names)), classTypeSchemes_Inh_Alternative :: !(M.Map Name TpScheme), collectErrors_Inh_Alternative :: !(TypeErrors), collectWarnings_Inh_Alternative :: !(Warnings), counter_Inh_Alternative :: !(Int), curClassPred_Inh_Alternative :: !(Maybe Predicate), curPred_Inh_Alternative :: !(Maybe Predicate), currentChunk_Inh_Alternative :: !(Int), dictionaryEnvironment_Inh_Alternative :: !(DictionaryEnvironment), importEnvironment_Inh_Alternative :: !(ImportEnvironment), instanceName_Inh_Alternative :: !(Maybe Name), instanceTypes_Inh_Alternative :: !([(Name, TpScheme)]), matchIO_Inh_Alternative :: !(IO ()), moduleName_Inh_Alternative :: !(Maybe Name), monos_Inh_Alternative :: !(Monos), namesInScope_Inh_Alternative :: !(Names), orderedTypeSynonyms_Inh_Alternative :: !(OrderedTypeSynonyms), parentTree_Inh_Alternative :: !(InfoTree), patternMatchWarnings_Inh_Alternative :: !([Warning]), requiredPredicates_Inh_Alternative :: !(Predicates), substitution_Inh_Alternative :: !(FixpointSubstitution), typeConstructors_Inh_Alternative :: !(TypeConstructorEnvironment), typeschemeMap_Inh_Alternative :: !(M.Map Int (Scheme Predicates)), uniqueChunk_Inh_Alternative :: !(Int), variableMapping_Inh_Alternative :: !(Maybe [(Name, Tp)]) }
data Syn_Alternative  = Syn_Alternative { assumptions_Syn_Alternative :: !(Assumptions), betaUnique_Syn_Alternative :: !(Int), collectErrors_Syn_Alternative :: !(TypeErrors), collectInstances_Syn_Alternative :: !([(Name, Instance)]), collectWarnings_Syn_Alternative :: !(Warnings), constraints_Syn_Alternative :: !(ConstraintSet), counter_Syn_Alternative :: !(Int), dictionaryEnvironment_Syn_Alternative :: !(DictionaryEnvironment), elements_Syn_Alternative :: !( ([PatternElement], Bool) ), infoTrees_Syn_Alternative :: !(InfoTrees), matchIO_Syn_Alternative :: !(IO ()), patternMatchWarnings_Syn_Alternative :: !([Warning]), self_Syn_Alternative :: !(Alternative), unboundNames_Syn_Alternative :: !(Names), uniqueChunk_Syn_Alternative :: !(Int), unrwar_Syn_Alternative :: !(Warning) }
{-# INLINABLE wrap_Alternative #-}
wrap_Alternative :: T_Alternative  -> Inh_Alternative  -> (Syn_Alternative )
wrap_Alternative !(T_Alternative act) !(Inh_Alternative _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaLeft _lhsIbetaRight _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeConstructors _lhsItypeschemeMap _lhsIuniqueChunk _lhsIvariableMapping) =
   Control.Monad.Identity.runIdentity (
     do !sem <- act
        let arg1 = T_Alternative_vIn1 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaLeft _lhsIbetaRight _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeConstructors _lhsItypeschemeMap _lhsIuniqueChunk _lhsIvariableMapping
        !(T_Alternative_vOut1 _lhsOassumptions _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraints _lhsOcounter _lhsOdictionaryEnvironment _lhsOelements _lhsOinfoTrees _lhsOmatchIO _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOunrwar) <- return (inv_Alternative_s2 sem arg1)
        return (Syn_Alternative _lhsOassumptions _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraints _lhsOcounter _lhsOdictionaryEnvironment _lhsOelements _lhsOinfoTrees _lhsOmatchIO _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOunrwar)
   )

-- cata
{-# NOINLINE sem_Alternative #-}
sem_Alternative :: Alternative  -> T_Alternative 
sem_Alternative ( Alternative_Hole range_ !id_ ) = sem_Alternative_Hole ( sem_Range range_ ) id_
sem_Alternative ( Alternative_Feedback range_ !feedback_ alternative_ ) = sem_Alternative_Feedback ( sem_Range range_ ) feedback_ ( sem_Alternative alternative_ )
sem_Alternative ( Alternative_Alternative range_ pattern_ righthandside_ ) = sem_Alternative_Alternative ( sem_Range range_ ) ( sem_Pattern pattern_ ) ( sem_RightHandSide righthandside_ )
sem_Alternative ( Alternative_Empty range_ ) = sem_Alternative_Empty ( sem_Range range_ )

-- semantic domain
newtype T_Alternative  = T_Alternative {
                                       attach_T_Alternative :: Identity (T_Alternative_s2 )
                                       }
newtype T_Alternative_s2  = C_Alternative_s2 {
                                             inv_Alternative_s2 :: (T_Alternative_v1 )
                                             }
data T_Alternative_s3  = C_Alternative_s3
type T_Alternative_v1  = (T_Alternative_vIn1 ) -> (T_Alternative_vOut1 )
data T_Alternative_vIn1  = T_Alternative_vIn1 ([((Expression, [String]), Core_TypingStrategy)]) (M.Map NameWithRange TpScheme) ([[Name]]) ([PredicateWithSource]) (Tp) (Tp) (Int) (ClassEnvironment) (ClassMemberEnvironment) (Maybe [(Name, TpScheme)]) (ClassNameEnvironment) (Maybe (Name, Names)) (M.Map Name TpScheme) (TypeErrors) (Warnings) (Int) (Maybe Predicate) (Maybe Predicate) (Int) (DictionaryEnvironment) (ImportEnvironment) (Maybe Name) ([(Name, TpScheme)]) (IO ()) (Maybe Name) (Monos) (Names) (OrderedTypeSynonyms) (InfoTree) ([Warning]) (Predicates) (FixpointSubstitution) (TypeConstructorEnvironment) (M.Map Int (Scheme Predicates)) (Int) (Maybe [(Name, Tp)])
data T_Alternative_vOut1  = T_Alternative_vOut1 (Assumptions) (Int) (TypeErrors) ([(Name, Instance)]) (Warnings) (ConstraintSet) (Int) (DictionaryEnvironment) ( ([PatternElement], Bool) ) (InfoTrees) (IO ()) ([Warning]) (Alternative) (Names) (Int) (Warning)
{-# NOINLINE sem_Alternative_Hole #-}
sem_Alternative_Hole :: T_Range  -> (String) -> T_Alternative 
sem_Alternative_Hole arg_range_ !arg_id_ = T_Alternative (return st2) where
   {-# NOINLINE st2 #-}
   !st2 = let
      v1 :: T_Alternative_v1 
      v1 = \ !(T_Alternative_vIn1 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaLeft _lhsIbetaRight _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeConstructors _lhsItypeschemeMap _lhsIuniqueChunk _lhsIvariableMapping) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         _lhsOelements ::  ([PatternElement], Bool) 
         _lhsOelements = rule0  ()
         _lhsOunrwar :: Warning
         _lhsOunrwar = rule1  ()
         _lhsOinfoTrees :: InfoTrees
         _lhsOinfoTrees = rule2  ()
         _lhsOassumptions :: Assumptions
         _lhsOassumptions = rule3  ()
         _constraints = rule4  ()
         _lhsOcollectInstances :: [(Name, Instance)]
         _lhsOcollectInstances = rule5  ()
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule6  ()
         _self = rule7 _rangeIself arg_id_
         _lhsOself :: Alternative
         _lhsOself = rule8 _self
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule9 _lhsIbetaUnique
         _lhsOcollectErrors :: TypeErrors
         _lhsOcollectErrors = rule10 _lhsIcollectErrors
         _lhsOcollectWarnings :: Warnings
         _lhsOcollectWarnings = rule11 _lhsIcollectWarnings
         _lhsOconstraints :: ConstraintSet
         _lhsOconstraints = rule12 _constraints
         _lhsOcounter :: Int
         _lhsOcounter = rule13 _lhsIcounter
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule14 _lhsIdictionaryEnvironment
         _lhsOmatchIO :: IO ()
         _lhsOmatchIO = rule15 _lhsImatchIO
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule16 _lhsIpatternMatchWarnings
         _lhsOuniqueChunk :: Int
         _lhsOuniqueChunk = rule17 _lhsIuniqueChunk
         !__result_ = T_Alternative_vOut1 _lhsOassumptions _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraints _lhsOcounter _lhsOdictionaryEnvironment _lhsOelements _lhsOinfoTrees _lhsOmatchIO _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOunrwar
         in __result_ )
     in C_Alternative_s2 v1
   {-# INLINE rule0 #-}
   rule0 = \  (_ :: ()) ->
                                         ([], False)
   {-# INLINE rule1 #-}
   rule1 = \  (_ :: ()) ->
                                         pmError "Alternative_Empty.unrwar" "empty alternative"
   {-# INLINE rule2 #-}
   rule2 = \  (_ :: ()) ->
                                      []
   {-# INLINE rule3 #-}
   rule3 = \  (_ :: ()) ->
                            noAssumptions
   {-# INLINE rule4 #-}
   rule4 = \  (_ :: ()) ->
                            emptyTree
   {-# INLINE rule5 #-}
   rule5 = \  (_ :: ()) ->
     []
   {-# INLINE rule6 #-}
   rule6 = \  (_ :: ()) ->
     []
   {-# INLINE rule7 #-}
   rule7 = \ ((_rangeIself) :: Range) id_ ->
     Alternative_Hole _rangeIself id_
   {-# INLINE rule8 #-}
   rule8 = \ _self ->
     _self
   {-# INLINE rule9 #-}
   rule9 = \ ((_lhsIbetaUnique) :: Int) ->
     _lhsIbetaUnique
   {-# INLINE rule10 #-}
   rule10 = \ ((_lhsIcollectErrors) :: TypeErrors) ->
     _lhsIcollectErrors
   {-# INLINE rule11 #-}
   rule11 = \ ((_lhsIcollectWarnings) :: Warnings) ->
     _lhsIcollectWarnings
   {-# INLINE rule12 #-}
   rule12 = \ _constraints ->
     _constraints
   {-# INLINE rule13 #-}
   rule13 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule14 #-}
   rule14 = \ ((_lhsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _lhsIdictionaryEnvironment
   {-# INLINE rule15 #-}
   rule15 = \ ((_lhsImatchIO) :: IO ()) ->
     _lhsImatchIO
   {-# INLINE rule16 #-}
   rule16 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule17 #-}
   rule17 = \ ((_lhsIuniqueChunk) :: Int) ->
     _lhsIuniqueChunk
{-# NOINLINE sem_Alternative_Feedback #-}
sem_Alternative_Feedback :: T_Range  -> (String) -> T_Alternative  -> T_Alternative 
sem_Alternative_Feedback arg_range_ !arg_feedback_ arg_alternative_ = T_Alternative (return st2) where
   {-# NOINLINE st2 #-}
   !st2 = let
      v1 :: T_Alternative_v1 
      v1 = \ !(T_Alternative_vIn1 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaLeft _lhsIbetaRight _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeConstructors _lhsItypeschemeMap _lhsIuniqueChunk _lhsIvariableMapping) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _alternativeX2 = Control.Monad.Identity.runIdentity (attach_T_Alternative (arg_alternative_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_Alternative_vOut1 _alternativeIassumptions _alternativeIbetaUnique _alternativeIcollectErrors _alternativeIcollectInstances _alternativeIcollectWarnings _alternativeIconstraints _alternativeIcounter _alternativeIdictionaryEnvironment _alternativeIelements _alternativeIinfoTrees _alternativeImatchIO _alternativeIpatternMatchWarnings _alternativeIself _alternativeIunboundNames _alternativeIuniqueChunk _alternativeIunrwar) = inv_Alternative_s2 _alternativeX2 (T_Alternative_vIn1 _alternativeOallPatterns _alternativeOallTypeSchemes _alternativeOambiguousConflicts _alternativeOavailablePredicates _alternativeObetaLeft _alternativeObetaRight _alternativeObetaUnique _alternativeOclassEnvironment _alternativeOclassMemberEnv _alternativeOclassMemberTypeSchemes _alternativeOclassNamesEnv _alternativeOclassPredicate _alternativeOclassTypeSchemes _alternativeOcollectErrors _alternativeOcollectWarnings _alternativeOcounter _alternativeOcurClassPred _alternativeOcurPred _alternativeOcurrentChunk _alternativeOdictionaryEnvironment _alternativeOimportEnvironment _alternativeOinstanceName _alternativeOinstanceTypes _alternativeOmatchIO _alternativeOmoduleName _alternativeOmonos _alternativeOnamesInScope _alternativeOorderedTypeSynonyms _alternativeOparentTree _alternativeOpatternMatchWarnings _alternativeOrequiredPredicates _alternativeOsubstitution _alternativeOtypeConstructors _alternativeOtypeschemeMap _alternativeOuniqueChunk _alternativeOvariableMapping)
         _lhsOcollectInstances :: [(Name, Instance)]
         _lhsOcollectInstances = rule18 _alternativeIcollectInstances
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule19 _alternativeIunboundNames
         _self = rule20 _alternativeIself _rangeIself arg_feedback_
         _lhsOself :: Alternative
         _lhsOself = rule21 _self
         _lhsOassumptions :: Assumptions
         _lhsOassumptions = rule22 _alternativeIassumptions
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule23 _alternativeIbetaUnique
         _lhsOcollectErrors :: TypeErrors
         _lhsOcollectErrors = rule24 _alternativeIcollectErrors
         _lhsOcollectWarnings :: Warnings
         _lhsOcollectWarnings = rule25 _alternativeIcollectWarnings
         _lhsOconstraints :: ConstraintSet
         _lhsOconstraints = rule26 _alternativeIconstraints
         _lhsOcounter :: Int
         _lhsOcounter = rule27 _alternativeIcounter
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule28 _alternativeIdictionaryEnvironment
         _lhsOelements ::  ([PatternElement], Bool) 
         _lhsOelements = rule29 _alternativeIelements
         _lhsOinfoTrees :: InfoTrees
         _lhsOinfoTrees = rule30 _alternativeIinfoTrees
         _lhsOmatchIO :: IO ()
         _lhsOmatchIO = rule31 _alternativeImatchIO
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule32 _alternativeIpatternMatchWarnings
         _lhsOuniqueChunk :: Int
         _lhsOuniqueChunk = rule33 _alternativeIuniqueChunk
         _lhsOunrwar :: Warning
         _lhsOunrwar = rule34 _alternativeIunrwar
         _alternativeOallPatterns = rule35 _lhsIallPatterns
         _alternativeOallTypeSchemes = rule36 _lhsIallTypeSchemes
         _alternativeOambiguousConflicts = rule37 _lhsIambiguousConflicts
         _alternativeOavailablePredicates = rule38 _lhsIavailablePredicates
         _alternativeObetaLeft = rule39 _lhsIbetaLeft
         _alternativeObetaRight = rule40 _lhsIbetaRight
         _alternativeObetaUnique = rule41 _lhsIbetaUnique
         _alternativeOclassEnvironment = rule42 _lhsIclassEnvironment
         _alternativeOclassMemberEnv = rule43 _lhsIclassMemberEnv
         _alternativeOclassMemberTypeSchemes = rule44 _lhsIclassMemberTypeSchemes
         _alternativeOclassNamesEnv = rule45 _lhsIclassNamesEnv
         _alternativeOclassPredicate = rule46 _lhsIclassPredicate
         _alternativeOclassTypeSchemes = rule47 _lhsIclassTypeSchemes
         _alternativeOcollectErrors = rule48 _lhsIcollectErrors
         _alternativeOcollectWarnings = rule49 _lhsIcollectWarnings
         _alternativeOcounter = rule50 _lhsIcounter
         _alternativeOcurClassPred = rule51 _lhsIcurClassPred
         _alternativeOcurPred = rule52 _lhsIcurPred
         _alternativeOcurrentChunk = rule53 _lhsIcurrentChunk
         _alternativeOdictionaryEnvironment = rule54 _lhsIdictionaryEnvironment
         _alternativeOimportEnvironment = rule55 _lhsIimportEnvironment
         _alternativeOinstanceName = rule56 _lhsIinstanceName
         _alternativeOinstanceTypes = rule57 _lhsIinstanceTypes
         _alternativeOmatchIO = rule58 _lhsImatchIO
         _alternativeOmoduleName = rule59 _lhsImoduleName
         _alternativeOmonos = rule60 _lhsImonos
         _alternativeOnamesInScope = rule61 _lhsInamesInScope
         _alternativeOorderedTypeSynonyms = rule62 _lhsIorderedTypeSynonyms
         _alternativeOparentTree = rule63 _lhsIparentTree
         _alternativeOpatternMatchWarnings = rule64 _lhsIpatternMatchWarnings
         _alternativeOrequiredPredicates = rule65 _lhsIrequiredPredicates
         _alternativeOsubstitution = rule66 _lhsIsubstitution
         _alternativeOtypeConstructors = rule67 _lhsItypeConstructors
         _alternativeOtypeschemeMap = rule68 _lhsItypeschemeMap
         _alternativeOuniqueChunk = rule69 _lhsIuniqueChunk
         _alternativeOvariableMapping = rule70 _lhsIvariableMapping
         !__result_ = T_Alternative_vOut1 _lhsOassumptions _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraints _lhsOcounter _lhsOdictionaryEnvironment _lhsOelements _lhsOinfoTrees _lhsOmatchIO _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOunrwar
         in __result_ )
     in C_Alternative_s2 v1
   {-# INLINE rule18 #-}
   rule18 = \ ((_alternativeIcollectInstances) :: [(Name, Instance)]) ->
     _alternativeIcollectInstances
   {-# INLINE rule19 #-}
   rule19 = \ ((_alternativeIunboundNames) :: Names) ->
     _alternativeIunboundNames
   {-# INLINE rule20 #-}
   rule20 = \ ((_alternativeIself) :: Alternative) ((_rangeIself) :: Range) feedback_ ->
     Alternative_Feedback _rangeIself feedback_ _alternativeIself
   {-# INLINE rule21 #-}
   rule21 = \ _self ->
     _self
   {-# INLINE rule22 #-}
   rule22 = \ ((_alternativeIassumptions) :: Assumptions) ->
     _alternativeIassumptions
   {-# INLINE rule23 #-}
   rule23 = \ ((_alternativeIbetaUnique) :: Int) ->
     _alternativeIbetaUnique
   {-# INLINE rule24 #-}
   rule24 = \ ((_alternativeIcollectErrors) :: TypeErrors) ->
     _alternativeIcollectErrors
   {-# INLINE rule25 #-}
   rule25 = \ ((_alternativeIcollectWarnings) :: Warnings) ->
     _alternativeIcollectWarnings
   {-# INLINE rule26 #-}
   rule26 = \ ((_alternativeIconstraints) :: ConstraintSet) ->
     _alternativeIconstraints
   {-# INLINE rule27 #-}
   rule27 = \ ((_alternativeIcounter) :: Int) ->
     _alternativeIcounter
   {-# INLINE rule28 #-}
   rule28 = \ ((_alternativeIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _alternativeIdictionaryEnvironment
   {-# INLINE rule29 #-}
   rule29 = \ ((_alternativeIelements) ::  ([PatternElement], Bool) ) ->
     _alternativeIelements
   {-# INLINE rule30 #-}
   rule30 = \ ((_alternativeIinfoTrees) :: InfoTrees) ->
     _alternativeIinfoTrees
   {-# INLINE rule31 #-}
   rule31 = \ ((_alternativeImatchIO) :: IO ()) ->
     _alternativeImatchIO
   {-# INLINE rule32 #-}
   rule32 = \ ((_alternativeIpatternMatchWarnings) :: [Warning]) ->
     _alternativeIpatternMatchWarnings
   {-# INLINE rule33 #-}
   rule33 = \ ((_alternativeIuniqueChunk) :: Int) ->
     _alternativeIuniqueChunk
   {-# INLINE rule34 #-}
   rule34 = \ ((_alternativeIunrwar) :: Warning) ->
     _alternativeIunrwar
   {-# INLINE rule35 #-}
   rule35 = \ ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ->
     _lhsIallPatterns
   {-# INLINE rule36 #-}
   rule36 = \ ((_lhsIallTypeSchemes) :: M.Map NameWithRange TpScheme) ->
     _lhsIallTypeSchemes
   {-# INLINE rule37 #-}
   rule37 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule38 #-}
   rule38 = \ ((_lhsIavailablePredicates) :: [PredicateWithSource]) ->
     _lhsIavailablePredicates
   {-# INLINE rule39 #-}
   rule39 = \ ((_lhsIbetaLeft) :: Tp) ->
     _lhsIbetaLeft
   {-# INLINE rule40 #-}
   rule40 = \ ((_lhsIbetaRight) :: Tp) ->
     _lhsIbetaRight
   {-# INLINE rule41 #-}
   rule41 = \ ((_lhsIbetaUnique) :: Int) ->
     _lhsIbetaUnique
   {-# INLINE rule42 #-}
   rule42 = \ ((_lhsIclassEnvironment) :: ClassEnvironment) ->
     _lhsIclassEnvironment
   {-# INLINE rule43 #-}
   rule43 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule44 #-}
   rule44 = \ ((_lhsIclassMemberTypeSchemes) :: Maybe [(Name, TpScheme)]) ->
     _lhsIclassMemberTypeSchemes
   {-# INLINE rule45 #-}
   rule45 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule46 #-}
   rule46 = \ ((_lhsIclassPredicate) :: Maybe (Name, Names)) ->
     _lhsIclassPredicate
   {-# INLINE rule47 #-}
   rule47 = \ ((_lhsIclassTypeSchemes) :: M.Map Name TpScheme) ->
     _lhsIclassTypeSchemes
   {-# INLINE rule48 #-}
   rule48 = \ ((_lhsIcollectErrors) :: TypeErrors) ->
     _lhsIcollectErrors
   {-# INLINE rule49 #-}
   rule49 = \ ((_lhsIcollectWarnings) :: Warnings) ->
     _lhsIcollectWarnings
   {-# INLINE rule50 #-}
   rule50 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule51 #-}
   rule51 = \ ((_lhsIcurClassPred) :: Maybe Predicate) ->
     _lhsIcurClassPred
   {-# INLINE rule52 #-}
   rule52 = \ ((_lhsIcurPred) :: Maybe Predicate) ->
     _lhsIcurPred
   {-# INLINE rule53 #-}
   rule53 = \ ((_lhsIcurrentChunk) :: Int) ->
     _lhsIcurrentChunk
   {-# INLINE rule54 #-}
   rule54 = \ ((_lhsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _lhsIdictionaryEnvironment
   {-# INLINE rule55 #-}
   rule55 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule56 #-}
   rule56 = \ ((_lhsIinstanceName) :: Maybe Name) ->
     _lhsIinstanceName
   {-# INLINE rule57 #-}
   rule57 = \ ((_lhsIinstanceTypes) :: [(Name, TpScheme)]) ->
     _lhsIinstanceTypes
   {-# INLINE rule58 #-}
   rule58 = \ ((_lhsImatchIO) :: IO ()) ->
     _lhsImatchIO
   {-# INLINE rule59 #-}
   rule59 = \ ((_lhsImoduleName) :: Maybe Name) ->
     _lhsImoduleName
   {-# INLINE rule60 #-}
   rule60 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule61 #-}
   rule61 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule62 #-}
   rule62 = \ ((_lhsIorderedTypeSynonyms) :: OrderedTypeSynonyms) ->
     _lhsIorderedTypeSynonyms
   {-# INLINE rule63 #-}
   rule63 = \ ((_lhsIparentTree) :: InfoTree) ->
     _lhsIparentTree
   {-# INLINE rule64 #-}
   rule64 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule65 #-}
   rule65 = \ ((_lhsIrequiredPredicates) :: Predicates) ->
     _lhsIrequiredPredicates
   {-# INLINE rule66 #-}
   rule66 = \ ((_lhsIsubstitution) :: FixpointSubstitution) ->
     _lhsIsubstitution
   {-# INLINE rule67 #-}
   rule67 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
   {-# INLINE rule68 #-}
   rule68 = \ ((_lhsItypeschemeMap) :: M.Map Int (Scheme Predicates)) ->
     _lhsItypeschemeMap
   {-# INLINE rule69 #-}
   rule69 = \ ((_lhsIuniqueChunk) :: Int) ->
     _lhsIuniqueChunk
   {-# INLINE rule70 #-}
   rule70 = \ ((_lhsIvariableMapping) :: Maybe [(Name, Tp)]) ->
     _lhsIvariableMapping
{-# NOINLINE sem_Alternative_Alternative #-}
sem_Alternative_Alternative :: T_Range  -> T_Pattern  -> T_RightHandSide  -> T_Alternative 
sem_Alternative_Alternative arg_range_ arg_pattern_ arg_righthandside_ = T_Alternative (return st2) where
   {-# NOINLINE st2 #-}
   !st2 = let
      v1 :: T_Alternative_v1 
      v1 = \ !(T_Alternative_vIn1 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaLeft _lhsIbetaRight _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeConstructors _lhsItypeschemeMap _lhsIuniqueChunk _lhsIvariableMapping) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _patternX119 = Control.Monad.Identity.runIdentity (attach_T_Pattern (arg_pattern_))
         _righthandsideX149 = Control.Monad.Identity.runIdentity (attach_T_RightHandSide (arg_righthandside_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_Pattern_vOut118 _patternIbeta _patternIbetaUnique _patternIconstraints _patternIcounter _patternIelements _patternIenvironment _patternIinfoTree _patternIpatVarNames _patternIpatternMatchWarnings _patternIself _patternIunboundNames) = inv_Pattern_s119 _patternX119 (T_Pattern_vIn118 _patternOambiguousConflicts _patternObetaUnique _patternOcounter _patternOimportEnvironment _patternOmonos _patternOnamesInScope _patternOparentTree _patternOpatternMatchWarnings _patternOtypeConstructors)
         (T_RightHandSide_vOut148 _righthandsideIassumptions _righthandsideIbetaUnique _righthandsideIcollectErrors _righthandsideIcollectInstances _righthandsideIcollectWarnings _righthandsideIconstraints _righthandsideIcounter _righthandsideIdictionaryEnvironment _righthandsideIfallthrough _righthandsideIinfoTree _righthandsideImatchIO _righthandsideIpatternMatchWarnings _righthandsideIself _righthandsideIunboundNames _righthandsideIuniqueChunk) = inv_RightHandSide_s149 _righthandsideX149 (T_RightHandSide_vIn148 _righthandsideOallPatterns _righthandsideOallTypeSchemes _righthandsideOambiguousConflicts _righthandsideOavailablePredicates _righthandsideObetaRight _righthandsideObetaUnique _righthandsideOclassEnvironment _righthandsideOclassMemberEnv _righthandsideOclassMemberTypeSchemes _righthandsideOclassNamesEnv _righthandsideOclassPredicate _righthandsideOclassTypeSchemes _righthandsideOcollectErrors _righthandsideOcollectWarnings _righthandsideOcounter _righthandsideOcurClassPred _righthandsideOcurPred _righthandsideOcurrentChunk _righthandsideOdictionaryEnvironment _righthandsideOimportEnvironment _righthandsideOinstanceName _righthandsideOinstanceTypes _righthandsideOmatchIO _righthandsideOmoduleName _righthandsideOmonos _righthandsideOnamesInScope _righthandsideOorderedTypeSynonyms _righthandsideOparentTree _righthandsideOpatternMatchWarnings _righthandsideOrequiredPredicates _righthandsideOsubstitution _righthandsideOtypeConstructors _righthandsideOtypeschemeMap _righthandsideOuniqueChunk _righthandsideOvariableMapping)
         _lhsOelements ::  ([PatternElement], Bool) 
         _lhsOelements = rule71 _patternIelements _righthandsideIfallthrough
         _lhsOunrwar :: Warning
         _lhsOunrwar = rule72 _patternIself _rangeIself
         (_namesInScope,_unboundNames,_scopeInfo) = rule73 _lhsInamesInScope _patternIpatVarNames _righthandsideIunboundNames
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule74 _unboundNames
         _lhsOinfoTrees :: InfoTrees
         _lhsOinfoTrees = rule75 _patternIinfoTree _righthandsideIinfoTree
         _cinfoLeft = rule76 _lhsIbetaLeft _lhsIparentTree _patternIinfoTree
         _cinfoBind = rule77 _lhsIparentTree _patternIenvironment
         _righthandsideOmonos = rule78 _csetBinds _lhsImonos _patternIenvironment
         _constraints = rule79 _conLeft _csetBinds _patternIconstraints _righthandsideIconstraints
         _conLeft = rule80 _cinfoLeft _lhsIbetaLeft _patternIbeta
         _lhsOassumptions :: Assumptions
         (_csetBinds,_lhsOassumptions) = rule81 _cinfoBind _patternIenvironment _righthandsideIassumptions
         _lhsOcollectInstances :: [(Name, Instance)]
         _lhsOcollectInstances = rule82 _righthandsideIcollectInstances
         _self = rule83 _patternIself _rangeIself _righthandsideIself
         _lhsOself :: Alternative
         _lhsOself = rule84 _self
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule85 _righthandsideIbetaUnique
         _lhsOcollectErrors :: TypeErrors
         _lhsOcollectErrors = rule86 _righthandsideIcollectErrors
         _lhsOcollectWarnings :: Warnings
         _lhsOcollectWarnings = rule87 _righthandsideIcollectWarnings
         _lhsOconstraints :: ConstraintSet
         _lhsOconstraints = rule88 _constraints
         _lhsOcounter :: Int
         _lhsOcounter = rule89 _righthandsideIcounter
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule90 _righthandsideIdictionaryEnvironment
         _lhsOmatchIO :: IO ()
         _lhsOmatchIO = rule91 _righthandsideImatchIO
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule92 _righthandsideIpatternMatchWarnings
         _lhsOuniqueChunk :: Int
         _lhsOuniqueChunk = rule93 _righthandsideIuniqueChunk
         _patternOambiguousConflicts = rule94 _lhsIambiguousConflicts
         _patternObetaUnique = rule95 _lhsIbetaUnique
         _patternOcounter = rule96 _lhsIcounter
         _patternOimportEnvironment = rule97 _lhsIimportEnvironment
         _patternOmonos = rule98 _lhsImonos
         _patternOnamesInScope = rule99 _namesInScope
         _patternOparentTree = rule100 _lhsIparentTree
         _patternOpatternMatchWarnings = rule101 _lhsIpatternMatchWarnings
         _patternOtypeConstructors = rule102 _lhsItypeConstructors
         _righthandsideOallPatterns = rule103 _lhsIallPatterns
         _righthandsideOallTypeSchemes = rule104 _lhsIallTypeSchemes
         _righthandsideOambiguousConflicts = rule105 _lhsIambiguousConflicts
         _righthandsideOavailablePredicates = rule106 _lhsIavailablePredicates
         _righthandsideObetaRight = rule107 _lhsIbetaRight
         _righthandsideObetaUnique = rule108 _patternIbetaUnique
         _righthandsideOclassEnvironment = rule109 _lhsIclassEnvironment
         _righthandsideOclassMemberEnv = rule110 _lhsIclassMemberEnv
         _righthandsideOclassMemberTypeSchemes = rule111 _lhsIclassMemberTypeSchemes
         _righthandsideOclassNamesEnv = rule112 _lhsIclassNamesEnv
         _righthandsideOclassPredicate = rule113 _lhsIclassPredicate
         _righthandsideOclassTypeSchemes = rule114 _lhsIclassTypeSchemes
         _righthandsideOcollectErrors = rule115 _lhsIcollectErrors
         _righthandsideOcollectWarnings = rule116 _lhsIcollectWarnings
         _righthandsideOcounter = rule117 _patternIcounter
         _righthandsideOcurClassPred = rule118 _lhsIcurClassPred
         _righthandsideOcurPred = rule119 _lhsIcurPred
         _righthandsideOcurrentChunk = rule120 _lhsIcurrentChunk
         _righthandsideOdictionaryEnvironment = rule121 _lhsIdictionaryEnvironment
         _righthandsideOimportEnvironment = rule122 _lhsIimportEnvironment
         _righthandsideOinstanceName = rule123 _lhsIinstanceName
         _righthandsideOinstanceTypes = rule124 _lhsIinstanceTypes
         _righthandsideOmatchIO = rule125 _lhsImatchIO
         _righthandsideOmoduleName = rule126 _lhsImoduleName
         _righthandsideOnamesInScope = rule127 _namesInScope
         _righthandsideOorderedTypeSynonyms = rule128 _lhsIorderedTypeSynonyms
         _righthandsideOparentTree = rule129 _lhsIparentTree
         _righthandsideOpatternMatchWarnings = rule130 _patternIpatternMatchWarnings
         _righthandsideOrequiredPredicates = rule131 _lhsIrequiredPredicates
         _righthandsideOsubstitution = rule132 _lhsIsubstitution
         _righthandsideOtypeConstructors = rule133 _lhsItypeConstructors
         _righthandsideOtypeschemeMap = rule134 _lhsItypeschemeMap
         _righthandsideOuniqueChunk = rule135 _lhsIuniqueChunk
         _righthandsideOvariableMapping = rule136 _lhsIvariableMapping
         !__result_ = T_Alternative_vOut1 _lhsOassumptions _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraints _lhsOcounter _lhsOdictionaryEnvironment _lhsOelements _lhsOinfoTrees _lhsOmatchIO _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOunrwar
         in __result_ )
     in C_Alternative_s2 v1
   {-# INLINE rule71 #-}
   rule71 = \ ((_patternIelements) ::   [PatternElement]        ) ((_righthandsideIfallthrough) :: Bool) ->
                                         (_patternIelements, _righthandsideIfallthrough)
   {-# INLINE rule72 #-}
   rule72 = \ ((_patternIself) :: Pattern) ((_rangeIself) :: Range) ->
                                         UnreachablePatternCase _rangeIself _patternIself
   {-# INLINE rule73 #-}
   rule73 = \ ((_lhsInamesInScope) :: Names) ((_patternIpatVarNames) :: Names) ((_righthandsideIunboundNames) :: Names) ->
                                                                        changeOfScope _patternIpatVarNames _righthandsideIunboundNames _lhsInamesInScope
   {-# INLINE rule74 #-}
   rule74 = \ _unboundNames ->
                                             _unboundNames
   {-# INLINE rule75 #-}
   rule75 = \ ((_patternIinfoTree) :: InfoTree) ((_righthandsideIinfoTree) :: InfoTree) ->
                                      [_patternIinfoTree, _righthandsideIinfoTree]
   {-# INLINE rule76 #-}
   rule76 = \ ((_lhsIbetaLeft) :: Tp) ((_lhsIparentTree) :: InfoTree) ((_patternIinfoTree) :: InfoTree) ->
     resultConstraint "case pattern" _patternIinfoTree
        [ Unifier (head (ftv _lhsIbetaLeft)) ("case patterns", attribute _lhsIparentTree, "case pattern") ]
   {-# INLINE rule77 #-}
   rule77 = \ ((_lhsIparentTree) :: InfoTree) ((_patternIenvironment) :: PatternAssumptions) ->
     \name -> variableConstraint "variable" (nameToUHA_Expr name)
        [ FolkloreConstraint
        , makeUnifier name "case alternative" _patternIenvironment _lhsIparentTree
        ]
   {-# INLINE rule78 #-}
   rule78 = \ _csetBinds ((_lhsImonos) :: Monos) ((_patternIenvironment) :: PatternAssumptions) ->
                                      M.elems _patternIenvironment ++ getMonos _csetBinds ++ _lhsImonos
   {-# INLINE rule79 #-}
   rule79 = \ _conLeft _csetBinds ((_patternIconstraints) :: ConstraintSet) ((_righthandsideIconstraints) :: ConstraintSet) ->
                                      _csetBinds .>>.
                                      Node [ _conLeft  .<. _patternIconstraints
                                           , _righthandsideIconstraints
                                           ]
   {-# INLINE rule80 #-}
   rule80 = \ _cinfoLeft ((_lhsIbetaLeft) :: Tp) ((_patternIbeta) :: Tp) ->
                                      [ (_patternIbeta .==. _lhsIbetaLeft) _cinfoLeft ]
   {-# INLINE rule81 #-}
   rule81 = \ _cinfoBind ((_patternIenvironment) :: PatternAssumptions) ((_righthandsideIassumptions) :: Assumptions) ->
                                          (_patternIenvironment .===. _righthandsideIassumptions) _cinfoBind
   {-# INLINE rule82 #-}
   rule82 = \ ((_righthandsideIcollectInstances) :: [(Name, Instance)]) ->
     _righthandsideIcollectInstances
   {-# INLINE rule83 #-}
   rule83 = \ ((_patternIself) :: Pattern) ((_rangeIself) :: Range) ((_righthandsideIself) :: RightHandSide) ->
     Alternative_Alternative _rangeIself _patternIself _righthandsideIself
   {-# INLINE rule84 #-}
   rule84 = \ _self ->
     _self
   {-# INLINE rule85 #-}
   rule85 = \ ((_righthandsideIbetaUnique) :: Int) ->
     _righthandsideIbetaUnique
   {-# INLINE rule86 #-}
   rule86 = \ ((_righthandsideIcollectErrors) :: TypeErrors) ->
     _righthandsideIcollectErrors
   {-# INLINE rule87 #-}
   rule87 = \ ((_righthandsideIcollectWarnings) :: Warnings) ->
     _righthandsideIcollectWarnings
   {-# INLINE rule88 #-}
   rule88 = \ _constraints ->
     _constraints
   {-# INLINE rule89 #-}
   rule89 = \ ((_righthandsideIcounter) :: Int) ->
     _righthandsideIcounter
   {-# INLINE rule90 #-}
   rule90 = \ ((_righthandsideIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _righthandsideIdictionaryEnvironment
   {-# INLINE rule91 #-}
   rule91 = \ ((_righthandsideImatchIO) :: IO ()) ->
     _righthandsideImatchIO
   {-# INLINE rule92 #-}
   rule92 = \ ((_righthandsideIpatternMatchWarnings) :: [Warning]) ->
     _righthandsideIpatternMatchWarnings
   {-# INLINE rule93 #-}
   rule93 = \ ((_righthandsideIuniqueChunk) :: Int) ->
     _righthandsideIuniqueChunk
   {-# INLINE rule94 #-}
   rule94 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule95 #-}
   rule95 = \ ((_lhsIbetaUnique) :: Int) ->
     _lhsIbetaUnique
   {-# INLINE rule96 #-}
   rule96 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule97 #-}
   rule97 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule98 #-}
   rule98 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule99 #-}
   rule99 = \ _namesInScope ->
     _namesInScope
   {-# INLINE rule100 #-}
   rule100 = \ ((_lhsIparentTree) :: InfoTree) ->
     _lhsIparentTree
   {-# INLINE rule101 #-}
   rule101 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule102 #-}
   rule102 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
   {-# INLINE rule103 #-}
   rule103 = \ ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ->
     _lhsIallPatterns
   {-# INLINE rule104 #-}
   rule104 = \ ((_lhsIallTypeSchemes) :: M.Map NameWithRange TpScheme) ->
     _lhsIallTypeSchemes
   {-# INLINE rule105 #-}
   rule105 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule106 #-}
   rule106 = \ ((_lhsIavailablePredicates) :: [PredicateWithSource]) ->
     _lhsIavailablePredicates
   {-# INLINE rule107 #-}
   rule107 = \ ((_lhsIbetaRight) :: Tp) ->
     _lhsIbetaRight
   {-# INLINE rule108 #-}
   rule108 = \ ((_patternIbetaUnique) :: Int) ->
     _patternIbetaUnique
   {-# INLINE rule109 #-}
   rule109 = \ ((_lhsIclassEnvironment) :: ClassEnvironment) ->
     _lhsIclassEnvironment
   {-# INLINE rule110 #-}
   rule110 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule111 #-}
   rule111 = \ ((_lhsIclassMemberTypeSchemes) :: Maybe [(Name, TpScheme)]) ->
     _lhsIclassMemberTypeSchemes
   {-# INLINE rule112 #-}
   rule112 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule113 #-}
   rule113 = \ ((_lhsIclassPredicate) :: Maybe (Name, Names)) ->
     _lhsIclassPredicate
   {-# INLINE rule114 #-}
   rule114 = \ ((_lhsIclassTypeSchemes) :: M.Map Name TpScheme) ->
     _lhsIclassTypeSchemes
   {-# INLINE rule115 #-}
   rule115 = \ ((_lhsIcollectErrors) :: TypeErrors) ->
     _lhsIcollectErrors
   {-# INLINE rule116 #-}
   rule116 = \ ((_lhsIcollectWarnings) :: Warnings) ->
     _lhsIcollectWarnings
   {-# INLINE rule117 #-}
   rule117 = \ ((_patternIcounter) :: Int) ->
     _patternIcounter
   {-# INLINE rule118 #-}
   rule118 = \ ((_lhsIcurClassPred) :: Maybe Predicate) ->
     _lhsIcurClassPred
   {-# INLINE rule119 #-}
   rule119 = \ ((_lhsIcurPred) :: Maybe Predicate) ->
     _lhsIcurPred
   {-# INLINE rule120 #-}
   rule120 = \ ((_lhsIcurrentChunk) :: Int) ->
     _lhsIcurrentChunk
   {-# INLINE rule121 #-}
   rule121 = \ ((_lhsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _lhsIdictionaryEnvironment
   {-# INLINE rule122 #-}
   rule122 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule123 #-}
   rule123 = \ ((_lhsIinstanceName) :: Maybe Name) ->
     _lhsIinstanceName
   {-# INLINE rule124 #-}
   rule124 = \ ((_lhsIinstanceTypes) :: [(Name, TpScheme)]) ->
     _lhsIinstanceTypes
   {-# INLINE rule125 #-}
   rule125 = \ ((_lhsImatchIO) :: IO ()) ->
     _lhsImatchIO
   {-# INLINE rule126 #-}
   rule126 = \ ((_lhsImoduleName) :: Maybe Name) ->
     _lhsImoduleName
   {-# INLINE rule127 #-}
   rule127 = \ _namesInScope ->
     _namesInScope
   {-# INLINE rule128 #-}
   rule128 = \ ((_lhsIorderedTypeSynonyms) :: OrderedTypeSynonyms) ->
     _lhsIorderedTypeSynonyms
   {-# INLINE rule129 #-}
   rule129 = \ ((_lhsIparentTree) :: InfoTree) ->
     _lhsIparentTree
   {-# INLINE rule130 #-}
   rule130 = \ ((_patternIpatternMatchWarnings) :: [Warning]) ->
     _patternIpatternMatchWarnings
   {-# INLINE rule131 #-}
   rule131 = \ ((_lhsIrequiredPredicates) :: Predicates) ->
     _lhsIrequiredPredicates
   {-# INLINE rule132 #-}
   rule132 = \ ((_lhsIsubstitution) :: FixpointSubstitution) ->
     _lhsIsubstitution
   {-# INLINE rule133 #-}
   rule133 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
   {-# INLINE rule134 #-}
   rule134 = \ ((_lhsItypeschemeMap) :: M.Map Int (Scheme Predicates)) ->
     _lhsItypeschemeMap
   {-# INLINE rule135 #-}
   rule135 = \ ((_lhsIuniqueChunk) :: Int) ->
     _lhsIuniqueChunk
   {-# INLINE rule136 #-}
   rule136 = \ ((_lhsIvariableMapping) :: Maybe [(Name, Tp)]) ->
     _lhsIvariableMapping
{-# NOINLINE sem_Alternative_Empty #-}
sem_Alternative_Empty :: T_Range  -> T_Alternative 
sem_Alternative_Empty arg_range_ = T_Alternative (return st2) where
   {-# NOINLINE st2 #-}
   !st2 = let
      v1 :: T_Alternative_v1 
      v1 = \ !(T_Alternative_vIn1 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaLeft _lhsIbetaRight _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeConstructors _lhsItypeschemeMap _lhsIuniqueChunk _lhsIvariableMapping) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         _lhsOelements ::  ([PatternElement], Bool) 
         _lhsOelements = rule137  ()
         _lhsOunrwar :: Warning
         _lhsOunrwar = rule138  ()
         _lhsOinfoTrees :: InfoTrees
         _lhsOinfoTrees = rule139  ()
         _lhsOassumptions :: Assumptions
         _lhsOassumptions = rule140  ()
         _constraints = rule141  ()
         _lhsOcollectInstances :: [(Name, Instance)]
         _lhsOcollectInstances = rule142  ()
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule143  ()
         _self = rule144 _rangeIself
         _lhsOself :: Alternative
         _lhsOself = rule145 _self
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule146 _lhsIbetaUnique
         _lhsOcollectErrors :: TypeErrors
         _lhsOcollectErrors = rule147 _lhsIcollectErrors
         _lhsOcollectWarnings :: Warnings
         _lhsOcollectWarnings = rule148 _lhsIcollectWarnings
         _lhsOconstraints :: ConstraintSet
         _lhsOconstraints = rule149 _constraints
         _lhsOcounter :: Int
         _lhsOcounter = rule150 _lhsIcounter
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule151 _lhsIdictionaryEnvironment
         _lhsOmatchIO :: IO ()
         _lhsOmatchIO = rule152 _lhsImatchIO
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule153 _lhsIpatternMatchWarnings
         _lhsOuniqueChunk :: Int
         _lhsOuniqueChunk = rule154 _lhsIuniqueChunk
         !__result_ = T_Alternative_vOut1 _lhsOassumptions _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraints _lhsOcounter _lhsOdictionaryEnvironment _lhsOelements _lhsOinfoTrees _lhsOmatchIO _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOunrwar
         in __result_ )
     in C_Alternative_s2 v1
   {-# INLINE rule137 #-}
   rule137 = \  (_ :: ()) ->
                                         ([], False)
   {-# INLINE rule138 #-}
   rule138 = \  (_ :: ()) ->
                                         pmError "Alternative_Empty.unrwar" "empty alternative"
   {-# INLINE rule139 #-}
   rule139 = \  (_ :: ()) ->
                                      []
   {-# INLINE rule140 #-}
   rule140 = \  (_ :: ()) ->
                            noAssumptions
   {-# INLINE rule141 #-}
   rule141 = \  (_ :: ()) ->
                            emptyTree
   {-# INLINE rule142 #-}
   rule142 = \  (_ :: ()) ->
     []
   {-# INLINE rule143 #-}
   rule143 = \  (_ :: ()) ->
     []
   {-# INLINE rule144 #-}
   rule144 = \ ((_rangeIself) :: Range) ->
     Alternative_Empty _rangeIself
   {-# INLINE rule145 #-}
   rule145 = \ _self ->
     _self
   {-# INLINE rule146 #-}
   rule146 = \ ((_lhsIbetaUnique) :: Int) ->
     _lhsIbetaUnique
   {-# INLINE rule147 #-}
   rule147 = \ ((_lhsIcollectErrors) :: TypeErrors) ->
     _lhsIcollectErrors
   {-# INLINE rule148 #-}
   rule148 = \ ((_lhsIcollectWarnings) :: Warnings) ->
     _lhsIcollectWarnings
   {-# INLINE rule149 #-}
   rule149 = \ _constraints ->
     _constraints
   {-# INLINE rule150 #-}
   rule150 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule151 #-}
   rule151 = \ ((_lhsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _lhsIdictionaryEnvironment
   {-# INLINE rule152 #-}
   rule152 = \ ((_lhsImatchIO) :: IO ()) ->
     _lhsImatchIO
   {-# INLINE rule153 #-}
   rule153 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule154 #-}
   rule154 = \ ((_lhsIuniqueChunk) :: Int) ->
     _lhsIuniqueChunk

-- Alternatives ------------------------------------------------
-- wrapper
data Inh_Alternatives  = Inh_Alternatives { allPatterns_Inh_Alternatives :: !([((Expression, [String]), Core_TypingStrategy)]), allTypeSchemes_Inh_Alternatives :: !(M.Map NameWithRange TpScheme), ambiguousConflicts_Inh_Alternatives :: !([[Name]]), availablePredicates_Inh_Alternatives :: !([PredicateWithSource]), betaLeft_Inh_Alternatives :: !(Tp), betaRight_Inh_Alternatives :: !(Tp), betaUnique_Inh_Alternatives :: !(Int), classEnvironment_Inh_Alternatives :: !(ClassEnvironment), classMemberEnv_Inh_Alternatives :: !(ClassMemberEnvironment), classMemberTypeSchemes_Inh_Alternatives :: !(Maybe [(Name, TpScheme)]), classNamesEnv_Inh_Alternatives :: !(ClassNameEnvironment), classPredicate_Inh_Alternatives :: !(Maybe (Name, Names)), classTypeSchemes_Inh_Alternatives :: !(M.Map Name TpScheme), collectErrors_Inh_Alternatives :: !(TypeErrors), collectWarnings_Inh_Alternatives :: !(Warnings), counter_Inh_Alternatives :: !(Int), curClassPred_Inh_Alternatives :: !(Maybe Predicate), curPred_Inh_Alternatives :: !(Maybe Predicate), currentChunk_Inh_Alternatives :: !(Int), dictionaryEnvironment_Inh_Alternatives :: !(DictionaryEnvironment), importEnvironment_Inh_Alternatives :: !(ImportEnvironment), instanceName_Inh_Alternatives :: !(Maybe Name), instanceTypes_Inh_Alternatives :: !([(Name, TpScheme)]), matchIO_Inh_Alternatives :: !(IO ()), moduleName_Inh_Alternatives :: !(Maybe Name), monos_Inh_Alternatives :: !(Monos), namesInScope_Inh_Alternatives :: !(Names), orderedTypeSynonyms_Inh_Alternatives :: !(OrderedTypeSynonyms), parentTree_Inh_Alternatives :: !(InfoTree), patternMatchWarnings_Inh_Alternatives :: !([Warning]), requiredPredicates_Inh_Alternatives :: !(Predicates), substitution_Inh_Alternatives :: !(FixpointSubstitution), typeConstructors_Inh_Alternatives :: !(TypeConstructorEnvironment), typeschemeMap_Inh_Alternatives :: !(M.Map Int (Scheme Predicates)), uniqueChunk_Inh_Alternatives :: !(Int), variableMapping_Inh_Alternatives :: !(Maybe [(Name, Tp)]) }
data Syn_Alternatives  = Syn_Alternatives { assumptions_Syn_Alternatives :: !(Assumptions), betaUnique_Syn_Alternatives :: !(Int), collectErrors_Syn_Alternatives :: !(TypeErrors), collectInstances_Syn_Alternatives :: !([(Name, Instance)]), collectWarnings_Syn_Alternatives :: !(Warnings), constraintslist_Syn_Alternatives :: !(ConstraintSets), counter_Syn_Alternatives :: !(Int), dictionaryEnvironment_Syn_Alternatives :: !(DictionaryEnvironment), elementss_Syn_Alternatives :: !([([PatternElement], Bool)]), infoTrees_Syn_Alternatives :: !(InfoTrees), matchIO_Syn_Alternatives :: !(IO ()), patternMatchWarnings_Syn_Alternatives :: !([Warning]), self_Syn_Alternatives :: !(Alternatives), unboundNames_Syn_Alternatives :: !(Names), uniqueChunk_Syn_Alternatives :: !(Int), unrwars_Syn_Alternatives :: !([Warning]) }
{-# INLINABLE wrap_Alternatives #-}
wrap_Alternatives :: T_Alternatives  -> Inh_Alternatives  -> (Syn_Alternatives )
wrap_Alternatives !(T_Alternatives act) !(Inh_Alternatives _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaLeft _lhsIbetaRight _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeConstructors _lhsItypeschemeMap _lhsIuniqueChunk _lhsIvariableMapping) =
   Control.Monad.Identity.runIdentity (
     do !sem <- act
        let arg4 = T_Alternatives_vIn4 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaLeft _lhsIbetaRight _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeConstructors _lhsItypeschemeMap _lhsIuniqueChunk _lhsIvariableMapping
        !(T_Alternatives_vOut4 _lhsOassumptions _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraintslist _lhsOcounter _lhsOdictionaryEnvironment _lhsOelementss _lhsOinfoTrees _lhsOmatchIO _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOunrwars) <- return (inv_Alternatives_s5 sem arg4)
        return (Syn_Alternatives _lhsOassumptions _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraintslist _lhsOcounter _lhsOdictionaryEnvironment _lhsOelementss _lhsOinfoTrees _lhsOmatchIO _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOunrwars)
   )

-- cata
{-# NOINLINE sem_Alternatives #-}
sem_Alternatives :: Alternatives  -> T_Alternatives 
sem_Alternatives list = Prelude.foldr sem_Alternatives_Cons sem_Alternatives_Nil (Prelude.map sem_Alternative list)

-- semantic domain
newtype T_Alternatives  = T_Alternatives {
                                         attach_T_Alternatives :: Identity (T_Alternatives_s5 )
                                         }
newtype T_Alternatives_s5  = C_Alternatives_s5 {
                                               inv_Alternatives_s5 :: (T_Alternatives_v4 )
                                               }
data T_Alternatives_s6  = C_Alternatives_s6
type T_Alternatives_v4  = (T_Alternatives_vIn4 ) -> (T_Alternatives_vOut4 )
data T_Alternatives_vIn4  = T_Alternatives_vIn4 ([((Expression, [String]), Core_TypingStrategy)]) (M.Map NameWithRange TpScheme) ([[Name]]) ([PredicateWithSource]) (Tp) (Tp) (Int) (ClassEnvironment) (ClassMemberEnvironment) (Maybe [(Name, TpScheme)]) (ClassNameEnvironment) (Maybe (Name, Names)) (M.Map Name TpScheme) (TypeErrors) (Warnings) (Int) (Maybe Predicate) (Maybe Predicate) (Int) (DictionaryEnvironment) (ImportEnvironment) (Maybe Name) ([(Name, TpScheme)]) (IO ()) (Maybe Name) (Monos) (Names) (OrderedTypeSynonyms) (InfoTree) ([Warning]) (Predicates) (FixpointSubstitution) (TypeConstructorEnvironment) (M.Map Int (Scheme Predicates)) (Int) (Maybe [(Name, Tp)])
data T_Alternatives_vOut4  = T_Alternatives_vOut4 (Assumptions) (Int) (TypeErrors) ([(Name, Instance)]) (Warnings) (ConstraintSets) (Int) (DictionaryEnvironment) ([([PatternElement], Bool)]) (InfoTrees) (IO ()) ([Warning]) (Alternatives) (Names) (Int) ([Warning])
{-# NOINLINE sem_Alternatives_Cons #-}
sem_Alternatives_Cons :: T_Alternative  -> T_Alternatives  -> T_Alternatives 
sem_Alternatives_Cons arg_hd_ arg_tl_ = T_Alternatives (return st5) where
   {-# NOINLINE st5 #-}
   !st5 = let
      v4 :: T_Alternatives_v4 
      v4 = \ !(T_Alternatives_vIn4 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaLeft _lhsIbetaRight _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeConstructors _lhsItypeschemeMap _lhsIuniqueChunk _lhsIvariableMapping) -> ( let
         _hdX2 = Control.Monad.Identity.runIdentity (attach_T_Alternative (arg_hd_))
         _tlX5 = Control.Monad.Identity.runIdentity (attach_T_Alternatives (arg_tl_))
         (T_Alternative_vOut1 _hdIassumptions _hdIbetaUnique _hdIcollectErrors _hdIcollectInstances _hdIcollectWarnings _hdIconstraints _hdIcounter _hdIdictionaryEnvironment _hdIelements _hdIinfoTrees _hdImatchIO _hdIpatternMatchWarnings _hdIself _hdIunboundNames _hdIuniqueChunk _hdIunrwar) = inv_Alternative_s2 _hdX2 (T_Alternative_vIn1 _hdOallPatterns _hdOallTypeSchemes _hdOambiguousConflicts _hdOavailablePredicates _hdObetaLeft _hdObetaRight _hdObetaUnique _hdOclassEnvironment _hdOclassMemberEnv _hdOclassMemberTypeSchemes _hdOclassNamesEnv _hdOclassPredicate _hdOclassTypeSchemes _hdOcollectErrors _hdOcollectWarnings _hdOcounter _hdOcurClassPred _hdOcurPred _hdOcurrentChunk _hdOdictionaryEnvironment _hdOimportEnvironment _hdOinstanceName _hdOinstanceTypes _hdOmatchIO _hdOmoduleName _hdOmonos _hdOnamesInScope _hdOorderedTypeSynonyms _hdOparentTree _hdOpatternMatchWarnings _hdOrequiredPredicates _hdOsubstitution _hdOtypeConstructors _hdOtypeschemeMap _hdOuniqueChunk _hdOvariableMapping)
         (T_Alternatives_vOut4 _tlIassumptions _tlIbetaUnique _tlIcollectErrors _tlIcollectInstances _tlIcollectWarnings _tlIconstraintslist _tlIcounter _tlIdictionaryEnvironment _tlIelementss _tlIinfoTrees _tlImatchIO _tlIpatternMatchWarnings _tlIself _tlIunboundNames _tlIuniqueChunk _tlIunrwars) = inv_Alternatives_s5 _tlX5 (T_Alternatives_vIn4 _tlOallPatterns _tlOallTypeSchemes _tlOambiguousConflicts _tlOavailablePredicates _tlObetaLeft _tlObetaRight _tlObetaUnique _tlOclassEnvironment _tlOclassMemberEnv _tlOclassMemberTypeSchemes _tlOclassNamesEnv _tlOclassPredicate _tlOclassTypeSchemes _tlOcollectErrors _tlOcollectWarnings _tlOcounter _tlOcurClassPred _tlOcurPred _tlOcurrentChunk _tlOdictionaryEnvironment _tlOimportEnvironment _tlOinstanceName _tlOinstanceTypes _tlOmatchIO _tlOmoduleName _tlOmonos _tlOnamesInScope _tlOorderedTypeSynonyms _tlOparentTree _tlOpatternMatchWarnings _tlOrequiredPredicates _tlOsubstitution _tlOtypeConstructors _tlOtypeschemeMap _tlOuniqueChunk _tlOvariableMapping)
         _lhsOelementss :: [([PatternElement], Bool)]
         _lhsOelementss = rule155 _hdIelements _tlIelementss
         _lhsOunrwars :: [Warning]
         _lhsOunrwars = rule156 _hdIunrwar _tlIunrwars
         _lhsOinfoTrees :: InfoTrees
         _lhsOinfoTrees = rule157 _hdIinfoTrees _tlIinfoTrees
         _lhsOassumptions :: Assumptions
         _lhsOassumptions = rule158 _hdIassumptions _tlIassumptions
         _lhsOconstraintslist :: ConstraintSets
         _lhsOconstraintslist = rule159 _hdIconstraints _tlIconstraintslist
         _lhsOcollectInstances :: [(Name, Instance)]
         _lhsOcollectInstances = rule160 _hdIcollectInstances _tlIcollectInstances
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule161 _hdIunboundNames _tlIunboundNames
         _self = rule162 _hdIself _tlIself
         _lhsOself :: Alternatives
         _lhsOself = rule163 _self
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule164 _tlIbetaUnique
         _lhsOcollectErrors :: TypeErrors
         _lhsOcollectErrors = rule165 _tlIcollectErrors
         _lhsOcollectWarnings :: Warnings
         _lhsOcollectWarnings = rule166 _tlIcollectWarnings
         _lhsOcounter :: Int
         _lhsOcounter = rule167 _tlIcounter
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule168 _tlIdictionaryEnvironment
         _lhsOmatchIO :: IO ()
         _lhsOmatchIO = rule169 _tlImatchIO
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule170 _tlIpatternMatchWarnings
         _lhsOuniqueChunk :: Int
         _lhsOuniqueChunk = rule171 _tlIuniqueChunk
         _hdOallPatterns = rule172 _lhsIallPatterns
         _hdOallTypeSchemes = rule173 _lhsIallTypeSchemes
         _hdOambiguousConflicts = rule174 _lhsIambiguousConflicts
         _hdOavailablePredicates = rule175 _lhsIavailablePredicates
         _hdObetaLeft = rule176 _lhsIbetaLeft
         _hdObetaRight = rule177 _lhsIbetaRight
         _hdObetaUnique = rule178 _lhsIbetaUnique
         _hdOclassEnvironment = rule179 _lhsIclassEnvironment
         _hdOclassMemberEnv = rule180 _lhsIclassMemberEnv
         _hdOclassMemberTypeSchemes = rule181 _lhsIclassMemberTypeSchemes
         _hdOclassNamesEnv = rule182 _lhsIclassNamesEnv
         _hdOclassPredicate = rule183 _lhsIclassPredicate
         _hdOclassTypeSchemes = rule184 _lhsIclassTypeSchemes
         _hdOcollectErrors = rule185 _lhsIcollectErrors
         _hdOcollectWarnings = rule186 _lhsIcollectWarnings
         _hdOcounter = rule187 _lhsIcounter
         _hdOcurClassPred = rule188 _lhsIcurClassPred
         _hdOcurPred = rule189 _lhsIcurPred
         _hdOcurrentChunk = rule190 _lhsIcurrentChunk
         _hdOdictionaryEnvironment = rule191 _lhsIdictionaryEnvironment
         _hdOimportEnvironment = rule192 _lhsIimportEnvironment
         _hdOinstanceName = rule193 _lhsIinstanceName
         _hdOinstanceTypes = rule194 _lhsIinstanceTypes
         _hdOmatchIO = rule195 _lhsImatchIO
         _hdOmoduleName = rule196 _lhsImoduleName
         _hdOmonos = rule197 _lhsImonos
         _hdOnamesInScope = rule198 _lhsInamesInScope
         _hdOorderedTypeSynonyms = rule199 _lhsIorderedTypeSynonyms
         _hdOparentTree = rule200 _lhsIparentTree
         _hdOpatternMatchWarnings = rule201 _lhsIpatternMatchWarnings
         _hdOrequiredPredicates = rule202 _lhsIrequiredPredicates
         _hdOsubstitution = rule203 _lhsIsubstitution
         _hdOtypeConstructors = rule204 _lhsItypeConstructors
         _hdOtypeschemeMap = rule205 _lhsItypeschemeMap
         _hdOuniqueChunk = rule206 _lhsIuniqueChunk
         _hdOvariableMapping = rule207 _lhsIvariableMapping
         _tlOallPatterns = rule208 _lhsIallPatterns
         _tlOallTypeSchemes = rule209 _lhsIallTypeSchemes
         _tlOambiguousConflicts = rule210 _lhsIambiguousConflicts
         _tlOavailablePredicates = rule211 _lhsIavailablePredicates
         _tlObetaLeft = rule212 _lhsIbetaLeft
         _tlObetaRight = rule213 _lhsIbetaRight
         _tlObetaUnique = rule214 _hdIbetaUnique
         _tlOclassEnvironment = rule215 _lhsIclassEnvironment
         _tlOclassMemberEnv = rule216 _lhsIclassMemberEnv
         _tlOclassMemberTypeSchemes = rule217 _lhsIclassMemberTypeSchemes
         _tlOclassNamesEnv = rule218 _lhsIclassNamesEnv
         _tlOclassPredicate = rule219 _lhsIclassPredicate
         _tlOclassTypeSchemes = rule220 _lhsIclassTypeSchemes
         _tlOcollectErrors = rule221 _hdIcollectErrors
         _tlOcollectWarnings = rule222 _hdIcollectWarnings
         _tlOcounter = rule223 _hdIcounter
         _tlOcurClassPred = rule224 _lhsIcurClassPred
         _tlOcurPred = rule225 _lhsIcurPred
         _tlOcurrentChunk = rule226 _lhsIcurrentChunk
         _tlOdictionaryEnvironment = rule227 _hdIdictionaryEnvironment
         _tlOimportEnvironment = rule228 _lhsIimportEnvironment
         _tlOinstanceName = rule229 _lhsIinstanceName
         _tlOinstanceTypes = rule230 _lhsIinstanceTypes
         _tlOmatchIO = rule231 _hdImatchIO
         _tlOmoduleName = rule232 _lhsImoduleName
         _tlOmonos = rule233 _lhsImonos
         _tlOnamesInScope = rule234 _lhsInamesInScope
         _tlOorderedTypeSynonyms = rule235 _lhsIorderedTypeSynonyms
         _tlOparentTree = rule236 _lhsIparentTree
         _tlOpatternMatchWarnings = rule237 _hdIpatternMatchWarnings
         _tlOrequiredPredicates = rule238 _lhsIrequiredPredicates
         _tlOsubstitution = rule239 _lhsIsubstitution
         _tlOtypeConstructors = rule240 _lhsItypeConstructors
         _tlOtypeschemeMap = rule241 _lhsItypeschemeMap
         _tlOuniqueChunk = rule242 _hdIuniqueChunk
         _tlOvariableMapping = rule243 _lhsIvariableMapping
         !__result_ = T_Alternatives_vOut4 _lhsOassumptions _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraintslist _lhsOcounter _lhsOdictionaryEnvironment _lhsOelementss _lhsOinfoTrees _lhsOmatchIO _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOunrwars
         in __result_ )
     in C_Alternatives_s5 v4
   {-# INLINE rule155 #-}
   rule155 = \ ((_hdIelements) ::  ([PatternElement], Bool) ) ((_tlIelementss) :: [([PatternElement], Bool)]) ->
                                         _hdIelements : _tlIelementss
   {-# INLINE rule156 #-}
   rule156 = \ ((_hdIunrwar) :: Warning) ((_tlIunrwars) :: [Warning]) ->
                                         _hdIunrwar   : _tlIunrwars
   {-# INLINE rule157 #-}
   rule157 = \ ((_hdIinfoTrees) :: InfoTrees) ((_tlIinfoTrees) :: InfoTrees) ->
                               _hdIinfoTrees ++ _tlIinfoTrees
   {-# INLINE rule158 #-}
   rule158 = \ ((_hdIassumptions) :: Assumptions) ((_tlIassumptions) :: Assumptions) ->
                                _hdIassumptions `combine` _tlIassumptions
   {-# INLINE rule159 #-}
   rule159 = \ ((_hdIconstraints) :: ConstraintSet) ((_tlIconstraintslist) :: ConstraintSets) ->
                                _hdIconstraints : _tlIconstraintslist
   {-# INLINE rule160 #-}
   rule160 = \ ((_hdIcollectInstances) :: [(Name, Instance)]) ((_tlIcollectInstances) :: [(Name, Instance)]) ->
     _hdIcollectInstances  ++  _tlIcollectInstances
   {-# INLINE rule161 #-}
   rule161 = \ ((_hdIunboundNames) :: Names) ((_tlIunboundNames) :: Names) ->
     ((++) _hdIunboundNames _tlIunboundNames)
   {-# INLINE rule162 #-}
   rule162 = \ ((_hdIself) :: Alternative) ((_tlIself) :: Alternatives) ->
     (:) _hdIself _tlIself
   {-# INLINE rule163 #-}
   rule163 = \ _self ->
     _self
   {-# INLINE rule164 #-}
   rule164 = \ ((_tlIbetaUnique) :: Int) ->
     _tlIbetaUnique
   {-# INLINE rule165 #-}
   rule165 = \ ((_tlIcollectErrors) :: TypeErrors) ->
     _tlIcollectErrors
   {-# INLINE rule166 #-}
   rule166 = \ ((_tlIcollectWarnings) :: Warnings) ->
     _tlIcollectWarnings
   {-# INLINE rule167 #-}
   rule167 = \ ((_tlIcounter) :: Int) ->
     _tlIcounter
   {-# INLINE rule168 #-}
   rule168 = \ ((_tlIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _tlIdictionaryEnvironment
   {-# INLINE rule169 #-}
   rule169 = \ ((_tlImatchIO) :: IO ()) ->
     _tlImatchIO
   {-# INLINE rule170 #-}
   rule170 = \ ((_tlIpatternMatchWarnings) :: [Warning]) ->
     _tlIpatternMatchWarnings
   {-# INLINE rule171 #-}
   rule171 = \ ((_tlIuniqueChunk) :: Int) ->
     _tlIuniqueChunk
   {-# INLINE rule172 #-}
   rule172 = \ ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ->
     _lhsIallPatterns
   {-# INLINE rule173 #-}
   rule173 = \ ((_lhsIallTypeSchemes) :: M.Map NameWithRange TpScheme) ->
     _lhsIallTypeSchemes
   {-# INLINE rule174 #-}
   rule174 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule175 #-}
   rule175 = \ ((_lhsIavailablePredicates) :: [PredicateWithSource]) ->
     _lhsIavailablePredicates
   {-# INLINE rule176 #-}
   rule176 = \ ((_lhsIbetaLeft) :: Tp) ->
     _lhsIbetaLeft
   {-# INLINE rule177 #-}
   rule177 = \ ((_lhsIbetaRight) :: Tp) ->
     _lhsIbetaRight
   {-# INLINE rule178 #-}
   rule178 = \ ((_lhsIbetaUnique) :: Int) ->
     _lhsIbetaUnique
   {-# INLINE rule179 #-}
   rule179 = \ ((_lhsIclassEnvironment) :: ClassEnvironment) ->
     _lhsIclassEnvironment
   {-# INLINE rule180 #-}
   rule180 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule181 #-}
   rule181 = \ ((_lhsIclassMemberTypeSchemes) :: Maybe [(Name, TpScheme)]) ->
     _lhsIclassMemberTypeSchemes
   {-# INLINE rule182 #-}
   rule182 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule183 #-}
   rule183 = \ ((_lhsIclassPredicate) :: Maybe (Name, Names)) ->
     _lhsIclassPredicate
   {-# INLINE rule184 #-}
   rule184 = \ ((_lhsIclassTypeSchemes) :: M.Map Name TpScheme) ->
     _lhsIclassTypeSchemes
   {-# INLINE rule185 #-}
   rule185 = \ ((_lhsIcollectErrors) :: TypeErrors) ->
     _lhsIcollectErrors
   {-# INLINE rule186 #-}
   rule186 = \ ((_lhsIcollectWarnings) :: Warnings) ->
     _lhsIcollectWarnings
   {-# INLINE rule187 #-}
   rule187 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule188 #-}
   rule188 = \ ((_lhsIcurClassPred) :: Maybe Predicate) ->
     _lhsIcurClassPred
   {-# INLINE rule189 #-}
   rule189 = \ ((_lhsIcurPred) :: Maybe Predicate) ->
     _lhsIcurPred
   {-# INLINE rule190 #-}
   rule190 = \ ((_lhsIcurrentChunk) :: Int) ->
     _lhsIcurrentChunk
   {-# INLINE rule191 #-}
   rule191 = \ ((_lhsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _lhsIdictionaryEnvironment
   {-# INLINE rule192 #-}
   rule192 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule193 #-}
   rule193 = \ ((_lhsIinstanceName) :: Maybe Name) ->
     _lhsIinstanceName
   {-# INLINE rule194 #-}
   rule194 = \ ((_lhsIinstanceTypes) :: [(Name, TpScheme)]) ->
     _lhsIinstanceTypes
   {-# INLINE rule195 #-}
   rule195 = \ ((_lhsImatchIO) :: IO ()) ->
     _lhsImatchIO
   {-# INLINE rule196 #-}
   rule196 = \ ((_lhsImoduleName) :: Maybe Name) ->
     _lhsImoduleName
   {-# INLINE rule197 #-}
   rule197 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule198 #-}
   rule198 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule199 #-}
   rule199 = \ ((_lhsIorderedTypeSynonyms) :: OrderedTypeSynonyms) ->
     _lhsIorderedTypeSynonyms
   {-# INLINE rule200 #-}
   rule200 = \ ((_lhsIparentTree) :: InfoTree) ->
     _lhsIparentTree
   {-# INLINE rule201 #-}
   rule201 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule202 #-}
   rule202 = \ ((_lhsIrequiredPredicates) :: Predicates) ->
     _lhsIrequiredPredicates
   {-# INLINE rule203 #-}
   rule203 = \ ((_lhsIsubstitution) :: FixpointSubstitution) ->
     _lhsIsubstitution
   {-# INLINE rule204 #-}
   rule204 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
   {-# INLINE rule205 #-}
   rule205 = \ ((_lhsItypeschemeMap) :: M.Map Int (Scheme Predicates)) ->
     _lhsItypeschemeMap
   {-# INLINE rule206 #-}
   rule206 = \ ((_lhsIuniqueChunk) :: Int) ->
     _lhsIuniqueChunk
   {-# INLINE rule207 #-}
   rule207 = \ ((_lhsIvariableMapping) :: Maybe [(Name, Tp)]) ->
     _lhsIvariableMapping
   {-# INLINE rule208 #-}
   rule208 = \ ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ->
     _lhsIallPatterns
   {-# INLINE rule209 #-}
   rule209 = \ ((_lhsIallTypeSchemes) :: M.Map NameWithRange TpScheme) ->
     _lhsIallTypeSchemes
   {-# INLINE rule210 #-}
   rule210 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule211 #-}
   rule211 = \ ((_lhsIavailablePredicates) :: [PredicateWithSource]) ->
     _lhsIavailablePredicates
   {-# INLINE rule212 #-}
   rule212 = \ ((_lhsIbetaLeft) :: Tp) ->
     _lhsIbetaLeft
   {-# INLINE rule213 #-}
   rule213 = \ ((_lhsIbetaRight) :: Tp) ->
     _lhsIbetaRight
   {-# INLINE rule214 #-}
   rule214 = \ ((_hdIbetaUnique) :: Int) ->
     _hdIbetaUnique
   {-# INLINE rule215 #-}
   rule215 = \ ((_lhsIclassEnvironment) :: ClassEnvironment) ->
     _lhsIclassEnvironment
   {-# INLINE rule216 #-}
   rule216 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule217 #-}
   rule217 = \ ((_lhsIclassMemberTypeSchemes) :: Maybe [(Name, TpScheme)]) ->
     _lhsIclassMemberTypeSchemes
   {-# INLINE rule218 #-}
   rule218 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule219 #-}
   rule219 = \ ((_lhsIclassPredicate) :: Maybe (Name, Names)) ->
     _lhsIclassPredicate
   {-# INLINE rule220 #-}
   rule220 = \ ((_lhsIclassTypeSchemes) :: M.Map Name TpScheme) ->
     _lhsIclassTypeSchemes
   {-# INLINE rule221 #-}
   rule221 = \ ((_hdIcollectErrors) :: TypeErrors) ->
     _hdIcollectErrors
   {-# INLINE rule222 #-}
   rule222 = \ ((_hdIcollectWarnings) :: Warnings) ->
     _hdIcollectWarnings
   {-# INLINE rule223 #-}
   rule223 = \ ((_hdIcounter) :: Int) ->
     _hdIcounter
   {-# INLINE rule224 #-}
   rule224 = \ ((_lhsIcurClassPred) :: Maybe Predicate) ->
     _lhsIcurClassPred
   {-# INLINE rule225 #-}
   rule225 = \ ((_lhsIcurPred) :: Maybe Predicate) ->
     _lhsIcurPred
   {-# INLINE rule226 #-}
   rule226 = \ ((_lhsIcurrentChunk) :: Int) ->
     _lhsIcurrentChunk
   {-# INLINE rule227 #-}
   rule227 = \ ((_hdIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _hdIdictionaryEnvironment
   {-# INLINE rule228 #-}
   rule228 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule229 #-}
   rule229 = \ ((_lhsIinstanceName) :: Maybe Name) ->
     _lhsIinstanceName
   {-# INLINE rule230 #-}
   rule230 = \ ((_lhsIinstanceTypes) :: [(Name, TpScheme)]) ->
     _lhsIinstanceTypes
   {-# INLINE rule231 #-}
   rule231 = \ ((_hdImatchIO) :: IO ()) ->
     _hdImatchIO
   {-# INLINE rule232 #-}
   rule232 = \ ((_lhsImoduleName) :: Maybe Name) ->
     _lhsImoduleName
   {-# INLINE rule233 #-}
   rule233 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule234 #-}
   rule234 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule235 #-}
   rule235 = \ ((_lhsIorderedTypeSynonyms) :: OrderedTypeSynonyms) ->
     _lhsIorderedTypeSynonyms
   {-# INLINE rule236 #-}
   rule236 = \ ((_lhsIparentTree) :: InfoTree) ->
     _lhsIparentTree
   {-# INLINE rule237 #-}
   rule237 = \ ((_hdIpatternMatchWarnings) :: [Warning]) ->
     _hdIpatternMatchWarnings
   {-# INLINE rule238 #-}
   rule238 = \ ((_lhsIrequiredPredicates) :: Predicates) ->
     _lhsIrequiredPredicates
   {-# INLINE rule239 #-}
   rule239 = \ ((_lhsIsubstitution) :: FixpointSubstitution) ->
     _lhsIsubstitution
   {-# INLINE rule240 #-}
   rule240 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
   {-# INLINE rule241 #-}
   rule241 = \ ((_lhsItypeschemeMap) :: M.Map Int (Scheme Predicates)) ->
     _lhsItypeschemeMap
   {-# INLINE rule242 #-}
   rule242 = \ ((_hdIuniqueChunk) :: Int) ->
     _hdIuniqueChunk
   {-# INLINE rule243 #-}
   rule243 = \ ((_lhsIvariableMapping) :: Maybe [(Name, Tp)]) ->
     _lhsIvariableMapping
{-# NOINLINE sem_Alternatives_Nil #-}
sem_Alternatives_Nil ::  T_Alternatives 
sem_Alternatives_Nil  = T_Alternatives (return st5) where
   {-# NOINLINE st5 #-}
   !st5 = let
      v4 :: T_Alternatives_v4 
      v4 = \ !(T_Alternatives_vIn4 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaLeft _lhsIbetaRight _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeConstructors _lhsItypeschemeMap _lhsIuniqueChunk _lhsIvariableMapping) -> ( let
         _lhsOelementss :: [([PatternElement], Bool)]
         _lhsOelementss = rule244  ()
         _lhsOunrwars :: [Warning]
         _lhsOunrwars = rule245  ()
         _lhsOinfoTrees :: InfoTrees
         _lhsOinfoTrees = rule246  ()
         _lhsOassumptions :: Assumptions
         _lhsOassumptions = rule247  ()
         _lhsOconstraintslist :: ConstraintSets
         _lhsOconstraintslist = rule248  ()
         _lhsOcollectInstances :: [(Name, Instance)]
         _lhsOcollectInstances = rule249  ()
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule250  ()
         _self = rule251  ()
         _lhsOself :: Alternatives
         _lhsOself = rule252 _self
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule253 _lhsIbetaUnique
         _lhsOcollectErrors :: TypeErrors
         _lhsOcollectErrors = rule254 _lhsIcollectErrors
         _lhsOcollectWarnings :: Warnings
         _lhsOcollectWarnings = rule255 _lhsIcollectWarnings
         _lhsOcounter :: Int
         _lhsOcounter = rule256 _lhsIcounter
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule257 _lhsIdictionaryEnvironment
         _lhsOmatchIO :: IO ()
         _lhsOmatchIO = rule258 _lhsImatchIO
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule259 _lhsIpatternMatchWarnings
         _lhsOuniqueChunk :: Int
         _lhsOuniqueChunk = rule260 _lhsIuniqueChunk
         !__result_ = T_Alternatives_vOut4 _lhsOassumptions _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraintslist _lhsOcounter _lhsOdictionaryEnvironment _lhsOelementss _lhsOinfoTrees _lhsOmatchIO _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOunrwars
         in __result_ )
     in C_Alternatives_s5 v4
   {-# INLINE rule244 #-}
   rule244 = \  (_ :: ()) ->
                                         []
   {-# INLINE rule245 #-}
   rule245 = \  (_ :: ()) ->
                                         []
   {-# INLINE rule246 #-}
   rule246 = \  (_ :: ()) ->
                               []
   {-# INLINE rule247 #-}
   rule247 = \  (_ :: ()) ->
                                noAssumptions
   {-# INLINE rule248 #-}
   rule248 = \  (_ :: ()) ->
                                []
   {-# INLINE rule249 #-}
   rule249 = \  (_ :: ()) ->
     []
   {-# INLINE rule250 #-}
   rule250 = \  (_ :: ()) ->
     []
   {-# INLINE rule251 #-}
   rule251 = \  (_ :: ()) ->
     []
   {-# INLINE rule252 #-}
   rule252 = \ _self ->
     _self
   {-# INLINE rule253 #-}
   rule253 = \ ((_lhsIbetaUnique) :: Int) ->
     _lhsIbetaUnique
   {-# INLINE rule254 #-}
   rule254 = \ ((_lhsIcollectErrors) :: TypeErrors) ->
     _lhsIcollectErrors
   {-# INLINE rule255 #-}
   rule255 = \ ((_lhsIcollectWarnings) :: Warnings) ->
     _lhsIcollectWarnings
   {-# INLINE rule256 #-}
   rule256 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule257 #-}
   rule257 = \ ((_lhsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _lhsIdictionaryEnvironment
   {-# INLINE rule258 #-}
   rule258 = \ ((_lhsImatchIO) :: IO ()) ->
     _lhsImatchIO
   {-# INLINE rule259 #-}
   rule259 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule260 #-}
   rule260 = \ ((_lhsIuniqueChunk) :: Int) ->
     _lhsIuniqueChunk

-- AnnotatedType -----------------------------------------------
-- wrapper
data Inh_AnnotatedType  = Inh_AnnotatedType { ambiguousConflicts_Inh_AnnotatedType :: !([[Name]]), classMemberEnv_Inh_AnnotatedType :: !(ClassMemberEnvironment), classNamesEnv_Inh_AnnotatedType :: !(ClassNameEnvironment), counter_Inh_AnnotatedType :: !(Int), namesInScope_Inh_AnnotatedType :: !(Names) }
data Syn_AnnotatedType  = Syn_AnnotatedType { counter_Syn_AnnotatedType :: !(Int), self_Syn_AnnotatedType :: !(AnnotatedType), unboundNames_Syn_AnnotatedType :: !(Names) }
{-# INLINABLE wrap_AnnotatedType #-}
wrap_AnnotatedType :: T_AnnotatedType  -> Inh_AnnotatedType  -> (Syn_AnnotatedType )
wrap_AnnotatedType !(T_AnnotatedType act) !(Inh_AnnotatedType _lhsIambiguousConflicts _lhsIclassMemberEnv _lhsIclassNamesEnv _lhsIcounter _lhsInamesInScope) =
   Control.Monad.Identity.runIdentity (
     do !sem <- act
        let arg7 = T_AnnotatedType_vIn7 _lhsIambiguousConflicts _lhsIclassMemberEnv _lhsIclassNamesEnv _lhsIcounter _lhsInamesInScope
        !(T_AnnotatedType_vOut7 _lhsOcounter _lhsOself _lhsOunboundNames) <- return (inv_AnnotatedType_s8 sem arg7)
        return (Syn_AnnotatedType _lhsOcounter _lhsOself _lhsOunboundNames)
   )

-- cata
{-# INLINE sem_AnnotatedType #-}
sem_AnnotatedType :: AnnotatedType  -> T_AnnotatedType 
sem_AnnotatedType ( AnnotatedType_AnnotatedType range_ !strict_ type_ ) = sem_AnnotatedType_AnnotatedType ( sem_Range range_ ) strict_ ( sem_Type type_ )

-- semantic domain
newtype T_AnnotatedType  = T_AnnotatedType {
                                           attach_T_AnnotatedType :: Identity (T_AnnotatedType_s8 )
                                           }
newtype T_AnnotatedType_s8  = C_AnnotatedType_s8 {
                                                 inv_AnnotatedType_s8 :: (T_AnnotatedType_v7 )
                                                 }
data T_AnnotatedType_s9  = C_AnnotatedType_s9
type T_AnnotatedType_v7  = (T_AnnotatedType_vIn7 ) -> (T_AnnotatedType_vOut7 )
data T_AnnotatedType_vIn7  = T_AnnotatedType_vIn7 ([[Name]]) (ClassMemberEnvironment) (ClassNameEnvironment) (Int) (Names)
data T_AnnotatedType_vOut7  = T_AnnotatedType_vOut7 (Int) (AnnotatedType) (Names)
{-# NOINLINE sem_AnnotatedType_AnnotatedType #-}
sem_AnnotatedType_AnnotatedType :: T_Range  -> (Bool) -> T_Type  -> T_AnnotatedType 
sem_AnnotatedType_AnnotatedType arg_range_ !arg_strict_ arg_type_ = T_AnnotatedType (return st8) where
   {-# NOINLINE st8 #-}
   !st8 = let
      v7 :: T_AnnotatedType_v7 
      v7 = \ !(T_AnnotatedType_vIn7 _lhsIambiguousConflicts _lhsIclassMemberEnv _lhsIclassNamesEnv _lhsIcounter _lhsInamesInScope) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _typeX164 = Control.Monad.Identity.runIdentity (attach_T_Type (arg_type_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_Type_vOut163 _typeIself) = inv_Type_s164 _typeX164 (T_Type_vIn163 _typeOclassMemberEnv _typeOclassNamesEnv)
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule261  ()
         _self = rule262 _rangeIself _typeIself arg_strict_
         _lhsOself :: AnnotatedType
         _lhsOself = rule263 _self
         _lhsOcounter :: Int
         _lhsOcounter = rule264 _lhsIcounter
         _typeOclassMemberEnv = rule265 _lhsIclassMemberEnv
         _typeOclassNamesEnv = rule266 _lhsIclassNamesEnv
         !__result_ = T_AnnotatedType_vOut7 _lhsOcounter _lhsOself _lhsOunboundNames
         in __result_ )
     in C_AnnotatedType_s8 v7
   {-# INLINE rule261 #-}
   rule261 = \  (_ :: ()) ->
     []
   {-# INLINE rule262 #-}
   rule262 = \ ((_rangeIself) :: Range) ((_typeIself) :: Type) strict_ ->
     AnnotatedType_AnnotatedType _rangeIself strict_ _typeIself
   {-# INLINE rule263 #-}
   rule263 = \ _self ->
     _self
   {-# INLINE rule264 #-}
   rule264 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule265 #-}
   rule265 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule266 #-}
   rule266 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv

-- AnnotatedTypes ----------------------------------------------
-- wrapper
data Inh_AnnotatedTypes  = Inh_AnnotatedTypes { ambiguousConflicts_Inh_AnnotatedTypes :: !([[Name]]), classMemberEnv_Inh_AnnotatedTypes :: !(ClassMemberEnvironment), classNamesEnv_Inh_AnnotatedTypes :: !(ClassNameEnvironment), counter_Inh_AnnotatedTypes :: !(Int), namesInScope_Inh_AnnotatedTypes :: !(Names) }
data Syn_AnnotatedTypes  = Syn_AnnotatedTypes { counter_Syn_AnnotatedTypes :: !(Int), self_Syn_AnnotatedTypes :: !(AnnotatedTypes), unboundNames_Syn_AnnotatedTypes :: !(Names) }
{-# INLINABLE wrap_AnnotatedTypes #-}
wrap_AnnotatedTypes :: T_AnnotatedTypes  -> Inh_AnnotatedTypes  -> (Syn_AnnotatedTypes )
wrap_AnnotatedTypes !(T_AnnotatedTypes act) !(Inh_AnnotatedTypes _lhsIambiguousConflicts _lhsIclassMemberEnv _lhsIclassNamesEnv _lhsIcounter _lhsInamesInScope) =
   Control.Monad.Identity.runIdentity (
     do !sem <- act
        let arg10 = T_AnnotatedTypes_vIn10 _lhsIambiguousConflicts _lhsIclassMemberEnv _lhsIclassNamesEnv _lhsIcounter _lhsInamesInScope
        !(T_AnnotatedTypes_vOut10 _lhsOcounter _lhsOself _lhsOunboundNames) <- return (inv_AnnotatedTypes_s11 sem arg10)
        return (Syn_AnnotatedTypes _lhsOcounter _lhsOself _lhsOunboundNames)
   )

-- cata
{-# NOINLINE sem_AnnotatedTypes #-}
sem_AnnotatedTypes :: AnnotatedTypes  -> T_AnnotatedTypes 
sem_AnnotatedTypes list = Prelude.foldr sem_AnnotatedTypes_Cons sem_AnnotatedTypes_Nil (Prelude.map sem_AnnotatedType list)

-- semantic domain
newtype T_AnnotatedTypes  = T_AnnotatedTypes {
                                             attach_T_AnnotatedTypes :: Identity (T_AnnotatedTypes_s11 )
                                             }
newtype T_AnnotatedTypes_s11  = C_AnnotatedTypes_s11 {
                                                     inv_AnnotatedTypes_s11 :: (T_AnnotatedTypes_v10 )
                                                     }
data T_AnnotatedTypes_s12  = C_AnnotatedTypes_s12
type T_AnnotatedTypes_v10  = (T_AnnotatedTypes_vIn10 ) -> (T_AnnotatedTypes_vOut10 )
data T_AnnotatedTypes_vIn10  = T_AnnotatedTypes_vIn10 ([[Name]]) (ClassMemberEnvironment) (ClassNameEnvironment) (Int) (Names)
data T_AnnotatedTypes_vOut10  = T_AnnotatedTypes_vOut10 (Int) (AnnotatedTypes) (Names)
{-# NOINLINE sem_AnnotatedTypes_Cons #-}
sem_AnnotatedTypes_Cons :: T_AnnotatedType  -> T_AnnotatedTypes  -> T_AnnotatedTypes 
sem_AnnotatedTypes_Cons arg_hd_ arg_tl_ = T_AnnotatedTypes (return st11) where
   {-# NOINLINE st11 #-}
   !st11 = let
      v10 :: T_AnnotatedTypes_v10 
      v10 = \ !(T_AnnotatedTypes_vIn10 _lhsIambiguousConflicts _lhsIclassMemberEnv _lhsIclassNamesEnv _lhsIcounter _lhsInamesInScope) -> ( let
         _hdX8 = Control.Monad.Identity.runIdentity (attach_T_AnnotatedType (arg_hd_))
         _tlX11 = Control.Monad.Identity.runIdentity (attach_T_AnnotatedTypes (arg_tl_))
         (T_AnnotatedType_vOut7 _hdIcounter _hdIself _hdIunboundNames) = inv_AnnotatedType_s8 _hdX8 (T_AnnotatedType_vIn7 _hdOambiguousConflicts _hdOclassMemberEnv _hdOclassNamesEnv _hdOcounter _hdOnamesInScope)
         (T_AnnotatedTypes_vOut10 _tlIcounter _tlIself _tlIunboundNames) = inv_AnnotatedTypes_s11 _tlX11 (T_AnnotatedTypes_vIn10 _tlOambiguousConflicts _tlOclassMemberEnv _tlOclassNamesEnv _tlOcounter _tlOnamesInScope)
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule267 _hdIunboundNames _tlIunboundNames
         _self = rule268 _hdIself _tlIself
         _lhsOself :: AnnotatedTypes
         _lhsOself = rule269 _self
         _lhsOcounter :: Int
         _lhsOcounter = rule270 _tlIcounter
         _hdOambiguousConflicts = rule271 _lhsIambiguousConflicts
         _hdOclassMemberEnv = rule272 _lhsIclassMemberEnv
         _hdOclassNamesEnv = rule273 _lhsIclassNamesEnv
         _hdOcounter = rule274 _lhsIcounter
         _hdOnamesInScope = rule275 _lhsInamesInScope
         _tlOambiguousConflicts = rule276 _lhsIambiguousConflicts
         _tlOclassMemberEnv = rule277 _lhsIclassMemberEnv
         _tlOclassNamesEnv = rule278 _lhsIclassNamesEnv
         _tlOcounter = rule279 _hdIcounter
         _tlOnamesInScope = rule280 _lhsInamesInScope
         !__result_ = T_AnnotatedTypes_vOut10 _lhsOcounter _lhsOself _lhsOunboundNames
         in __result_ )
     in C_AnnotatedTypes_s11 v10
   {-# INLINE rule267 #-}
   rule267 = \ ((_hdIunboundNames) :: Names) ((_tlIunboundNames) :: Names) ->
     ((++) _hdIunboundNames _tlIunboundNames)
   {-# INLINE rule268 #-}
   rule268 = \ ((_hdIself) :: AnnotatedType) ((_tlIself) :: AnnotatedTypes) ->
     (:) _hdIself _tlIself
   {-# INLINE rule269 #-}
   rule269 = \ _self ->
     _self
   {-# INLINE rule270 #-}
   rule270 = \ ((_tlIcounter) :: Int) ->
     _tlIcounter
   {-# INLINE rule271 #-}
   rule271 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule272 #-}
   rule272 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule273 #-}
   rule273 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule274 #-}
   rule274 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule275 #-}
   rule275 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule276 #-}
   rule276 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule277 #-}
   rule277 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule278 #-}
   rule278 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule279 #-}
   rule279 = \ ((_hdIcounter) :: Int) ->
     _hdIcounter
   {-# INLINE rule280 #-}
   rule280 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
{-# NOINLINE sem_AnnotatedTypes_Nil #-}
sem_AnnotatedTypes_Nil ::  T_AnnotatedTypes 
sem_AnnotatedTypes_Nil  = T_AnnotatedTypes (return st11) where
   {-# NOINLINE st11 #-}
   !st11 = let
      v10 :: T_AnnotatedTypes_v10 
      v10 = \ !(T_AnnotatedTypes_vIn10 _lhsIambiguousConflicts _lhsIclassMemberEnv _lhsIclassNamesEnv _lhsIcounter _lhsInamesInScope) -> ( let
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule281  ()
         _self = rule282  ()
         _lhsOself :: AnnotatedTypes
         _lhsOself = rule283 _self
         _lhsOcounter :: Int
         _lhsOcounter = rule284 _lhsIcounter
         !__result_ = T_AnnotatedTypes_vOut10 _lhsOcounter _lhsOself _lhsOunboundNames
         in __result_ )
     in C_AnnotatedTypes_s11 v10
   {-# INLINE rule281 #-}
   rule281 = \  (_ :: ()) ->
     []
   {-# INLINE rule282 #-}
   rule282 = \  (_ :: ()) ->
     []
   {-# INLINE rule283 #-}
   rule283 = \ _self ->
     _self
   {-# INLINE rule284 #-}
   rule284 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter

-- Body --------------------------------------------------------
-- wrapper
data Inh_Body  = Inh_Body { allPatterns_Inh_Body :: !([((Expression, [String]), Core_TypingStrategy)]), allTypeSchemes_Inh_Body :: !(M.Map NameWithRange TpScheme), ambiguousConflicts_Inh_Body :: !([[Name]]), availablePredicates_Inh_Body :: !([PredicateWithSource]), betaUnique_Inh_Body :: !(Int), classEnvironment_Inh_Body :: !(ClassEnvironment), classMemberEnv_Inh_Body :: !(ClassMemberEnvironment), classMemberTypeSchemes_Inh_Body :: !(Maybe [(Name, TpScheme)]), classNamesEnv_Inh_Body :: !(ClassNameEnvironment), classPredicate_Inh_Body :: !(Maybe (Name, Names)), classTypeSchemes_Inh_Body :: !(M.Map Name TpScheme), collectErrors_Inh_Body :: !(TypeErrors), collectWarnings_Inh_Body :: !(Warnings), counter_Inh_Body :: !(Int), curClassPred_Inh_Body :: !(Maybe Predicate), curPred_Inh_Body :: !(Maybe Predicate), currentChunk_Inh_Body :: !(Int), dictionaryEnvironment_Inh_Body :: !(DictionaryEnvironment), importEnvironment_Inh_Body :: !(ImportEnvironment), instanceName_Inh_Body :: !(Maybe Name), instanceTypes_Inh_Body :: !([(Name, TpScheme)]), isTopLevel_Inh_Body :: !(Bool), matchIO_Inh_Body :: !(IO ()), moduleName_Inh_Body :: !(Maybe Name), moduleQual_Inh_Body :: !( [String] ), monos_Inh_Body :: !(Monos), namesInScope_Inh_Body :: !(Names), orderedTypeSynonyms_Inh_Body :: !(OrderedTypeSynonyms), patternMatchWarnings_Inh_Body :: !([Warning]), requiredPredicates_Inh_Body :: !(Predicates), substitution_Inh_Body :: !(FixpointSubstitution), typeConstructors_Inh_Body :: !(TypeConstructorEnvironment), typeschemeMap_Inh_Body :: !(M.Map Int (Scheme Predicates)), uniqueChunk_Inh_Body :: !(Int), variableMapping_Inh_Body :: !(Maybe [(Name, Tp)]) }
data Syn_Body  = Syn_Body { assumptions_Syn_Body :: !(Assumptions), betaUnique_Syn_Body :: !(Int), classMemberNames_Syn_Body :: !(Names), collectErrors_Syn_Body :: !(TypeErrors), collectInstances_Syn_Body :: !([(Name, Instance)]), collectWarnings_Syn_Body :: !(Warnings), constraints_Syn_Body :: !(ConstraintSet), counter_Syn_Body :: !(Int), declVarNames_Syn_Body :: !(Names), dictionaryEnvironment_Syn_Body :: !(DictionaryEnvironment), infoTree_Syn_Body :: !(InfoTree), matchIO_Syn_Body :: !(IO ()), patternMatchWarnings_Syn_Body :: !([Warning]), self_Syn_Body :: !(Body), toplevelTypes_Syn_Body :: !(TypeEnvironment), unboundNames_Syn_Body :: !(Names), uniqueChunk_Syn_Body :: !(Int) }
{-# INLINABLE wrap_Body #-}
wrap_Body :: T_Body  -> Inh_Body  -> (Syn_Body )
wrap_Body !(T_Body act) !(Inh_Body _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsIisTopLevel _lhsImatchIO _lhsImoduleName _lhsImoduleQual _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeConstructors _lhsItypeschemeMap _lhsIuniqueChunk _lhsIvariableMapping) =
   Control.Monad.Identity.runIdentity (
     do !sem <- act
        let arg13 = T_Body_vIn13 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsIisTopLevel _lhsImatchIO _lhsImoduleName _lhsImoduleQual _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeConstructors _lhsItypeschemeMap _lhsIuniqueChunk _lhsIvariableMapping
        !(T_Body_vOut13 _lhsOassumptions _lhsObetaUnique _lhsOclassMemberNames _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraints _lhsOcounter _lhsOdeclVarNames _lhsOdictionaryEnvironment _lhsOinfoTree _lhsOmatchIO _lhsOpatternMatchWarnings _lhsOself _lhsOtoplevelTypes _lhsOunboundNames _lhsOuniqueChunk) <- return (inv_Body_s14 sem arg13)
        return (Syn_Body _lhsOassumptions _lhsObetaUnique _lhsOclassMemberNames _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraints _lhsOcounter _lhsOdeclVarNames _lhsOdictionaryEnvironment _lhsOinfoTree _lhsOmatchIO _lhsOpatternMatchWarnings _lhsOself _lhsOtoplevelTypes _lhsOunboundNames _lhsOuniqueChunk)
   )

-- cata
{-# NOINLINE sem_Body #-}
sem_Body :: Body  -> T_Body 
sem_Body ( Body_Hole range_ !id_ ) = sem_Body_Hole ( sem_Range range_ ) id_
sem_Body ( Body_Body range_ importdeclarations_ declarations_ ) = sem_Body_Body ( sem_Range range_ ) ( sem_ImportDeclarations importdeclarations_ ) ( sem_Declarations declarations_ )

-- semantic domain
newtype T_Body  = T_Body {
                         attach_T_Body :: Identity (T_Body_s14 )
                         }
newtype T_Body_s14  = C_Body_s14 {
                                 inv_Body_s14 :: (T_Body_v13 )
                                 }
data T_Body_s15  = C_Body_s15
type T_Body_v13  = (T_Body_vIn13 ) -> (T_Body_vOut13 )
data T_Body_vIn13  = T_Body_vIn13 ([((Expression, [String]), Core_TypingStrategy)]) (M.Map NameWithRange TpScheme) ([[Name]]) ([PredicateWithSource]) (Int) (ClassEnvironment) (ClassMemberEnvironment) (Maybe [(Name, TpScheme)]) (ClassNameEnvironment) (Maybe (Name, Names)) (M.Map Name TpScheme) (TypeErrors) (Warnings) (Int) (Maybe Predicate) (Maybe Predicate) (Int) (DictionaryEnvironment) (ImportEnvironment) (Maybe Name) ([(Name, TpScheme)]) (Bool) (IO ()) (Maybe Name) ( [String] ) (Monos) (Names) (OrderedTypeSynonyms) ([Warning]) (Predicates) (FixpointSubstitution) (TypeConstructorEnvironment) (M.Map Int (Scheme Predicates)) (Int) (Maybe [(Name, Tp)])
data T_Body_vOut13  = T_Body_vOut13 (Assumptions) (Int) (Names) (TypeErrors) ([(Name, Instance)]) (Warnings) (ConstraintSet) (Int) (Names) (DictionaryEnvironment) (InfoTree) (IO ()) ([Warning]) (Body) (TypeEnvironment) (Names) (Int)
{-# NOINLINE sem_Body_Hole #-}
sem_Body_Hole :: T_Range  -> (String) -> T_Body 
sem_Body_Hole arg_range_ !arg_id_ = T_Body (return st14) where
   {-# NOINLINE st14 #-}
   !st14 = let
      v13 :: T_Body_v13 
      v13 = \ !(T_Body_vIn13 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsIisTopLevel _lhsImatchIO _lhsImoduleName _lhsImoduleQual _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeConstructors _lhsItypeschemeMap _lhsIuniqueChunk _lhsIvariableMapping) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         _lhsOinfoTree :: InfoTree
         _lhsOinfoTree = rule285  ()
         _lhsOtoplevelTypes :: TypeEnvironment
         _lhsOtoplevelTypes = rule286  ()
         _lhsOassumptions :: Assumptions
         _lhsOassumptions = rule287  ()
         _lhsOconstraints :: ConstraintSet
         _lhsOconstraints = rule288  ()
         _lhsOclassMemberNames :: Names
         _lhsOclassMemberNames = rule289  ()
         _lhsOcollectInstances :: [(Name, Instance)]
         _lhsOcollectInstances = rule290  ()
         _lhsOdeclVarNames :: Names
         _lhsOdeclVarNames = rule291  ()
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule292  ()
         _self = rule293 _rangeIself arg_id_
         _lhsOself :: Body
         _lhsOself = rule294 _self
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule295 _lhsIbetaUnique
         _lhsOcollectErrors :: TypeErrors
         _lhsOcollectErrors = rule296 _lhsIcollectErrors
         _lhsOcollectWarnings :: Warnings
         _lhsOcollectWarnings = rule297 _lhsIcollectWarnings
         _lhsOcounter :: Int
         _lhsOcounter = rule298 _lhsIcounter
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule299 _lhsIdictionaryEnvironment
         _lhsOmatchIO :: IO ()
         _lhsOmatchIO = rule300 _lhsImatchIO
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule301 _lhsIpatternMatchWarnings
         _lhsOuniqueChunk :: Int
         _lhsOuniqueChunk = rule302 _lhsIuniqueChunk
         !__result_ = T_Body_vOut13 _lhsOassumptions _lhsObetaUnique _lhsOclassMemberNames _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraints _lhsOcounter _lhsOdeclVarNames _lhsOdictionaryEnvironment _lhsOinfoTree _lhsOmatchIO _lhsOpatternMatchWarnings _lhsOself _lhsOtoplevelTypes _lhsOunboundNames _lhsOuniqueChunk
         in __result_ )
     in C_Body_s14 v13
   {-# INLINE rule285 #-}
   rule285 = \  (_ :: ()) ->
                                    root (LocalInfo {self = UHA_Decls [], assignedType = Nothing, monos = []}) []
   {-# INLINE rule286 #-}
   rule286 = \  (_ :: ()) ->
                                   M.empty
   {-# INLINE rule287 #-}
   rule287 = \  (_ :: ()) ->
                            noAssumptions
   {-# INLINE rule288 #-}
   rule288 = \  (_ :: ()) ->
                            emptyTree
   {-# INLINE rule289 #-}
   rule289 = \  (_ :: ()) ->
     []
   {-# INLINE rule290 #-}
   rule290 = \  (_ :: ()) ->
     []
   {-# INLINE rule291 #-}
   rule291 = \  (_ :: ()) ->
     []
   {-# INLINE rule292 #-}
   rule292 = \  (_ :: ()) ->
     []
   {-# INLINE rule293 #-}
   rule293 = \ ((_rangeIself) :: Range) id_ ->
     Body_Hole _rangeIself id_
   {-# INLINE rule294 #-}
   rule294 = \ _self ->
     _self
   {-# INLINE rule295 #-}
   rule295 = \ ((_lhsIbetaUnique) :: Int) ->
     _lhsIbetaUnique
   {-# INLINE rule296 #-}
   rule296 = \ ((_lhsIcollectErrors) :: TypeErrors) ->
     _lhsIcollectErrors
   {-# INLINE rule297 #-}
   rule297 = \ ((_lhsIcollectWarnings) :: Warnings) ->
     _lhsIcollectWarnings
   {-# INLINE rule298 #-}
   rule298 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule299 #-}
   rule299 = \ ((_lhsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _lhsIdictionaryEnvironment
   {-# INLINE rule300 #-}
   rule300 = \ ((_lhsImatchIO) :: IO ()) ->
     _lhsImatchIO
   {-# INLINE rule301 #-}
   rule301 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule302 #-}
   rule302 = \ ((_lhsIuniqueChunk) :: Int) ->
     _lhsIuniqueChunk
{-# NOINLINE sem_Body_Body #-}
sem_Body_Body :: T_Range  -> T_ImportDeclarations  -> T_Declarations  -> T_Body 
sem_Body_Body arg_range_ arg_importdeclarations_ arg_declarations_ = T_Body (return st14) where
   {-# NOINLINE st14 #-}
   !st14 = let
      v13 :: T_Body_v13 
      v13 = \ !(T_Body_vIn13 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsIisTopLevel _lhsImatchIO _lhsImoduleName _lhsImoduleQual _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeConstructors _lhsItypeschemeMap _lhsIuniqueChunk _lhsIvariableMapping) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _importdeclarationsX74 = Control.Monad.Identity.runIdentity (attach_T_ImportDeclarations (arg_importdeclarations_))
         _declarationsX32 = Control.Monad.Identity.runIdentity (attach_T_Declarations (arg_declarations_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_ImportDeclarations_vOut73 _importdeclarationsIself) = inv_ImportDeclarations_s74 _importdeclarationsX74 (T_ImportDeclarations_vIn73 )
         (T_Declarations_vOut31 _declarationsIbetaUnique _declarationsIbindingGroups _declarationsIboundBetas _declarationsIclassMemberNames _declarationsIcollectErrors _declarationsIcollectInstances _declarationsIcollectWarnings _declarationsIcounter _declarationsIdeclVarNames _declarationsIdictionaryEnvironment _declarationsIinfoTrees _declarationsImatchIO _declarationsIpatternMatchWarnings _declarationsIrestrictedNames _declarationsIself _declarationsIsimplePatNames _declarationsItypeMemberBindings _declarationsItypeSignatures _declarationsIunboundNames _declarationsIuniqueChunk) = inv_Declarations_s32 _declarationsX32 (T_Declarations_vIn31 _declarationsOallPatterns _declarationsOallTypeSchemes _declarationsOambiguousConflicts _declarationsOavailablePredicates _declarationsObetaUnique _declarationsObindingGroups _declarationsOclassEnvironment _declarationsOclassMemberEnv _declarationsOclassMemberTypeSchemes _declarationsOclassNamesEnv _declarationsOclassPredicate _declarationsOclassTypeSchemes _declarationsOcollectErrors _declarationsOcollectWarnings _declarationsOcounter _declarationsOcurClassPred _declarationsOcurPred _declarationsOcurrentChunk _declarationsOdictionaryEnvironment _declarationsOimportEnvironment _declarationsOinheritedBDG _declarationsOinstanceName _declarationsOinstanceTypes _declarationsOisTopLevel _declarationsOmatchIO _declarationsOmoduleName _declarationsOmoduleQual _declarationsOmonos _declarationsOnamesInScope _declarationsOorderedTypeSynonyms _declarationsOparentTree _declarationsOpatternMatchWarnings _declarationsOrequiredPredicates _declarationsOsubstitution _declarationsOtypeConstructors _declarationsOtypeSignatures _declarationsOtypeschemeMap _declarationsOuniqueChunk _declarationsOvariableMapping)
         _parentTree = rule303 _declInfo _declarationsIinfoTrees
         _lhsOinfoTree :: InfoTree
         _lhsOinfoTree = rule304 _parentTree
         _declInfo = rule305 _declarationsIself _lhsImonos
         _cinfo = rule306  ()
         _inferredTypes = rule307 _implicitsFM _lhsItypeschemeMap
         _env = rule308 _lhsIimportEnvironment
         _lhsOcollectWarnings :: Warnings
         _lhsOcollectWarnings = rule309 _declarationsIcollectWarnings _declarationsIsimplePatNames _env _inferredTypes _lhsIimportEnvironment
         _lhsOcollectErrors :: TypeErrors
         _lhsOcollectErrors = rule310 _declarationsIcollectErrors _declarationsIrestrictedNames _inferredTypes _lhsIimportEnvironment
         _lhsOtoplevelTypes :: TypeEnvironment
         _lhsOtoplevelTypes = rule311 _declarationsItypeSignatures _inferredTypes
         _allTypeSchemes = rule312 _lhsIallTypeSchemes _localTypes
         _localTypes = rule313 _declarationsIbindingGroups _declarationsItypeSignatures _inferredTypes
         _declarationsOtypeSignatures = rule314  ()
         _lhsOuniqueChunk :: Int
         _lhsOuniqueChunk = rule315 _chunkNr
         _declarationsObindingGroups = rule316  ()
         _lhsOassumptions :: Assumptions
         _lhsOassumptions = rule317 _assumps
         (_csetBinds,_assumps) = rule318 _aset _cinfo _lhsIimportEnvironment
         _constraints = rule319 _cset _csetBinds
         _lhsObetaUnique :: Int
         (_aset,_cset,_inheritedBDG,_chunkNr,_lhsObetaUnique,_implicitsFM) = rule320 _declarationsIbetaUnique _declarationsIbindingGroups _declarationsItypeSignatures _declarationsIuniqueChunk _lhsIcurrentChunk _lhsImonos
         _lhsOclassMemberNames :: Names
         _lhsOclassMemberNames = rule321 _declarationsIclassMemberNames
         _lhsOcollectInstances :: [(Name, Instance)]
         _lhsOcollectInstances = rule322 _declarationsIcollectInstances
         _lhsOdeclVarNames :: Names
         _lhsOdeclVarNames = rule323 _declarationsIdeclVarNames
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule324 _declarationsIunboundNames
         _self = rule325 _declarationsIself _importdeclarationsIself _rangeIself
         _lhsOself :: Body
         _lhsOself = rule326 _self
         _lhsOconstraints :: ConstraintSet
         _lhsOconstraints = rule327 _constraints
         _lhsOcounter :: Int
         _lhsOcounter = rule328 _declarationsIcounter
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule329 _declarationsIdictionaryEnvironment
         _lhsOmatchIO :: IO ()
         _lhsOmatchIO = rule330 _declarationsImatchIO
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule331 _declarationsIpatternMatchWarnings
         _declarationsOallPatterns = rule332 _lhsIallPatterns
         _declarationsOallTypeSchemes = rule333 _allTypeSchemes
         _declarationsOambiguousConflicts = rule334 _lhsIambiguousConflicts
         _declarationsOavailablePredicates = rule335 _lhsIavailablePredicates
         _declarationsObetaUnique = rule336 _lhsIbetaUnique
         _declarationsOclassEnvironment = rule337 _lhsIclassEnvironment
         _declarationsOclassMemberEnv = rule338 _lhsIclassMemberEnv
         _declarationsOclassMemberTypeSchemes = rule339 _lhsIclassMemberTypeSchemes
         _declarationsOclassNamesEnv = rule340 _lhsIclassNamesEnv
         _declarationsOclassPredicate = rule341 _lhsIclassPredicate
         _declarationsOclassTypeSchemes = rule342 _lhsIclassTypeSchemes
         _declarationsOcollectErrors = rule343 _lhsIcollectErrors
         _declarationsOcollectWarnings = rule344 _lhsIcollectWarnings
         _declarationsOcounter = rule345 _lhsIcounter
         _declarationsOcurClassPred = rule346 _lhsIcurClassPred
         _declarationsOcurPred = rule347 _lhsIcurPred
         _declarationsOcurrentChunk = rule348 _lhsIcurrentChunk
         _declarationsOdictionaryEnvironment = rule349 _lhsIdictionaryEnvironment
         _declarationsOimportEnvironment = rule350 _lhsIimportEnvironment
         _declarationsOinheritedBDG = rule351 _inheritedBDG
         _declarationsOinstanceName = rule352 _lhsIinstanceName
         _declarationsOinstanceTypes = rule353 _lhsIinstanceTypes
         _declarationsOisTopLevel = rule354 _lhsIisTopLevel
         _declarationsOmatchIO = rule355 _lhsImatchIO
         _declarationsOmoduleName = rule356 _lhsImoduleName
         _declarationsOmoduleQual = rule357 _lhsImoduleQual
         _declarationsOmonos = rule358 _lhsImonos
         _declarationsOnamesInScope = rule359 _lhsInamesInScope
         _declarationsOorderedTypeSynonyms = rule360 _lhsIorderedTypeSynonyms
         _declarationsOparentTree = rule361 _parentTree
         _declarationsOpatternMatchWarnings = rule362 _lhsIpatternMatchWarnings
         _declarationsOrequiredPredicates = rule363 _lhsIrequiredPredicates
         _declarationsOsubstitution = rule364 _lhsIsubstitution
         _declarationsOtypeConstructors = rule365 _lhsItypeConstructors
         _declarationsOtypeschemeMap = rule366 _lhsItypeschemeMap
         _declarationsOuniqueChunk = rule367 _lhsIuniqueChunk
         _declarationsOvariableMapping = rule368 _lhsIvariableMapping
         !__result_ = T_Body_vOut13 _lhsOassumptions _lhsObetaUnique _lhsOclassMemberNames _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraints _lhsOcounter _lhsOdeclVarNames _lhsOdictionaryEnvironment _lhsOinfoTree _lhsOmatchIO _lhsOpatternMatchWarnings _lhsOself _lhsOtoplevelTypes _lhsOunboundNames _lhsOuniqueChunk
         in __result_ )
     in C_Body_s14 v13
   {-# INLINE rule303 #-}
   rule303 = \ _declInfo ((_declarationsIinfoTrees) :: InfoTrees) ->
                                      root _declInfo _declarationsIinfoTrees
   {-# INLINE rule304 #-}
   rule304 = \ _parentTree ->
                                      _parentTree
   {-# INLINE rule305 #-}
   rule305 = \ ((_declarationsIself) :: Declarations) ((_lhsImonos) :: Monos) ->
                          LocalInfo { self = UHA_Decls _declarationsIself
                                    , assignedType = Nothing
                                    , monos = _lhsImonos
                                    }
   {-# INLINE rule306 #-}
   rule306 = \  (_ :: ()) ->
     \name -> variableConstraint "variable" (nameToUHA_Expr name)
        [ FolkloreConstraint, HasTrustFactor 10.0, IsImported name ]
   {-# INLINE rule307 #-}
   rule307 = \ _implicitsFM ((_lhsItypeschemeMap) :: M.Map Int (Scheme Predicates)) ->
                                        findInferredTypes _lhsItypeschemeMap _implicitsFM
   {-# INLINE rule308 #-}
   rule308 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
                                        typeConstructors _lhsIimportEnvironment `M.union` M.map ((,) 0) (classNameEnvironment _lhsIimportEnvironment)
   {-# INLINE rule309 #-}
   rule309 = \ ((_declarationsIcollectWarnings) :: Warnings) ((_declarationsIsimplePatNames) :: Names) _env _inferredTypes ((_lhsIimportEnvironment) :: ImportEnvironment) ->
                                        map (convertWarnings _env) . filter notQualifiedWarnings $
                                        missingTypeSignature True _declarationsIsimplePatNames _inferredTypes _lhsIimportEnvironment
                                        ++ _declarationsIcollectWarnings
   {-# INLINE rule310 #-}
   rule310 = \ ((_declarationsIcollectErrors) :: TypeErrors) ((_declarationsIrestrictedNames) :: Names) _inferredTypes ((_lhsIimportEnvironment) :: ImportEnvironment) ->
                                        restrictedNameErrors _lhsIimportEnvironment _inferredTypes _declarationsIrestrictedNames
                                        ++ _declarationsIcollectErrors
   {-# INLINE rule311 #-}
   rule311 = \ ((_declarationsItypeSignatures) :: TypeEnvironment) _inferredTypes ->
                                   _declarationsItypeSignatures `M.union` _inferredTypes
   {-# INLINE rule312 #-}
   rule312 = \ ((_lhsIallTypeSchemes) :: M.Map NameWithRange TpScheme) _localTypes ->
                                    _localTypes `M.union` _lhsIallTypeSchemes
   {-# INLINE rule313 #-}
   rule313 = \ ((_declarationsIbindingGroups) :: BindingGroups) ((_declarationsItypeSignatures) :: TypeEnvironment) _inferredTypes ->
                                    makeLocalTypeEnv (_declarationsItypeSignatures `M.union` _inferredTypes) _declarationsIbindingGroups
   {-# INLINE rule314 #-}
   rule314 = \  (_ :: ()) ->
                                                                  M.empty
   {-# INLINE rule315 #-}
   rule315 = \ _chunkNr ->
                                                     _chunkNr
   {-# INLINE rule316 #-}
   rule316 = \  (_ :: ()) ->
                                          []
   {-# INLINE rule317 #-}
   rule317 = \ _assumps ->
                                          _assumps
   {-# INLINE rule318 #-}
   rule318 = \ _aset _cinfo ((_lhsIimportEnvironment) :: ImportEnvironment) ->
                                          (typeEnvironment _lhsIimportEnvironment .:::. (_aset)) _cinfo
   {-# INLINE rule319 #-}
   rule319 = \ _cset _csetBinds ->
                                          (_csetBinds).>>. _cset
   {-# INLINE rule320 #-}
   rule320 = \ ((_declarationsIbetaUnique) :: Int) ((_declarationsIbindingGroups) :: BindingGroups) ((_declarationsItypeSignatures) :: TypeEnvironment) ((_declarationsIuniqueChunk) :: Int) ((_lhsIcurrentChunk) :: Int) ((_lhsImonos) :: Monos) ->
           let inputBDG = (True, _lhsIcurrentChunk, _declarationsIuniqueChunk, _lhsImonos, _declarationsItypeSignatures, Nothing, _declarationsIbetaUnique)
           in performBindingGroup inputBDG _declarationsIbindingGroups
   {-# INLINE rule321 #-}
   rule321 = \ ((_declarationsIclassMemberNames) :: Names) ->
     _declarationsIclassMemberNames
   {-# INLINE rule322 #-}
   rule322 = \ ((_declarationsIcollectInstances) :: [(Name, Instance)]) ->
     _declarationsIcollectInstances
   {-# INLINE rule323 #-}
   rule323 = \ ((_declarationsIdeclVarNames) :: Names) ->
     _declarationsIdeclVarNames
   {-# INLINE rule324 #-}
   rule324 = \ ((_declarationsIunboundNames) :: Names) ->
     _declarationsIunboundNames
   {-# INLINE rule325 #-}
   rule325 = \ ((_declarationsIself) :: Declarations) ((_importdeclarationsIself) :: ImportDeclarations) ((_rangeIself) :: Range) ->
     Body_Body _rangeIself _importdeclarationsIself _declarationsIself
   {-# INLINE rule326 #-}
   rule326 = \ _self ->
     _self
   {-# INLINE rule327 #-}
   rule327 = \ _constraints ->
     _constraints
   {-# INLINE rule328 #-}
   rule328 = \ ((_declarationsIcounter) :: Int) ->
     _declarationsIcounter
   {-# INLINE rule329 #-}
   rule329 = \ ((_declarationsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _declarationsIdictionaryEnvironment
   {-# INLINE rule330 #-}
   rule330 = \ ((_declarationsImatchIO) :: IO ()) ->
     _declarationsImatchIO
   {-# INLINE rule331 #-}
   rule331 = \ ((_declarationsIpatternMatchWarnings) :: [Warning]) ->
     _declarationsIpatternMatchWarnings
   {-# INLINE rule332 #-}
   rule332 = \ ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ->
     _lhsIallPatterns
   {-# INLINE rule333 #-}
   rule333 = \ _allTypeSchemes ->
     _allTypeSchemes
   {-# INLINE rule334 #-}
   rule334 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule335 #-}
   rule335 = \ ((_lhsIavailablePredicates) :: [PredicateWithSource]) ->
     _lhsIavailablePredicates
   {-# INLINE rule336 #-}
   rule336 = \ ((_lhsIbetaUnique) :: Int) ->
     _lhsIbetaUnique
   {-# INLINE rule337 #-}
   rule337 = \ ((_lhsIclassEnvironment) :: ClassEnvironment) ->
     _lhsIclassEnvironment
   {-# INLINE rule338 #-}
   rule338 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule339 #-}
   rule339 = \ ((_lhsIclassMemberTypeSchemes) :: Maybe [(Name, TpScheme)]) ->
     _lhsIclassMemberTypeSchemes
   {-# INLINE rule340 #-}
   rule340 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule341 #-}
   rule341 = \ ((_lhsIclassPredicate) :: Maybe (Name, Names)) ->
     _lhsIclassPredicate
   {-# INLINE rule342 #-}
   rule342 = \ ((_lhsIclassTypeSchemes) :: M.Map Name TpScheme) ->
     _lhsIclassTypeSchemes
   {-# INLINE rule343 #-}
   rule343 = \ ((_lhsIcollectErrors) :: TypeErrors) ->
     _lhsIcollectErrors
   {-# INLINE rule344 #-}
   rule344 = \ ((_lhsIcollectWarnings) :: Warnings) ->
     _lhsIcollectWarnings
   {-# INLINE rule345 #-}
   rule345 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule346 #-}
   rule346 = \ ((_lhsIcurClassPred) :: Maybe Predicate) ->
     _lhsIcurClassPred
   {-# INLINE rule347 #-}
   rule347 = \ ((_lhsIcurPred) :: Maybe Predicate) ->
     _lhsIcurPred
   {-# INLINE rule348 #-}
   rule348 = \ ((_lhsIcurrentChunk) :: Int) ->
     _lhsIcurrentChunk
   {-# INLINE rule349 #-}
   rule349 = \ ((_lhsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _lhsIdictionaryEnvironment
   {-# INLINE rule350 #-}
   rule350 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule351 #-}
   rule351 = \ _inheritedBDG ->
     _inheritedBDG
   {-# INLINE rule352 #-}
   rule352 = \ ((_lhsIinstanceName) :: Maybe Name) ->
     _lhsIinstanceName
   {-# INLINE rule353 #-}
   rule353 = \ ((_lhsIinstanceTypes) :: [(Name, TpScheme)]) ->
     _lhsIinstanceTypes
   {-# INLINE rule354 #-}
   rule354 = \ ((_lhsIisTopLevel) :: Bool) ->
     _lhsIisTopLevel
   {-# INLINE rule355 #-}
   rule355 = \ ((_lhsImatchIO) :: IO ()) ->
     _lhsImatchIO
   {-# INLINE rule356 #-}
   rule356 = \ ((_lhsImoduleName) :: Maybe Name) ->
     _lhsImoduleName
   {-# INLINE rule357 #-}
   rule357 = \ ((_lhsImoduleQual) ::  [String] ) ->
     _lhsImoduleQual
   {-# INLINE rule358 #-}
   rule358 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule359 #-}
   rule359 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule360 #-}
   rule360 = \ ((_lhsIorderedTypeSynonyms) :: OrderedTypeSynonyms) ->
     _lhsIorderedTypeSynonyms
   {-# INLINE rule361 #-}
   rule361 = \ _parentTree ->
     _parentTree
   {-# INLINE rule362 #-}
   rule362 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule363 #-}
   rule363 = \ ((_lhsIrequiredPredicates) :: Predicates) ->
     _lhsIrequiredPredicates
   {-# INLINE rule364 #-}
   rule364 = \ ((_lhsIsubstitution) :: FixpointSubstitution) ->
     _lhsIsubstitution
   {-# INLINE rule365 #-}
   rule365 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
   {-# INLINE rule366 #-}
   rule366 = \ ((_lhsItypeschemeMap) :: M.Map Int (Scheme Predicates)) ->
     _lhsItypeschemeMap
   {-# INLINE rule367 #-}
   rule367 = \ ((_lhsIuniqueChunk) :: Int) ->
     _lhsIuniqueChunk
   {-# INLINE rule368 #-}
   rule368 = \ ((_lhsIvariableMapping) :: Maybe [(Name, Tp)]) ->
     _lhsIvariableMapping

-- Constructor -------------------------------------------------
-- wrapper
data Inh_Constructor  = Inh_Constructor { ambiguousConflicts_Inh_Constructor :: !([[Name]]), classMemberEnv_Inh_Constructor :: !(ClassMemberEnvironment), classNamesEnv_Inh_Constructor :: !(ClassNameEnvironment), counter_Inh_Constructor :: !(Int), namesInScope_Inh_Constructor :: !(Names) }
data Syn_Constructor  = Syn_Constructor { counter_Syn_Constructor :: !(Int), self_Syn_Constructor :: !(Constructor), unboundNames_Syn_Constructor :: !(Names) }
{-# INLINABLE wrap_Constructor #-}
wrap_Constructor :: T_Constructor  -> Inh_Constructor  -> (Syn_Constructor )
wrap_Constructor !(T_Constructor act) !(Inh_Constructor _lhsIambiguousConflicts _lhsIclassMemberEnv _lhsIclassNamesEnv _lhsIcounter _lhsInamesInScope) =
   Control.Monad.Identity.runIdentity (
     do !sem <- act
        let arg16 = T_Constructor_vIn16 _lhsIambiguousConflicts _lhsIclassMemberEnv _lhsIclassNamesEnv _lhsIcounter _lhsInamesInScope
        !(T_Constructor_vOut16 _lhsOcounter _lhsOself _lhsOunboundNames) <- return (inv_Constructor_s17 sem arg16)
        return (Syn_Constructor _lhsOcounter _lhsOself _lhsOunboundNames)
   )

-- cata
{-# NOINLINE sem_Constructor #-}
sem_Constructor :: Constructor  -> T_Constructor 
sem_Constructor ( Constructor_Constructor range_ constructor_ types_ ) = sem_Constructor_Constructor ( sem_Range range_ ) ( sem_Name constructor_ ) ( sem_AnnotatedTypes types_ )
sem_Constructor ( Constructor_Infix range_ leftType_ constructorOperator_ rightType_ ) = sem_Constructor_Infix ( sem_Range range_ ) ( sem_AnnotatedType leftType_ ) ( sem_Name constructorOperator_ ) ( sem_AnnotatedType rightType_ )
sem_Constructor ( Constructor_Record range_ constructor_ fieldDeclarations_ ) = sem_Constructor_Record ( sem_Range range_ ) ( sem_Name constructor_ ) ( sem_FieldDeclarations fieldDeclarations_ )

-- semantic domain
newtype T_Constructor  = T_Constructor {
                                       attach_T_Constructor :: Identity (T_Constructor_s17 )
                                       }
newtype T_Constructor_s17  = C_Constructor_s17 {
                                               inv_Constructor_s17 :: (T_Constructor_v16 )
                                               }
data T_Constructor_s18  = C_Constructor_s18
type T_Constructor_v16  = (T_Constructor_vIn16 ) -> (T_Constructor_vOut16 )
data T_Constructor_vIn16  = T_Constructor_vIn16 ([[Name]]) (ClassMemberEnvironment) (ClassNameEnvironment) (Int) (Names)
data T_Constructor_vOut16  = T_Constructor_vOut16 (Int) (Constructor) (Names)
{-# NOINLINE sem_Constructor_Constructor #-}
sem_Constructor_Constructor :: T_Range  -> T_Name  -> T_AnnotatedTypes  -> T_Constructor 
sem_Constructor_Constructor arg_range_ arg_constructor_ arg_types_ = T_Constructor (return st17) where
   {-# NOINLINE st17 #-}
   !st17 = let
      v16 :: T_Constructor_v16 
      v16 = \ !(T_Constructor_vIn16 _lhsIambiguousConflicts _lhsIclassMemberEnv _lhsIclassNamesEnv _lhsIcounter _lhsInamesInScope) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _constructorX113 = Control.Monad.Identity.runIdentity (attach_T_Name (arg_constructor_))
         _typesX11 = Control.Monad.Identity.runIdentity (attach_T_AnnotatedTypes (arg_types_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_Name_vOut112 _constructorIself) = inv_Name_s113 _constructorX113 (T_Name_vIn112 )
         (T_AnnotatedTypes_vOut10 _typesIcounter _typesIself _typesIunboundNames) = inv_AnnotatedTypes_s11 _typesX11 (T_AnnotatedTypes_vIn10 _typesOambiguousConflicts _typesOclassMemberEnv _typesOclassNamesEnv _typesOcounter _typesOnamesInScope)
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule369 _typesIunboundNames
         _self = rule370 _constructorIself _rangeIself _typesIself
         _lhsOself :: Constructor
         _lhsOself = rule371 _self
         _lhsOcounter :: Int
         _lhsOcounter = rule372 _typesIcounter
         _typesOambiguousConflicts = rule373 _lhsIambiguousConflicts
         _typesOclassMemberEnv = rule374 _lhsIclassMemberEnv
         _typesOclassNamesEnv = rule375 _lhsIclassNamesEnv
         _typesOcounter = rule376 _lhsIcounter
         _typesOnamesInScope = rule377 _lhsInamesInScope
         !__result_ = T_Constructor_vOut16 _lhsOcounter _lhsOself _lhsOunboundNames
         in __result_ )
     in C_Constructor_s17 v16
   {-# INLINE rule369 #-}
   rule369 = \ ((_typesIunboundNames) :: Names) ->
     _typesIunboundNames
   {-# INLINE rule370 #-}
   rule370 = \ ((_constructorIself) :: Name) ((_rangeIself) :: Range) ((_typesIself) :: AnnotatedTypes) ->
     Constructor_Constructor _rangeIself _constructorIself _typesIself
   {-# INLINE rule371 #-}
   rule371 = \ _self ->
     _self
   {-# INLINE rule372 #-}
   rule372 = \ ((_typesIcounter) :: Int) ->
     _typesIcounter
   {-# INLINE rule373 #-}
   rule373 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule374 #-}
   rule374 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule375 #-}
   rule375 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule376 #-}
   rule376 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule377 #-}
   rule377 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
{-# NOINLINE sem_Constructor_Infix #-}
sem_Constructor_Infix :: T_Range  -> T_AnnotatedType  -> T_Name  -> T_AnnotatedType  -> T_Constructor 
sem_Constructor_Infix arg_range_ arg_leftType_ arg_constructorOperator_ arg_rightType_ = T_Constructor (return st17) where
   {-# NOINLINE st17 #-}
   !st17 = let
      v16 :: T_Constructor_v16 
      v16 = \ !(T_Constructor_vIn16 _lhsIambiguousConflicts _lhsIclassMemberEnv _lhsIclassNamesEnv _lhsIcounter _lhsInamesInScope) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _leftTypeX8 = Control.Monad.Identity.runIdentity (attach_T_AnnotatedType (arg_leftType_))
         _constructorOperatorX113 = Control.Monad.Identity.runIdentity (attach_T_Name (arg_constructorOperator_))
         _rightTypeX8 = Control.Monad.Identity.runIdentity (attach_T_AnnotatedType (arg_rightType_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_AnnotatedType_vOut7 _leftTypeIcounter _leftTypeIself _leftTypeIunboundNames) = inv_AnnotatedType_s8 _leftTypeX8 (T_AnnotatedType_vIn7 _leftTypeOambiguousConflicts _leftTypeOclassMemberEnv _leftTypeOclassNamesEnv _leftTypeOcounter _leftTypeOnamesInScope)
         (T_Name_vOut112 _constructorOperatorIself) = inv_Name_s113 _constructorOperatorX113 (T_Name_vIn112 )
         (T_AnnotatedType_vOut7 _rightTypeIcounter _rightTypeIself _rightTypeIunboundNames) = inv_AnnotatedType_s8 _rightTypeX8 (T_AnnotatedType_vIn7 _rightTypeOambiguousConflicts _rightTypeOclassMemberEnv _rightTypeOclassNamesEnv _rightTypeOcounter _rightTypeOnamesInScope)
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule378 _leftTypeIunboundNames _rightTypeIunboundNames
         _self = rule379 _constructorOperatorIself _leftTypeIself _rangeIself _rightTypeIself
         _lhsOself :: Constructor
         _lhsOself = rule380 _self
         _lhsOcounter :: Int
         _lhsOcounter = rule381 _rightTypeIcounter
         _leftTypeOambiguousConflicts = rule382 _lhsIambiguousConflicts
         _leftTypeOclassMemberEnv = rule383 _lhsIclassMemberEnv
         _leftTypeOclassNamesEnv = rule384 _lhsIclassNamesEnv
         _leftTypeOcounter = rule385 _lhsIcounter
         _leftTypeOnamesInScope = rule386 _lhsInamesInScope
         _rightTypeOambiguousConflicts = rule387 _lhsIambiguousConflicts
         _rightTypeOclassMemberEnv = rule388 _lhsIclassMemberEnv
         _rightTypeOclassNamesEnv = rule389 _lhsIclassNamesEnv
         _rightTypeOcounter = rule390 _leftTypeIcounter
         _rightTypeOnamesInScope = rule391 _lhsInamesInScope
         !__result_ = T_Constructor_vOut16 _lhsOcounter _lhsOself _lhsOunboundNames
         in __result_ )
     in C_Constructor_s17 v16
   {-# INLINE rule378 #-}
   rule378 = \ ((_leftTypeIunboundNames) :: Names) ((_rightTypeIunboundNames) :: Names) ->
     ((++) _leftTypeIunboundNames _rightTypeIunboundNames)
   {-# INLINE rule379 #-}
   rule379 = \ ((_constructorOperatorIself) :: Name) ((_leftTypeIself) :: AnnotatedType) ((_rangeIself) :: Range) ((_rightTypeIself) :: AnnotatedType) ->
     Constructor_Infix _rangeIself _leftTypeIself _constructorOperatorIself _rightTypeIself
   {-# INLINE rule380 #-}
   rule380 = \ _self ->
     _self
   {-# INLINE rule381 #-}
   rule381 = \ ((_rightTypeIcounter) :: Int) ->
     _rightTypeIcounter
   {-# INLINE rule382 #-}
   rule382 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule383 #-}
   rule383 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule384 #-}
   rule384 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule385 #-}
   rule385 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule386 #-}
   rule386 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule387 #-}
   rule387 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule388 #-}
   rule388 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule389 #-}
   rule389 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule390 #-}
   rule390 = \ ((_leftTypeIcounter) :: Int) ->
     _leftTypeIcounter
   {-# INLINE rule391 #-}
   rule391 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
{-# NOINLINE sem_Constructor_Record #-}
sem_Constructor_Record :: T_Range  -> T_Name  -> T_FieldDeclarations  -> T_Constructor 
sem_Constructor_Record arg_range_ arg_constructor_ arg_fieldDeclarations_ = T_Constructor (return st17) where
   {-# NOINLINE st17 #-}
   !st17 = let
      v16 :: T_Constructor_v16 
      v16 = \ !(T_Constructor_vIn16 _lhsIambiguousConflicts _lhsIclassMemberEnv _lhsIclassNamesEnv _lhsIcounter _lhsInamesInScope) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _constructorX113 = Control.Monad.Identity.runIdentity (attach_T_Name (arg_constructor_))
         _fieldDeclarationsX50 = Control.Monad.Identity.runIdentity (attach_T_FieldDeclarations (arg_fieldDeclarations_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_Name_vOut112 _constructorIself) = inv_Name_s113 _constructorX113 (T_Name_vIn112 )
         (T_FieldDeclarations_vOut49 _fieldDeclarationsIcounter _fieldDeclarationsIself _fieldDeclarationsIunboundNames) = inv_FieldDeclarations_s50 _fieldDeclarationsX50 (T_FieldDeclarations_vIn49 _fieldDeclarationsOambiguousConflicts _fieldDeclarationsOclassMemberEnv _fieldDeclarationsOclassNamesEnv _fieldDeclarationsOcounter _fieldDeclarationsOnamesInScope)
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule392 _fieldDeclarationsIunboundNames
         _self = rule393 _constructorIself _fieldDeclarationsIself _rangeIself
         _lhsOself :: Constructor
         _lhsOself = rule394 _self
         _lhsOcounter :: Int
         _lhsOcounter = rule395 _fieldDeclarationsIcounter
         _fieldDeclarationsOambiguousConflicts = rule396 _lhsIambiguousConflicts
         _fieldDeclarationsOclassMemberEnv = rule397 _lhsIclassMemberEnv
         _fieldDeclarationsOclassNamesEnv = rule398 _lhsIclassNamesEnv
         _fieldDeclarationsOcounter = rule399 _lhsIcounter
         _fieldDeclarationsOnamesInScope = rule400 _lhsInamesInScope
         !__result_ = T_Constructor_vOut16 _lhsOcounter _lhsOself _lhsOunboundNames
         in __result_ )
     in C_Constructor_s17 v16
   {-# INLINE rule392 #-}
   rule392 = \ ((_fieldDeclarationsIunboundNames) :: Names) ->
     _fieldDeclarationsIunboundNames
   {-# INLINE rule393 #-}
   rule393 = \ ((_constructorIself) :: Name) ((_fieldDeclarationsIself) :: FieldDeclarations) ((_rangeIself) :: Range) ->
     Constructor_Record _rangeIself _constructorIself _fieldDeclarationsIself
   {-# INLINE rule394 #-}
   rule394 = \ _self ->
     _self
   {-# INLINE rule395 #-}
   rule395 = \ ((_fieldDeclarationsIcounter) :: Int) ->
     _fieldDeclarationsIcounter
   {-# INLINE rule396 #-}
   rule396 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule397 #-}
   rule397 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule398 #-}
   rule398 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule399 #-}
   rule399 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule400 #-}
   rule400 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope

-- Constructors ------------------------------------------------
-- wrapper
data Inh_Constructors  = Inh_Constructors { ambiguousConflicts_Inh_Constructors :: !([[Name]]), classMemberEnv_Inh_Constructors :: !(ClassMemberEnvironment), classNamesEnv_Inh_Constructors :: !(ClassNameEnvironment), counter_Inh_Constructors :: !(Int), namesInScope_Inh_Constructors :: !(Names) }
data Syn_Constructors  = Syn_Constructors { counter_Syn_Constructors :: !(Int), self_Syn_Constructors :: !(Constructors), unboundNames_Syn_Constructors :: !(Names) }
{-# INLINABLE wrap_Constructors #-}
wrap_Constructors :: T_Constructors  -> Inh_Constructors  -> (Syn_Constructors )
wrap_Constructors !(T_Constructors act) !(Inh_Constructors _lhsIambiguousConflicts _lhsIclassMemberEnv _lhsIclassNamesEnv _lhsIcounter _lhsInamesInScope) =
   Control.Monad.Identity.runIdentity (
     do !sem <- act
        let arg19 = T_Constructors_vIn19 _lhsIambiguousConflicts _lhsIclassMemberEnv _lhsIclassNamesEnv _lhsIcounter _lhsInamesInScope
        !(T_Constructors_vOut19 _lhsOcounter _lhsOself _lhsOunboundNames) <- return (inv_Constructors_s20 sem arg19)
        return (Syn_Constructors _lhsOcounter _lhsOself _lhsOunboundNames)
   )

-- cata
{-# NOINLINE sem_Constructors #-}
sem_Constructors :: Constructors  -> T_Constructors 
sem_Constructors list = Prelude.foldr sem_Constructors_Cons sem_Constructors_Nil (Prelude.map sem_Constructor list)

-- semantic domain
newtype T_Constructors  = T_Constructors {
                                         attach_T_Constructors :: Identity (T_Constructors_s20 )
                                         }
newtype T_Constructors_s20  = C_Constructors_s20 {
                                                 inv_Constructors_s20 :: (T_Constructors_v19 )
                                                 }
data T_Constructors_s21  = C_Constructors_s21
type T_Constructors_v19  = (T_Constructors_vIn19 ) -> (T_Constructors_vOut19 )
data T_Constructors_vIn19  = T_Constructors_vIn19 ([[Name]]) (ClassMemberEnvironment) (ClassNameEnvironment) (Int) (Names)
data T_Constructors_vOut19  = T_Constructors_vOut19 (Int) (Constructors) (Names)
{-# NOINLINE sem_Constructors_Cons #-}
sem_Constructors_Cons :: T_Constructor  -> T_Constructors  -> T_Constructors 
sem_Constructors_Cons arg_hd_ arg_tl_ = T_Constructors (return st20) where
   {-# NOINLINE st20 #-}
   !st20 = let
      v19 :: T_Constructors_v19 
      v19 = \ !(T_Constructors_vIn19 _lhsIambiguousConflicts _lhsIclassMemberEnv _lhsIclassNamesEnv _lhsIcounter _lhsInamesInScope) -> ( let
         _hdX17 = Control.Monad.Identity.runIdentity (attach_T_Constructor (arg_hd_))
         _tlX20 = Control.Monad.Identity.runIdentity (attach_T_Constructors (arg_tl_))
         (T_Constructor_vOut16 _hdIcounter _hdIself _hdIunboundNames) = inv_Constructor_s17 _hdX17 (T_Constructor_vIn16 _hdOambiguousConflicts _hdOclassMemberEnv _hdOclassNamesEnv _hdOcounter _hdOnamesInScope)
         (T_Constructors_vOut19 _tlIcounter _tlIself _tlIunboundNames) = inv_Constructors_s20 _tlX20 (T_Constructors_vIn19 _tlOambiguousConflicts _tlOclassMemberEnv _tlOclassNamesEnv _tlOcounter _tlOnamesInScope)
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule401 _hdIunboundNames _tlIunboundNames
         _self = rule402 _hdIself _tlIself
         _lhsOself :: Constructors
         _lhsOself = rule403 _self
         _lhsOcounter :: Int
         _lhsOcounter = rule404 _tlIcounter
         _hdOambiguousConflicts = rule405 _lhsIambiguousConflicts
         _hdOclassMemberEnv = rule406 _lhsIclassMemberEnv
         _hdOclassNamesEnv = rule407 _lhsIclassNamesEnv
         _hdOcounter = rule408 _lhsIcounter
         _hdOnamesInScope = rule409 _lhsInamesInScope
         _tlOambiguousConflicts = rule410 _lhsIambiguousConflicts
         _tlOclassMemberEnv = rule411 _lhsIclassMemberEnv
         _tlOclassNamesEnv = rule412 _lhsIclassNamesEnv
         _tlOcounter = rule413 _hdIcounter
         _tlOnamesInScope = rule414 _lhsInamesInScope
         !__result_ = T_Constructors_vOut19 _lhsOcounter _lhsOself _lhsOunboundNames
         in __result_ )
     in C_Constructors_s20 v19
   {-# INLINE rule401 #-}
   rule401 = \ ((_hdIunboundNames) :: Names) ((_tlIunboundNames) :: Names) ->
     ((++) _hdIunboundNames _tlIunboundNames)
   {-# INLINE rule402 #-}
   rule402 = \ ((_hdIself) :: Constructor) ((_tlIself) :: Constructors) ->
     (:) _hdIself _tlIself
   {-# INLINE rule403 #-}
   rule403 = \ _self ->
     _self
   {-# INLINE rule404 #-}
   rule404 = \ ((_tlIcounter) :: Int) ->
     _tlIcounter
   {-# INLINE rule405 #-}
   rule405 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule406 #-}
   rule406 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule407 #-}
   rule407 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule408 #-}
   rule408 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule409 #-}
   rule409 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule410 #-}
   rule410 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule411 #-}
   rule411 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule412 #-}
   rule412 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule413 #-}
   rule413 = \ ((_hdIcounter) :: Int) ->
     _hdIcounter
   {-# INLINE rule414 #-}
   rule414 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
{-# NOINLINE sem_Constructors_Nil #-}
sem_Constructors_Nil ::  T_Constructors 
sem_Constructors_Nil  = T_Constructors (return st20) where
   {-# NOINLINE st20 #-}
   !st20 = let
      v19 :: T_Constructors_v19 
      v19 = \ !(T_Constructors_vIn19 _lhsIambiguousConflicts _lhsIclassMemberEnv _lhsIclassNamesEnv _lhsIcounter _lhsInamesInScope) -> ( let
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule415  ()
         _self = rule416  ()
         _lhsOself :: Constructors
         _lhsOself = rule417 _self
         _lhsOcounter :: Int
         _lhsOcounter = rule418 _lhsIcounter
         !__result_ = T_Constructors_vOut19 _lhsOcounter _lhsOself _lhsOunboundNames
         in __result_ )
     in C_Constructors_s20 v19
   {-# INLINE rule415 #-}
   rule415 = \  (_ :: ()) ->
     []
   {-# INLINE rule416 #-}
   rule416 = \  (_ :: ()) ->
     []
   {-# INLINE rule417 #-}
   rule417 = \ _self ->
     _self
   {-# INLINE rule418 #-}
   rule418 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter

-- ContextItem -------------------------------------------------
-- wrapper
data Inh_ContextItem  = Inh_ContextItem { classMemberEnv_Inh_ContextItem :: !(ClassMemberEnvironment), classNamesEnv_Inh_ContextItem :: !(ClassNameEnvironment) }
data Syn_ContextItem  = Syn_ContextItem { self_Syn_ContextItem :: !(ContextItem) }
{-# INLINABLE wrap_ContextItem #-}
wrap_ContextItem :: T_ContextItem  -> Inh_ContextItem  -> (Syn_ContextItem )
wrap_ContextItem !(T_ContextItem act) !(Inh_ContextItem _lhsIclassMemberEnv _lhsIclassNamesEnv) =
   Control.Monad.Identity.runIdentity (
     do !sem <- act
        let arg22 = T_ContextItem_vIn22 _lhsIclassMemberEnv _lhsIclassNamesEnv
        !(T_ContextItem_vOut22 _lhsOself) <- return (inv_ContextItem_s23 sem arg22)
        return (Syn_ContextItem _lhsOself)
   )

-- cata
{-# NOINLINE sem_ContextItem #-}
sem_ContextItem :: ContextItem  -> T_ContextItem 
sem_ContextItem ( ContextItem_ContextItem range_ name_ types_ ) = sem_ContextItem_ContextItem ( sem_Range range_ ) ( sem_Name name_ ) ( sem_Types types_ )

-- semantic domain
newtype T_ContextItem  = T_ContextItem {
                                       attach_T_ContextItem :: Identity (T_ContextItem_s23 )
                                       }
newtype T_ContextItem_s23  = C_ContextItem_s23 {
                                               inv_ContextItem_s23 :: (T_ContextItem_v22 )
                                               }
data T_ContextItem_s24  = C_ContextItem_s24
type T_ContextItem_v22  = (T_ContextItem_vIn22 ) -> (T_ContextItem_vOut22 )
data T_ContextItem_vIn22  = T_ContextItem_vIn22 (ClassMemberEnvironment) (ClassNameEnvironment)
data T_ContextItem_vOut22  = T_ContextItem_vOut22 (ContextItem)
{-# NOINLINE sem_ContextItem_ContextItem #-}
sem_ContextItem_ContextItem :: T_Range  -> T_Name  -> T_Types  -> T_ContextItem 
sem_ContextItem_ContextItem arg_range_ arg_name_ arg_types_ = T_ContextItem (return st23) where
   {-# NOINLINE st23 #-}
   !st23 = let
      v22 :: T_ContextItem_v22 
      v22 = \ !(T_ContextItem_vIn22 _lhsIclassMemberEnv _lhsIclassNamesEnv) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _nameX113 = Control.Monad.Identity.runIdentity (attach_T_Name (arg_name_))
         _typesX167 = Control.Monad.Identity.runIdentity (attach_T_Types (arg_types_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_Name_vOut112 _nameIself) = inv_Name_s113 _nameX113 (T_Name_vIn112 )
         (T_Types_vOut166 _typesIself) = inv_Types_s167 _typesX167 (T_Types_vIn166 _typesOclassMemberEnv _typesOclassNamesEnv)
         _tyconEnv = rule419  ()
         _self = rule420 _nameIself _rangeIself _typesIself
         _lhsOself :: ContextItem
         _lhsOself = rule421 _self
         _typesOclassMemberEnv = rule422 _lhsIclassMemberEnv
         _typesOclassNamesEnv = rule423 _lhsIclassNamesEnv
         !__result_ = T_ContextItem_vOut22 _lhsOself
         in __result_ )
     in C_ContextItem_s23 v22
   {-# INLINE rule419 #-}
   rule419 = \  (_ :: ()) ->
                                        internalError "PartialSyntax.ag" "n/a" "ContextItem.ContextItem"
   {-# INLINE rule420 #-}
   rule420 = \ ((_nameIself) :: Name) ((_rangeIself) :: Range) ((_typesIself) :: Types) ->
     ContextItem_ContextItem _rangeIself _nameIself _typesIself
   {-# INLINE rule421 #-}
   rule421 = \ _self ->
     _self
   {-# INLINE rule422 #-}
   rule422 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule423 #-}
   rule423 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv

-- ContextItems ------------------------------------------------
-- wrapper
data Inh_ContextItems  = Inh_ContextItems { classMemberEnv_Inh_ContextItems :: !(ClassMemberEnvironment), classNamesEnv_Inh_ContextItems :: !(ClassNameEnvironment) }
data Syn_ContextItems  = Syn_ContextItems { self_Syn_ContextItems :: !(ContextItems) }
{-# INLINABLE wrap_ContextItems #-}
wrap_ContextItems :: T_ContextItems  -> Inh_ContextItems  -> (Syn_ContextItems )
wrap_ContextItems !(T_ContextItems act) !(Inh_ContextItems _lhsIclassMemberEnv _lhsIclassNamesEnv) =
   Control.Monad.Identity.runIdentity (
     do !sem <- act
        let arg25 = T_ContextItems_vIn25 _lhsIclassMemberEnv _lhsIclassNamesEnv
        !(T_ContextItems_vOut25 _lhsOself) <- return (inv_ContextItems_s26 sem arg25)
        return (Syn_ContextItems _lhsOself)
   )

-- cata
{-# NOINLINE sem_ContextItems #-}
sem_ContextItems :: ContextItems  -> T_ContextItems 
sem_ContextItems list = Prelude.foldr sem_ContextItems_Cons sem_ContextItems_Nil (Prelude.map sem_ContextItem list)

-- semantic domain
newtype T_ContextItems  = T_ContextItems {
                                         attach_T_ContextItems :: Identity (T_ContextItems_s26 )
                                         }
newtype T_ContextItems_s26  = C_ContextItems_s26 {
                                                 inv_ContextItems_s26 :: (T_ContextItems_v25 )
                                                 }
data T_ContextItems_s27  = C_ContextItems_s27
type T_ContextItems_v25  = (T_ContextItems_vIn25 ) -> (T_ContextItems_vOut25 )
data T_ContextItems_vIn25  = T_ContextItems_vIn25 (ClassMemberEnvironment) (ClassNameEnvironment)
data T_ContextItems_vOut25  = T_ContextItems_vOut25 (ContextItems)
{-# NOINLINE sem_ContextItems_Cons #-}
sem_ContextItems_Cons :: T_ContextItem  -> T_ContextItems  -> T_ContextItems 
sem_ContextItems_Cons arg_hd_ arg_tl_ = T_ContextItems (return st26) where
   {-# NOINLINE st26 #-}
   !st26 = let
      v25 :: T_ContextItems_v25 
      v25 = \ !(T_ContextItems_vIn25 _lhsIclassMemberEnv _lhsIclassNamesEnv) -> ( let
         _hdX23 = Control.Monad.Identity.runIdentity (attach_T_ContextItem (arg_hd_))
         _tlX26 = Control.Monad.Identity.runIdentity (attach_T_ContextItems (arg_tl_))
         (T_ContextItem_vOut22 _hdIself) = inv_ContextItem_s23 _hdX23 (T_ContextItem_vIn22 _hdOclassMemberEnv _hdOclassNamesEnv)
         (T_ContextItems_vOut25 _tlIself) = inv_ContextItems_s26 _tlX26 (T_ContextItems_vIn25 _tlOclassMemberEnv _tlOclassNamesEnv)
         _self = rule424 _hdIself _tlIself
         _lhsOself :: ContextItems
         _lhsOself = rule425 _self
         _hdOclassMemberEnv = rule426 _lhsIclassMemberEnv
         _hdOclassNamesEnv = rule427 _lhsIclassNamesEnv
         _tlOclassMemberEnv = rule428 _lhsIclassMemberEnv
         _tlOclassNamesEnv = rule429 _lhsIclassNamesEnv
         !__result_ = T_ContextItems_vOut25 _lhsOself
         in __result_ )
     in C_ContextItems_s26 v25
   {-# INLINE rule424 #-}
   rule424 = \ ((_hdIself) :: ContextItem) ((_tlIself) :: ContextItems) ->
     (:) _hdIself _tlIself
   {-# INLINE rule425 #-}
   rule425 = \ _self ->
     _self
   {-# INLINE rule426 #-}
   rule426 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule427 #-}
   rule427 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule428 #-}
   rule428 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule429 #-}
   rule429 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
{-# NOINLINE sem_ContextItems_Nil #-}
sem_ContextItems_Nil ::  T_ContextItems 
sem_ContextItems_Nil  = T_ContextItems (return st26) where
   {-# NOINLINE st26 #-}
   !st26 = let
      v25 :: T_ContextItems_v25 
      v25 = \ !(T_ContextItems_vIn25 _lhsIclassMemberEnv _lhsIclassNamesEnv) -> ( let
         _self = rule430  ()
         _lhsOself :: ContextItems
         _lhsOself = rule431 _self
         !__result_ = T_ContextItems_vOut25 _lhsOself
         in __result_ )
     in C_ContextItems_s26 v25
   {-# INLINE rule430 #-}
   rule430 = \  (_ :: ()) ->
     []
   {-# INLINE rule431 #-}
   rule431 = \ _self ->
     _self

-- Declaration -------------------------------------------------
-- wrapper
data Inh_Declaration  = Inh_Declaration { allPatterns_Inh_Declaration :: !([((Expression, [String]), Core_TypingStrategy)]), allTypeSchemes_Inh_Declaration :: !(M.Map NameWithRange TpScheme), ambiguousConflicts_Inh_Declaration :: !([[Name]]), availablePredicates_Inh_Declaration :: !([PredicateWithSource]), betaUnique_Inh_Declaration :: !(Int), bindingGroups_Inh_Declaration :: !(BindingGroups), classEnvironment_Inh_Declaration :: !(ClassEnvironment), classMemberEnv_Inh_Declaration :: !(ClassMemberEnvironment), classMemberTypeSchemes_Inh_Declaration :: !(Maybe [(Name, TpScheme)]), classNamesEnv_Inh_Declaration :: !(ClassNameEnvironment), classPredicate_Inh_Declaration :: !(Maybe (Name, Names)), classTypeSchemes_Inh_Declaration :: !(M.Map Name TpScheme), collectErrors_Inh_Declaration :: !(TypeErrors), collectWarnings_Inh_Declaration :: !(Warnings), counter_Inh_Declaration :: !(Int), curClassPred_Inh_Declaration :: !(Maybe Predicate), curPred_Inh_Declaration :: !(Maybe Predicate), currentChunk_Inh_Declaration :: !(Int), dictionaryEnvironment_Inh_Declaration :: !(DictionaryEnvironment), importEnvironment_Inh_Declaration :: !(ImportEnvironment), inheritedBDG_Inh_Declaration :: !(InheritedBDG), instanceName_Inh_Declaration :: !(Maybe Name), instanceTypes_Inh_Declaration :: !([(Name, TpScheme)]), isTopLevel_Inh_Declaration :: !(Bool), matchIO_Inh_Declaration :: !(IO ()), moduleName_Inh_Declaration :: !(Maybe Name), moduleQual_Inh_Declaration :: !( [String] ), monos_Inh_Declaration :: !(Monos), namesInScope_Inh_Declaration :: !(Names), orderedTypeSynonyms_Inh_Declaration :: !(OrderedTypeSynonyms), parentTree_Inh_Declaration :: !(InfoTree), patternMatchWarnings_Inh_Declaration :: !([Warning]), requiredPredicates_Inh_Declaration :: !(Predicates), substitution_Inh_Declaration :: !(FixpointSubstitution), typeConstructors_Inh_Declaration :: !(TypeConstructorEnvironment), typeSignatures_Inh_Declaration :: !(TypeEnvironment), typeschemeMap_Inh_Declaration :: !(M.Map Int (Scheme Predicates)), uniqueChunk_Inh_Declaration :: !(Int), variableMapping_Inh_Declaration :: !(Maybe [(Name, Tp)]) }
data Syn_Declaration  = Syn_Declaration { betaUnique_Syn_Declaration :: !(Int), bindingGroups_Syn_Declaration :: !(BindingGroups), boundBetas_Syn_Declaration :: !([(Name, Tp, [Tp])]), classMemberNames_Syn_Declaration :: !(Names), collectErrors_Syn_Declaration :: !(TypeErrors), collectInstances_Syn_Declaration :: !([(Name, Instance)]), collectWarnings_Syn_Declaration :: !(Warnings), counter_Syn_Declaration :: !(Int), declVarNames_Syn_Declaration :: !(Names), dictionaryEnvironment_Syn_Declaration :: !(DictionaryEnvironment), infoTrees_Syn_Declaration :: !(InfoTrees), matchIO_Syn_Declaration :: !(IO ()), patternMatchWarnings_Syn_Declaration :: !([Warning]), restrictedNames_Syn_Declaration :: !(Names), self_Syn_Declaration :: !(Declaration), simplePatNames_Syn_Declaration :: !(Names), typeMemberBindings_Syn_Declaration :: !([(Name, TpScheme)]), typeSignatures_Syn_Declaration :: !(TypeEnvironment), unboundNames_Syn_Declaration :: !(Names), uniqueChunk_Syn_Declaration :: !(Int) }
{-# INLINABLE wrap_Declaration #-}
wrap_Declaration :: T_Declaration  -> Inh_Declaration  -> (Syn_Declaration )
wrap_Declaration !(T_Declaration act) !(Inh_Declaration _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaUnique _lhsIbindingGroups _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinheritedBDG _lhsIinstanceName _lhsIinstanceTypes _lhsIisTopLevel _lhsImatchIO _lhsImoduleName _lhsImoduleQual _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeConstructors _lhsItypeSignatures _lhsItypeschemeMap _lhsIuniqueChunk _lhsIvariableMapping) =
   Control.Monad.Identity.runIdentity (
     do !sem <- act
        let arg28 = T_Declaration_vIn28 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaUnique _lhsIbindingGroups _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinheritedBDG _lhsIinstanceName _lhsIinstanceTypes _lhsIisTopLevel _lhsImatchIO _lhsImoduleName _lhsImoduleQual _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeConstructors _lhsItypeSignatures _lhsItypeschemeMap _lhsIuniqueChunk _lhsIvariableMapping
        !(T_Declaration_vOut28 _lhsObetaUnique _lhsObindingGroups _lhsOboundBetas _lhsOclassMemberNames _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOcounter _lhsOdeclVarNames _lhsOdictionaryEnvironment _lhsOinfoTrees _lhsOmatchIO _lhsOpatternMatchWarnings _lhsOrestrictedNames _lhsOself _lhsOsimplePatNames _lhsOtypeMemberBindings _lhsOtypeSignatures _lhsOunboundNames _lhsOuniqueChunk) <- return (inv_Declaration_s29 sem arg28)
        return (Syn_Declaration _lhsObetaUnique _lhsObindingGroups _lhsOboundBetas _lhsOclassMemberNames _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOcounter _lhsOdeclVarNames _lhsOdictionaryEnvironment _lhsOinfoTrees _lhsOmatchIO _lhsOpatternMatchWarnings _lhsOrestrictedNames _lhsOself _lhsOsimplePatNames _lhsOtypeMemberBindings _lhsOtypeSignatures _lhsOunboundNames _lhsOuniqueChunk)
   )

-- cata
{-# NOINLINE sem_Declaration #-}
sem_Declaration :: Declaration  -> T_Declaration 
sem_Declaration ( Declaration_Hole range_ !id_ ) = sem_Declaration_Hole ( sem_Range range_ ) id_
sem_Declaration ( Declaration_Type range_ simpletype_ type_ ) = sem_Declaration_Type ( sem_Range range_ ) ( sem_SimpleType simpletype_ ) ( sem_Type type_ )
sem_Declaration ( Declaration_Data range_ context_ simpletype_ constructors_ derivings_ ) = sem_Declaration_Data ( sem_Range range_ ) ( sem_ContextItems context_ ) ( sem_SimpleType simpletype_ ) ( sem_Constructors constructors_ ) ( sem_Names derivings_ )
sem_Declaration ( Declaration_Newtype range_ context_ simpletype_ constructor_ derivings_ ) = sem_Declaration_Newtype ( sem_Range range_ ) ( sem_ContextItems context_ ) ( sem_SimpleType simpletype_ ) ( sem_Constructor constructor_ ) ( sem_Names derivings_ )
sem_Declaration ( Declaration_Class range_ context_ simpletype_ where_ ) = sem_Declaration_Class ( sem_Range range_ ) ( sem_ContextItems context_ ) ( sem_SimpleType simpletype_ ) ( sem_MaybeDeclarations where_ )
sem_Declaration ( Declaration_Instance range_ context_ name_ types_ where_ ) = sem_Declaration_Instance ( sem_Range range_ ) ( sem_ContextItems context_ ) ( sem_Name name_ ) ( sem_Types types_ ) ( sem_MaybeDeclarations where_ )
sem_Declaration ( Declaration_Default range_ types_ ) = sem_Declaration_Default ( sem_Range range_ ) ( sem_Types types_ )
sem_Declaration ( Declaration_FunctionBindings range_ bindings_ ) = sem_Declaration_FunctionBindings ( sem_Range range_ ) ( sem_FunctionBindings bindings_ )
sem_Declaration ( Declaration_PatternBinding range_ pattern_ righthandside_ ) = sem_Declaration_PatternBinding ( sem_Range range_ ) ( sem_Pattern pattern_ ) ( sem_RightHandSide righthandside_ )
sem_Declaration ( Declaration_TypeSignature range_ names_ type_ ) = sem_Declaration_TypeSignature ( sem_Range range_ ) ( sem_Names names_ ) ( sem_Type type_ )
sem_Declaration ( Declaration_Fixity range_ fixity_ priority_ operators_ ) = sem_Declaration_Fixity ( sem_Range range_ ) ( sem_Fixity fixity_ ) ( sem_MaybeInt priority_ ) ( sem_Names operators_ )
sem_Declaration ( Declaration_Empty range_ ) = sem_Declaration_Empty ( sem_Range range_ )

-- semantic domain
newtype T_Declaration  = T_Declaration {
                                       attach_T_Declaration :: Identity (T_Declaration_s29 )
                                       }
newtype T_Declaration_s29  = C_Declaration_s29 {
                                               inv_Declaration_s29 :: (T_Declaration_v28 )
                                               }
data T_Declaration_s30  = C_Declaration_s30
type T_Declaration_v28  = (T_Declaration_vIn28 ) -> (T_Declaration_vOut28 )
data T_Declaration_vIn28  = T_Declaration_vIn28 ([((Expression, [String]), Core_TypingStrategy)]) (M.Map NameWithRange TpScheme) ([[Name]]) ([PredicateWithSource]) (Int) (BindingGroups) (ClassEnvironment) (ClassMemberEnvironment) (Maybe [(Name, TpScheme)]) (ClassNameEnvironment) (Maybe (Name, Names)) (M.Map Name TpScheme) (TypeErrors) (Warnings) (Int) (Maybe Predicate) (Maybe Predicate) (Int) (DictionaryEnvironment) (ImportEnvironment) (InheritedBDG) (Maybe Name) ([(Name, TpScheme)]) (Bool) (IO ()) (Maybe Name) ( [String] ) (Monos) (Names) (OrderedTypeSynonyms) (InfoTree) ([Warning]) (Predicates) (FixpointSubstitution) (TypeConstructorEnvironment) (TypeEnvironment) (M.Map Int (Scheme Predicates)) (Int) (Maybe [(Name, Tp)])
data T_Declaration_vOut28  = T_Declaration_vOut28 (Int) (BindingGroups) ([(Name, Tp, [Tp])]) (Names) (TypeErrors) ([(Name, Instance)]) (Warnings) (Int) (Names) (DictionaryEnvironment) (InfoTrees) (IO ()) ([Warning]) (Names) (Declaration) (Names) ([(Name, TpScheme)]) (TypeEnvironment) (Names) (Int)
{-# NOINLINE sem_Declaration_Hole #-}
sem_Declaration_Hole :: T_Range  -> (String) -> T_Declaration 
sem_Declaration_Hole arg_range_ !arg_id_ = T_Declaration (return st29) where
   {-# NOINLINE st29 #-}
   !st29 = let
      v28 :: T_Declaration_v28 
      v28 = \ !(T_Declaration_vIn28 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaUnique _lhsIbindingGroups _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinheritedBDG _lhsIinstanceName _lhsIinstanceTypes _lhsIisTopLevel _lhsImatchIO _lhsImoduleName _lhsImoduleQual _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeConstructors _lhsItypeSignatures _lhsItypeschemeMap _lhsIuniqueChunk _lhsIvariableMapping) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         _lhsOinfoTrees :: InfoTrees
         _lhsOinfoTrees = rule432  ()
         _lhsOboundBetas :: [(Name, Tp, [Tp])]
         _lhsOboundBetas = rule433  ()
         _lhsOclassMemberNames :: Names
         _lhsOclassMemberNames = rule434  ()
         _lhsOcollectInstances :: [(Name, Instance)]
         _lhsOcollectInstances = rule435  ()
         _lhsOdeclVarNames :: Names
         _lhsOdeclVarNames = rule436  ()
         _lhsOrestrictedNames :: Names
         _lhsOrestrictedNames = rule437  ()
         _lhsOsimplePatNames :: Names
         _lhsOsimplePatNames = rule438  ()
         _lhsOtypeMemberBindings :: [(Name, TpScheme)]
         _lhsOtypeMemberBindings = rule439  ()
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule440  ()
         _self = rule441 _rangeIself arg_id_
         _lhsOself :: Declaration
         _lhsOself = rule442 _self
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule443 _lhsIbetaUnique
         _lhsObindingGroups :: BindingGroups
         _lhsObindingGroups = rule444 _lhsIbindingGroups
         _lhsOcollectErrors :: TypeErrors
         _lhsOcollectErrors = rule445 _lhsIcollectErrors
         _lhsOcollectWarnings :: Warnings
         _lhsOcollectWarnings = rule446 _lhsIcollectWarnings
         _lhsOcounter :: Int
         _lhsOcounter = rule447 _lhsIcounter
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule448 _lhsIdictionaryEnvironment
         _lhsOmatchIO :: IO ()
         _lhsOmatchIO = rule449 _lhsImatchIO
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule450 _lhsIpatternMatchWarnings
         _lhsOtypeSignatures :: TypeEnvironment
         _lhsOtypeSignatures = rule451 _lhsItypeSignatures
         _lhsOuniqueChunk :: Int
         _lhsOuniqueChunk = rule452 _lhsIuniqueChunk
         !__result_ = T_Declaration_vOut28 _lhsObetaUnique _lhsObindingGroups _lhsOboundBetas _lhsOclassMemberNames _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOcounter _lhsOdeclVarNames _lhsOdictionaryEnvironment _lhsOinfoTrees _lhsOmatchIO _lhsOpatternMatchWarnings _lhsOrestrictedNames _lhsOself _lhsOsimplePatNames _lhsOtypeMemberBindings _lhsOtypeSignatures _lhsOunboundNames _lhsOuniqueChunk
         in __result_ )
     in C_Declaration_s29 v28
   {-# INLINE rule432 #-}
   rule432 = \  (_ :: ()) ->
                                 []
   {-# INLINE rule433 #-}
   rule433 = \  (_ :: ()) ->
     []
   {-# INLINE rule434 #-}
   rule434 = \  (_ :: ()) ->
     []
   {-# INLINE rule435 #-}
   rule435 = \  (_ :: ()) ->
     []
   {-# INLINE rule436 #-}
   rule436 = \  (_ :: ()) ->
     []
   {-# INLINE rule437 #-}
   rule437 = \  (_ :: ()) ->
     []
   {-# INLINE rule438 #-}
   rule438 = \  (_ :: ()) ->
     []
   {-# INLINE rule439 #-}
   rule439 = \  (_ :: ()) ->
     []
   {-# INLINE rule440 #-}
   rule440 = \  (_ :: ()) ->
     []
   {-# INLINE rule441 #-}
   rule441 = \ ((_rangeIself) :: Range) id_ ->
     Declaration_Hole _rangeIself id_
   {-# INLINE rule442 #-}
   rule442 = \ _self ->
     _self
   {-# INLINE rule443 #-}
   rule443 = \ ((_lhsIbetaUnique) :: Int) ->
     _lhsIbetaUnique
   {-# INLINE rule444 #-}
   rule444 = \ ((_lhsIbindingGroups) :: BindingGroups) ->
     _lhsIbindingGroups
   {-# INLINE rule445 #-}
   rule445 = \ ((_lhsIcollectErrors) :: TypeErrors) ->
     _lhsIcollectErrors
   {-# INLINE rule446 #-}
   rule446 = \ ((_lhsIcollectWarnings) :: Warnings) ->
     _lhsIcollectWarnings
   {-# INLINE rule447 #-}
   rule447 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule448 #-}
   rule448 = \ ((_lhsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _lhsIdictionaryEnvironment
   {-# INLINE rule449 #-}
   rule449 = \ ((_lhsImatchIO) :: IO ()) ->
     _lhsImatchIO
   {-# INLINE rule450 #-}
   rule450 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule451 #-}
   rule451 = \ ((_lhsItypeSignatures) :: TypeEnvironment) ->
     _lhsItypeSignatures
   {-# INLINE rule452 #-}
   rule452 = \ ((_lhsIuniqueChunk) :: Int) ->
     _lhsIuniqueChunk
{-# NOINLINE sem_Declaration_Type #-}
sem_Declaration_Type :: T_Range  -> T_SimpleType  -> T_Type  -> T_Declaration 
sem_Declaration_Type arg_range_ arg_simpletype_ arg_type_ = T_Declaration (return st29) where
   {-# NOINLINE st29 #-}
   !st29 = let
      v28 :: T_Declaration_v28 
      v28 = \ !(T_Declaration_vIn28 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaUnique _lhsIbindingGroups _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinheritedBDG _lhsIinstanceName _lhsIinstanceTypes _lhsIisTopLevel _lhsImatchIO _lhsImoduleName _lhsImoduleQual _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeConstructors _lhsItypeSignatures _lhsItypeschemeMap _lhsIuniqueChunk _lhsIvariableMapping) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _simpletypeX152 = Control.Monad.Identity.runIdentity (attach_T_SimpleType (arg_simpletype_))
         _typeX164 = Control.Monad.Identity.runIdentity (attach_T_Type (arg_type_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_SimpleType_vOut151 _simpletypeIname _simpletypeIself _simpletypeItypevariables) = inv_SimpleType_s152 _simpletypeX152 (T_SimpleType_vIn151 )
         (T_Type_vOut163 _typeIself) = inv_Type_s164 _typeX164 (T_Type_vIn163 _typeOclassMemberEnv _typeOclassNamesEnv)
         _lhsOinfoTrees :: InfoTrees
         _lhsOinfoTrees = rule453  ()
         _lhsOboundBetas :: [(Name, Tp, [Tp])]
         _lhsOboundBetas = rule454  ()
         _lhsOclassMemberNames :: Names
         _lhsOclassMemberNames = rule455  ()
         _lhsOcollectInstances :: [(Name, Instance)]
         _lhsOcollectInstances = rule456  ()
         _lhsOdeclVarNames :: Names
         _lhsOdeclVarNames = rule457  ()
         _lhsOrestrictedNames :: Names
         _lhsOrestrictedNames = rule458  ()
         _lhsOsimplePatNames :: Names
         _lhsOsimplePatNames = rule459  ()
         _lhsOtypeMemberBindings :: [(Name, TpScheme)]
         _lhsOtypeMemberBindings = rule460  ()
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule461  ()
         _self = rule462 _rangeIself _simpletypeIself _typeIself
         _lhsOself :: Declaration
         _lhsOself = rule463 _self
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule464 _lhsIbetaUnique
         _lhsObindingGroups :: BindingGroups
         _lhsObindingGroups = rule465 _lhsIbindingGroups
         _lhsOcollectErrors :: TypeErrors
         _lhsOcollectErrors = rule466 _lhsIcollectErrors
         _lhsOcollectWarnings :: Warnings
         _lhsOcollectWarnings = rule467 _lhsIcollectWarnings
         _lhsOcounter :: Int
         _lhsOcounter = rule468 _lhsIcounter
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule469 _lhsIdictionaryEnvironment
         _lhsOmatchIO :: IO ()
         _lhsOmatchIO = rule470 _lhsImatchIO
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule471 _lhsIpatternMatchWarnings
         _lhsOtypeSignatures :: TypeEnvironment
         _lhsOtypeSignatures = rule472 _lhsItypeSignatures
         _lhsOuniqueChunk :: Int
         _lhsOuniqueChunk = rule473 _lhsIuniqueChunk
         _typeOclassMemberEnv = rule474 _lhsIclassMemberEnv
         _typeOclassNamesEnv = rule475 _lhsIclassNamesEnv
         !__result_ = T_Declaration_vOut28 _lhsObetaUnique _lhsObindingGroups _lhsOboundBetas _lhsOclassMemberNames _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOcounter _lhsOdeclVarNames _lhsOdictionaryEnvironment _lhsOinfoTrees _lhsOmatchIO _lhsOpatternMatchWarnings _lhsOrestrictedNames _lhsOself _lhsOsimplePatNames _lhsOtypeMemberBindings _lhsOtypeSignatures _lhsOunboundNames _lhsOuniqueChunk
         in __result_ )
     in C_Declaration_s29 v28
   {-# INLINE rule453 #-}
   rule453 = \  (_ :: ()) ->
                                 []
   {-# INLINE rule454 #-}
   rule454 = \  (_ :: ()) ->
     []
   {-# INLINE rule455 #-}
   rule455 = \  (_ :: ()) ->
     []
   {-# INLINE rule456 #-}
   rule456 = \  (_ :: ()) ->
     []
   {-# INLINE rule457 #-}
   rule457 = \  (_ :: ()) ->
     []
   {-# INLINE rule458 #-}
   rule458 = \  (_ :: ()) ->
     []
   {-# INLINE rule459 #-}
   rule459 = \  (_ :: ()) ->
     []
   {-# INLINE rule460 #-}
   rule460 = \  (_ :: ()) ->
     []
   {-# INLINE rule461 #-}
   rule461 = \  (_ :: ()) ->
     []
   {-# INLINE rule462 #-}
   rule462 = \ ((_rangeIself) :: Range) ((_simpletypeIself) :: SimpleType) ((_typeIself) :: Type) ->
     Declaration_Type _rangeIself _simpletypeIself _typeIself
   {-# INLINE rule463 #-}
   rule463 = \ _self ->
     _self
   {-# INLINE rule464 #-}
   rule464 = \ ((_lhsIbetaUnique) :: Int) ->
     _lhsIbetaUnique
   {-# INLINE rule465 #-}
   rule465 = \ ((_lhsIbindingGroups) :: BindingGroups) ->
     _lhsIbindingGroups
   {-# INLINE rule466 #-}
   rule466 = \ ((_lhsIcollectErrors) :: TypeErrors) ->
     _lhsIcollectErrors
   {-# INLINE rule467 #-}
   rule467 = \ ((_lhsIcollectWarnings) :: Warnings) ->
     _lhsIcollectWarnings
   {-# INLINE rule468 #-}
   rule468 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule469 #-}
   rule469 = \ ((_lhsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _lhsIdictionaryEnvironment
   {-# INLINE rule470 #-}
   rule470 = \ ((_lhsImatchIO) :: IO ()) ->
     _lhsImatchIO
   {-# INLINE rule471 #-}
   rule471 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule472 #-}
   rule472 = \ ((_lhsItypeSignatures) :: TypeEnvironment) ->
     _lhsItypeSignatures
   {-# INLINE rule473 #-}
   rule473 = \ ((_lhsIuniqueChunk) :: Int) ->
     _lhsIuniqueChunk
   {-# INLINE rule474 #-}
   rule474 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule475 #-}
   rule475 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
{-# NOINLINE sem_Declaration_Data #-}
sem_Declaration_Data :: T_Range  -> T_ContextItems  -> T_SimpleType  -> T_Constructors  -> T_Names  -> T_Declaration 
sem_Declaration_Data arg_range_ arg_context_ arg_simpletype_ arg_constructors_ arg_derivings_ = T_Declaration (return st29) where
   {-# NOINLINE st29 #-}
   !st29 = let
      v28 :: T_Declaration_v28 
      v28 = \ !(T_Declaration_vIn28 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaUnique _lhsIbindingGroups _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinheritedBDG _lhsIinstanceName _lhsIinstanceTypes _lhsIisTopLevel _lhsImatchIO _lhsImoduleName _lhsImoduleQual _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeConstructors _lhsItypeSignatures _lhsItypeschemeMap _lhsIuniqueChunk _lhsIvariableMapping) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _contextX26 = Control.Monad.Identity.runIdentity (attach_T_ContextItems (arg_context_))
         _simpletypeX152 = Control.Monad.Identity.runIdentity (attach_T_SimpleType (arg_simpletype_))
         _constructorsX20 = Control.Monad.Identity.runIdentity (attach_T_Constructors (arg_constructors_))
         _derivingsX116 = Control.Monad.Identity.runIdentity (attach_T_Names (arg_derivings_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_ContextItems_vOut25 _contextIself) = inv_ContextItems_s26 _contextX26 (T_ContextItems_vIn25 _contextOclassMemberEnv _contextOclassNamesEnv)
         (T_SimpleType_vOut151 _simpletypeIname _simpletypeIself _simpletypeItypevariables) = inv_SimpleType_s152 _simpletypeX152 (T_SimpleType_vIn151 )
         (T_Constructors_vOut19 _constructorsIcounter _constructorsIself _constructorsIunboundNames) = inv_Constructors_s20 _constructorsX20 (T_Constructors_vIn19 _constructorsOambiguousConflicts _constructorsOclassMemberEnv _constructorsOclassNamesEnv _constructorsOcounter _constructorsOnamesInScope)
         (T_Names_vOut115 _derivingsIself) = inv_Names_s116 _derivingsX116 (T_Names_vIn115 )
         _lhsOinfoTrees :: InfoTrees
         _lhsOinfoTrees = rule476  ()
         _lhsOcollectInstances :: [(Name, Instance)]
         _lhsOcollectInstances = rule477 _lhsImoduleQual _qualDers _simpletypeIname _simpletypeItypevariables
         _qualDers = rule478 _derivingsIself _lhsIimportEnvironment
         _lhsOboundBetas :: [(Name, Tp, [Tp])]
         _lhsOboundBetas = rule479  ()
         _lhsOclassMemberNames :: Names
         _lhsOclassMemberNames = rule480  ()
         _lhsOdeclVarNames :: Names
         _lhsOdeclVarNames = rule481  ()
         _lhsOrestrictedNames :: Names
         _lhsOrestrictedNames = rule482  ()
         _lhsOsimplePatNames :: Names
         _lhsOsimplePatNames = rule483  ()
         _lhsOtypeMemberBindings :: [(Name, TpScheme)]
         _lhsOtypeMemberBindings = rule484  ()
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule485 _constructorsIunboundNames
         _self = rule486 _constructorsIself _contextIself _derivingsIself _rangeIself _simpletypeIself
         _lhsOself :: Declaration
         _lhsOself = rule487 _self
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule488 _lhsIbetaUnique
         _lhsObindingGroups :: BindingGroups
         _lhsObindingGroups = rule489 _lhsIbindingGroups
         _lhsOcollectErrors :: TypeErrors
         _lhsOcollectErrors = rule490 _lhsIcollectErrors
         _lhsOcollectWarnings :: Warnings
         _lhsOcollectWarnings = rule491 _lhsIcollectWarnings
         _lhsOcounter :: Int
         _lhsOcounter = rule492 _constructorsIcounter
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule493 _lhsIdictionaryEnvironment
         _lhsOmatchIO :: IO ()
         _lhsOmatchIO = rule494 _lhsImatchIO
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule495 _lhsIpatternMatchWarnings
         _lhsOtypeSignatures :: TypeEnvironment
         _lhsOtypeSignatures = rule496 _lhsItypeSignatures
         _lhsOuniqueChunk :: Int
         _lhsOuniqueChunk = rule497 _lhsIuniqueChunk
         _contextOclassMemberEnv = rule498 _lhsIclassMemberEnv
         _contextOclassNamesEnv = rule499 _lhsIclassNamesEnv
         _constructorsOambiguousConflicts = rule500 _lhsIambiguousConflicts
         _constructorsOclassMemberEnv = rule501 _lhsIclassMemberEnv
         _constructorsOclassNamesEnv = rule502 _lhsIclassNamesEnv
         _constructorsOcounter = rule503 _lhsIcounter
         _constructorsOnamesInScope = rule504 _lhsInamesInScope
         !__result_ = T_Declaration_vOut28 _lhsObetaUnique _lhsObindingGroups _lhsOboundBetas _lhsOclassMemberNames _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOcounter _lhsOdeclVarNames _lhsOdictionaryEnvironment _lhsOinfoTrees _lhsOmatchIO _lhsOpatternMatchWarnings _lhsOrestrictedNames _lhsOself _lhsOsimplePatNames _lhsOtypeMemberBindings _lhsOtypeSignatures _lhsOunboundNames _lhsOuniqueChunk
         in __result_ )
     in C_Declaration_s29 v28
   {-# INLINE rule476 #-}
   rule476 = \  (_ :: ()) ->
                                 []
   {-# INLINE rule477 #-}
   rule477 = \ ((_lhsImoduleQual) ::  [String] ) _qualDers ((_simpletypeIname) :: Name) ((_simpletypeItypevariables) :: Names) ->
                                    [ (cl, makeInstance (show cl) (length _simpletypeItypevariables) (getNameName $ addQualified _lhsImoduleQual _simpletypeIname) True)
                                      | cl <- _qualDers
                                    ]
   {-# INLINE rule478 #-}
   rule478 = \ ((_derivingsIself) :: Names) ((_lhsIimportEnvironment) :: ImportEnvironment) ->
                                   map (convertClassNameToQualified _lhsIimportEnvironment) _derivingsIself
   {-# INLINE rule479 #-}
   rule479 = \  (_ :: ()) ->
     []
   {-# INLINE rule480 #-}
   rule480 = \  (_ :: ()) ->
     []
   {-# INLINE rule481 #-}
   rule481 = \  (_ :: ()) ->
     []
   {-# INLINE rule482 #-}
   rule482 = \  (_ :: ()) ->
     []
   {-# INLINE rule483 #-}
   rule483 = \  (_ :: ()) ->
     []
   {-# INLINE rule484 #-}
   rule484 = \  (_ :: ()) ->
     []
   {-# INLINE rule485 #-}
   rule485 = \ ((_constructorsIunboundNames) :: Names) ->
     _constructorsIunboundNames
   {-# INLINE rule486 #-}
   rule486 = \ ((_constructorsIself) :: Constructors) ((_contextIself) :: ContextItems) ((_derivingsIself) :: Names) ((_rangeIself) :: Range) ((_simpletypeIself) :: SimpleType) ->
     Declaration_Data _rangeIself _contextIself _simpletypeIself _constructorsIself _derivingsIself
   {-# INLINE rule487 #-}
   rule487 = \ _self ->
     _self
   {-# INLINE rule488 #-}
   rule488 = \ ((_lhsIbetaUnique) :: Int) ->
     _lhsIbetaUnique
   {-# INLINE rule489 #-}
   rule489 = \ ((_lhsIbindingGroups) :: BindingGroups) ->
     _lhsIbindingGroups
   {-# INLINE rule490 #-}
   rule490 = \ ((_lhsIcollectErrors) :: TypeErrors) ->
     _lhsIcollectErrors
   {-# INLINE rule491 #-}
   rule491 = \ ((_lhsIcollectWarnings) :: Warnings) ->
     _lhsIcollectWarnings
   {-# INLINE rule492 #-}
   rule492 = \ ((_constructorsIcounter) :: Int) ->
     _constructorsIcounter
   {-# INLINE rule493 #-}
   rule493 = \ ((_lhsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _lhsIdictionaryEnvironment
   {-# INLINE rule494 #-}
   rule494 = \ ((_lhsImatchIO) :: IO ()) ->
     _lhsImatchIO
   {-# INLINE rule495 #-}
   rule495 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule496 #-}
   rule496 = \ ((_lhsItypeSignatures) :: TypeEnvironment) ->
     _lhsItypeSignatures
   {-# INLINE rule497 #-}
   rule497 = \ ((_lhsIuniqueChunk) :: Int) ->
     _lhsIuniqueChunk
   {-# INLINE rule498 #-}
   rule498 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule499 #-}
   rule499 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule500 #-}
   rule500 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule501 #-}
   rule501 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule502 #-}
   rule502 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule503 #-}
   rule503 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule504 #-}
   rule504 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
{-# NOINLINE sem_Declaration_Newtype #-}
sem_Declaration_Newtype :: T_Range  -> T_ContextItems  -> T_SimpleType  -> T_Constructor  -> T_Names  -> T_Declaration 
sem_Declaration_Newtype arg_range_ arg_context_ arg_simpletype_ arg_constructor_ arg_derivings_ = T_Declaration (return st29) where
   {-# NOINLINE st29 #-}
   !st29 = let
      v28 :: T_Declaration_v28 
      v28 = \ !(T_Declaration_vIn28 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaUnique _lhsIbindingGroups _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinheritedBDG _lhsIinstanceName _lhsIinstanceTypes _lhsIisTopLevel _lhsImatchIO _lhsImoduleName _lhsImoduleQual _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeConstructors _lhsItypeSignatures _lhsItypeschemeMap _lhsIuniqueChunk _lhsIvariableMapping) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _contextX26 = Control.Monad.Identity.runIdentity (attach_T_ContextItems (arg_context_))
         _simpletypeX152 = Control.Monad.Identity.runIdentity (attach_T_SimpleType (arg_simpletype_))
         _constructorX17 = Control.Monad.Identity.runIdentity (attach_T_Constructor (arg_constructor_))
         _derivingsX116 = Control.Monad.Identity.runIdentity (attach_T_Names (arg_derivings_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_ContextItems_vOut25 _contextIself) = inv_ContextItems_s26 _contextX26 (T_ContextItems_vIn25 _contextOclassMemberEnv _contextOclassNamesEnv)
         (T_SimpleType_vOut151 _simpletypeIname _simpletypeIself _simpletypeItypevariables) = inv_SimpleType_s152 _simpletypeX152 (T_SimpleType_vIn151 )
         (T_Constructor_vOut16 _constructorIcounter _constructorIself _constructorIunboundNames) = inv_Constructor_s17 _constructorX17 (T_Constructor_vIn16 _constructorOambiguousConflicts _constructorOclassMemberEnv _constructorOclassNamesEnv _constructorOcounter _constructorOnamesInScope)
         (T_Names_vOut115 _derivingsIself) = inv_Names_s116 _derivingsX116 (T_Names_vIn115 )
         _infoTrees = rule505  ()
         _lhsOboundBetas :: [(Name, Tp, [Tp])]
         _lhsOboundBetas = rule506  ()
         _lhsOclassMemberNames :: Names
         _lhsOclassMemberNames = rule507  ()
         _lhsOcollectInstances :: [(Name, Instance)]
         _lhsOcollectInstances = rule508  ()
         _lhsOdeclVarNames :: Names
         _lhsOdeclVarNames = rule509  ()
         _lhsOrestrictedNames :: Names
         _lhsOrestrictedNames = rule510  ()
         _lhsOsimplePatNames :: Names
         _lhsOsimplePatNames = rule511  ()
         _lhsOtypeMemberBindings :: [(Name, TpScheme)]
         _lhsOtypeMemberBindings = rule512  ()
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule513 _constructorIunboundNames
         _self = rule514 _constructorIself _contextIself _derivingsIself _rangeIself _simpletypeIself
         _lhsOself :: Declaration
         _lhsOself = rule515 _self
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule516 _lhsIbetaUnique
         _lhsObindingGroups :: BindingGroups
         _lhsObindingGroups = rule517 _lhsIbindingGroups
         _lhsOcollectErrors :: TypeErrors
         _lhsOcollectErrors = rule518 _lhsIcollectErrors
         _lhsOcollectWarnings :: Warnings
         _lhsOcollectWarnings = rule519 _lhsIcollectWarnings
         _lhsOcounter :: Int
         _lhsOcounter = rule520 _constructorIcounter
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule521 _lhsIdictionaryEnvironment
         _lhsOinfoTrees :: InfoTrees
         _lhsOinfoTrees = rule522 _infoTrees
         _lhsOmatchIO :: IO ()
         _lhsOmatchIO = rule523 _lhsImatchIO
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule524 _lhsIpatternMatchWarnings
         _lhsOtypeSignatures :: TypeEnvironment
         _lhsOtypeSignatures = rule525 _lhsItypeSignatures
         _lhsOuniqueChunk :: Int
         _lhsOuniqueChunk = rule526 _lhsIuniqueChunk
         _contextOclassMemberEnv = rule527 _lhsIclassMemberEnv
         _contextOclassNamesEnv = rule528 _lhsIclassNamesEnv
         _constructorOambiguousConflicts = rule529 _lhsIambiguousConflicts
         _constructorOclassMemberEnv = rule530 _lhsIclassMemberEnv
         _constructorOclassNamesEnv = rule531 _lhsIclassNamesEnv
         _constructorOcounter = rule532 _lhsIcounter
         _constructorOnamesInScope = rule533 _lhsInamesInScope
         !__result_ = T_Declaration_vOut28 _lhsObetaUnique _lhsObindingGroups _lhsOboundBetas _lhsOclassMemberNames _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOcounter _lhsOdeclVarNames _lhsOdictionaryEnvironment _lhsOinfoTrees _lhsOmatchIO _lhsOpatternMatchWarnings _lhsOrestrictedNames _lhsOself _lhsOsimplePatNames _lhsOtypeMemberBindings _lhsOtypeSignatures _lhsOunboundNames _lhsOuniqueChunk
         in __result_ )
     in C_Declaration_s29 v28
   {-# INLINE rule505 #-}
   rule505 = \  (_ :: ()) ->
                                                                            globalInfoError
   {-# INLINE rule506 #-}
   rule506 = \  (_ :: ()) ->
     []
   {-# INLINE rule507 #-}
   rule507 = \  (_ :: ()) ->
     []
   {-# INLINE rule508 #-}
   rule508 = \  (_ :: ()) ->
     []
   {-# INLINE rule509 #-}
   rule509 = \  (_ :: ()) ->
     []
   {-# INLINE rule510 #-}
   rule510 = \  (_ :: ()) ->
     []
   {-# INLINE rule511 #-}
   rule511 = \  (_ :: ()) ->
     []
   {-# INLINE rule512 #-}
   rule512 = \  (_ :: ()) ->
     []
   {-# INLINE rule513 #-}
   rule513 = \ ((_constructorIunboundNames) :: Names) ->
     _constructorIunboundNames
   {-# INLINE rule514 #-}
   rule514 = \ ((_constructorIself) :: Constructor) ((_contextIself) :: ContextItems) ((_derivingsIself) :: Names) ((_rangeIself) :: Range) ((_simpletypeIself) :: SimpleType) ->
     Declaration_Newtype _rangeIself _contextIself _simpletypeIself _constructorIself _derivingsIself
   {-# INLINE rule515 #-}
   rule515 = \ _self ->
     _self
   {-# INLINE rule516 #-}
   rule516 = \ ((_lhsIbetaUnique) :: Int) ->
     _lhsIbetaUnique
   {-# INLINE rule517 #-}
   rule517 = \ ((_lhsIbindingGroups) :: BindingGroups) ->
     _lhsIbindingGroups
   {-# INLINE rule518 #-}
   rule518 = \ ((_lhsIcollectErrors) :: TypeErrors) ->
     _lhsIcollectErrors
   {-# INLINE rule519 #-}
   rule519 = \ ((_lhsIcollectWarnings) :: Warnings) ->
     _lhsIcollectWarnings
   {-# INLINE rule520 #-}
   rule520 = \ ((_constructorIcounter) :: Int) ->
     _constructorIcounter
   {-# INLINE rule521 #-}
   rule521 = \ ((_lhsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _lhsIdictionaryEnvironment
   {-# INLINE rule522 #-}
   rule522 = \ _infoTrees ->
     _infoTrees
   {-# INLINE rule523 #-}
   rule523 = \ ((_lhsImatchIO) :: IO ()) ->
     _lhsImatchIO
   {-# INLINE rule524 #-}
   rule524 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule525 #-}
   rule525 = \ ((_lhsItypeSignatures) :: TypeEnvironment) ->
     _lhsItypeSignatures
   {-# INLINE rule526 #-}
   rule526 = \ ((_lhsIuniqueChunk) :: Int) ->
     _lhsIuniqueChunk
   {-# INLINE rule527 #-}
   rule527 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule528 #-}
   rule528 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule529 #-}
   rule529 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule530 #-}
   rule530 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule531 #-}
   rule531 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule532 #-}
   rule532 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule533 #-}
   rule533 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
{-# NOINLINE sem_Declaration_Class #-}
sem_Declaration_Class :: T_Range  -> T_ContextItems  -> T_SimpleType  -> T_MaybeDeclarations  -> T_Declaration 
sem_Declaration_Class arg_range_ arg_context_ arg_simpletype_ arg_where_ = T_Declaration (return st29) where
   {-# NOINLINE st29 #-}
   !st29 = let
      v28 :: T_Declaration_v28 
      v28 = \ !(T_Declaration_vIn28 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaUnique _lhsIbindingGroups _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinheritedBDG _lhsIinstanceName _lhsIinstanceTypes _lhsIisTopLevel _lhsImatchIO _lhsImoduleName _lhsImoduleQual _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeConstructors _lhsItypeSignatures _lhsItypeschemeMap _lhsIuniqueChunk _lhsIvariableMapping) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _contextX26 = Control.Monad.Identity.runIdentity (attach_T_ContextItems (arg_context_))
         _simpletypeX152 = Control.Monad.Identity.runIdentity (attach_T_SimpleType (arg_simpletype_))
         _whereX89 = Control.Monad.Identity.runIdentity (attach_T_MaybeDeclarations (arg_where_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_ContextItems_vOut25 _contextIself) = inv_ContextItems_s26 _contextX26 (T_ContextItems_vIn25 _contextOclassMemberEnv _contextOclassNamesEnv)
         (T_SimpleType_vOut151 _simpletypeIname _simpletypeIself _simpletypeItypevariables) = inv_SimpleType_s152 _simpletypeX152 (T_SimpleType_vIn151 )
         (T_MaybeDeclarations_vOut88 _whereIassumptions _whereIbetaUnique _whereIboundBetas _whereIcollectErrors _whereIcollectInstances _whereIcollectWarnings _whereIconstraints _whereIcounter _whereIdeclVarNames _whereIdictionaryEnvironment _whereIinfoTrees _whereIlocalTypes _whereImatchIO _whereInamesInScope _whereIpatternMatchWarnings _whereIself _whereItypeMemberBindings _whereIunboundNames _whereIuniqueChunk) = inv_MaybeDeclarations_s89 _whereX89 (T_MaybeDeclarations_vIn88 _whereOallPatterns _whereOallTypeSchemes _whereOambiguousConflicts _whereOassumptions _whereOavailablePredicates _whereObetaUnique _whereOclassEnvironment _whereOclassMemberEnv _whereOclassMemberTypeSchemes _whereOclassNamesEnv _whereOclassPredicate _whereOclassTypeSchemes _whereOcollectErrors _whereOcollectWarnings _whereOconstraints _whereOcounter _whereOcurClassPred _whereOcurPred _whereOcurrentChunk _whereOdictionaryEnvironment _whereOimportEnvironment _whereOinstanceName _whereOinstanceTypes _whereOmatchIO _whereOmoduleName _whereOmonos _whereOnamesInScope _whereOorderedTypeSynonyms _whereOparentTree _whereOpatternMatchWarnings _whereOrequiredPredicates _whereOsubstitution _whereOtypeConstructors _whereOtypeschemeMap _whereOunboundNames _whereOuniqueChunk _whereOvariableMapping)
         (_namesInScope,_unboundNames,_scopeInfo) = rule534 _lhsInamesInScope _whereIdeclVarNames _whereIunboundNames
         _lhsOclassMemberNames :: Names
         _lhsOclassMemberNames = rule535 _classMemberNames
         _classMemberNames = rule536 _lhsIclassMemberEnv _qualifiedClassName
         _qualifiedClassName = rule537 _lhsIclassNamesEnv _simpletypeIname
         _whereOunboundNames = rule538  ()
         _lhsOdeclVarNames :: Names
         _lhsOdeclVarNames = rule539  ()
         _whereOcurClassPred = rule540 _classBeta _qualName
         _whereOinstanceName = rule541 _qualName
         _qualName = rule542 _lhsIimportEnvironment _simpletypeIname
         _lhsObindingGroups :: BindingGroups
         _lhsObindingGroups = rule543 _classMembers _environment _lhsIbindingGroups _whereIassumptions
         _whereOassumptions = rule544  ()
         _whereOconstraints = rule545  ()
         _whereObetaUnique = rule546 _lhsIbetaUnique _whereItypeMemberBindings
         _whereOclassMemberTypeSchemes = rule547 _lhsIallTypeSchemes _whereItypeMemberBindings
         _whereOclassPredicate = rule548 _qualName _simpletypeItypevariables
         _environment = rule549 _members
         _classBeta = rule550 _lhsIbetaUnique
         _classMembers = rule551 _members _qualName _simpletypeItypevariables _whereIconstraints
         _members = rule552 _lhsIbetaUnique _whereItypeMemberBindings
         _lhsOboundBetas :: [(Name, Tp, [Tp])]
         _lhsOboundBetas = rule553 _whereIboundBetas
         _lhsOcollectInstances :: [(Name, Instance)]
         _lhsOcollectInstances = rule554 _whereIcollectInstances
         _lhsOrestrictedNames :: Names
         _lhsOrestrictedNames = rule555  ()
         _lhsOsimplePatNames :: Names
         _lhsOsimplePatNames = rule556  ()
         _lhsOtypeMemberBindings :: [(Name, TpScheme)]
         _lhsOtypeMemberBindings = rule557 _whereItypeMemberBindings
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule558 _unboundNames
         _self = rule559 _contextIself _rangeIself _simpletypeIself _whereIself
         _lhsOself :: Declaration
         _lhsOself = rule560 _self
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule561 _whereIbetaUnique
         _lhsOcollectErrors :: TypeErrors
         _lhsOcollectErrors = rule562 _whereIcollectErrors
         _lhsOcollectWarnings :: Warnings
         _lhsOcollectWarnings = rule563 _whereIcollectWarnings
         _lhsOcounter :: Int
         _lhsOcounter = rule564 _whereIcounter
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule565 _whereIdictionaryEnvironment
         _lhsOinfoTrees :: InfoTrees
         _lhsOinfoTrees = rule566 _whereIinfoTrees
         _lhsOmatchIO :: IO ()
         _lhsOmatchIO = rule567 _whereImatchIO
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule568 _whereIpatternMatchWarnings
         _lhsOtypeSignatures :: TypeEnvironment
         _lhsOtypeSignatures = rule569 _lhsItypeSignatures
         _lhsOuniqueChunk :: Int
         _lhsOuniqueChunk = rule570 _whereIuniqueChunk
         _contextOclassMemberEnv = rule571 _lhsIclassMemberEnv
         _contextOclassNamesEnv = rule572 _lhsIclassNamesEnv
         _whereOallPatterns = rule573 _lhsIallPatterns
         _whereOallTypeSchemes = rule574 _lhsIallTypeSchemes
         _whereOambiguousConflicts = rule575 _lhsIambiguousConflicts
         _whereOavailablePredicates = rule576 _lhsIavailablePredicates
         _whereOclassEnvironment = rule577 _lhsIclassEnvironment
         _whereOclassMemberEnv = rule578 _lhsIclassMemberEnv
         _whereOclassNamesEnv = rule579 _lhsIclassNamesEnv
         _whereOclassTypeSchemes = rule580 _lhsIclassTypeSchemes
         _whereOcollectErrors = rule581 _lhsIcollectErrors
         _whereOcollectWarnings = rule582 _lhsIcollectWarnings
         _whereOcounter = rule583 _lhsIcounter
         _whereOcurPred = rule584 _lhsIcurPred
         _whereOcurrentChunk = rule585 _lhsIcurrentChunk
         _whereOdictionaryEnvironment = rule586 _lhsIdictionaryEnvironment
         _whereOimportEnvironment = rule587 _lhsIimportEnvironment
         _whereOinstanceTypes = rule588 _lhsIinstanceTypes
         _whereOmatchIO = rule589 _lhsImatchIO
         _whereOmoduleName = rule590 _lhsImoduleName
         _whereOmonos = rule591 _lhsImonos
         _whereOnamesInScope = rule592 _namesInScope
         _whereOorderedTypeSynonyms = rule593 _lhsIorderedTypeSynonyms
         _whereOparentTree = rule594 _lhsIparentTree
         _whereOpatternMatchWarnings = rule595 _lhsIpatternMatchWarnings
         _whereOrequiredPredicates = rule596 _lhsIrequiredPredicates
         _whereOsubstitution = rule597 _lhsIsubstitution
         _whereOtypeConstructors = rule598 _lhsItypeConstructors
         _whereOtypeschemeMap = rule599 _lhsItypeschemeMap
         _whereOuniqueChunk = rule600 _lhsIuniqueChunk
         _whereOvariableMapping = rule601 _lhsIvariableMapping
         !__result_ = T_Declaration_vOut28 _lhsObetaUnique _lhsObindingGroups _lhsOboundBetas _lhsOclassMemberNames _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOcounter _lhsOdeclVarNames _lhsOdictionaryEnvironment _lhsOinfoTrees _lhsOmatchIO _lhsOpatternMatchWarnings _lhsOrestrictedNames _lhsOself _lhsOsimplePatNames _lhsOtypeMemberBindings _lhsOtypeSignatures _lhsOunboundNames _lhsOuniqueChunk
         in __result_ )
     in C_Declaration_s29 v28
   {-# INLINE rule534 #-}
   rule534 = \ ((_lhsInamesInScope) :: Names) ((_whereIdeclVarNames) :: Names) ((_whereIunboundNames) :: Names) ->
                                                              changeOfScope (_whereIdeclVarNames) _whereIunboundNames _lhsInamesInScope
   {-# INLINE rule535 #-}
   rule535 = \ _classMemberNames ->
                                         _classMemberNames
   {-# INLINE rule536 #-}
   rule536 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) _qualifiedClassName ->
                                         getClassMemberNames _qualifiedClassName _lhsIclassMemberEnv
   {-# INLINE rule537 #-}
   rule537 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ((_simpletypeIname) :: Name) ->
                                         M.findWithDefault _simpletypeIname _simpletypeIname _lhsIclassNamesEnv
   {-# INLINE rule538 #-}
   rule538 = \  (_ :: ()) ->
                                      []
   {-# INLINE rule539 #-}
   rule539 = \  (_ :: ()) ->
                                             []
   {-# INLINE rule540 #-}
   rule540 = \ _classBeta _qualName ->
                               Just $ Predicate (getNameName _qualName) _classBeta
   {-# INLINE rule541 #-}
   rule541 = \ _qualName ->
                               Just $ _qualName
   {-# INLINE rule542 #-}
   rule542 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ((_simpletypeIname) :: Name) ->
                               convertClassNameToQualified _lhsIimportEnvironment _simpletypeIname
   {-# INLINE rule543 #-}
   rule543 = \ _classMembers _environment ((_lhsIbindingGroups) :: BindingGroups) ((_whereIassumptions) :: Assumptions) ->
                                        (_environment    , _whereIassumptions, _classMembers    ) : _lhsIbindingGroups
   {-# INLINE rule544 #-}
   rule544 = \  (_ :: ()) ->
                                        noAssumptions
   {-# INLINE rule545 #-}
   rule545 = \  (_ :: ()) ->
                                        emptyTree
   {-# INLINE rule546 #-}
   rule546 = \ ((_lhsIbetaUnique) :: Int) ((_whereItypeMemberBindings) :: [(Name, TpScheme)]) ->
                                        _lhsIbetaUnique + 1 + (length _whereItypeMemberBindings)
   {-# INLINE rule547 #-}
   rule547 = \ ((_lhsIallTypeSchemes) :: M.Map NameWithRange TpScheme) ((_whereItypeMemberBindings) :: [(Name, TpScheme)]) ->
                                                 appendClasses _whereItypeMemberBindings _lhsIallTypeSchemes
   {-# INLINE rule548 #-}
   rule548 = \ _qualName ((_simpletypeItypevariables) :: Names) ->
                                         Just (_qualName, _simpletypeItypevariables)
   {-# INLINE rule549 #-}
   rule549 = \ _members ->
                                        M.fromList $ map (\((n, _), tp)->(n, tp)) _members
   {-# INLINE rule550 #-}
   rule550 = \ ((_lhsIbetaUnique) :: Int) ->
                                        TVar _lhsIbetaUnique
   {-# INLINE rule551 #-}
   rule551 = \ _members _qualName ((_simpletypeItypevariables) :: Names) ((_whereIconstraints) :: ConstraintSet) ->
                                        (map (\((_, tpscheme), tp) ->
                                              let
                                                  typeVars = _simpletypeItypevariables
                                                  className = _qualName
                                                  typeIndices = filter (\(_, s) -> s `elem` (map getNameName typeVars)) (getQuantorMap tpscheme)
                                                  typeVariablesMapped = map (\(n, s) -> (fromJust $ find (\tv -> getNameName tv == s) typeVars, TVar n)) typeIndices
                                                  tpWContext = addContextToType className typeVariablesMapped tpscheme
                                              in unitTree $ (tp .::. tpWContext) emptyConstraintInfo
                                          ) _members)
                                          ++
                                          [_whereIconstraints]
   {-# INLINE rule552 #-}
   rule552 = \ ((_lhsIbetaUnique) :: Int) ((_whereItypeMemberBindings) :: [(Name, TpScheme)]) ->
                                        zip _whereItypeMemberBindings (map TVar [(_lhsIbetaUnique + 1)..])
   {-# INLINE rule553 #-}
   rule553 = \ ((_whereIboundBetas) :: [(Name, Tp, [Tp])]) ->
     _whereIboundBetas
   {-# INLINE rule554 #-}
   rule554 = \ ((_whereIcollectInstances) :: [(Name, Instance)]) ->
     _whereIcollectInstances
   {-# INLINE rule555 #-}
   rule555 = \  (_ :: ()) ->
     []
   {-# INLINE rule556 #-}
   rule556 = \  (_ :: ()) ->
     []
   {-# INLINE rule557 #-}
   rule557 = \ ((_whereItypeMemberBindings) :: [(Name, TpScheme)]) ->
     _whereItypeMemberBindings
   {-# INLINE rule558 #-}
   rule558 = \ _unboundNames ->
     _unboundNames
   {-# INLINE rule559 #-}
   rule559 = \ ((_contextIself) :: ContextItems) ((_rangeIself) :: Range) ((_simpletypeIself) :: SimpleType) ((_whereIself) :: MaybeDeclarations) ->
     Declaration_Class _rangeIself _contextIself _simpletypeIself _whereIself
   {-# INLINE rule560 #-}
   rule560 = \ _self ->
     _self
   {-# INLINE rule561 #-}
   rule561 = \ ((_whereIbetaUnique) :: Int) ->
     _whereIbetaUnique
   {-# INLINE rule562 #-}
   rule562 = \ ((_whereIcollectErrors) :: TypeErrors) ->
     _whereIcollectErrors
   {-# INLINE rule563 #-}
   rule563 = \ ((_whereIcollectWarnings) :: Warnings) ->
     _whereIcollectWarnings
   {-# INLINE rule564 #-}
   rule564 = \ ((_whereIcounter) :: Int) ->
     _whereIcounter
   {-# INLINE rule565 #-}
   rule565 = \ ((_whereIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _whereIdictionaryEnvironment
   {-# INLINE rule566 #-}
   rule566 = \ ((_whereIinfoTrees) :: InfoTrees) ->
     _whereIinfoTrees
   {-# INLINE rule567 #-}
   rule567 = \ ((_whereImatchIO) :: IO ()) ->
     _whereImatchIO
   {-# INLINE rule568 #-}
   rule568 = \ ((_whereIpatternMatchWarnings) :: [Warning]) ->
     _whereIpatternMatchWarnings
   {-# INLINE rule569 #-}
   rule569 = \ ((_lhsItypeSignatures) :: TypeEnvironment) ->
     _lhsItypeSignatures
   {-# INLINE rule570 #-}
   rule570 = \ ((_whereIuniqueChunk) :: Int) ->
     _whereIuniqueChunk
   {-# INLINE rule571 #-}
   rule571 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule572 #-}
   rule572 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule573 #-}
   rule573 = \ ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ->
     _lhsIallPatterns
   {-# INLINE rule574 #-}
   rule574 = \ ((_lhsIallTypeSchemes) :: M.Map NameWithRange TpScheme) ->
     _lhsIallTypeSchemes
   {-# INLINE rule575 #-}
   rule575 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule576 #-}
   rule576 = \ ((_lhsIavailablePredicates) :: [PredicateWithSource]) ->
     _lhsIavailablePredicates
   {-# INLINE rule577 #-}
   rule577 = \ ((_lhsIclassEnvironment) :: ClassEnvironment) ->
     _lhsIclassEnvironment
   {-# INLINE rule578 #-}
   rule578 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule579 #-}
   rule579 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule580 #-}
   rule580 = \ ((_lhsIclassTypeSchemes) :: M.Map Name TpScheme) ->
     _lhsIclassTypeSchemes
   {-# INLINE rule581 #-}
   rule581 = \ ((_lhsIcollectErrors) :: TypeErrors) ->
     _lhsIcollectErrors
   {-# INLINE rule582 #-}
   rule582 = \ ((_lhsIcollectWarnings) :: Warnings) ->
     _lhsIcollectWarnings
   {-# INLINE rule583 #-}
   rule583 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule584 #-}
   rule584 = \ ((_lhsIcurPred) :: Maybe Predicate) ->
     _lhsIcurPred
   {-# INLINE rule585 #-}
   rule585 = \ ((_lhsIcurrentChunk) :: Int) ->
     _lhsIcurrentChunk
   {-# INLINE rule586 #-}
   rule586 = \ ((_lhsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _lhsIdictionaryEnvironment
   {-# INLINE rule587 #-}
   rule587 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule588 #-}
   rule588 = \ ((_lhsIinstanceTypes) :: [(Name, TpScheme)]) ->
     _lhsIinstanceTypes
   {-# INLINE rule589 #-}
   rule589 = \ ((_lhsImatchIO) :: IO ()) ->
     _lhsImatchIO
   {-# INLINE rule590 #-}
   rule590 = \ ((_lhsImoduleName) :: Maybe Name) ->
     _lhsImoduleName
   {-# INLINE rule591 #-}
   rule591 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule592 #-}
   rule592 = \ _namesInScope ->
     _namesInScope
   {-# INLINE rule593 #-}
   rule593 = \ ((_lhsIorderedTypeSynonyms) :: OrderedTypeSynonyms) ->
     _lhsIorderedTypeSynonyms
   {-# INLINE rule594 #-}
   rule594 = \ ((_lhsIparentTree) :: InfoTree) ->
     _lhsIparentTree
   {-# INLINE rule595 #-}
   rule595 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule596 #-}
   rule596 = \ ((_lhsIrequiredPredicates) :: Predicates) ->
     _lhsIrequiredPredicates
   {-# INLINE rule597 #-}
   rule597 = \ ((_lhsIsubstitution) :: FixpointSubstitution) ->
     _lhsIsubstitution
   {-# INLINE rule598 #-}
   rule598 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
   {-# INLINE rule599 #-}
   rule599 = \ ((_lhsItypeschemeMap) :: M.Map Int (Scheme Predicates)) ->
     _lhsItypeschemeMap
   {-# INLINE rule600 #-}
   rule600 = \ ((_lhsIuniqueChunk) :: Int) ->
     _lhsIuniqueChunk
   {-# INLINE rule601 #-}
   rule601 = \ ((_lhsIvariableMapping) :: Maybe [(Name, Tp)]) ->
     _lhsIvariableMapping
{-# NOINLINE sem_Declaration_Instance #-}
sem_Declaration_Instance :: T_Range  -> T_ContextItems  -> T_Name  -> T_Types  -> T_MaybeDeclarations  -> T_Declaration 
sem_Declaration_Instance arg_range_ arg_context_ arg_name_ arg_types_ arg_where_ = T_Declaration (return st29) where
   {-# NOINLINE st29 #-}
   !st29 = let
      v28 :: T_Declaration_v28 
      v28 = \ !(T_Declaration_vIn28 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaUnique _lhsIbindingGroups _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinheritedBDG _lhsIinstanceName _lhsIinstanceTypes _lhsIisTopLevel _lhsImatchIO _lhsImoduleName _lhsImoduleQual _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeConstructors _lhsItypeSignatures _lhsItypeschemeMap _lhsIuniqueChunk _lhsIvariableMapping) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _contextX26 = Control.Monad.Identity.runIdentity (attach_T_ContextItems (arg_context_))
         _nameX113 = Control.Monad.Identity.runIdentity (attach_T_Name (arg_name_))
         _typesX167 = Control.Monad.Identity.runIdentity (attach_T_Types (arg_types_))
         _whereX89 = Control.Monad.Identity.runIdentity (attach_T_MaybeDeclarations (arg_where_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_ContextItems_vOut25 _contextIself) = inv_ContextItems_s26 _contextX26 (T_ContextItems_vIn25 _contextOclassMemberEnv _contextOclassNamesEnv)
         (T_Name_vOut112 _nameIself) = inv_Name_s113 _nameX113 (T_Name_vIn112 )
         (T_Types_vOut166 _typesIself) = inv_Types_s167 _typesX167 (T_Types_vIn166 _typesOclassMemberEnv _typesOclassNamesEnv)
         (T_MaybeDeclarations_vOut88 _whereIassumptions _whereIbetaUnique _whereIboundBetas _whereIcollectErrors _whereIcollectInstances _whereIcollectWarnings _whereIconstraints _whereIcounter _whereIdeclVarNames _whereIdictionaryEnvironment _whereIinfoTrees _whereIlocalTypes _whereImatchIO _whereInamesInScope _whereIpatternMatchWarnings _whereIself _whereItypeMemberBindings _whereIunboundNames _whereIuniqueChunk) = inv_MaybeDeclarations_s89 _whereX89 (T_MaybeDeclarations_vIn88 _whereOallPatterns _whereOallTypeSchemes _whereOambiguousConflicts _whereOassumptions _whereOavailablePredicates _whereObetaUnique _whereOclassEnvironment _whereOclassMemberEnv _whereOclassMemberTypeSchemes _whereOclassNamesEnv _whereOclassPredicate _whereOclassTypeSchemes _whereOcollectErrors _whereOcollectWarnings _whereOconstraints _whereOcounter _whereOcurClassPred _whereOcurPred _whereOcurrentChunk _whereOdictionaryEnvironment _whereOimportEnvironment _whereOinstanceName _whereOinstanceTypes _whereOmatchIO _whereOmoduleName _whereOmonos _whereOnamesInScope _whereOorderedTypeSynonyms _whereOparentTree _whereOpatternMatchWarnings _whereOrequiredPredicates _whereOsubstitution _whereOtypeConstructors _whereOtypeschemeMap _whereOunboundNames _whereOuniqueChunk _whereOvariableMapping)
         _whereOunboundNames = rule602  ()
         _lhsOdeclVarNames :: Names
         _lhsOdeclVarNames = rule603  ()
         _parentTree = rule604 _lhsIparentTree _localInfo _whereIinfoTrees
         _lhsOinfoTrees :: InfoTrees
         _lhsOinfoTrees = rule605 _parentTree
         _localInfo = rule606 _lhsImonos _self
         _lhsOcollectInstances :: [(Name, Instance)]
         _lhsOcollectInstances = rule607 _contextQual _qualName _stype _typevariables
         _contextQual = rule608 _contextIself _lhsIimportEnvironment
         _type = rule609 _typesIself
         _stype = rule610 _type _typevariables
         _typevariables = rule611 _type
         _whereOinstanceName = rule612 _qualName
         _whereOavailablePredicates = rule613 _lhsIavailablePredicates _superPredicates
         _qualName = rule614 _lhsIimportEnvironment _nameIself
         _lhsOcollectErrors :: TypeErrors
         _lhsOcollectErrors = rule615 _instanceBetas _lhsIcollectErrors _lhsIimportEnvironment _lhsIrequiredPredicates _qualName _rangeIself _superClasses _typesIself
         _whereObetaUnique = rule616 _lhsIbetaUnique _memberBetas _superClasses _typeVariabeles
         _whereOassumptions = rule617  ()
         _whereOconstraints = rule618  ()
         _whereOvariableMapping = rule619 _classMembers _instBeta
         _whereOclassMemberTypeSchemes = rule620 _lhsIallTypeSchemes _lhsIimportEnvironment _qualName
         _whereOinstanceTypes = rule621 _classMembers _lhsIimportEnvironment _qualName
         _classMembers = rule622 _lhsIimportEnvironment _qualName
         _lhsObindingGroups :: BindingGroups
         _lhsObindingGroups = rule623 _constraints _lhsIbindingGroups _whereIassumptions
         _constraints = rule624 _instanceConstraints _superPredicates _whereIconstraints
         _superPredicates = rule625 _instanceBetas _qualName _superClasses
         _instanceConstraints = rule626 _cinfo _instBeta _instanceBetas _instanceTpScheme _instsType _superClasses
         _instBeta = rule627 _lhsIbetaUnique
         _typeVariabeles = rule628 _typesIself
         _instanceBetas = rule629 _lhsIbetaUnique _typeVariabeles
         _instsType = rule630 _instanceBetas _lhsIimportEnvironment _typesIself
         _instanceTpScheme = rule631 _lhsIimportEnvironment _superClasses _typesIself
         _superClasses = rule632 _contextQual
         _memberSuperClassBeta = rule633 _lhsIbetaUnique _typeVariabeles
         _memberBetas = rule634 _lhsIimportEnvironment _qualName _whereIboundBetas
         _cinfo = rule635 _instanceTpScheme _parentTree _rangeIself
         _lhsOboundBetas :: [(Name, Tp, [Tp])]
         _lhsOboundBetas = rule636 _whereIboundBetas
         _lhsOclassMemberNames :: Names
         _lhsOclassMemberNames = rule637  ()
         _lhsOrestrictedNames :: Names
         _lhsOrestrictedNames = rule638  ()
         _lhsOsimplePatNames :: Names
         _lhsOsimplePatNames = rule639  ()
         _lhsOtypeMemberBindings :: [(Name, TpScheme)]
         _lhsOtypeMemberBindings = rule640 _whereItypeMemberBindings
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule641 _whereIunboundNames
         _self = rule642 _contextIself _nameIself _rangeIself _typesIself _whereIself
         _lhsOself :: Declaration
         _lhsOself = rule643 _self
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule644 _whereIbetaUnique
         _lhsOcollectWarnings :: Warnings
         _lhsOcollectWarnings = rule645 _whereIcollectWarnings
         _lhsOcounter :: Int
         _lhsOcounter = rule646 _whereIcounter
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule647 _whereIdictionaryEnvironment
         _lhsOmatchIO :: IO ()
         _lhsOmatchIO = rule648 _whereImatchIO
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule649 _whereIpatternMatchWarnings
         _lhsOtypeSignatures :: TypeEnvironment
         _lhsOtypeSignatures = rule650 _lhsItypeSignatures
         _lhsOuniqueChunk :: Int
         _lhsOuniqueChunk = rule651 _whereIuniqueChunk
         _contextOclassMemberEnv = rule652 _lhsIclassMemberEnv
         _contextOclassNamesEnv = rule653 _lhsIclassNamesEnv
         _typesOclassMemberEnv = rule654 _lhsIclassMemberEnv
         _typesOclassNamesEnv = rule655 _lhsIclassNamesEnv
         _whereOallPatterns = rule656 _lhsIallPatterns
         _whereOallTypeSchemes = rule657 _lhsIallTypeSchemes
         _whereOambiguousConflicts = rule658 _lhsIambiguousConflicts
         _whereOclassEnvironment = rule659 _lhsIclassEnvironment
         _whereOclassMemberEnv = rule660 _lhsIclassMemberEnv
         _whereOclassNamesEnv = rule661 _lhsIclassNamesEnv
         _whereOclassPredicate = rule662 _lhsIclassPredicate
         _whereOclassTypeSchemes = rule663 _lhsIclassTypeSchemes
         _whereOcollectErrors = rule664 _lhsIcollectErrors
         _whereOcollectWarnings = rule665 _lhsIcollectWarnings
         _whereOcounter = rule666 _lhsIcounter
         _whereOcurClassPred = rule667 _lhsIcurClassPred
         _whereOcurPred = rule668 _lhsIcurPred
         _whereOcurrentChunk = rule669 _lhsIcurrentChunk
         _whereOdictionaryEnvironment = rule670 _lhsIdictionaryEnvironment
         _whereOimportEnvironment = rule671 _lhsIimportEnvironment
         _whereOmatchIO = rule672 _lhsImatchIO
         _whereOmoduleName = rule673 _lhsImoduleName
         _whereOmonos = rule674 _lhsImonos
         _whereOnamesInScope = rule675 _lhsInamesInScope
         _whereOorderedTypeSynonyms = rule676 _lhsIorderedTypeSynonyms
         _whereOparentTree = rule677 _parentTree
         _whereOpatternMatchWarnings = rule678 _lhsIpatternMatchWarnings
         _whereOrequiredPredicates = rule679 _lhsIrequiredPredicates
         _whereOsubstitution = rule680 _lhsIsubstitution
         _whereOtypeConstructors = rule681 _lhsItypeConstructors
         _whereOtypeschemeMap = rule682 _lhsItypeschemeMap
         _whereOuniqueChunk = rule683 _lhsIuniqueChunk
         !__result_ = T_Declaration_vOut28 _lhsObetaUnique _lhsObindingGroups _lhsOboundBetas _lhsOclassMemberNames _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOcounter _lhsOdeclVarNames _lhsOdictionaryEnvironment _lhsOinfoTrees _lhsOmatchIO _lhsOpatternMatchWarnings _lhsOrestrictedNames _lhsOself _lhsOsimplePatNames _lhsOtypeMemberBindings _lhsOtypeSignatures _lhsOunboundNames _lhsOuniqueChunk
         in __result_ )
     in C_Declaration_s29 v28
   {-# INLINE rule602 #-}
   rule602 = \  (_ :: ()) ->
                                      []
   {-# INLINE rule603 #-}
   rule603 = \  (_ :: ()) ->
                                             []
   {-# INLINE rule604 #-}
   rule604 = \ ((_lhsIparentTree) :: InfoTree) _localInfo ((_whereIinfoTrees) :: InfoTrees) ->
                                        node _lhsIparentTree _localInfo _whereIinfoTrees
   {-# INLINE rule605 #-}
   rule605 = \ _parentTree ->
                                        [_parentTree]
   {-# INLINE rule606 #-}
   rule606 = \ ((_lhsImonos) :: Monos) _self ->
                            LocalInfo { self = UHA_Decl _self
                                      , assignedType = Nothing
                                      , monos = _lhsImonos
                                      }
   {-# INLINE rule607 #-}
   rule607 = \ _contextQual _qualName _stype _typevariables ->
                                    [(_qualName, updateSuperclasses _typevariables (getSuperClasses _contextQual) $ makeInstance
                                        (show _qualName) (length _typevariables) _stype False)]
   {-# INLINE rule608 #-}
   rule608 = \ ((_contextIself) :: ContextItems) ((_lhsIimportEnvironment) :: ImportEnvironment) ->
                                    map (convertContextItemToQualified _lhsIimportEnvironment) _contextIself
   {-# INLINE rule609 #-}
   rule609 = \ ((_typesIself) :: Types) ->
                                    head _typesIself
   {-# INLINE rule610 #-}
   rule610 = \ _type _typevariables ->
                                    showInstanceType $ makeTpFromType _typevariables _type
   {-# INLINE rule611 #-}
   rule611 = \ _type ->
                                    zip (namesInType _type) [TVar n | n <- [0..]]
   {-# INLINE rule612 #-}
   rule612 = \ _qualName ->
                                      Just _qualName
   {-# INLINE rule613 #-}
   rule613 = \ ((_lhsIavailablePredicates) :: [PredicateWithSource]) _superPredicates ->
                                      _superPredicates ++ _lhsIavailablePredicates
   {-# INLINE rule614 #-}
   rule614 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ((_nameIself) :: Name) ->
                                      convertClassNameToQualified _lhsIimportEnvironment _nameIself
   {-# INLINE rule615 #-}
   rule615 = \ _instanceBetas ((_lhsIcollectErrors) :: TypeErrors) ((_lhsIimportEnvironment) :: ImportEnvironment) ((_lhsIrequiredPredicates) :: Predicates) _qualName ((_rangeIself) :: Range) _superClasses ((_typesIself) :: Types) ->
                                            let
                                              unqualifier = unQualifyName _lhsIimportEnvironment
                                              checkPredicate :: Predicate -> [TypeError]
                                              checkPredicate p@(Predicate _ v)
                                                  | p `elem` map (superClassToPredicate _instanceBetas) _superClasses = []
                                                  | v `elem` map snd _instanceBetas = [makeMissingInstancePredicateError _rangeIself (unqualifier _qualName)
                                                                                      (show $ makeTpSchemeFromType (chead $ _typesIself)) (convertPredicate unqualifier p)
                                                                                      (map (\(n,v') -> (convertString unqualifier n, v')) _superClasses) _instanceBetas]
                                                  | otherwise = []
                                            in (concatMap checkPredicate _lhsIrequiredPredicates) ++ _lhsIcollectErrors
   {-# INLINE rule616 #-}
   rule616 = \ ((_lhsIbetaUnique) :: Int) _memberBetas _superClasses _typeVariabeles ->
                                            _lhsIbetaUnique + 2 + length(_typeVariabeles) + length (_memberBetas) * (length (_superClasses) + 1)
   {-# INLINE rule617 #-}
   rule617 = \  (_ :: ()) ->
                                            noAssumptions
   {-# INLINE rule618 #-}
   rule618 = \  (_ :: ()) ->
                                            emptyTree
   {-# INLINE rule619 #-}
   rule619 = \ _classMembers _instBeta ->
                                            Just [(chead $ fst $ _classMembers, _instBeta)]
   {-# INLINE rule620 #-}
   rule620 = \ ((_lhsIallTypeSchemes) :: M.Map NameWithRange TpScheme) ((_lhsIimportEnvironment) :: ImportEnvironment) _qualName ->
                                             appendClasses ((maybe (error "Invalid class name") ((map (\(n, tps, _, _)->(n, tps))).snd)
                                              $ M.lookup _qualName (classMemberEnvironment _lhsIimportEnvironment))) _lhsIallTypeSchemes
   {-# INLINE rule621 #-}
   rule621 = \ _classMembers ((_lhsIimportEnvironment) :: ImportEnvironment) _qualName ->
                                            maybe [] ((map (\(n, tps, _, _)->(n, let
                                                      typeVars = fst _classMembers
                                                      className = _qualName
                                                      typeIndices = filter (\(_, s) -> s `elem` (map getNameName typeVars)) (getQuantorMap tps)
                                                      typeVariablesMapped = map (\(n', s) -> (fromJust $ find (\tv -> getNameName tv == s) typeVars, TVar n')) typeIndices
                                                      tpWContext = addContextToType className typeVariablesMapped tps
                                                  in tpWContext))).snd) $ M.lookup _qualName (classMemberEnvironment _lhsIimportEnvironment)
   {-# INLINE rule622 #-}
   rule622 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) _qualName ->
                                            selectClass _lhsIimportEnvironment _qualName
   {-# INLINE rule623 #-}
   rule623 = \ _constraints ((_lhsIbindingGroups) :: BindingGroups) ((_whereIassumptions) :: Assumptions) ->
                                            (noAssumptions,  _whereIassumptions, _constraints    ) : _lhsIbindingGroups
   {-# INLINE rule624 #-}
   rule624 = \ _instanceConstraints _superPredicates ((_whereIconstraints) :: ConstraintSet) ->
                                            (if null _superPredicates then id else id) $ [Node $ [_whereIconstraints] ++ _instanceConstraints]
   {-# INLINE rule625 #-}
   rule625 = \ _instanceBetas _qualName _superClasses ->
                                            map (
                                                  (\s ->
                                                      let
                                                          Predicate _ tvar = prd
                                                          prd = superClassToPredicate _instanceBetas s
                                                          tv = (getNameName . fst . fromJust $ find (\ib -> tvar == snd ib) _instanceBetas)
                                                      in superClassToPredicateWithSource
                                                          prd
                                                          (getNameName _qualName)
                                                          tv
                                                  )
                                              ) _superClasses
   {-# INLINE rule626 #-}
   rule626 = \ _cinfo _instBeta _instanceBetas _instanceTpScheme _instsType _superClasses ->
                                            [
                                                  (   [TC2 $ Assume prd _cinfo | prd <- map (superClassToPredicate _instanceBetas) _superClasses] ++
                                                      [(!::!)
                                                          _instBeta
                                                          _instanceTpScheme
                                                          []
                                                          _cinfo ,
                                                      ((_instBeta     .==. _instsType    ) _cinfo    )
                                                  ]) .>. Node []
                                              ]
   {-# INLINE rule627 #-}
   rule627 = \ ((_lhsIbetaUnique) :: Int) ->
                                            TVar      _lhsIbetaUnique
   {-# INLINE rule628 #-}
   rule628 = \ ((_typesIself) :: Types) ->
                                            namesInType (chead $ _typesIself)
   {-# INLINE rule629 #-}
   rule629 = \ ((_lhsIbetaUnique) :: Int) _typeVariabeles ->
                                            (zip _typeVariabeles [TVar n | n <- [_lhsIbetaUnique + 2..]])
   {-# INLINE rule630 #-}
   rule630 = \ _instanceBetas ((_lhsIimportEnvironment) :: ImportEnvironment) ((_typesIself) :: Types) ->
                                            convertTpToQualified _lhsIimportEnvironment $ makeTpFromType _instanceBetas (chead $ _typesIself)
   {-# INLINE rule631 #-}
   rule631 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) _superClasses ((_typesIself) :: Types) ->
                                            convertTpSchemeToQualified _lhsIimportEnvironment $ addPredicatesToTpScheme (_superClasses) $ makeTpSchemeFromType (chead _typesIself)
   {-# INLINE rule632 #-}
   rule632 = \ _contextQual ->
                                            getSuperClasses _contextQual
   {-# INLINE rule633 #-}
   rule633 = \ ((_lhsIbetaUnique) :: Int) _typeVariabeles ->
                                            [TVar v | v <- [(_lhsIbetaUnique + 2 + length _typeVariabeles)..]]
   {-# INLINE rule634 #-}
   rule634 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) _qualName ((_whereIboundBetas) :: [(Name, Tp, [Tp])]) ->
                                            matchClassDefinitionToInstanceDefinition
                                                  (maybe (error "Unknown class") (map (\(n, tp, _, _) -> (n, tp)).snd) $ M.lookup _qualName $ classMemberEnvironment _lhsIimportEnvironment) $
                                                  map (\(n, b, _) -> (n, b)) _whereIboundBetas
   {-# INLINE rule635 #-}
   rule635 = \ _instanceTpScheme _parentTree ((_rangeIself) :: Range) ->
                                            resultConstraint "instance definition" _parentTree [SkolemizedTypeScheme ([], _instanceTpScheme), TypeSignatureLocation _rangeIself]
   {-# INLINE rule636 #-}
   rule636 = \ ((_whereIboundBetas) :: [(Name, Tp, [Tp])]) ->
     _whereIboundBetas
   {-# INLINE rule637 #-}
   rule637 = \  (_ :: ()) ->
     []
   {-# INLINE rule638 #-}
   rule638 = \  (_ :: ()) ->
     []
   {-# INLINE rule639 #-}
   rule639 = \  (_ :: ()) ->
     []
   {-# INLINE rule640 #-}
   rule640 = \ ((_whereItypeMemberBindings) :: [(Name, TpScheme)]) ->
     _whereItypeMemberBindings
   {-# INLINE rule641 #-}
   rule641 = \ ((_whereIunboundNames) :: Names) ->
     _whereIunboundNames
   {-# INLINE rule642 #-}
   rule642 = \ ((_contextIself) :: ContextItems) ((_nameIself) :: Name) ((_rangeIself) :: Range) ((_typesIself) :: Types) ((_whereIself) :: MaybeDeclarations) ->
     Declaration_Instance _rangeIself _contextIself _nameIself _typesIself _whereIself
   {-# INLINE rule643 #-}
   rule643 = \ _self ->
     _self
   {-# INLINE rule644 #-}
   rule644 = \ ((_whereIbetaUnique) :: Int) ->
     _whereIbetaUnique
   {-# INLINE rule645 #-}
   rule645 = \ ((_whereIcollectWarnings) :: Warnings) ->
     _whereIcollectWarnings
   {-# INLINE rule646 #-}
   rule646 = \ ((_whereIcounter) :: Int) ->
     _whereIcounter
   {-# INLINE rule647 #-}
   rule647 = \ ((_whereIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _whereIdictionaryEnvironment
   {-# INLINE rule648 #-}
   rule648 = \ ((_whereImatchIO) :: IO ()) ->
     _whereImatchIO
   {-# INLINE rule649 #-}
   rule649 = \ ((_whereIpatternMatchWarnings) :: [Warning]) ->
     _whereIpatternMatchWarnings
   {-# INLINE rule650 #-}
   rule650 = \ ((_lhsItypeSignatures) :: TypeEnvironment) ->
     _lhsItypeSignatures
   {-# INLINE rule651 #-}
   rule651 = \ ((_whereIuniqueChunk) :: Int) ->
     _whereIuniqueChunk
   {-# INLINE rule652 #-}
   rule652 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule653 #-}
   rule653 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule654 #-}
   rule654 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule655 #-}
   rule655 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule656 #-}
   rule656 = \ ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ->
     _lhsIallPatterns
   {-# INLINE rule657 #-}
   rule657 = \ ((_lhsIallTypeSchemes) :: M.Map NameWithRange TpScheme) ->
     _lhsIallTypeSchemes
   {-# INLINE rule658 #-}
   rule658 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule659 #-}
   rule659 = \ ((_lhsIclassEnvironment) :: ClassEnvironment) ->
     _lhsIclassEnvironment
   {-# INLINE rule660 #-}
   rule660 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule661 #-}
   rule661 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule662 #-}
   rule662 = \ ((_lhsIclassPredicate) :: Maybe (Name, Names)) ->
     _lhsIclassPredicate
   {-# INLINE rule663 #-}
   rule663 = \ ((_lhsIclassTypeSchemes) :: M.Map Name TpScheme) ->
     _lhsIclassTypeSchemes
   {-# INLINE rule664 #-}
   rule664 = \ ((_lhsIcollectErrors) :: TypeErrors) ->
     _lhsIcollectErrors
   {-# INLINE rule665 #-}
   rule665 = \ ((_lhsIcollectWarnings) :: Warnings) ->
     _lhsIcollectWarnings
   {-# INLINE rule666 #-}
   rule666 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule667 #-}
   rule667 = \ ((_lhsIcurClassPred) :: Maybe Predicate) ->
     _lhsIcurClassPred
   {-# INLINE rule668 #-}
   rule668 = \ ((_lhsIcurPred) :: Maybe Predicate) ->
     _lhsIcurPred
   {-# INLINE rule669 #-}
   rule669 = \ ((_lhsIcurrentChunk) :: Int) ->
     _lhsIcurrentChunk
   {-# INLINE rule670 #-}
   rule670 = \ ((_lhsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _lhsIdictionaryEnvironment
   {-# INLINE rule671 #-}
   rule671 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule672 #-}
   rule672 = \ ((_lhsImatchIO) :: IO ()) ->
     _lhsImatchIO
   {-# INLINE rule673 #-}
   rule673 = \ ((_lhsImoduleName) :: Maybe Name) ->
     _lhsImoduleName
   {-# INLINE rule674 #-}
   rule674 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule675 #-}
   rule675 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule676 #-}
   rule676 = \ ((_lhsIorderedTypeSynonyms) :: OrderedTypeSynonyms) ->
     _lhsIorderedTypeSynonyms
   {-# INLINE rule677 #-}
   rule677 = \ _parentTree ->
     _parentTree
   {-# INLINE rule678 #-}
   rule678 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule679 #-}
   rule679 = \ ((_lhsIrequiredPredicates) :: Predicates) ->
     _lhsIrequiredPredicates
   {-# INLINE rule680 #-}
   rule680 = \ ((_lhsIsubstitution) :: FixpointSubstitution) ->
     _lhsIsubstitution
   {-# INLINE rule681 #-}
   rule681 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
   {-# INLINE rule682 #-}
   rule682 = \ ((_lhsItypeschemeMap) :: M.Map Int (Scheme Predicates)) ->
     _lhsItypeschemeMap
   {-# INLINE rule683 #-}
   rule683 = \ ((_lhsIuniqueChunk) :: Int) ->
     _lhsIuniqueChunk
{-# NOINLINE sem_Declaration_Default #-}
sem_Declaration_Default :: T_Range  -> T_Types  -> T_Declaration 
sem_Declaration_Default arg_range_ arg_types_ = T_Declaration (return st29) where
   {-# NOINLINE st29 #-}
   !st29 = let
      v28 :: T_Declaration_v28 
      v28 = \ !(T_Declaration_vIn28 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaUnique _lhsIbindingGroups _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinheritedBDG _lhsIinstanceName _lhsIinstanceTypes _lhsIisTopLevel _lhsImatchIO _lhsImoduleName _lhsImoduleQual _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeConstructors _lhsItypeSignatures _lhsItypeschemeMap _lhsIuniqueChunk _lhsIvariableMapping) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _typesX167 = Control.Monad.Identity.runIdentity (attach_T_Types (arg_types_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_Types_vOut166 _typesIself) = inv_Types_s167 _typesX167 (T_Types_vIn166 _typesOclassMemberEnv _typesOclassNamesEnv)
         _infoTrees = rule684  ()
         _lhsOboundBetas :: [(Name, Tp, [Tp])]
         _lhsOboundBetas = rule685  ()
         _lhsOclassMemberNames :: Names
         _lhsOclassMemberNames = rule686  ()
         _lhsOcollectInstances :: [(Name, Instance)]
         _lhsOcollectInstances = rule687  ()
         _lhsOdeclVarNames :: Names
         _lhsOdeclVarNames = rule688  ()
         _lhsOrestrictedNames :: Names
         _lhsOrestrictedNames = rule689  ()
         _lhsOsimplePatNames :: Names
         _lhsOsimplePatNames = rule690  ()
         _lhsOtypeMemberBindings :: [(Name, TpScheme)]
         _lhsOtypeMemberBindings = rule691  ()
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule692  ()
         _self = rule693 _rangeIself _typesIself
         _lhsOself :: Declaration
         _lhsOself = rule694 _self
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule695 _lhsIbetaUnique
         _lhsObindingGroups :: BindingGroups
         _lhsObindingGroups = rule696 _lhsIbindingGroups
         _lhsOcollectErrors :: TypeErrors
         _lhsOcollectErrors = rule697 _lhsIcollectErrors
         _lhsOcollectWarnings :: Warnings
         _lhsOcollectWarnings = rule698 _lhsIcollectWarnings
         _lhsOcounter :: Int
         _lhsOcounter = rule699 _lhsIcounter
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule700 _lhsIdictionaryEnvironment
         _lhsOinfoTrees :: InfoTrees
         _lhsOinfoTrees = rule701 _infoTrees
         _lhsOmatchIO :: IO ()
         _lhsOmatchIO = rule702 _lhsImatchIO
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule703 _lhsIpatternMatchWarnings
         _lhsOtypeSignatures :: TypeEnvironment
         _lhsOtypeSignatures = rule704 _lhsItypeSignatures
         _lhsOuniqueChunk :: Int
         _lhsOuniqueChunk = rule705 _lhsIuniqueChunk
         _typesOclassMemberEnv = rule706 _lhsIclassMemberEnv
         _typesOclassNamesEnv = rule707 _lhsIclassNamesEnv
         !__result_ = T_Declaration_vOut28 _lhsObetaUnique _lhsObindingGroups _lhsOboundBetas _lhsOclassMemberNames _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOcounter _lhsOdeclVarNames _lhsOdictionaryEnvironment _lhsOinfoTrees _lhsOmatchIO _lhsOpatternMatchWarnings _lhsOrestrictedNames _lhsOself _lhsOsimplePatNames _lhsOtypeMemberBindings _lhsOtypeSignatures _lhsOunboundNames _lhsOuniqueChunk
         in __result_ )
     in C_Declaration_s29 v28
   {-# INLINE rule684 #-}
   rule684 = \  (_ :: ()) ->
                                                                            globalInfoError
   {-# INLINE rule685 #-}
   rule685 = \  (_ :: ()) ->
     []
   {-# INLINE rule686 #-}
   rule686 = \  (_ :: ()) ->
     []
   {-# INLINE rule687 #-}
   rule687 = \  (_ :: ()) ->
     []
   {-# INLINE rule688 #-}
   rule688 = \  (_ :: ()) ->
     []
   {-# INLINE rule689 #-}
   rule689 = \  (_ :: ()) ->
     []
   {-# INLINE rule690 #-}
   rule690 = \  (_ :: ()) ->
     []
   {-# INLINE rule691 #-}
   rule691 = \  (_ :: ()) ->
     []
   {-# INLINE rule692 #-}
   rule692 = \  (_ :: ()) ->
     []
   {-# INLINE rule693 #-}
   rule693 = \ ((_rangeIself) :: Range) ((_typesIself) :: Types) ->
     Declaration_Default _rangeIself _typesIself
   {-# INLINE rule694 #-}
   rule694 = \ _self ->
     _self
   {-# INLINE rule695 #-}
   rule695 = \ ((_lhsIbetaUnique) :: Int) ->
     _lhsIbetaUnique
   {-# INLINE rule696 #-}
   rule696 = \ ((_lhsIbindingGroups) :: BindingGroups) ->
     _lhsIbindingGroups
   {-# INLINE rule697 #-}
   rule697 = \ ((_lhsIcollectErrors) :: TypeErrors) ->
     _lhsIcollectErrors
   {-# INLINE rule698 #-}
   rule698 = \ ((_lhsIcollectWarnings) :: Warnings) ->
     _lhsIcollectWarnings
   {-# INLINE rule699 #-}
   rule699 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule700 #-}
   rule700 = \ ((_lhsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _lhsIdictionaryEnvironment
   {-# INLINE rule701 #-}
   rule701 = \ _infoTrees ->
     _infoTrees
   {-# INLINE rule702 #-}
   rule702 = \ ((_lhsImatchIO) :: IO ()) ->
     _lhsImatchIO
   {-# INLINE rule703 #-}
   rule703 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule704 #-}
   rule704 = \ ((_lhsItypeSignatures) :: TypeEnvironment) ->
     _lhsItypeSignatures
   {-# INLINE rule705 #-}
   rule705 = \ ((_lhsIuniqueChunk) :: Int) ->
     _lhsIuniqueChunk
   {-# INLINE rule706 #-}
   rule706 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule707 #-}
   rule707 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
{-# NOINLINE sem_Declaration_FunctionBindings #-}
sem_Declaration_FunctionBindings :: T_Range  -> T_FunctionBindings  -> T_Declaration 
sem_Declaration_FunctionBindings arg_range_ arg_bindings_ = T_Declaration (return st29) where
   {-# NOINLINE st29 #-}
   !st29 = let
      v28 :: T_Declaration_v28 
      v28 = \ !(T_Declaration_vIn28 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaUnique _lhsIbindingGroups _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinheritedBDG _lhsIinstanceName _lhsIinstanceTypes _lhsIisTopLevel _lhsImatchIO _lhsImoduleName _lhsImoduleQual _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeConstructors _lhsItypeSignatures _lhsItypeschemeMap _lhsIuniqueChunk _lhsIvariableMapping) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _bindingsX59 = Control.Monad.Identity.runIdentity (attach_T_FunctionBindings (arg_bindings_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_FunctionBindings_vOut58 _bindingsIargcount _bindingsIassumptions _bindingsIbetaUnique _bindingsIcollectErrors _bindingsIcollectInstances _bindingsIcollectWarnings _bindingsIconstraintslist _bindingsIcounter _bindingsIdictionaryEnvironment _bindingsIelementss _bindingsIinfoTrees _bindingsImatchIO _bindingsIname _bindingsInumberOfPatterns _bindingsIpatternMatchWarnings _bindingsIself _bindingsIunboundNames _bindingsIuniqueChunk _bindingsIunrwars) = inv_FunctionBindings_s59 _bindingsX59 (T_FunctionBindings_vIn58 _bindingsOallPatterns _bindingsOallTypeSchemes _bindingsOambiguousConflicts _bindingsOavailablePredicates _bindingsObetaRight _bindingsObetaUnique _bindingsObetasLeft _bindingsOclassEnvironment _bindingsOclassMemberEnv _bindingsOclassMemberTypeSchemes _bindingsOclassNamesEnv _bindingsOclassPredicate _bindingsOclassTypeSchemes _bindingsOcollectErrors _bindingsOcollectWarnings _bindingsOcounter _bindingsOcurClassPred _bindingsOcurPred _bindingsOcurrentChunk _bindingsOdictionaryEnvironment _bindingsOimportEnvironment _bindingsOinstanceName _bindingsOinstanceTypes _bindingsOmatchIO _bindingsOmoduleName _bindingsOmonos _bindingsOnamesInScope _bindingsOorderedTypeSynonyms _bindingsOparentTree _bindingsOpatternMatchWarnings _bindingsOrequiredPredicates _bindingsOsubstitution _bindingsOtypeConstructors _bindingsOtypeschemeMap _bindingsOuniqueChunk _bindingsOvariableMapping)
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule708 _beta _bindingsIargcount _bindingsIelementss _bindingsIname _bindingsIpatternMatchWarnings _bindingsIunrwars _lhsIimportEnvironment _lhsIsubstitution _rangeIself
         _lhsOdeclVarNames :: Names
         _lhsOdeclVarNames = rule709 _bindingsIname
         _parentTree = rule710 _bindingsIinfoTrees _lhsIparentTree _localInfo
         _lhsOinfoTrees :: InfoTrees
         _lhsOinfoTrees = rule711 _parentTree
         _localInfo = rule712 _lhsImonos _self
         _cinfo = rule713 _bindingsIname _bindingsInumberOfPatterns _lhsIinstanceName _lhsIinstanceTypes _parentTree
         _bindingsOcurrentChunk = rule714 _bindingsIname _lhsIinheritedBDG
         _declPredicates = rule715 _beta _lhsIorderedTypeSynonyms _lhsIsubstitution _scheme
         _scheme = rule716 _bindingsIname _lhsIallTypeSchemes _lhsIclassMemberTypeSchemes _lhsIinstanceName
         _originalFunctionType = rule717 _bindingsIname _lhsIimportEnvironment _lhsIinstanceName
         _bindingsOcurPred = rule718 _beta _declPredicates _lhsIclassPredicate _lhsIsubstitution _originalFunctionType
         _bindingsOavailablePredicates = rule719 _declPredicates _lhsIavailablePredicates
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule720 _bindingsIdictionaryEnvironment _bindingsIname _declPredicates _lhsIinstanceName
         _lhsObindingGroups :: BindingGroups
         _lhsObindingGroups = rule721 _lhsIbindingGroups _mybdggrp
         _lhsOboundBetas :: [(Name, Tp, [Tp])]
         _lhsOboundBetas = rule722 _beta _betaRight _betasLeft _bindingsIname
         _bindingsObetaUnique = rule723 _bindingsInumberOfPatterns _lhsIbetaUnique
         _bindingsOmonos = rule724 _bindingsIname _lhsIinheritedBDG _lhsImonos
         _beta = rule725 _lhsIbetaUnique
         _betaRight = rule726 _lhsIbetaUnique
         _betasLeft = rule727 _bindingsInumberOfPatterns _lhsIbetaUnique
         _newcon = rule728 _beta _betaRight _betasLeft _cinfo
         _functionType = rule729 _bindingsIname _lhsIinstanceTypes
         _mybdggrp = rule730 _beta _bindingsIassumptions _bindingsIconstraintslist _bindingsIname _cinfo _lhsIbetaUnique _lhsIinstanceName _lhsIinstanceTypes _lhsIisTopLevel _lhsImoduleQual _lhsIvariableMapping _newcon
         _lhsOclassMemberNames :: Names
         _lhsOclassMemberNames = rule731  ()
         _lhsOcollectInstances :: [(Name, Instance)]
         _lhsOcollectInstances = rule732 _bindingsIcollectInstances
         _lhsOrestrictedNames :: Names
         _lhsOrestrictedNames = rule733  ()
         _lhsOsimplePatNames :: Names
         _lhsOsimplePatNames = rule734  ()
         _lhsOtypeMemberBindings :: [(Name, TpScheme)]
         _lhsOtypeMemberBindings = rule735  ()
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule736 _bindingsIunboundNames
         _self = rule737 _bindingsIself _rangeIself
         _lhsOself :: Declaration
         _lhsOself = rule738 _self
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule739 _bindingsIbetaUnique
         _lhsOcollectErrors :: TypeErrors
         _lhsOcollectErrors = rule740 _bindingsIcollectErrors
         _lhsOcollectWarnings :: Warnings
         _lhsOcollectWarnings = rule741 _bindingsIcollectWarnings
         _lhsOcounter :: Int
         _lhsOcounter = rule742 _bindingsIcounter
         _lhsOmatchIO :: IO ()
         _lhsOmatchIO = rule743 _bindingsImatchIO
         _lhsOtypeSignatures :: TypeEnvironment
         _lhsOtypeSignatures = rule744 _lhsItypeSignatures
         _lhsOuniqueChunk :: Int
         _lhsOuniqueChunk = rule745 _bindingsIuniqueChunk
         _bindingsOallPatterns = rule746 _lhsIallPatterns
         _bindingsOallTypeSchemes = rule747 _lhsIallTypeSchemes
         _bindingsOambiguousConflicts = rule748 _lhsIambiguousConflicts
         _bindingsObetaRight = rule749 _betaRight
         _bindingsObetasLeft = rule750 _betasLeft
         _bindingsOclassEnvironment = rule751 _lhsIclassEnvironment
         _bindingsOclassMemberEnv = rule752 _lhsIclassMemberEnv
         _bindingsOclassMemberTypeSchemes = rule753 _lhsIclassMemberTypeSchemes
         _bindingsOclassNamesEnv = rule754 _lhsIclassNamesEnv
         _bindingsOclassPredicate = rule755 _lhsIclassPredicate
         _bindingsOclassTypeSchemes = rule756 _lhsIclassTypeSchemes
         _bindingsOcollectErrors = rule757 _lhsIcollectErrors
         _bindingsOcollectWarnings = rule758 _lhsIcollectWarnings
         _bindingsOcounter = rule759 _lhsIcounter
         _bindingsOcurClassPred = rule760 _lhsIcurClassPred
         _bindingsOdictionaryEnvironment = rule761 _lhsIdictionaryEnvironment
         _bindingsOimportEnvironment = rule762 _lhsIimportEnvironment
         _bindingsOinstanceName = rule763 _lhsIinstanceName
         _bindingsOinstanceTypes = rule764 _lhsIinstanceTypes
         _bindingsOmatchIO = rule765 _lhsImatchIO
         _bindingsOmoduleName = rule766 _lhsImoduleName
         _bindingsOnamesInScope = rule767 _lhsInamesInScope
         _bindingsOorderedTypeSynonyms = rule768 _lhsIorderedTypeSynonyms
         _bindingsOparentTree = rule769 _parentTree
         _bindingsOpatternMatchWarnings = rule770 _lhsIpatternMatchWarnings
         _bindingsOrequiredPredicates = rule771 _lhsIrequiredPredicates
         _bindingsOsubstitution = rule772 _lhsIsubstitution
         _bindingsOtypeConstructors = rule773 _lhsItypeConstructors
         _bindingsOtypeschemeMap = rule774 _lhsItypeschemeMap
         _bindingsOuniqueChunk = rule775 _lhsIuniqueChunk
         _bindingsOvariableMapping = rule776 _lhsIvariableMapping
         !__result_ = T_Declaration_vOut28 _lhsObetaUnique _lhsObindingGroups _lhsOboundBetas _lhsOclassMemberNames _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOcounter _lhsOdeclVarNames _lhsOdictionaryEnvironment _lhsOinfoTrees _lhsOmatchIO _lhsOpatternMatchWarnings _lhsOrestrictedNames _lhsOself _lhsOsimplePatNames _lhsOtypeMemberBindings _lhsOtypeSignatures _lhsOunboundNames _lhsOuniqueChunk
         in __result_ )
     in C_Declaration_s29 v28
   {-# INLINE rule708 #-}
   rule708 = \ _beta ((_bindingsIargcount) :: Int) ((_bindingsIelementss) :: [([PatternElement], Bool)]) ((_bindingsIname) :: Name) ((_bindingsIpatternMatchWarnings) :: [Warning]) ((_bindingsIunrwars) :: [Warning]) ((_lhsIimportEnvironment) :: ImportEnvironment) ((_lhsIsubstitution) :: FixpointSubstitution) ((_rangeIself) :: Range) ->
                                                    ( if _bindingsIargcount == 0 then
                                                        []
                                                      else
                                                        patternMatchWarnings _lhsIimportEnvironment
                                                                         _lhsIsubstitution
                                                                         _beta
                                                                         (take _bindingsIargcount . fst . functionSpine)
                                                                         _bindingsIelementss
                                                                         _rangeIself
                                                                         (Just _bindingsIname)
                                                                         True
                                                                         _bindingsIunrwars
                                                                         "function bindings"
                                                                         "="
                                                    ) ++ _bindingsIpatternMatchWarnings
   {-# INLINE rule709 #-}
   rule709 = \ ((_bindingsIname) :: Name) ->
                                             [_bindingsIname]
   {-# INLINE rule710 #-}
   rule710 = \ ((_bindingsIinfoTrees) :: InfoTrees) ((_lhsIparentTree) :: InfoTree) _localInfo ->
                                             node _lhsIparentTree _localInfo _bindingsIinfoTrees
   {-# INLINE rule711 #-}
   rule711 = \ _parentTree ->
                                             [_parentTree]
   {-# INLINE rule712 #-}
   rule712 = \ ((_lhsImonos) :: Monos) _self ->
                            LocalInfo { self = UHA_Decl _self
                                      , assignedType = Nothing
                                      , monos = _lhsImonos
                                      }
   {-# INLINE rule713 #-}
   rule713 = \ ((_bindingsIname) :: Name) ((_bindingsInumberOfPatterns) :: Int) ((_lhsIinstanceName) :: Maybe Name) ((_lhsIinstanceTypes) :: [(Name, TpScheme)]) _parentTree ->
     resultConstraint "function bindings (INTERNAL ERROR)" _parentTree $
        [ FolkloreConstraint, highlyTrusted, FuntionBindingEdge _bindingsInumberOfPatterns ] ++
       if isJust _lhsIinstanceName then
         let
           functionType = lookup _bindingsIname _lhsIinstanceTypes
         in maybe [] (\ft -> [SkolemizedTypeScheme ([], ft), TypeSignatureLocation noRange]) functionType
       else []
   {-# INLINE rule714 #-}
   rule714 = \ ((_bindingsIname) :: Name) ((_lhsIinheritedBDG) :: InheritedBDG) ->
                                                        findCurrentChunk _bindingsIname _lhsIinheritedBDG
   {-# INLINE rule715 #-}
   rule715 = \ _beta ((_lhsIorderedTypeSynonyms) :: OrderedTypeSynonyms) ((_lhsIsubstitution) :: FixpointSubstitution) _scheme ->
                                            let
                                                !predicates = matchTypeWithScheme _lhsIorderedTypeSynonyms
                                                                (_lhsIsubstitution |-> _beta)
                                                                (_lhsIsubstitution |-> _scheme)
                                            in expandPredicates _lhsIorderedTypeSynonyms predicates
   {-# INLINE rule716 #-}
   rule716 = \ ((_bindingsIname) :: Name) ((_lhsIallTypeSchemes) :: M.Map NameWithRange TpScheme) ((_lhsIclassMemberTypeSchemes) :: Maybe [(Name, TpScheme)]) ((_lhsIinstanceName) :: Maybe Name) ->
                                              let
                                                  classFunctions :: Maybe Name -> [(Name, TpScheme)]
                                                  classFunctions Nothing = []
                                                  classFunctions (Just _) = fromJust _lhsIclassMemberTypeSchemes
                                                  searchClasses :: Name -> TpScheme
                                                  searchClasses name = maybe (err name) snd $ find (\(n, _)->n == name) (classFunctions _lhsIinstanceName)
                                                  err name = internalError "TypeInferenceOverloading.ag" "n/a"
                                                      ("could not find type for function binding for " ++ show name ++ " in " ++ "")
                                              in  M.findWithDefault (searchClasses _bindingsIname) (NameWithRange _bindingsIname) (_lhsIallTypeSchemes)
   {-# INLINE rule717 #-}
   rule717 = \ ((_bindingsIname) :: Name) ((_lhsIimportEnvironment) :: ImportEnvironment) ((_lhsIinstanceName) :: Maybe Name) ->
                                               fmap
                                                      (\cname -> (\(_, tp, _, _) -> tp) $ fromJust $ find (\(n, _, _, _)-> n == _bindingsIname) $ snd $ fromJust $ M.lookup cname (classMemberEnvironment _lhsIimportEnvironment))
                                                  _lhsIinstanceName
   {-# INLINE rule718 #-}
   rule718 = \ _beta _declPredicates ((_lhsIclassPredicate) :: Maybe (Name, Names)) ((_lhsIsubstitution) :: FixpointSubstitution) _originalFunctionType ->
                                                  getCurrentClassPredicate
                                                      _lhsIclassPredicate
                                                      (_lhsIsubstitution |-> _beta)
                                                      (_lhsIsubstitution |-> _originalFunctionType)
                                                      (_lhsIsubstitution |-> _declPredicates)
   {-# INLINE rule719 #-}
   rule719 = \ _declPredicates ((_lhsIavailablePredicates) :: [PredicateWithSource]) ->
                                             map PredicateFunction _declPredicates ++ _lhsIavailablePredicates
   {-# INLINE rule720 #-}
   rule720 = \ ((_bindingsIdictionaryEnvironment) :: DictionaryEnvironment) ((_bindingsIname) :: Name) _declPredicates ((_lhsIinstanceName) :: Maybe Name) ->
                                              if (not $ isJust _lhsIinstanceName) then
                                                  addForDeclaration _bindingsIname _declPredicates _bindingsIdictionaryEnvironment
                                              else
                                                  _bindingsIdictionaryEnvironment
   {-# INLINE rule721 #-}
   rule721 = \ ((_lhsIbindingGroups) :: BindingGroups) _mybdggrp ->
                                   _mybdggrp : _lhsIbindingGroups
   {-# INLINE rule722 #-}
   rule722 = \ _beta _betaRight _betasLeft ((_bindingsIname) :: Name) ->
                                   [(_bindingsIname, _beta, _betasLeft ++ [_betaRight])]
   {-# INLINE rule723 #-}
   rule723 = \ ((_bindingsInumberOfPatterns) :: Int) ((_lhsIbetaUnique) :: Int) ->
                                   _lhsIbetaUnique + 2 + _bindingsInumberOfPatterns
   {-# INLINE rule724 #-}
   rule724 = \ ((_bindingsIname) :: Name) ((_lhsIinheritedBDG) :: InheritedBDG) ((_lhsImonos) :: Monos) ->
                                   findMono _bindingsIname _lhsIinheritedBDG ++ _lhsImonos
   {-# INLINE rule725 #-}
   rule725 = \ ((_lhsIbetaUnique) :: Int) ->
                                   TVar _lhsIbetaUnique
   {-# INLINE rule726 #-}
   rule726 = \ ((_lhsIbetaUnique) :: Int) ->
                                   TVar (_lhsIbetaUnique + 1)
   {-# INLINE rule727 #-}
   rule727 = \ ((_bindingsInumberOfPatterns) :: Int) ((_lhsIbetaUnique) :: Int) ->
                                   take _bindingsInumberOfPatterns (map TVar [_lhsIbetaUnique + 2..])
   {-# INLINE rule728 #-}
   rule728 = \ _beta _betaRight _betasLeft _cinfo ->
                                   (_beta .==. foldr (.->.) _betaRight _betasLeft) _cinfo
   {-# INLINE rule729 #-}
   rule729 = \ ((_bindingsIname) :: Name) ((_lhsIinstanceTypes) :: [(Name, TpScheme)]) ->
                                   lookup _bindingsIname _lhsIinstanceTypes
   {-# INLINE rule730 #-}
   rule730 = \ _beta ((_bindingsIassumptions) :: Assumptions) ((_bindingsIconstraintslist) :: ConstraintSets) ((_bindingsIname) :: Name) _cinfo ((_lhsIbetaUnique) :: Int) ((_lhsIinstanceName) :: Maybe Name) ((_lhsIinstanceTypes) :: [(Name, TpScheme)]) ((_lhsIisTopLevel) :: Bool) ((_lhsImoduleQual) ::  [String] ) ((_lhsIvariableMapping) :: Maybe [(Name, Tp)]) _newcon ->
                                   let
                                      assumptions = filterAssumptions _bindingsIassumptions
                                      filterAssumptions = M.filterWithKey (\k _ -> not $ k `elem` map fst _lhsIinstanceTypes )
                                    in ( if _lhsIisTopLevel then
                                      M.fromList [(_bindingsIname, _beta), (addQualified _lhsImoduleQual _bindingsIname, _beta)]
                                      else M.fromList [(_bindingsIname, _beta)]
                                   , assumptions
                                   , [ Node [ Phase (-1) [_newcon]
                                            , Receive _lhsIbetaUnique
                                            , Node _bindingsIconstraintslist
                                            , if isJust _lhsIinstanceName then
                                                  let
                                                      functionType = lookup _bindingsIname _lhsIinstanceTypes
                                                  in maybe emptyTree (\ft -> listTree [
                                                          (_beta !::!  replaceName (head $ fromJust _lhsIvariableMapping) ft) [] _cinfo
                                                      ]) functionType
                                              else
                                                  emptyTree
                                          ]
                                     ]
                                   )
   {-# INLINE rule731 #-}
   rule731 = \  (_ :: ()) ->
     []
   {-# INLINE rule732 #-}
   rule732 = \ ((_bindingsIcollectInstances) :: [(Name, Instance)]) ->
     _bindingsIcollectInstances
   {-# INLINE rule733 #-}
   rule733 = \  (_ :: ()) ->
     []
   {-# INLINE rule734 #-}
   rule734 = \  (_ :: ()) ->
     []
   {-# INLINE rule735 #-}
   rule735 = \  (_ :: ()) ->
     []
   {-# INLINE rule736 #-}
   rule736 = \ ((_bindingsIunboundNames) :: Names) ->
     _bindingsIunboundNames
   {-# INLINE rule737 #-}
   rule737 = \ ((_bindingsIself) :: FunctionBindings) ((_rangeIself) :: Range) ->
     Declaration_FunctionBindings _rangeIself _bindingsIself
   {-# INLINE rule738 #-}
   rule738 = \ _self ->
     _self
   {-# INLINE rule739 #-}
   rule739 = \ ((_bindingsIbetaUnique) :: Int) ->
     _bindingsIbetaUnique
   {-# INLINE rule740 #-}
   rule740 = \ ((_bindingsIcollectErrors) :: TypeErrors) ->
     _bindingsIcollectErrors
   {-# INLINE rule741 #-}
   rule741 = \ ((_bindingsIcollectWarnings) :: Warnings) ->
     _bindingsIcollectWarnings
   {-# INLINE rule742 #-}
   rule742 = \ ((_bindingsIcounter) :: Int) ->
     _bindingsIcounter
   {-# INLINE rule743 #-}
   rule743 = \ ((_bindingsImatchIO) :: IO ()) ->
     _bindingsImatchIO
   {-# INLINE rule744 #-}
   rule744 = \ ((_lhsItypeSignatures) :: TypeEnvironment) ->
     _lhsItypeSignatures
   {-# INLINE rule745 #-}
   rule745 = \ ((_bindingsIuniqueChunk) :: Int) ->
     _bindingsIuniqueChunk
   {-# INLINE rule746 #-}
   rule746 = \ ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ->
     _lhsIallPatterns
   {-# INLINE rule747 #-}
   rule747 = \ ((_lhsIallTypeSchemes) :: M.Map NameWithRange TpScheme) ->
     _lhsIallTypeSchemes
   {-# INLINE rule748 #-}
   rule748 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule749 #-}
   rule749 = \ _betaRight ->
     _betaRight
   {-# INLINE rule750 #-}
   rule750 = \ _betasLeft ->
     _betasLeft
   {-# INLINE rule751 #-}
   rule751 = \ ((_lhsIclassEnvironment) :: ClassEnvironment) ->
     _lhsIclassEnvironment
   {-# INLINE rule752 #-}
   rule752 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule753 #-}
   rule753 = \ ((_lhsIclassMemberTypeSchemes) :: Maybe [(Name, TpScheme)]) ->
     _lhsIclassMemberTypeSchemes
   {-# INLINE rule754 #-}
   rule754 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule755 #-}
   rule755 = \ ((_lhsIclassPredicate) :: Maybe (Name, Names)) ->
     _lhsIclassPredicate
   {-# INLINE rule756 #-}
   rule756 = \ ((_lhsIclassTypeSchemes) :: M.Map Name TpScheme) ->
     _lhsIclassTypeSchemes
   {-# INLINE rule757 #-}
   rule757 = \ ((_lhsIcollectErrors) :: TypeErrors) ->
     _lhsIcollectErrors
   {-# INLINE rule758 #-}
   rule758 = \ ((_lhsIcollectWarnings) :: Warnings) ->
     _lhsIcollectWarnings
   {-# INLINE rule759 #-}
   rule759 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule760 #-}
   rule760 = \ ((_lhsIcurClassPred) :: Maybe Predicate) ->
     _lhsIcurClassPred
   {-# INLINE rule761 #-}
   rule761 = \ ((_lhsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _lhsIdictionaryEnvironment
   {-# INLINE rule762 #-}
   rule762 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule763 #-}
   rule763 = \ ((_lhsIinstanceName) :: Maybe Name) ->
     _lhsIinstanceName
   {-# INLINE rule764 #-}
   rule764 = \ ((_lhsIinstanceTypes) :: [(Name, TpScheme)]) ->
     _lhsIinstanceTypes
   {-# INLINE rule765 #-}
   rule765 = \ ((_lhsImatchIO) :: IO ()) ->
     _lhsImatchIO
   {-# INLINE rule766 #-}
   rule766 = \ ((_lhsImoduleName) :: Maybe Name) ->
     _lhsImoduleName
   {-# INLINE rule767 #-}
   rule767 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule768 #-}
   rule768 = \ ((_lhsIorderedTypeSynonyms) :: OrderedTypeSynonyms) ->
     _lhsIorderedTypeSynonyms
   {-# INLINE rule769 #-}
   rule769 = \ _parentTree ->
     _parentTree
   {-# INLINE rule770 #-}
   rule770 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule771 #-}
   rule771 = \ ((_lhsIrequiredPredicates) :: Predicates) ->
     _lhsIrequiredPredicates
   {-# INLINE rule772 #-}
   rule772 = \ ((_lhsIsubstitution) :: FixpointSubstitution) ->
     _lhsIsubstitution
   {-# INLINE rule773 #-}
   rule773 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
   {-# INLINE rule774 #-}
   rule774 = \ ((_lhsItypeschemeMap) :: M.Map Int (Scheme Predicates)) ->
     _lhsItypeschemeMap
   {-# INLINE rule775 #-}
   rule775 = \ ((_lhsIuniqueChunk) :: Int) ->
     _lhsIuniqueChunk
   {-# INLINE rule776 #-}
   rule776 = \ ((_lhsIvariableMapping) :: Maybe [(Name, Tp)]) ->
     _lhsIvariableMapping
{-# NOINLINE sem_Declaration_PatternBinding #-}
sem_Declaration_PatternBinding :: T_Range  -> T_Pattern  -> T_RightHandSide  -> T_Declaration 
sem_Declaration_PatternBinding arg_range_ arg_pattern_ arg_righthandside_ = T_Declaration (return st29) where
   {-# NOINLINE st29 #-}
   !st29 = let
      v28 :: T_Declaration_v28 
      v28 = \ !(T_Declaration_vIn28 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaUnique _lhsIbindingGroups _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinheritedBDG _lhsIinstanceName _lhsIinstanceTypes _lhsIisTopLevel _lhsImatchIO _lhsImoduleName _lhsImoduleQual _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeConstructors _lhsItypeSignatures _lhsItypeschemeMap _lhsIuniqueChunk _lhsIvariableMapping) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _patternX119 = Control.Monad.Identity.runIdentity (attach_T_Pattern (arg_pattern_))
         _righthandsideX149 = Control.Monad.Identity.runIdentity (attach_T_RightHandSide (arg_righthandside_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_Pattern_vOut118 _patternIbeta _patternIbetaUnique _patternIconstraints _patternIcounter _patternIelements _patternIenvironment _patternIinfoTree _patternIpatVarNames _patternIpatternMatchWarnings _patternIself _patternIunboundNames) = inv_Pattern_s119 _patternX119 (T_Pattern_vIn118 _patternOambiguousConflicts _patternObetaUnique _patternOcounter _patternOimportEnvironment _patternOmonos _patternOnamesInScope _patternOparentTree _patternOpatternMatchWarnings _patternOtypeConstructors)
         (T_RightHandSide_vOut148 _righthandsideIassumptions _righthandsideIbetaUnique _righthandsideIcollectErrors _righthandsideIcollectInstances _righthandsideIcollectWarnings _righthandsideIconstraints _righthandsideIcounter _righthandsideIdictionaryEnvironment _righthandsideIfallthrough _righthandsideIinfoTree _righthandsideImatchIO _righthandsideIpatternMatchWarnings _righthandsideIself _righthandsideIunboundNames _righthandsideIuniqueChunk) = inv_RightHandSide_s149 _righthandsideX149 (T_RightHandSide_vIn148 _righthandsideOallPatterns _righthandsideOallTypeSchemes _righthandsideOambiguousConflicts _righthandsideOavailablePredicates _righthandsideObetaRight _righthandsideObetaUnique _righthandsideOclassEnvironment _righthandsideOclassMemberEnv _righthandsideOclassMemberTypeSchemes _righthandsideOclassNamesEnv _righthandsideOclassPredicate _righthandsideOclassTypeSchemes _righthandsideOcollectErrors _righthandsideOcollectWarnings _righthandsideOcounter _righthandsideOcurClassPred _righthandsideOcurPred _righthandsideOcurrentChunk _righthandsideOdictionaryEnvironment _righthandsideOimportEnvironment _righthandsideOinstanceName _righthandsideOinstanceTypes _righthandsideOmatchIO _righthandsideOmoduleName _righthandsideOmonos _righthandsideOnamesInScope _righthandsideOorderedTypeSynonyms _righthandsideOparentTree _righthandsideOpatternMatchWarnings _righthandsideOrequiredPredicates _righthandsideOsubstitution _righthandsideOtypeConstructors _righthandsideOtypeschemeMap _righthandsideOuniqueChunk _righthandsideOvariableMapping)
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule777 _lhsIimportEnvironment _lhsIsubstitution _patternIbeta _patternIelements _rangeIself _righthandsideIfallthrough _righthandsideIpatternMatchWarnings
         _lhsOdeclVarNames :: Names
         _lhsOdeclVarNames = rule778 _patternIpatVarNames
         _parentTree = rule779 _lhsIparentTree _localInfo _patternIinfoTree _righthandsideIinfoTree
         _lhsOinfoTrees :: InfoTrees
         _lhsOinfoTrees = rule780 _parentTree
         _localInfo = rule781 _lhsImonos _self
         _cinfo = rule782 _parentTree
         _lhsOrestrictedNames :: Names
         _lhsOsimplePatNames :: Names
         (_lhsOrestrictedNames,_lhsOsimplePatNames) = rule783 _patternIpatVarNames _patternIself
         _righthandsideOcurrentChunk = rule784 _lhsIinheritedBDG _patternIenvironment
         _declPredicates = rule785 _betaRight _lhsIallTypeSchemes _lhsIorderedTypeSynonyms _lhsIsubstitution _patternIself
         _righthandsideOavailablePredicates = rule786 _declPredicates _lhsIavailablePredicates
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule787 _declPredicates _righthandsideIdictionaryEnvironment
         _lhsObindingGroups :: BindingGroups
         _lhsObindingGroups = rule788 _lhsIbindingGroups _mybdggrp
         _patternObetaUnique = rule789 _lhsIbetaUnique
         _righthandsideOmonos = rule790 _lhsIinheritedBDG _lhsImonos _patternIenvironment
         _betaRight = rule791 _lhsIbetaUnique
         _newcon = rule792 _betaRight _cinfo _patternIbeta
         _mybdggrp = rule793 _lhsIisTopLevel _lhsImoduleQual _mainConstraint _newcon _patternIconstraints _patternIenvironment _righthandsideIassumptions _righthandsideIconstraints
         _betaMain = rule794 _lhsIbetaUnique
         _mainConstraint = rule795 _betaMain _cinfo _lhsImoduleName _patternIbeta _patternIenvironment
         _lhsOboundBetas :: [(Name, Tp, [Tp])]
         _lhsOboundBetas = rule796  ()
         _lhsOclassMemberNames :: Names
         _lhsOclassMemberNames = rule797  ()
         _lhsOcollectInstances :: [(Name, Instance)]
         _lhsOcollectInstances = rule798 _righthandsideIcollectInstances
         _lhsOtypeMemberBindings :: [(Name, TpScheme)]
         _lhsOtypeMemberBindings = rule799  ()
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule800 _patternIunboundNames _righthandsideIunboundNames
         _self = rule801 _patternIself _rangeIself _righthandsideIself
         _lhsOself :: Declaration
         _lhsOself = rule802 _self
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule803 _righthandsideIbetaUnique
         _lhsOcollectErrors :: TypeErrors
         _lhsOcollectErrors = rule804 _righthandsideIcollectErrors
         _lhsOcollectWarnings :: Warnings
         _lhsOcollectWarnings = rule805 _righthandsideIcollectWarnings
         _lhsOcounter :: Int
         _lhsOcounter = rule806 _righthandsideIcounter
         _lhsOmatchIO :: IO ()
         _lhsOmatchIO = rule807 _righthandsideImatchIO
         _lhsOtypeSignatures :: TypeEnvironment
         _lhsOtypeSignatures = rule808 _lhsItypeSignatures
         _lhsOuniqueChunk :: Int
         _lhsOuniqueChunk = rule809 _righthandsideIuniqueChunk
         _patternOambiguousConflicts = rule810 _lhsIambiguousConflicts
         _patternOcounter = rule811 _lhsIcounter
         _patternOimportEnvironment = rule812 _lhsIimportEnvironment
         _patternOmonos = rule813 _lhsImonos
         _patternOnamesInScope = rule814 _lhsInamesInScope
         _patternOparentTree = rule815 _parentTree
         _patternOpatternMatchWarnings = rule816 _lhsIpatternMatchWarnings
         _patternOtypeConstructors = rule817 _lhsItypeConstructors
         _righthandsideOallPatterns = rule818 _lhsIallPatterns
         _righthandsideOallTypeSchemes = rule819 _lhsIallTypeSchemes
         _righthandsideOambiguousConflicts = rule820 _lhsIambiguousConflicts
         _righthandsideObetaRight = rule821 _betaRight
         _righthandsideObetaUnique = rule822 _patternIbetaUnique
         _righthandsideOclassEnvironment = rule823 _lhsIclassEnvironment
         _righthandsideOclassMemberEnv = rule824 _lhsIclassMemberEnv
         _righthandsideOclassMemberTypeSchemes = rule825 _lhsIclassMemberTypeSchemes
         _righthandsideOclassNamesEnv = rule826 _lhsIclassNamesEnv
         _righthandsideOclassPredicate = rule827 _lhsIclassPredicate
         _righthandsideOclassTypeSchemes = rule828 _lhsIclassTypeSchemes
         _righthandsideOcollectErrors = rule829 _lhsIcollectErrors
         _righthandsideOcollectWarnings = rule830 _lhsIcollectWarnings
         _righthandsideOcounter = rule831 _patternIcounter
         _righthandsideOcurClassPred = rule832 _lhsIcurClassPred
         _righthandsideOcurPred = rule833 _lhsIcurPred
         _righthandsideOdictionaryEnvironment = rule834 _lhsIdictionaryEnvironment
         _righthandsideOimportEnvironment = rule835 _lhsIimportEnvironment
         _righthandsideOinstanceName = rule836 _lhsIinstanceName
         _righthandsideOinstanceTypes = rule837 _lhsIinstanceTypes
         _righthandsideOmatchIO = rule838 _lhsImatchIO
         _righthandsideOmoduleName = rule839 _lhsImoduleName
         _righthandsideOnamesInScope = rule840 _lhsInamesInScope
         _righthandsideOorderedTypeSynonyms = rule841 _lhsIorderedTypeSynonyms
         _righthandsideOparentTree = rule842 _parentTree
         _righthandsideOpatternMatchWarnings = rule843 _patternIpatternMatchWarnings
         _righthandsideOrequiredPredicates = rule844 _lhsIrequiredPredicates
         _righthandsideOsubstitution = rule845 _lhsIsubstitution
         _righthandsideOtypeConstructors = rule846 _lhsItypeConstructors
         _righthandsideOtypeschemeMap = rule847 _lhsItypeschemeMap
         _righthandsideOuniqueChunk = rule848 _lhsIuniqueChunk
         _righthandsideOvariableMapping = rule849 _lhsIvariableMapping
         !__result_ = T_Declaration_vOut28 _lhsObetaUnique _lhsObindingGroups _lhsOboundBetas _lhsOclassMemberNames _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOcounter _lhsOdeclVarNames _lhsOdictionaryEnvironment _lhsOinfoTrees _lhsOmatchIO _lhsOpatternMatchWarnings _lhsOrestrictedNames _lhsOself _lhsOsimplePatNames _lhsOtypeMemberBindings _lhsOtypeSignatures _lhsOunboundNames _lhsOuniqueChunk
         in __result_ )
     in C_Declaration_s29 v28
   {-# INLINE rule777 #-}
   rule777 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ((_lhsIsubstitution) :: FixpointSubstitution) ((_patternIbeta) :: Tp) ((_patternIelements) ::   [PatternElement]        ) ((_rangeIself) :: Range) ((_righthandsideIfallthrough) :: Bool) ((_righthandsideIpatternMatchWarnings) :: [Warning]) ->
                                                    patternMatchWarnings _lhsIimportEnvironment
                                                                         _lhsIsubstitution
                                                                         _patternIbeta
                                                                         (:[])
                                                                         [(_patternIelements, _righthandsideIfallthrough)]
                                                                         _rangeIself
                                                                         Nothing
                                                                         False
                                                                         []
                                                                         "pattern binding"
                                                                         "="
                                                    ++ _righthandsideIpatternMatchWarnings
   {-# INLINE rule778 #-}
   rule778 = \ ((_patternIpatVarNames) :: Names) ->
                                             _patternIpatVarNames
   {-# INLINE rule779 #-}
   rule779 = \ ((_lhsIparentTree) :: InfoTree) _localInfo ((_patternIinfoTree) :: InfoTree) ((_righthandsideIinfoTree) :: InfoTree) ->
                                             node _lhsIparentTree _localInfo [_patternIinfoTree, _righthandsideIinfoTree]
   {-# INLINE rule780 #-}
   rule780 = \ _parentTree ->
                                             [_parentTree]
   {-# INLINE rule781 #-}
   rule781 = \ ((_lhsImonos) :: Monos) _self ->
                            LocalInfo { self = UHA_Decl _self
                                      , assignedType = Nothing
                                      , monos = _lhsImonos
                                      }
   {-# INLINE rule782 #-}
   rule782 = \ _parentTree ->
     orphanConstraint 1 "right hand side" _parentTree
        []
   {-# INLINE rule783 #-}
   rule783 = \ ((_patternIpatVarNames) :: Names) ((_patternIself) :: Pattern) ->
              if isSimplePattern _patternIself
                then ([], _patternIpatVarNames)
                else (_patternIpatVarNames, [])
   {-# INLINE rule784 #-}
   rule784 = \ ((_lhsIinheritedBDG) :: InheritedBDG) ((_patternIenvironment) :: PatternAssumptions) ->
                                                        findCurrentChunk (head (M.keys _patternIenvironment)) _lhsIinheritedBDG
   {-# INLINE rule785 #-}
   rule785 = \ _betaRight ((_lhsIallTypeSchemes) :: M.Map NameWithRange TpScheme) ((_lhsIorderedTypeSynonyms) :: OrderedTypeSynonyms) ((_lhsIsubstitution) :: FixpointSubstitution) ((_patternIself) :: Pattern) ->
                                          case _patternIself of
                                            Pattern_Variable _ name ->
                                               let scheme     = M.findWithDefault err (NameWithRange name) _lhsIallTypeSchemes
                                                   predicates = matchTypeWithScheme _lhsIorderedTypeSynonyms
                                                                   (_lhsIsubstitution |-> _betaRight)
                                                                   (_lhsIsubstitution |-> scheme)
                                                   err = internalError "TypeInferenceOverloading.ag" "n/a" ("could not find type for pattern binding "++show name)
                                               in Just (name, expandPredicates _lhsIorderedTypeSynonyms predicates)
                                            _ -> Nothing
   {-# INLINE rule786 #-}
   rule786 = \ _declPredicates ((_lhsIavailablePredicates) :: [PredicateWithSource]) ->
                                               case _declPredicates of
                                                  Just (_, ps) -> (map PredicateFunction ps ++ _lhsIavailablePredicates)
                                                  Nothing      -> _lhsIavailablePredicates
   {-# INLINE rule787 #-}
   rule787 = \ _declPredicates ((_righthandsideIdictionaryEnvironment) :: DictionaryEnvironment) ->
                                                 case _declPredicates of
                                                    Just (n, ps) -> addForDeclaration n ps _righthandsideIdictionaryEnvironment
                                                    Nothing      -> _righthandsideIdictionaryEnvironment
   {-# INLINE rule788 #-}
   rule788 = \ ((_lhsIbindingGroups) :: BindingGroups) _mybdggrp ->
                                        _mybdggrp : _lhsIbindingGroups
   {-# INLINE rule789 #-}
   rule789 = \ ((_lhsIbetaUnique) :: Int) ->
                                        _lhsIbetaUnique + 2
   {-# INLINE rule790 #-}
   rule790 = \ ((_lhsIinheritedBDG) :: InheritedBDG) ((_lhsImonos) :: Monos) ((_patternIenvironment) :: PatternAssumptions) ->
                                        findMono (chead (M.keys _patternIenvironment)) _lhsIinheritedBDG ++ _lhsImonos
   {-# INLINE rule791 #-}
   rule791 = \ ((_lhsIbetaUnique) :: Int) ->
                                        TVar _lhsIbetaUnique
   {-# INLINE rule792 #-}
   rule792 = \ _betaRight _cinfo ((_patternIbeta) :: Tp) ->
                                        [ (_betaRight .==. _patternIbeta) _cinfo ]
   {-# INLINE rule793 #-}
   rule793 = \ ((_lhsIisTopLevel) :: Bool) ((_lhsImoduleQual) ::  [String] ) _mainConstraint _newcon ((_patternIconstraints) :: ConstraintSet) ((_patternIenvironment) :: PatternAssumptions) ((_righthandsideIassumptions) :: Assumptions) ((_righthandsideIconstraints) :: ConstraintSet) ->
                                        ( if _lhsIisTopLevel then
                                              M.foldrWithKey (\n result old -> M.insert (addQualified _lhsImoduleQual n) result old) _patternIenvironment _patternIenvironment
                                              else _patternIenvironment
                                        , _righthandsideIassumptions
                                        , [ _newcon .>.
                                            Node [ _patternIconstraints
                                                 , _righthandsideIconstraints
                                                 ]
                                            , listTree _mainConstraint
                                          ]
                                        )
   {-# INLINE rule794 #-}
   rule794 = \ ((_lhsIbetaUnique) :: Int) ->
                                         TVar $ _lhsIbetaUnique + 1
   {-# INLINE rule795 #-}
   rule795 = \ _betaMain _cinfo ((_lhsImoduleName) :: Maybe Name) ((_patternIbeta) :: Tp) ((_patternIenvironment) :: PatternAssumptions) ->
                                          if "main" `elem` map (getNameName . fst) (M.toList _patternIenvironment) && (getNameName <$> _lhsImoduleName) == Just "Main" then
                                              [(_patternIbeta .==. TApp (TCon "IO") _betaMain) _cinfo]
                                          else
                                              []
   {-# INLINE rule796 #-}
   rule796 = \  (_ :: ()) ->
     []
   {-# INLINE rule797 #-}
   rule797 = \  (_ :: ()) ->
     []
   {-# INLINE rule798 #-}
   rule798 = \ ((_righthandsideIcollectInstances) :: [(Name, Instance)]) ->
     _righthandsideIcollectInstances
   {-# INLINE rule799 #-}
   rule799 = \  (_ :: ()) ->
     []
   {-# INLINE rule800 #-}
   rule800 = \ ((_patternIunboundNames) :: Names) ((_righthandsideIunboundNames) :: Names) ->
     ((++) _patternIunboundNames _righthandsideIunboundNames)
   {-# INLINE rule801 #-}
   rule801 = \ ((_patternIself) :: Pattern) ((_rangeIself) :: Range) ((_righthandsideIself) :: RightHandSide) ->
     Declaration_PatternBinding _rangeIself _patternIself _righthandsideIself
   {-# INLINE rule802 #-}
   rule802 = \ _self ->
     _self
   {-# INLINE rule803 #-}
   rule803 = \ ((_righthandsideIbetaUnique) :: Int) ->
     _righthandsideIbetaUnique
   {-# INLINE rule804 #-}
   rule804 = \ ((_righthandsideIcollectErrors) :: TypeErrors) ->
     _righthandsideIcollectErrors
   {-# INLINE rule805 #-}
   rule805 = \ ((_righthandsideIcollectWarnings) :: Warnings) ->
     _righthandsideIcollectWarnings
   {-# INLINE rule806 #-}
   rule806 = \ ((_righthandsideIcounter) :: Int) ->
     _righthandsideIcounter
   {-# INLINE rule807 #-}
   rule807 = \ ((_righthandsideImatchIO) :: IO ()) ->
     _righthandsideImatchIO
   {-# INLINE rule808 #-}
   rule808 = \ ((_lhsItypeSignatures) :: TypeEnvironment) ->
     _lhsItypeSignatures
   {-# INLINE rule809 #-}
   rule809 = \ ((_righthandsideIuniqueChunk) :: Int) ->
     _righthandsideIuniqueChunk
   {-# INLINE rule810 #-}
   rule810 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule811 #-}
   rule811 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule812 #-}
   rule812 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule813 #-}
   rule813 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule814 #-}
   rule814 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule815 #-}
   rule815 = \ _parentTree ->
     _parentTree
   {-# INLINE rule816 #-}
   rule816 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule817 #-}
   rule817 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
   {-# INLINE rule818 #-}
   rule818 = \ ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ->
     _lhsIallPatterns
   {-# INLINE rule819 #-}
   rule819 = \ ((_lhsIallTypeSchemes) :: M.Map NameWithRange TpScheme) ->
     _lhsIallTypeSchemes
   {-# INLINE rule820 #-}
   rule820 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule821 #-}
   rule821 = \ _betaRight ->
     _betaRight
   {-# INLINE rule822 #-}
   rule822 = \ ((_patternIbetaUnique) :: Int) ->
     _patternIbetaUnique
   {-# INLINE rule823 #-}
   rule823 = \ ((_lhsIclassEnvironment) :: ClassEnvironment) ->
     _lhsIclassEnvironment
   {-# INLINE rule824 #-}
   rule824 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule825 #-}
   rule825 = \ ((_lhsIclassMemberTypeSchemes) :: Maybe [(Name, TpScheme)]) ->
     _lhsIclassMemberTypeSchemes
   {-# INLINE rule826 #-}
   rule826 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule827 #-}
   rule827 = \ ((_lhsIclassPredicate) :: Maybe (Name, Names)) ->
     _lhsIclassPredicate
   {-# INLINE rule828 #-}
   rule828 = \ ((_lhsIclassTypeSchemes) :: M.Map Name TpScheme) ->
     _lhsIclassTypeSchemes
   {-# INLINE rule829 #-}
   rule829 = \ ((_lhsIcollectErrors) :: TypeErrors) ->
     _lhsIcollectErrors
   {-# INLINE rule830 #-}
   rule830 = \ ((_lhsIcollectWarnings) :: Warnings) ->
     _lhsIcollectWarnings
   {-# INLINE rule831 #-}
   rule831 = \ ((_patternIcounter) :: Int) ->
     _patternIcounter
   {-# INLINE rule832 #-}
   rule832 = \ ((_lhsIcurClassPred) :: Maybe Predicate) ->
     _lhsIcurClassPred
   {-# INLINE rule833 #-}
   rule833 = \ ((_lhsIcurPred) :: Maybe Predicate) ->
     _lhsIcurPred
   {-# INLINE rule834 #-}
   rule834 = \ ((_lhsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _lhsIdictionaryEnvironment
   {-# INLINE rule835 #-}
   rule835 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule836 #-}
   rule836 = \ ((_lhsIinstanceName) :: Maybe Name) ->
     _lhsIinstanceName
   {-# INLINE rule837 #-}
   rule837 = \ ((_lhsIinstanceTypes) :: [(Name, TpScheme)]) ->
     _lhsIinstanceTypes
   {-# INLINE rule838 #-}
   rule838 = \ ((_lhsImatchIO) :: IO ()) ->
     _lhsImatchIO
   {-# INLINE rule839 #-}
   rule839 = \ ((_lhsImoduleName) :: Maybe Name) ->
     _lhsImoduleName
   {-# INLINE rule840 #-}
   rule840 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule841 #-}
   rule841 = \ ((_lhsIorderedTypeSynonyms) :: OrderedTypeSynonyms) ->
     _lhsIorderedTypeSynonyms
   {-# INLINE rule842 #-}
   rule842 = \ _parentTree ->
     _parentTree
   {-# INLINE rule843 #-}
   rule843 = \ ((_patternIpatternMatchWarnings) :: [Warning]) ->
     _patternIpatternMatchWarnings
   {-# INLINE rule844 #-}
   rule844 = \ ((_lhsIrequiredPredicates) :: Predicates) ->
     _lhsIrequiredPredicates
   {-# INLINE rule845 #-}
   rule845 = \ ((_lhsIsubstitution) :: FixpointSubstitution) ->
     _lhsIsubstitution
   {-# INLINE rule846 #-}
   rule846 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
   {-# INLINE rule847 #-}
   rule847 = \ ((_lhsItypeschemeMap) :: M.Map Int (Scheme Predicates)) ->
     _lhsItypeschemeMap
   {-# INLINE rule848 #-}
   rule848 = \ ((_lhsIuniqueChunk) :: Int) ->
     _lhsIuniqueChunk
   {-# INLINE rule849 #-}
   rule849 = \ ((_lhsIvariableMapping) :: Maybe [(Name, Tp)]) ->
     _lhsIvariableMapping
{-# NOINLINE sem_Declaration_TypeSignature #-}
sem_Declaration_TypeSignature :: T_Range  -> T_Names  -> T_Type  -> T_Declaration 
sem_Declaration_TypeSignature arg_range_ arg_names_ arg_type_ = T_Declaration (return st29) where
   {-# NOINLINE st29 #-}
   !st29 = let
      v28 :: T_Declaration_v28 
      v28 = \ !(T_Declaration_vIn28 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaUnique _lhsIbindingGroups _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinheritedBDG _lhsIinstanceName _lhsIinstanceTypes _lhsIisTopLevel _lhsImatchIO _lhsImoduleName _lhsImoduleQual _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeConstructors _lhsItypeSignatures _lhsItypeschemeMap _lhsIuniqueChunk _lhsIvariableMapping) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _namesX116 = Control.Monad.Identity.runIdentity (attach_T_Names (arg_names_))
         _typeX164 = Control.Monad.Identity.runIdentity (attach_T_Type (arg_type_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_Names_vOut115 _namesIself) = inv_Names_s116 _namesX116 (T_Names_vIn115 )
         (T_Type_vOut163 _typeIself) = inv_Type_s164 _typeX164 (T_Type_vIn163 _typeOclassMemberEnv _typeOclassNamesEnv)
         _lhsOinfoTrees :: InfoTrees
         _lhsOinfoTrees = rule850  ()
         _lhsOtypeSignatures :: TypeEnvironment
         _lhsOtypeSignatures = rule851 _lhsItypeSignatures _namesIself _typeScheme
         _typeScheme = rule852 _lhsIclassPredicate _lhsIimportEnvironment _typeIself
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule853 _lhsIbetaUnique
         _lhsOtypeMemberBindings :: [(Name, TpScheme)]
         _lhsOtypeMemberBindings = rule854 _lhsIimportEnvironment _namesIself _typeIself
         _lhsOboundBetas :: [(Name, Tp, [Tp])]
         _lhsOboundBetas = rule855  ()
         _lhsOclassMemberNames :: Names
         _lhsOclassMemberNames = rule856  ()
         _lhsOcollectInstances :: [(Name, Instance)]
         _lhsOcollectInstances = rule857  ()
         _lhsOdeclVarNames :: Names
         _lhsOdeclVarNames = rule858  ()
         _lhsOrestrictedNames :: Names
         _lhsOrestrictedNames = rule859  ()
         _lhsOsimplePatNames :: Names
         _lhsOsimplePatNames = rule860  ()
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule861  ()
         _self = rule862 _namesIself _rangeIself _typeIself
         _lhsOself :: Declaration
         _lhsOself = rule863 _self
         _lhsObindingGroups :: BindingGroups
         _lhsObindingGroups = rule864 _lhsIbindingGroups
         _lhsOcollectErrors :: TypeErrors
         _lhsOcollectErrors = rule865 _lhsIcollectErrors
         _lhsOcollectWarnings :: Warnings
         _lhsOcollectWarnings = rule866 _lhsIcollectWarnings
         _lhsOcounter :: Int
         _lhsOcounter = rule867 _lhsIcounter
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule868 _lhsIdictionaryEnvironment
         _lhsOmatchIO :: IO ()
         _lhsOmatchIO = rule869 _lhsImatchIO
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule870 _lhsIpatternMatchWarnings
         _lhsOuniqueChunk :: Int
         _lhsOuniqueChunk = rule871 _lhsIuniqueChunk
         _typeOclassMemberEnv = rule872 _lhsIclassMemberEnv
         _typeOclassNamesEnv = rule873 _lhsIclassNamesEnv
         !__result_ = T_Declaration_vOut28 _lhsObetaUnique _lhsObindingGroups _lhsOboundBetas _lhsOclassMemberNames _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOcounter _lhsOdeclVarNames _lhsOdictionaryEnvironment _lhsOinfoTrees _lhsOmatchIO _lhsOpatternMatchWarnings _lhsOrestrictedNames _lhsOself _lhsOsimplePatNames _lhsOtypeMemberBindings _lhsOtypeSignatures _lhsOunboundNames _lhsOuniqueChunk
         in __result_ )
     in C_Declaration_s29 v28
   {-# INLINE rule850 #-}
   rule850 = \  (_ :: ()) ->
                                       []
   {-# INLINE rule851 #-}
   rule851 = \ ((_lhsItypeSignatures) :: TypeEnvironment) ((_namesIself) :: Names) _typeScheme ->
                               _lhsItypeSignatures `M.union` (M.fromList [ (name, _typeScheme) | name <- _namesIself ])
   {-# INLINE rule852 #-}
   rule852 = \ ((_lhsIclassPredicate) :: Maybe (Name, Names)) ((_lhsIimportEnvironment) :: ImportEnvironment) ((_typeIself) :: Type) ->
                                if isJust _lhsIclassPredicate then
                                  let
                                    Just (className, typeVars) = _lhsIclassPredicate
                                    qualName = convertClassNameToQualified _lhsIimportEnvironment className
                                    tpscheme = makeTpSchemeFromType (convertTypeToQualified _lhsIimportEnvironment _typeIself)
                                    typeIndices = filter (\(_, s) -> s `elem` (map getNameName typeVars)) (getQuantorMap tpscheme)
                                    typeVariablesMapped = map (\(n, s) -> (fromJust $ find (\tv -> getNameName tv == s) typeVars, TVar n)) typeIndices
                                    tpWContext = addContextToType qualName typeVariablesMapped tpscheme
                                  in tpWContext
                                else
                                  convertTpSchemeToQualified _lhsIimportEnvironment (makeTpSchemeFromType _typeIself)
   {-# INLINE rule853 #-}
   rule853 = \ ((_lhsIbetaUnique) :: Int) ->
                                     _lhsIbetaUnique + 1
   {-# INLINE rule854 #-}
   rule854 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ((_namesIself) :: Names) ((_typeIself) :: Type) ->
                                             map (\name -> (name, makeTpSchemeFromType $ convertTypeToQualified _lhsIimportEnvironment _typeIself)) _namesIself
   {-# INLINE rule855 #-}
   rule855 = \  (_ :: ()) ->
     []
   {-# INLINE rule856 #-}
   rule856 = \  (_ :: ()) ->
     []
   {-# INLINE rule857 #-}
   rule857 = \  (_ :: ()) ->
     []
   {-# INLINE rule858 #-}
   rule858 = \  (_ :: ()) ->
     []
   {-# INLINE rule859 #-}
   rule859 = \  (_ :: ()) ->
     []
   {-# INLINE rule860 #-}
   rule860 = \  (_ :: ()) ->
     []
   {-# INLINE rule861 #-}
   rule861 = \  (_ :: ()) ->
     []
   {-# INLINE rule862 #-}
   rule862 = \ ((_namesIself) :: Names) ((_rangeIself) :: Range) ((_typeIself) :: Type) ->
     Declaration_TypeSignature _rangeIself _namesIself _typeIself
   {-# INLINE rule863 #-}
   rule863 = \ _self ->
     _self
   {-# INLINE rule864 #-}
   rule864 = \ ((_lhsIbindingGroups) :: BindingGroups) ->
     _lhsIbindingGroups
   {-# INLINE rule865 #-}
   rule865 = \ ((_lhsIcollectErrors) :: TypeErrors) ->
     _lhsIcollectErrors
   {-# INLINE rule866 #-}
   rule866 = \ ((_lhsIcollectWarnings) :: Warnings) ->
     _lhsIcollectWarnings
   {-# INLINE rule867 #-}
   rule867 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule868 #-}
   rule868 = \ ((_lhsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _lhsIdictionaryEnvironment
   {-# INLINE rule869 #-}
   rule869 = \ ((_lhsImatchIO) :: IO ()) ->
     _lhsImatchIO
   {-# INLINE rule870 #-}
   rule870 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule871 #-}
   rule871 = \ ((_lhsIuniqueChunk) :: Int) ->
     _lhsIuniqueChunk
   {-# INLINE rule872 #-}
   rule872 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule873 #-}
   rule873 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
{-# NOINLINE sem_Declaration_Fixity #-}
sem_Declaration_Fixity :: T_Range  -> T_Fixity  -> T_MaybeInt  -> T_Names  -> T_Declaration 
sem_Declaration_Fixity arg_range_ arg_fixity_ arg_priority_ arg_operators_ = T_Declaration (return st29) where
   {-# NOINLINE st29 #-}
   !st29 = let
      v28 :: T_Declaration_v28 
      v28 = \ !(T_Declaration_vIn28 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaUnique _lhsIbindingGroups _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinheritedBDG _lhsIinstanceName _lhsIinstanceTypes _lhsIisTopLevel _lhsImatchIO _lhsImoduleName _lhsImoduleQual _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeConstructors _lhsItypeSignatures _lhsItypeschemeMap _lhsIuniqueChunk _lhsIvariableMapping) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _fixityX53 = Control.Monad.Identity.runIdentity (attach_T_Fixity (arg_fixity_))
         _priorityX101 = Control.Monad.Identity.runIdentity (attach_T_MaybeInt (arg_priority_))
         _operatorsX116 = Control.Monad.Identity.runIdentity (attach_T_Names (arg_operators_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_Fixity_vOut52 _fixityIself) = inv_Fixity_s53 _fixityX53 (T_Fixity_vIn52 )
         (T_MaybeInt_vOut100 _priorityIself) = inv_MaybeInt_s101 _priorityX101 (T_MaybeInt_vIn100 )
         (T_Names_vOut115 _operatorsIself) = inv_Names_s116 _operatorsX116 (T_Names_vIn115 )
         _lhsOinfoTrees :: InfoTrees
         _lhsOinfoTrees = rule874  ()
         _lhsOboundBetas :: [(Name, Tp, [Tp])]
         _lhsOboundBetas = rule875  ()
         _lhsOclassMemberNames :: Names
         _lhsOclassMemberNames = rule876  ()
         _lhsOcollectInstances :: [(Name, Instance)]
         _lhsOcollectInstances = rule877  ()
         _lhsOdeclVarNames :: Names
         _lhsOdeclVarNames = rule878  ()
         _lhsOrestrictedNames :: Names
         _lhsOrestrictedNames = rule879  ()
         _lhsOsimplePatNames :: Names
         _lhsOsimplePatNames = rule880  ()
         _lhsOtypeMemberBindings :: [(Name, TpScheme)]
         _lhsOtypeMemberBindings = rule881  ()
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule882  ()
         _self = rule883 _fixityIself _operatorsIself _priorityIself _rangeIself
         _lhsOself :: Declaration
         _lhsOself = rule884 _self
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule885 _lhsIbetaUnique
         _lhsObindingGroups :: BindingGroups
         _lhsObindingGroups = rule886 _lhsIbindingGroups
         _lhsOcollectErrors :: TypeErrors
         _lhsOcollectErrors = rule887 _lhsIcollectErrors
         _lhsOcollectWarnings :: Warnings
         _lhsOcollectWarnings = rule888 _lhsIcollectWarnings
         _lhsOcounter :: Int
         _lhsOcounter = rule889 _lhsIcounter
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule890 _lhsIdictionaryEnvironment
         _lhsOmatchIO :: IO ()
         _lhsOmatchIO = rule891 _lhsImatchIO
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule892 _lhsIpatternMatchWarnings
         _lhsOtypeSignatures :: TypeEnvironment
         _lhsOtypeSignatures = rule893 _lhsItypeSignatures
         _lhsOuniqueChunk :: Int
         _lhsOuniqueChunk = rule894 _lhsIuniqueChunk
         !__result_ = T_Declaration_vOut28 _lhsObetaUnique _lhsObindingGroups _lhsOboundBetas _lhsOclassMemberNames _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOcounter _lhsOdeclVarNames _lhsOdictionaryEnvironment _lhsOinfoTrees _lhsOmatchIO _lhsOpatternMatchWarnings _lhsOrestrictedNames _lhsOself _lhsOsimplePatNames _lhsOtypeMemberBindings _lhsOtypeSignatures _lhsOunboundNames _lhsOuniqueChunk
         in __result_ )
     in C_Declaration_s29 v28
   {-# INLINE rule874 #-}
   rule874 = \  (_ :: ()) ->
                                       []
   {-# INLINE rule875 #-}
   rule875 = \  (_ :: ()) ->
     []
   {-# INLINE rule876 #-}
   rule876 = \  (_ :: ()) ->
     []
   {-# INLINE rule877 #-}
   rule877 = \  (_ :: ()) ->
     []
   {-# INLINE rule878 #-}
   rule878 = \  (_ :: ()) ->
     []
   {-# INLINE rule879 #-}
   rule879 = \  (_ :: ()) ->
     []
   {-# INLINE rule880 #-}
   rule880 = \  (_ :: ()) ->
     []
   {-# INLINE rule881 #-}
   rule881 = \  (_ :: ()) ->
     []
   {-# INLINE rule882 #-}
   rule882 = \  (_ :: ()) ->
     []
   {-# INLINE rule883 #-}
   rule883 = \ ((_fixityIself) :: Fixity) ((_operatorsIself) :: Names) ((_priorityIself) :: MaybeInt) ((_rangeIself) :: Range) ->
     Declaration_Fixity _rangeIself _fixityIself _priorityIself _operatorsIself
   {-# INLINE rule884 #-}
   rule884 = \ _self ->
     _self
   {-# INLINE rule885 #-}
   rule885 = \ ((_lhsIbetaUnique) :: Int) ->
     _lhsIbetaUnique
   {-# INLINE rule886 #-}
   rule886 = \ ((_lhsIbindingGroups) :: BindingGroups) ->
     _lhsIbindingGroups
   {-# INLINE rule887 #-}
   rule887 = \ ((_lhsIcollectErrors) :: TypeErrors) ->
     _lhsIcollectErrors
   {-# INLINE rule888 #-}
   rule888 = \ ((_lhsIcollectWarnings) :: Warnings) ->
     _lhsIcollectWarnings
   {-# INLINE rule889 #-}
   rule889 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule890 #-}
   rule890 = \ ((_lhsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _lhsIdictionaryEnvironment
   {-# INLINE rule891 #-}
   rule891 = \ ((_lhsImatchIO) :: IO ()) ->
     _lhsImatchIO
   {-# INLINE rule892 #-}
   rule892 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule893 #-}
   rule893 = \ ((_lhsItypeSignatures) :: TypeEnvironment) ->
     _lhsItypeSignatures
   {-# INLINE rule894 #-}
   rule894 = \ ((_lhsIuniqueChunk) :: Int) ->
     _lhsIuniqueChunk
{-# NOINLINE sem_Declaration_Empty #-}
sem_Declaration_Empty :: T_Range  -> T_Declaration 
sem_Declaration_Empty arg_range_ = T_Declaration (return st29) where
   {-# NOINLINE st29 #-}
   !st29 = let
      v28 :: T_Declaration_v28 
      v28 = \ !(T_Declaration_vIn28 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaUnique _lhsIbindingGroups _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinheritedBDG _lhsIinstanceName _lhsIinstanceTypes _lhsIisTopLevel _lhsImatchIO _lhsImoduleName _lhsImoduleQual _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeConstructors _lhsItypeSignatures _lhsItypeschemeMap _lhsIuniqueChunk _lhsIvariableMapping) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         _lhsOinfoTrees :: InfoTrees
         _lhsOinfoTrees = rule895  ()
         _lhsOboundBetas :: [(Name, Tp, [Tp])]
         _lhsOboundBetas = rule896  ()
         _lhsOclassMemberNames :: Names
         _lhsOclassMemberNames = rule897  ()
         _lhsOcollectInstances :: [(Name, Instance)]
         _lhsOcollectInstances = rule898  ()
         _lhsOdeclVarNames :: Names
         _lhsOdeclVarNames = rule899  ()
         _lhsOrestrictedNames :: Names
         _lhsOrestrictedNames = rule900  ()
         _lhsOsimplePatNames :: Names
         _lhsOsimplePatNames = rule901  ()
         _lhsOtypeMemberBindings :: [(Name, TpScheme)]
         _lhsOtypeMemberBindings = rule902  ()
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule903  ()
         _self = rule904 _rangeIself
         _lhsOself :: Declaration
         _lhsOself = rule905 _self
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule906 _lhsIbetaUnique
         _lhsObindingGroups :: BindingGroups
         _lhsObindingGroups = rule907 _lhsIbindingGroups
         _lhsOcollectErrors :: TypeErrors
         _lhsOcollectErrors = rule908 _lhsIcollectErrors
         _lhsOcollectWarnings :: Warnings
         _lhsOcollectWarnings = rule909 _lhsIcollectWarnings
         _lhsOcounter :: Int
         _lhsOcounter = rule910 _lhsIcounter
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule911 _lhsIdictionaryEnvironment
         _lhsOmatchIO :: IO ()
         _lhsOmatchIO = rule912 _lhsImatchIO
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule913 _lhsIpatternMatchWarnings
         _lhsOtypeSignatures :: TypeEnvironment
         _lhsOtypeSignatures = rule914 _lhsItypeSignatures
         _lhsOuniqueChunk :: Int
         _lhsOuniqueChunk = rule915 _lhsIuniqueChunk
         !__result_ = T_Declaration_vOut28 _lhsObetaUnique _lhsObindingGroups _lhsOboundBetas _lhsOclassMemberNames _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOcounter _lhsOdeclVarNames _lhsOdictionaryEnvironment _lhsOinfoTrees _lhsOmatchIO _lhsOpatternMatchWarnings _lhsOrestrictedNames _lhsOself _lhsOsimplePatNames _lhsOtypeMemberBindings _lhsOtypeSignatures _lhsOunboundNames _lhsOuniqueChunk
         in __result_ )
     in C_Declaration_s29 v28
   {-# INLINE rule895 #-}
   rule895 = \  (_ :: ()) ->
                                       []
   {-# INLINE rule896 #-}
   rule896 = \  (_ :: ()) ->
     []
   {-# INLINE rule897 #-}
   rule897 = \  (_ :: ()) ->
     []
   {-# INLINE rule898 #-}
   rule898 = \  (_ :: ()) ->
     []
   {-# INLINE rule899 #-}
   rule899 = \  (_ :: ()) ->
     []
   {-# INLINE rule900 #-}
   rule900 = \  (_ :: ()) ->
     []
   {-# INLINE rule901 #-}
   rule901 = \  (_ :: ()) ->
     []
   {-# INLINE rule902 #-}
   rule902 = \  (_ :: ()) ->
     []
   {-# INLINE rule903 #-}
   rule903 = \  (_ :: ()) ->
     []
   {-# INLINE rule904 #-}
   rule904 = \ ((_rangeIself) :: Range) ->
     Declaration_Empty _rangeIself
   {-# INLINE rule905 #-}
   rule905 = \ _self ->
     _self
   {-# INLINE rule906 #-}
   rule906 = \ ((_lhsIbetaUnique) :: Int) ->
     _lhsIbetaUnique
   {-# INLINE rule907 #-}
   rule907 = \ ((_lhsIbindingGroups) :: BindingGroups) ->
     _lhsIbindingGroups
   {-# INLINE rule908 #-}
   rule908 = \ ((_lhsIcollectErrors) :: TypeErrors) ->
     _lhsIcollectErrors
   {-# INLINE rule909 #-}
   rule909 = \ ((_lhsIcollectWarnings) :: Warnings) ->
     _lhsIcollectWarnings
   {-# INLINE rule910 #-}
   rule910 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule911 #-}
   rule911 = \ ((_lhsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _lhsIdictionaryEnvironment
   {-# INLINE rule912 #-}
   rule912 = \ ((_lhsImatchIO) :: IO ()) ->
     _lhsImatchIO
   {-# INLINE rule913 #-}
   rule913 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule914 #-}
   rule914 = \ ((_lhsItypeSignatures) :: TypeEnvironment) ->
     _lhsItypeSignatures
   {-# INLINE rule915 #-}
   rule915 = \ ((_lhsIuniqueChunk) :: Int) ->
     _lhsIuniqueChunk

-- Declarations ------------------------------------------------
-- wrapper
data Inh_Declarations  = Inh_Declarations { allPatterns_Inh_Declarations :: !([((Expression, [String]), Core_TypingStrategy)]), allTypeSchemes_Inh_Declarations :: !(M.Map NameWithRange TpScheme), ambiguousConflicts_Inh_Declarations :: !([[Name]]), availablePredicates_Inh_Declarations :: !([PredicateWithSource]), betaUnique_Inh_Declarations :: !(Int), bindingGroups_Inh_Declarations :: !(BindingGroups), classEnvironment_Inh_Declarations :: !(ClassEnvironment), classMemberEnv_Inh_Declarations :: !(ClassMemberEnvironment), classMemberTypeSchemes_Inh_Declarations :: !(Maybe [(Name, TpScheme)]), classNamesEnv_Inh_Declarations :: !(ClassNameEnvironment), classPredicate_Inh_Declarations :: !(Maybe (Name, Names)), classTypeSchemes_Inh_Declarations :: !(M.Map Name TpScheme), collectErrors_Inh_Declarations :: !(TypeErrors), collectWarnings_Inh_Declarations :: !(Warnings), counter_Inh_Declarations :: !(Int), curClassPred_Inh_Declarations :: !(Maybe Predicate), curPred_Inh_Declarations :: !(Maybe Predicate), currentChunk_Inh_Declarations :: !(Int), dictionaryEnvironment_Inh_Declarations :: !(DictionaryEnvironment), importEnvironment_Inh_Declarations :: !(ImportEnvironment), inheritedBDG_Inh_Declarations :: !(InheritedBDG), instanceName_Inh_Declarations :: !(Maybe Name), instanceTypes_Inh_Declarations :: !([(Name, TpScheme)]), isTopLevel_Inh_Declarations :: !(Bool), matchIO_Inh_Declarations :: !(IO ()), moduleName_Inh_Declarations :: !(Maybe Name), moduleQual_Inh_Declarations :: !( [String] ), monos_Inh_Declarations :: !(Monos), namesInScope_Inh_Declarations :: !(Names), orderedTypeSynonyms_Inh_Declarations :: !(OrderedTypeSynonyms), parentTree_Inh_Declarations :: !(InfoTree), patternMatchWarnings_Inh_Declarations :: !([Warning]), requiredPredicates_Inh_Declarations :: !(Predicates), substitution_Inh_Declarations :: !(FixpointSubstitution), typeConstructors_Inh_Declarations :: !(TypeConstructorEnvironment), typeSignatures_Inh_Declarations :: !(TypeEnvironment), typeschemeMap_Inh_Declarations :: !(M.Map Int (Scheme Predicates)), uniqueChunk_Inh_Declarations :: !(Int), variableMapping_Inh_Declarations :: !(Maybe [(Name, Tp)]) }
data Syn_Declarations  = Syn_Declarations { betaUnique_Syn_Declarations :: !(Int), bindingGroups_Syn_Declarations :: !(BindingGroups), boundBetas_Syn_Declarations :: !([(Name, Tp, [Tp])]), classMemberNames_Syn_Declarations :: !(Names), collectErrors_Syn_Declarations :: !(TypeErrors), collectInstances_Syn_Declarations :: !([(Name, Instance)]), collectWarnings_Syn_Declarations :: !(Warnings), counter_Syn_Declarations :: !(Int), declVarNames_Syn_Declarations :: !(Names), dictionaryEnvironment_Syn_Declarations :: !(DictionaryEnvironment), infoTrees_Syn_Declarations :: !(InfoTrees), matchIO_Syn_Declarations :: !(IO ()), patternMatchWarnings_Syn_Declarations :: !([Warning]), restrictedNames_Syn_Declarations :: !(Names), self_Syn_Declarations :: !(Declarations), simplePatNames_Syn_Declarations :: !(Names), typeMemberBindings_Syn_Declarations :: !([(Name, TpScheme)]), typeSignatures_Syn_Declarations :: !(TypeEnvironment), unboundNames_Syn_Declarations :: !(Names), uniqueChunk_Syn_Declarations :: !(Int) }
{-# INLINABLE wrap_Declarations #-}
wrap_Declarations :: T_Declarations  -> Inh_Declarations  -> (Syn_Declarations )
wrap_Declarations !(T_Declarations act) !(Inh_Declarations _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaUnique _lhsIbindingGroups _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinheritedBDG _lhsIinstanceName _lhsIinstanceTypes _lhsIisTopLevel _lhsImatchIO _lhsImoduleName _lhsImoduleQual _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeConstructors _lhsItypeSignatures _lhsItypeschemeMap _lhsIuniqueChunk _lhsIvariableMapping) =
   Control.Monad.Identity.runIdentity (
     do !sem <- act
        let arg31 = T_Declarations_vIn31 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaUnique _lhsIbindingGroups _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinheritedBDG _lhsIinstanceName _lhsIinstanceTypes _lhsIisTopLevel _lhsImatchIO _lhsImoduleName _lhsImoduleQual _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeConstructors _lhsItypeSignatures _lhsItypeschemeMap _lhsIuniqueChunk _lhsIvariableMapping
        !(T_Declarations_vOut31 _lhsObetaUnique _lhsObindingGroups _lhsOboundBetas _lhsOclassMemberNames _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOcounter _lhsOdeclVarNames _lhsOdictionaryEnvironment _lhsOinfoTrees _lhsOmatchIO _lhsOpatternMatchWarnings _lhsOrestrictedNames _lhsOself _lhsOsimplePatNames _lhsOtypeMemberBindings _lhsOtypeSignatures _lhsOunboundNames _lhsOuniqueChunk) <- return (inv_Declarations_s32 sem arg31)
        return (Syn_Declarations _lhsObetaUnique _lhsObindingGroups _lhsOboundBetas _lhsOclassMemberNames _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOcounter _lhsOdeclVarNames _lhsOdictionaryEnvironment _lhsOinfoTrees _lhsOmatchIO _lhsOpatternMatchWarnings _lhsOrestrictedNames _lhsOself _lhsOsimplePatNames _lhsOtypeMemberBindings _lhsOtypeSignatures _lhsOunboundNames _lhsOuniqueChunk)
   )

-- cata
{-# NOINLINE sem_Declarations #-}
sem_Declarations :: Declarations  -> T_Declarations 
sem_Declarations list = Prelude.foldr sem_Declarations_Cons sem_Declarations_Nil (Prelude.map sem_Declaration list)

-- semantic domain
newtype T_Declarations  = T_Declarations {
                                         attach_T_Declarations :: Identity (T_Declarations_s32 )
                                         }
newtype T_Declarations_s32  = C_Declarations_s32 {
                                                 inv_Declarations_s32 :: (T_Declarations_v31 )
                                                 }
data T_Declarations_s33  = C_Declarations_s33
type T_Declarations_v31  = (T_Declarations_vIn31 ) -> (T_Declarations_vOut31 )
data T_Declarations_vIn31  = T_Declarations_vIn31 ([((Expression, [String]), Core_TypingStrategy)]) (M.Map NameWithRange TpScheme) ([[Name]]) ([PredicateWithSource]) (Int) (BindingGroups) (ClassEnvironment) (ClassMemberEnvironment) (Maybe [(Name, TpScheme)]) (ClassNameEnvironment) (Maybe (Name, Names)) (M.Map Name TpScheme) (TypeErrors) (Warnings) (Int) (Maybe Predicate) (Maybe Predicate) (Int) (DictionaryEnvironment) (ImportEnvironment) (InheritedBDG) (Maybe Name) ([(Name, TpScheme)]) (Bool) (IO ()) (Maybe Name) ( [String] ) (Monos) (Names) (OrderedTypeSynonyms) (InfoTree) ([Warning]) (Predicates) (FixpointSubstitution) (TypeConstructorEnvironment) (TypeEnvironment) (M.Map Int (Scheme Predicates)) (Int) (Maybe [(Name, Tp)])
data T_Declarations_vOut31  = T_Declarations_vOut31 (Int) (BindingGroups) ([(Name, Tp, [Tp])]) (Names) (TypeErrors) ([(Name, Instance)]) (Warnings) (Int) (Names) (DictionaryEnvironment) (InfoTrees) (IO ()) ([Warning]) (Names) (Declarations) (Names) ([(Name, TpScheme)]) (TypeEnvironment) (Names) (Int)
{-# NOINLINE sem_Declarations_Cons #-}
sem_Declarations_Cons :: T_Declaration  -> T_Declarations  -> T_Declarations 
sem_Declarations_Cons arg_hd_ arg_tl_ = T_Declarations (return st32) where
   {-# NOINLINE st32 #-}
   !st32 = let
      v31 :: T_Declarations_v31 
      v31 = \ !(T_Declarations_vIn31 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaUnique _lhsIbindingGroups _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinheritedBDG _lhsIinstanceName _lhsIinstanceTypes _lhsIisTopLevel _lhsImatchIO _lhsImoduleName _lhsImoduleQual _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeConstructors _lhsItypeSignatures _lhsItypeschemeMap _lhsIuniqueChunk _lhsIvariableMapping) -> ( let
         _hdX29 = Control.Monad.Identity.runIdentity (attach_T_Declaration (arg_hd_))
         _tlX32 = Control.Monad.Identity.runIdentity (attach_T_Declarations (arg_tl_))
         (T_Declaration_vOut28 _hdIbetaUnique _hdIbindingGroups _hdIboundBetas _hdIclassMemberNames _hdIcollectErrors _hdIcollectInstances _hdIcollectWarnings _hdIcounter _hdIdeclVarNames _hdIdictionaryEnvironment _hdIinfoTrees _hdImatchIO _hdIpatternMatchWarnings _hdIrestrictedNames _hdIself _hdIsimplePatNames _hdItypeMemberBindings _hdItypeSignatures _hdIunboundNames _hdIuniqueChunk) = inv_Declaration_s29 _hdX29 (T_Declaration_vIn28 _hdOallPatterns _hdOallTypeSchemes _hdOambiguousConflicts _hdOavailablePredicates _hdObetaUnique _hdObindingGroups _hdOclassEnvironment _hdOclassMemberEnv _hdOclassMemberTypeSchemes _hdOclassNamesEnv _hdOclassPredicate _hdOclassTypeSchemes _hdOcollectErrors _hdOcollectWarnings _hdOcounter _hdOcurClassPred _hdOcurPred _hdOcurrentChunk _hdOdictionaryEnvironment _hdOimportEnvironment _hdOinheritedBDG _hdOinstanceName _hdOinstanceTypes _hdOisTopLevel _hdOmatchIO _hdOmoduleName _hdOmoduleQual _hdOmonos _hdOnamesInScope _hdOorderedTypeSynonyms _hdOparentTree _hdOpatternMatchWarnings _hdOrequiredPredicates _hdOsubstitution _hdOtypeConstructors _hdOtypeSignatures _hdOtypeschemeMap _hdOuniqueChunk _hdOvariableMapping)
         (T_Declarations_vOut31 _tlIbetaUnique _tlIbindingGroups _tlIboundBetas _tlIclassMemberNames _tlIcollectErrors _tlIcollectInstances _tlIcollectWarnings _tlIcounter _tlIdeclVarNames _tlIdictionaryEnvironment _tlIinfoTrees _tlImatchIO _tlIpatternMatchWarnings _tlIrestrictedNames _tlIself _tlIsimplePatNames _tlItypeMemberBindings _tlItypeSignatures _tlIunboundNames _tlIuniqueChunk) = inv_Declarations_s32 _tlX32 (T_Declarations_vIn31 _tlOallPatterns _tlOallTypeSchemes _tlOambiguousConflicts _tlOavailablePredicates _tlObetaUnique _tlObindingGroups _tlOclassEnvironment _tlOclassMemberEnv _tlOclassMemberTypeSchemes _tlOclassNamesEnv _tlOclassPredicate _tlOclassTypeSchemes _tlOcollectErrors _tlOcollectWarnings _tlOcounter _tlOcurClassPred _tlOcurPred _tlOcurrentChunk _tlOdictionaryEnvironment _tlOimportEnvironment _tlOinheritedBDG _tlOinstanceName _tlOinstanceTypes _tlOisTopLevel _tlOmatchIO _tlOmoduleName _tlOmoduleQual _tlOmonos _tlOnamesInScope _tlOorderedTypeSynonyms _tlOparentTree _tlOpatternMatchWarnings _tlOrequiredPredicates _tlOsubstitution _tlOtypeConstructors _tlOtypeSignatures _tlOtypeschemeMap _tlOuniqueChunk _tlOvariableMapping)
         _lhsOinfoTrees :: InfoTrees
         _lhsOinfoTrees = rule916 _hdIinfoTrees _tlIinfoTrees
         _lhsOboundBetas :: [(Name, Tp, [Tp])]
         _lhsOboundBetas = rule917 _hdIboundBetas _tlIboundBetas
         _lhsOclassMemberNames :: Names
         _lhsOclassMemberNames = rule918 _hdIclassMemberNames _tlIclassMemberNames
         _lhsOcollectInstances :: [(Name, Instance)]
         _lhsOcollectInstances = rule919 _hdIcollectInstances _tlIcollectInstances
         _lhsOdeclVarNames :: Names
         _lhsOdeclVarNames = rule920 _hdIdeclVarNames _tlIdeclVarNames
         _lhsOrestrictedNames :: Names
         _lhsOrestrictedNames = rule921 _hdIrestrictedNames _tlIrestrictedNames
         _lhsOsimplePatNames :: Names
         _lhsOsimplePatNames = rule922 _hdIsimplePatNames _tlIsimplePatNames
         _lhsOtypeMemberBindings :: [(Name, TpScheme)]
         _lhsOtypeMemberBindings = rule923 _hdItypeMemberBindings _tlItypeMemberBindings
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule924 _hdIunboundNames _tlIunboundNames
         _self = rule925 _hdIself _tlIself
         _lhsOself :: Declarations
         _lhsOself = rule926 _self
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule927 _tlIbetaUnique
         _lhsObindingGroups :: BindingGroups
         _lhsObindingGroups = rule928 _tlIbindingGroups
         _lhsOcollectErrors :: TypeErrors
         _lhsOcollectErrors = rule929 _tlIcollectErrors
         _lhsOcollectWarnings :: Warnings
         _lhsOcollectWarnings = rule930 _tlIcollectWarnings
         _lhsOcounter :: Int
         _lhsOcounter = rule931 _tlIcounter
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule932 _tlIdictionaryEnvironment
         _lhsOmatchIO :: IO ()
         _lhsOmatchIO = rule933 _tlImatchIO
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule934 _tlIpatternMatchWarnings
         _lhsOtypeSignatures :: TypeEnvironment
         _lhsOtypeSignatures = rule935 _tlItypeSignatures
         _lhsOuniqueChunk :: Int
         _lhsOuniqueChunk = rule936 _tlIuniqueChunk
         _hdOallPatterns = rule937 _lhsIallPatterns
         _hdOallTypeSchemes = rule938 _lhsIallTypeSchemes
         _hdOambiguousConflicts = rule939 _lhsIambiguousConflicts
         _hdOavailablePredicates = rule940 _lhsIavailablePredicates
         _hdObetaUnique = rule941 _lhsIbetaUnique
         _hdObindingGroups = rule942 _lhsIbindingGroups
         _hdOclassEnvironment = rule943 _lhsIclassEnvironment
         _hdOclassMemberEnv = rule944 _lhsIclassMemberEnv
         _hdOclassMemberTypeSchemes = rule945 _lhsIclassMemberTypeSchemes
         _hdOclassNamesEnv = rule946 _lhsIclassNamesEnv
         _hdOclassPredicate = rule947 _lhsIclassPredicate
         _hdOclassTypeSchemes = rule948 _lhsIclassTypeSchemes
         _hdOcollectErrors = rule949 _lhsIcollectErrors
         _hdOcollectWarnings = rule950 _lhsIcollectWarnings
         _hdOcounter = rule951 _lhsIcounter
         _hdOcurClassPred = rule952 _lhsIcurClassPred
         _hdOcurPred = rule953 _lhsIcurPred
         _hdOcurrentChunk = rule954 _lhsIcurrentChunk
         _hdOdictionaryEnvironment = rule955 _lhsIdictionaryEnvironment
         _hdOimportEnvironment = rule956 _lhsIimportEnvironment
         _hdOinheritedBDG = rule957 _lhsIinheritedBDG
         _hdOinstanceName = rule958 _lhsIinstanceName
         _hdOinstanceTypes = rule959 _lhsIinstanceTypes
         _hdOisTopLevel = rule960 _lhsIisTopLevel
         _hdOmatchIO = rule961 _lhsImatchIO
         _hdOmoduleName = rule962 _lhsImoduleName
         _hdOmoduleQual = rule963 _lhsImoduleQual
         _hdOmonos = rule964 _lhsImonos
         _hdOnamesInScope = rule965 _lhsInamesInScope
         _hdOorderedTypeSynonyms = rule966 _lhsIorderedTypeSynonyms
         _hdOparentTree = rule967 _lhsIparentTree
         _hdOpatternMatchWarnings = rule968 _lhsIpatternMatchWarnings
         _hdOrequiredPredicates = rule969 _lhsIrequiredPredicates
         _hdOsubstitution = rule970 _lhsIsubstitution
         _hdOtypeConstructors = rule971 _lhsItypeConstructors
         _hdOtypeSignatures = rule972 _lhsItypeSignatures
         _hdOtypeschemeMap = rule973 _lhsItypeschemeMap
         _hdOuniqueChunk = rule974 _lhsIuniqueChunk
         _hdOvariableMapping = rule975 _lhsIvariableMapping
         _tlOallPatterns = rule976 _lhsIallPatterns
         _tlOallTypeSchemes = rule977 _lhsIallTypeSchemes
         _tlOambiguousConflicts = rule978 _lhsIambiguousConflicts
         _tlOavailablePredicates = rule979 _lhsIavailablePredicates
         _tlObetaUnique = rule980 _hdIbetaUnique
         _tlObindingGroups = rule981 _hdIbindingGroups
         _tlOclassEnvironment = rule982 _lhsIclassEnvironment
         _tlOclassMemberEnv = rule983 _lhsIclassMemberEnv
         _tlOclassMemberTypeSchemes = rule984 _lhsIclassMemberTypeSchemes
         _tlOclassNamesEnv = rule985 _lhsIclassNamesEnv
         _tlOclassPredicate = rule986 _lhsIclassPredicate
         _tlOclassTypeSchemes = rule987 _lhsIclassTypeSchemes
         _tlOcollectErrors = rule988 _hdIcollectErrors
         _tlOcollectWarnings = rule989 _hdIcollectWarnings
         _tlOcounter = rule990 _hdIcounter
         _tlOcurClassPred = rule991 _lhsIcurClassPred
         _tlOcurPred = rule992 _lhsIcurPred
         _tlOcurrentChunk = rule993 _lhsIcurrentChunk
         _tlOdictionaryEnvironment = rule994 _hdIdictionaryEnvironment
         _tlOimportEnvironment = rule995 _lhsIimportEnvironment
         _tlOinheritedBDG = rule996 _lhsIinheritedBDG
         _tlOinstanceName = rule997 _lhsIinstanceName
         _tlOinstanceTypes = rule998 _lhsIinstanceTypes
         _tlOisTopLevel = rule999 _lhsIisTopLevel
         _tlOmatchIO = rule1000 _hdImatchIO
         _tlOmoduleName = rule1001 _lhsImoduleName
         _tlOmoduleQual = rule1002 _lhsImoduleQual
         _tlOmonos = rule1003 _lhsImonos
         _tlOnamesInScope = rule1004 _lhsInamesInScope
         _tlOorderedTypeSynonyms = rule1005 _lhsIorderedTypeSynonyms
         _tlOparentTree = rule1006 _lhsIparentTree
         _tlOpatternMatchWarnings = rule1007 _hdIpatternMatchWarnings
         _tlOrequiredPredicates = rule1008 _lhsIrequiredPredicates
         _tlOsubstitution = rule1009 _lhsIsubstitution
         _tlOtypeConstructors = rule1010 _lhsItypeConstructors
         _tlOtypeSignatures = rule1011 _hdItypeSignatures
         _tlOtypeschemeMap = rule1012 _lhsItypeschemeMap
         _tlOuniqueChunk = rule1013 _hdIuniqueChunk
         _tlOvariableMapping = rule1014 _lhsIvariableMapping
         !__result_ = T_Declarations_vOut31 _lhsObetaUnique _lhsObindingGroups _lhsOboundBetas _lhsOclassMemberNames _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOcounter _lhsOdeclVarNames _lhsOdictionaryEnvironment _lhsOinfoTrees _lhsOmatchIO _lhsOpatternMatchWarnings _lhsOrestrictedNames _lhsOself _lhsOsimplePatNames _lhsOtypeMemberBindings _lhsOtypeSignatures _lhsOunboundNames _lhsOuniqueChunk
         in __result_ )
     in C_Declarations_s32 v31
   {-# INLINE rule916 #-}
   rule916 = \ ((_hdIinfoTrees) :: InfoTrees) ((_tlIinfoTrees) :: InfoTrees) ->
                               _hdIinfoTrees ++ _tlIinfoTrees
   {-# INLINE rule917 #-}
   rule917 = \ ((_hdIboundBetas) :: [(Name, Tp, [Tp])]) ((_tlIboundBetas) :: [(Name, Tp, [Tp])]) ->
     ((++) _hdIboundBetas _tlIboundBetas)
   {-# INLINE rule918 #-}
   rule918 = \ ((_hdIclassMemberNames) :: Names) ((_tlIclassMemberNames) :: Names) ->
     ((++) _hdIclassMemberNames _tlIclassMemberNames)
   {-# INLINE rule919 #-}
   rule919 = \ ((_hdIcollectInstances) :: [(Name, Instance)]) ((_tlIcollectInstances) :: [(Name, Instance)]) ->
     _hdIcollectInstances  ++  _tlIcollectInstances
   {-# INLINE rule920 #-}
   rule920 = \ ((_hdIdeclVarNames) :: Names) ((_tlIdeclVarNames) :: Names) ->
     _hdIdeclVarNames ++ _tlIdeclVarNames
   {-# INLINE rule921 #-}
   rule921 = \ ((_hdIrestrictedNames) :: Names) ((_tlIrestrictedNames) :: Names) ->
     _hdIrestrictedNames  ++  _tlIrestrictedNames
   {-# INLINE rule922 #-}
   rule922 = \ ((_hdIsimplePatNames) :: Names) ((_tlIsimplePatNames) :: Names) ->
     _hdIsimplePatNames  ++  _tlIsimplePatNames
   {-# INLINE rule923 #-}
   rule923 = \ ((_hdItypeMemberBindings) :: [(Name, TpScheme)]) ((_tlItypeMemberBindings) :: [(Name, TpScheme)]) ->
     ((++) _hdItypeMemberBindings _tlItypeMemberBindings)
   {-# INLINE rule924 #-}
   rule924 = \ ((_hdIunboundNames) :: Names) ((_tlIunboundNames) :: Names) ->
     ((++) _hdIunboundNames _tlIunboundNames)
   {-# INLINE rule925 #-}
   rule925 = \ ((_hdIself) :: Declaration) ((_tlIself) :: Declarations) ->
     (:) _hdIself _tlIself
   {-# INLINE rule926 #-}
   rule926 = \ _self ->
     _self
   {-# INLINE rule927 #-}
   rule927 = \ ((_tlIbetaUnique) :: Int) ->
     _tlIbetaUnique
   {-# INLINE rule928 #-}
   rule928 = \ ((_tlIbindingGroups) :: BindingGroups) ->
     _tlIbindingGroups
   {-# INLINE rule929 #-}
   rule929 = \ ((_tlIcollectErrors) :: TypeErrors) ->
     _tlIcollectErrors
   {-# INLINE rule930 #-}
   rule930 = \ ((_tlIcollectWarnings) :: Warnings) ->
     _tlIcollectWarnings
   {-# INLINE rule931 #-}
   rule931 = \ ((_tlIcounter) :: Int) ->
     _tlIcounter
   {-# INLINE rule932 #-}
   rule932 = \ ((_tlIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _tlIdictionaryEnvironment
   {-# INLINE rule933 #-}
   rule933 = \ ((_tlImatchIO) :: IO ()) ->
     _tlImatchIO
   {-# INLINE rule934 #-}
   rule934 = \ ((_tlIpatternMatchWarnings) :: [Warning]) ->
     _tlIpatternMatchWarnings
   {-# INLINE rule935 #-}
   rule935 = \ ((_tlItypeSignatures) :: TypeEnvironment) ->
     _tlItypeSignatures
   {-# INLINE rule936 #-}
   rule936 = \ ((_tlIuniqueChunk) :: Int) ->
     _tlIuniqueChunk
   {-# INLINE rule937 #-}
   rule937 = \ ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ->
     _lhsIallPatterns
   {-# INLINE rule938 #-}
   rule938 = \ ((_lhsIallTypeSchemes) :: M.Map NameWithRange TpScheme) ->
     _lhsIallTypeSchemes
   {-# INLINE rule939 #-}
   rule939 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule940 #-}
   rule940 = \ ((_lhsIavailablePredicates) :: [PredicateWithSource]) ->
     _lhsIavailablePredicates
   {-# INLINE rule941 #-}
   rule941 = \ ((_lhsIbetaUnique) :: Int) ->
     _lhsIbetaUnique
   {-# INLINE rule942 #-}
   rule942 = \ ((_lhsIbindingGroups) :: BindingGroups) ->
     _lhsIbindingGroups
   {-# INLINE rule943 #-}
   rule943 = \ ((_lhsIclassEnvironment) :: ClassEnvironment) ->
     _lhsIclassEnvironment
   {-# INLINE rule944 #-}
   rule944 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule945 #-}
   rule945 = \ ((_lhsIclassMemberTypeSchemes) :: Maybe [(Name, TpScheme)]) ->
     _lhsIclassMemberTypeSchemes
   {-# INLINE rule946 #-}
   rule946 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule947 #-}
   rule947 = \ ((_lhsIclassPredicate) :: Maybe (Name, Names)) ->
     _lhsIclassPredicate
   {-# INLINE rule948 #-}
   rule948 = \ ((_lhsIclassTypeSchemes) :: M.Map Name TpScheme) ->
     _lhsIclassTypeSchemes
   {-# INLINE rule949 #-}
   rule949 = \ ((_lhsIcollectErrors) :: TypeErrors) ->
     _lhsIcollectErrors
   {-# INLINE rule950 #-}
   rule950 = \ ((_lhsIcollectWarnings) :: Warnings) ->
     _lhsIcollectWarnings
   {-# INLINE rule951 #-}
   rule951 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule952 #-}
   rule952 = \ ((_lhsIcurClassPred) :: Maybe Predicate) ->
     _lhsIcurClassPred
   {-# INLINE rule953 #-}
   rule953 = \ ((_lhsIcurPred) :: Maybe Predicate) ->
     _lhsIcurPred
   {-# INLINE rule954 #-}
   rule954 = \ ((_lhsIcurrentChunk) :: Int) ->
     _lhsIcurrentChunk
   {-# INLINE rule955 #-}
   rule955 = \ ((_lhsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _lhsIdictionaryEnvironment
   {-# INLINE rule956 #-}
   rule956 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule957 #-}
   rule957 = \ ((_lhsIinheritedBDG) :: InheritedBDG) ->
     _lhsIinheritedBDG
   {-# INLINE rule958 #-}
   rule958 = \ ((_lhsIinstanceName) :: Maybe Name) ->
     _lhsIinstanceName
   {-# INLINE rule959 #-}
   rule959 = \ ((_lhsIinstanceTypes) :: [(Name, TpScheme)]) ->
     _lhsIinstanceTypes
   {-# INLINE rule960 #-}
   rule960 = \ ((_lhsIisTopLevel) :: Bool) ->
     _lhsIisTopLevel
   {-# INLINE rule961 #-}
   rule961 = \ ((_lhsImatchIO) :: IO ()) ->
     _lhsImatchIO
   {-# INLINE rule962 #-}
   rule962 = \ ((_lhsImoduleName) :: Maybe Name) ->
     _lhsImoduleName
   {-# INLINE rule963 #-}
   rule963 = \ ((_lhsImoduleQual) ::  [String] ) ->
     _lhsImoduleQual
   {-# INLINE rule964 #-}
   rule964 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule965 #-}
   rule965 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule966 #-}
   rule966 = \ ((_lhsIorderedTypeSynonyms) :: OrderedTypeSynonyms) ->
     _lhsIorderedTypeSynonyms
   {-# INLINE rule967 #-}
   rule967 = \ ((_lhsIparentTree) :: InfoTree) ->
     _lhsIparentTree
   {-# INLINE rule968 #-}
   rule968 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule969 #-}
   rule969 = \ ((_lhsIrequiredPredicates) :: Predicates) ->
     _lhsIrequiredPredicates
   {-# INLINE rule970 #-}
   rule970 = \ ((_lhsIsubstitution) :: FixpointSubstitution) ->
     _lhsIsubstitution
   {-# INLINE rule971 #-}
   rule971 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
   {-# INLINE rule972 #-}
   rule972 = \ ((_lhsItypeSignatures) :: TypeEnvironment) ->
     _lhsItypeSignatures
   {-# INLINE rule973 #-}
   rule973 = \ ((_lhsItypeschemeMap) :: M.Map Int (Scheme Predicates)) ->
     _lhsItypeschemeMap
   {-# INLINE rule974 #-}
   rule974 = \ ((_lhsIuniqueChunk) :: Int) ->
     _lhsIuniqueChunk
   {-# INLINE rule975 #-}
   rule975 = \ ((_lhsIvariableMapping) :: Maybe [(Name, Tp)]) ->
     _lhsIvariableMapping
   {-# INLINE rule976 #-}
   rule976 = \ ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ->
     _lhsIallPatterns
   {-# INLINE rule977 #-}
   rule977 = \ ((_lhsIallTypeSchemes) :: M.Map NameWithRange TpScheme) ->
     _lhsIallTypeSchemes
   {-# INLINE rule978 #-}
   rule978 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule979 #-}
   rule979 = \ ((_lhsIavailablePredicates) :: [PredicateWithSource]) ->
     _lhsIavailablePredicates
   {-# INLINE rule980 #-}
   rule980 = \ ((_hdIbetaUnique) :: Int) ->
     _hdIbetaUnique
   {-# INLINE rule981 #-}
   rule981 = \ ((_hdIbindingGroups) :: BindingGroups) ->
     _hdIbindingGroups
   {-# INLINE rule982 #-}
   rule982 = \ ((_lhsIclassEnvironment) :: ClassEnvironment) ->
     _lhsIclassEnvironment
   {-# INLINE rule983 #-}
   rule983 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule984 #-}
   rule984 = \ ((_lhsIclassMemberTypeSchemes) :: Maybe [(Name, TpScheme)]) ->
     _lhsIclassMemberTypeSchemes
   {-# INLINE rule985 #-}
   rule985 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule986 #-}
   rule986 = \ ((_lhsIclassPredicate) :: Maybe (Name, Names)) ->
     _lhsIclassPredicate
   {-# INLINE rule987 #-}
   rule987 = \ ((_lhsIclassTypeSchemes) :: M.Map Name TpScheme) ->
     _lhsIclassTypeSchemes
   {-# INLINE rule988 #-}
   rule988 = \ ((_hdIcollectErrors) :: TypeErrors) ->
     _hdIcollectErrors
   {-# INLINE rule989 #-}
   rule989 = \ ((_hdIcollectWarnings) :: Warnings) ->
     _hdIcollectWarnings
   {-# INLINE rule990 #-}
   rule990 = \ ((_hdIcounter) :: Int) ->
     _hdIcounter
   {-# INLINE rule991 #-}
   rule991 = \ ((_lhsIcurClassPred) :: Maybe Predicate) ->
     _lhsIcurClassPred
   {-# INLINE rule992 #-}
   rule992 = \ ((_lhsIcurPred) :: Maybe Predicate) ->
     _lhsIcurPred
   {-# INLINE rule993 #-}
   rule993 = \ ((_lhsIcurrentChunk) :: Int) ->
     _lhsIcurrentChunk
   {-# INLINE rule994 #-}
   rule994 = \ ((_hdIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _hdIdictionaryEnvironment
   {-# INLINE rule995 #-}
   rule995 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule996 #-}
   rule996 = \ ((_lhsIinheritedBDG) :: InheritedBDG) ->
     _lhsIinheritedBDG
   {-# INLINE rule997 #-}
   rule997 = \ ((_lhsIinstanceName) :: Maybe Name) ->
     _lhsIinstanceName
   {-# INLINE rule998 #-}
   rule998 = \ ((_lhsIinstanceTypes) :: [(Name, TpScheme)]) ->
     _lhsIinstanceTypes
   {-# INLINE rule999 #-}
   rule999 = \ ((_lhsIisTopLevel) :: Bool) ->
     _lhsIisTopLevel
   {-# INLINE rule1000 #-}
   rule1000 = \ ((_hdImatchIO) :: IO ()) ->
     _hdImatchIO
   {-# INLINE rule1001 #-}
   rule1001 = \ ((_lhsImoduleName) :: Maybe Name) ->
     _lhsImoduleName
   {-# INLINE rule1002 #-}
   rule1002 = \ ((_lhsImoduleQual) ::  [String] ) ->
     _lhsImoduleQual
   {-# INLINE rule1003 #-}
   rule1003 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule1004 #-}
   rule1004 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule1005 #-}
   rule1005 = \ ((_lhsIorderedTypeSynonyms) :: OrderedTypeSynonyms) ->
     _lhsIorderedTypeSynonyms
   {-# INLINE rule1006 #-}
   rule1006 = \ ((_lhsIparentTree) :: InfoTree) ->
     _lhsIparentTree
   {-# INLINE rule1007 #-}
   rule1007 = \ ((_hdIpatternMatchWarnings) :: [Warning]) ->
     _hdIpatternMatchWarnings
   {-# INLINE rule1008 #-}
   rule1008 = \ ((_lhsIrequiredPredicates) :: Predicates) ->
     _lhsIrequiredPredicates
   {-# INLINE rule1009 #-}
   rule1009 = \ ((_lhsIsubstitution) :: FixpointSubstitution) ->
     _lhsIsubstitution
   {-# INLINE rule1010 #-}
   rule1010 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
   {-# INLINE rule1011 #-}
   rule1011 = \ ((_hdItypeSignatures) :: TypeEnvironment) ->
     _hdItypeSignatures
   {-# INLINE rule1012 #-}
   rule1012 = \ ((_lhsItypeschemeMap) :: M.Map Int (Scheme Predicates)) ->
     _lhsItypeschemeMap
   {-# INLINE rule1013 #-}
   rule1013 = \ ((_hdIuniqueChunk) :: Int) ->
     _hdIuniqueChunk
   {-# INLINE rule1014 #-}
   rule1014 = \ ((_lhsIvariableMapping) :: Maybe [(Name, Tp)]) ->
     _lhsIvariableMapping
{-# NOINLINE sem_Declarations_Nil #-}
sem_Declarations_Nil ::  T_Declarations 
sem_Declarations_Nil  = T_Declarations (return st32) where
   {-# NOINLINE st32 #-}
   !st32 = let
      v31 :: T_Declarations_v31 
      v31 = \ !(T_Declarations_vIn31 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaUnique _lhsIbindingGroups _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinheritedBDG _lhsIinstanceName _lhsIinstanceTypes _lhsIisTopLevel _lhsImatchIO _lhsImoduleName _lhsImoduleQual _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeConstructors _lhsItypeSignatures _lhsItypeschemeMap _lhsIuniqueChunk _lhsIvariableMapping) -> ( let
         _lhsOinfoTrees :: InfoTrees
         _lhsOinfoTrees = rule1015  ()
         _lhsOboundBetas :: [(Name, Tp, [Tp])]
         _lhsOboundBetas = rule1016  ()
         _lhsOclassMemberNames :: Names
         _lhsOclassMemberNames = rule1017  ()
         _lhsOcollectInstances :: [(Name, Instance)]
         _lhsOcollectInstances = rule1018  ()
         _lhsOdeclVarNames :: Names
         _lhsOdeclVarNames = rule1019  ()
         _lhsOrestrictedNames :: Names
         _lhsOrestrictedNames = rule1020  ()
         _lhsOsimplePatNames :: Names
         _lhsOsimplePatNames = rule1021  ()
         _lhsOtypeMemberBindings :: [(Name, TpScheme)]
         _lhsOtypeMemberBindings = rule1022  ()
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule1023  ()
         _self = rule1024  ()
         _lhsOself :: Declarations
         _lhsOself = rule1025 _self
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule1026 _lhsIbetaUnique
         _lhsObindingGroups :: BindingGroups
         _lhsObindingGroups = rule1027 _lhsIbindingGroups
         _lhsOcollectErrors :: TypeErrors
         _lhsOcollectErrors = rule1028 _lhsIcollectErrors
         _lhsOcollectWarnings :: Warnings
         _lhsOcollectWarnings = rule1029 _lhsIcollectWarnings
         _lhsOcounter :: Int
         _lhsOcounter = rule1030 _lhsIcounter
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule1031 _lhsIdictionaryEnvironment
         _lhsOmatchIO :: IO ()
         _lhsOmatchIO = rule1032 _lhsImatchIO
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule1033 _lhsIpatternMatchWarnings
         _lhsOtypeSignatures :: TypeEnvironment
         _lhsOtypeSignatures = rule1034 _lhsItypeSignatures
         _lhsOuniqueChunk :: Int
         _lhsOuniqueChunk = rule1035 _lhsIuniqueChunk
         !__result_ = T_Declarations_vOut31 _lhsObetaUnique _lhsObindingGroups _lhsOboundBetas _lhsOclassMemberNames _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOcounter _lhsOdeclVarNames _lhsOdictionaryEnvironment _lhsOinfoTrees _lhsOmatchIO _lhsOpatternMatchWarnings _lhsOrestrictedNames _lhsOself _lhsOsimplePatNames _lhsOtypeMemberBindings _lhsOtypeSignatures _lhsOunboundNames _lhsOuniqueChunk
         in __result_ )
     in C_Declarations_s32 v31
   {-# INLINE rule1015 #-}
   rule1015 = \  (_ :: ()) ->
                               []
   {-# INLINE rule1016 #-}
   rule1016 = \  (_ :: ()) ->
     []
   {-# INLINE rule1017 #-}
   rule1017 = \  (_ :: ()) ->
     []
   {-# INLINE rule1018 #-}
   rule1018 = \  (_ :: ()) ->
     []
   {-# INLINE rule1019 #-}
   rule1019 = \  (_ :: ()) ->
     []
   {-# INLINE rule1020 #-}
   rule1020 = \  (_ :: ()) ->
     []
   {-# INLINE rule1021 #-}
   rule1021 = \  (_ :: ()) ->
     []
   {-# INLINE rule1022 #-}
   rule1022 = \  (_ :: ()) ->
     []
   {-# INLINE rule1023 #-}
   rule1023 = \  (_ :: ()) ->
     []
   {-# INLINE rule1024 #-}
   rule1024 = \  (_ :: ()) ->
     []
   {-# INLINE rule1025 #-}
   rule1025 = \ _self ->
     _self
   {-# INLINE rule1026 #-}
   rule1026 = \ ((_lhsIbetaUnique) :: Int) ->
     _lhsIbetaUnique
   {-# INLINE rule1027 #-}
   rule1027 = \ ((_lhsIbindingGroups) :: BindingGroups) ->
     _lhsIbindingGroups
   {-# INLINE rule1028 #-}
   rule1028 = \ ((_lhsIcollectErrors) :: TypeErrors) ->
     _lhsIcollectErrors
   {-# INLINE rule1029 #-}
   rule1029 = \ ((_lhsIcollectWarnings) :: Warnings) ->
     _lhsIcollectWarnings
   {-# INLINE rule1030 #-}
   rule1030 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule1031 #-}
   rule1031 = \ ((_lhsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _lhsIdictionaryEnvironment
   {-# INLINE rule1032 #-}
   rule1032 = \ ((_lhsImatchIO) :: IO ()) ->
     _lhsImatchIO
   {-# INLINE rule1033 #-}
   rule1033 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule1034 #-}
   rule1034 = \ ((_lhsItypeSignatures) :: TypeEnvironment) ->
     _lhsItypeSignatures
   {-# INLINE rule1035 #-}
   rule1035 = \ ((_lhsIuniqueChunk) :: Int) ->
     _lhsIuniqueChunk

-- Export ------------------------------------------------------
-- wrapper
data Inh_Export  = Inh_Export {  }
data Syn_Export  = Syn_Export { self_Syn_Export :: !(Export) }
{-# INLINABLE wrap_Export #-}
wrap_Export :: T_Export  -> Inh_Export  -> (Syn_Export )
wrap_Export !(T_Export act) !(Inh_Export ) =
   Control.Monad.Identity.runIdentity (
     do !sem <- act
        let arg34 = T_Export_vIn34 
        !(T_Export_vOut34 _lhsOself) <- return (inv_Export_s35 sem arg34)
        return (Syn_Export _lhsOself)
   )

-- cata
{-# NOINLINE sem_Export #-}
sem_Export :: Export  -> T_Export 
sem_Export ( Export_Variable range_ name_ ) = sem_Export_Variable ( sem_Range range_ ) ( sem_Name name_ )
sem_Export ( Export_TypeOrClass range_ name_ names_ ) = sem_Export_TypeOrClass ( sem_Range range_ ) ( sem_Name name_ ) ( sem_MaybeNames names_ )
sem_Export ( Export_TypeOrClassComplete range_ name_ ) = sem_Export_TypeOrClassComplete ( sem_Range range_ ) ( sem_Name name_ )
sem_Export ( Export_Module range_ name_ ) = sem_Export_Module ( sem_Range range_ ) ( sem_Name name_ )

-- semantic domain
newtype T_Export  = T_Export {
                             attach_T_Export :: Identity (T_Export_s35 )
                             }
newtype T_Export_s35  = C_Export_s35 {
                                     inv_Export_s35 :: (T_Export_v34 )
                                     }
data T_Export_s36  = C_Export_s36
type T_Export_v34  = (T_Export_vIn34 ) -> (T_Export_vOut34 )
data T_Export_vIn34  = T_Export_vIn34 
data T_Export_vOut34  = T_Export_vOut34 (Export)
{-# NOINLINE sem_Export_Variable #-}
sem_Export_Variable :: T_Range  -> T_Name  -> T_Export 
sem_Export_Variable arg_range_ arg_name_ = T_Export (return st35) where
   {-# NOINLINE st35 #-}
   !st35 = let
      v34 :: T_Export_v34 
      v34 = \ !(T_Export_vIn34 ) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _nameX113 = Control.Monad.Identity.runIdentity (attach_T_Name (arg_name_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_Name_vOut112 _nameIself) = inv_Name_s113 _nameX113 (T_Name_vIn112 )
         _self = rule1036 _nameIself _rangeIself
         _lhsOself :: Export
         _lhsOself = rule1037 _self
         !__result_ = T_Export_vOut34 _lhsOself
         in __result_ )
     in C_Export_s35 v34
   {-# INLINE rule1036 #-}
   rule1036 = \ ((_nameIself) :: Name) ((_rangeIself) :: Range) ->
     Export_Variable _rangeIself _nameIself
   {-# INLINE rule1037 #-}
   rule1037 = \ _self ->
     _self
{-# NOINLINE sem_Export_TypeOrClass #-}
sem_Export_TypeOrClass :: T_Range  -> T_Name  -> T_MaybeNames  -> T_Export 
sem_Export_TypeOrClass arg_range_ arg_name_ arg_names_ = T_Export (return st35) where
   {-# NOINLINE st35 #-}
   !st35 = let
      v34 :: T_Export_v34 
      v34 = \ !(T_Export_vIn34 ) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _nameX113 = Control.Monad.Identity.runIdentity (attach_T_Name (arg_name_))
         _namesX107 = Control.Monad.Identity.runIdentity (attach_T_MaybeNames (arg_names_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_Name_vOut112 _nameIself) = inv_Name_s113 _nameX113 (T_Name_vIn112 )
         (T_MaybeNames_vOut106 _namesIself) = inv_MaybeNames_s107 _namesX107 (T_MaybeNames_vIn106 )
         _self = rule1038 _nameIself _namesIself _rangeIself
         _lhsOself :: Export
         _lhsOself = rule1039 _self
         !__result_ = T_Export_vOut34 _lhsOself
         in __result_ )
     in C_Export_s35 v34
   {-# INLINE rule1038 #-}
   rule1038 = \ ((_nameIself) :: Name) ((_namesIself) :: MaybeNames) ((_rangeIself) :: Range) ->
     Export_TypeOrClass _rangeIself _nameIself _namesIself
   {-# INLINE rule1039 #-}
   rule1039 = \ _self ->
     _self
{-# NOINLINE sem_Export_TypeOrClassComplete #-}
sem_Export_TypeOrClassComplete :: T_Range  -> T_Name  -> T_Export 
sem_Export_TypeOrClassComplete arg_range_ arg_name_ = T_Export (return st35) where
   {-# NOINLINE st35 #-}
   !st35 = let
      v34 :: T_Export_v34 
      v34 = \ !(T_Export_vIn34 ) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _nameX113 = Control.Monad.Identity.runIdentity (attach_T_Name (arg_name_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_Name_vOut112 _nameIself) = inv_Name_s113 _nameX113 (T_Name_vIn112 )
         _self = rule1040 _nameIself _rangeIself
         _lhsOself :: Export
         _lhsOself = rule1041 _self
         !__result_ = T_Export_vOut34 _lhsOself
         in __result_ )
     in C_Export_s35 v34
   {-# INLINE rule1040 #-}
   rule1040 = \ ((_nameIself) :: Name) ((_rangeIself) :: Range) ->
     Export_TypeOrClassComplete _rangeIself _nameIself
   {-# INLINE rule1041 #-}
   rule1041 = \ _self ->
     _self
{-# NOINLINE sem_Export_Module #-}
sem_Export_Module :: T_Range  -> T_Name  -> T_Export 
sem_Export_Module arg_range_ arg_name_ = T_Export (return st35) where
   {-# NOINLINE st35 #-}
   !st35 = let
      v34 :: T_Export_v34 
      v34 = \ !(T_Export_vIn34 ) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _nameX113 = Control.Monad.Identity.runIdentity (attach_T_Name (arg_name_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_Name_vOut112 _nameIself) = inv_Name_s113 _nameX113 (T_Name_vIn112 )
         _self = rule1042 _nameIself _rangeIself
         _lhsOself :: Export
         _lhsOself = rule1043 _self
         !__result_ = T_Export_vOut34 _lhsOself
         in __result_ )
     in C_Export_s35 v34
   {-# INLINE rule1042 #-}
   rule1042 = \ ((_nameIself) :: Name) ((_rangeIself) :: Range) ->
     Export_Module _rangeIself _nameIself
   {-# INLINE rule1043 #-}
   rule1043 = \ _self ->
     _self

-- Exports -----------------------------------------------------
-- wrapper
data Inh_Exports  = Inh_Exports {  }
data Syn_Exports  = Syn_Exports { self_Syn_Exports :: !(Exports) }
{-# INLINABLE wrap_Exports #-}
wrap_Exports :: T_Exports  -> Inh_Exports  -> (Syn_Exports )
wrap_Exports !(T_Exports act) !(Inh_Exports ) =
   Control.Monad.Identity.runIdentity (
     do !sem <- act
        let arg37 = T_Exports_vIn37 
        !(T_Exports_vOut37 _lhsOself) <- return (inv_Exports_s38 sem arg37)
        return (Syn_Exports _lhsOself)
   )

-- cata
{-# NOINLINE sem_Exports #-}
sem_Exports :: Exports  -> T_Exports 
sem_Exports list = Prelude.foldr sem_Exports_Cons sem_Exports_Nil (Prelude.map sem_Export list)

-- semantic domain
newtype T_Exports  = T_Exports {
                               attach_T_Exports :: Identity (T_Exports_s38 )
                               }
newtype T_Exports_s38  = C_Exports_s38 {
                                       inv_Exports_s38 :: (T_Exports_v37 )
                                       }
data T_Exports_s39  = C_Exports_s39
type T_Exports_v37  = (T_Exports_vIn37 ) -> (T_Exports_vOut37 )
data T_Exports_vIn37  = T_Exports_vIn37 
data T_Exports_vOut37  = T_Exports_vOut37 (Exports)
{-# NOINLINE sem_Exports_Cons #-}
sem_Exports_Cons :: T_Export  -> T_Exports  -> T_Exports 
sem_Exports_Cons arg_hd_ arg_tl_ = T_Exports (return st38) where
   {-# NOINLINE st38 #-}
   !st38 = let
      v37 :: T_Exports_v37 
      v37 = \ !(T_Exports_vIn37 ) -> ( let
         _hdX35 = Control.Monad.Identity.runIdentity (attach_T_Export (arg_hd_))
         _tlX38 = Control.Monad.Identity.runIdentity (attach_T_Exports (arg_tl_))
         (T_Export_vOut34 _hdIself) = inv_Export_s35 _hdX35 (T_Export_vIn34 )
         (T_Exports_vOut37 _tlIself) = inv_Exports_s38 _tlX38 (T_Exports_vIn37 )
         _self = rule1044 _hdIself _tlIself
         _lhsOself :: Exports
         _lhsOself = rule1045 _self
         !__result_ = T_Exports_vOut37 _lhsOself
         in __result_ )
     in C_Exports_s38 v37
   {-# INLINE rule1044 #-}
   rule1044 = \ ((_hdIself) :: Export) ((_tlIself) :: Exports) ->
     (:) _hdIself _tlIself
   {-# INLINE rule1045 #-}
   rule1045 = \ _self ->
     _self
{-# NOINLINE sem_Exports_Nil #-}
sem_Exports_Nil ::  T_Exports 
sem_Exports_Nil  = T_Exports (return st38) where
   {-# NOINLINE st38 #-}
   !st38 = let
      v37 :: T_Exports_v37 
      v37 = \ !(T_Exports_vIn37 ) -> ( let
         _self = rule1046  ()
         _lhsOself :: Exports
         _lhsOself = rule1047 _self
         !__result_ = T_Exports_vOut37 _lhsOself
         in __result_ )
     in C_Exports_s38 v37
   {-# INLINE rule1046 #-}
   rule1046 = \  (_ :: ()) ->
     []
   {-# INLINE rule1047 #-}
   rule1047 = \ _self ->
     _self

-- Expression --------------------------------------------------
-- wrapper
data Inh_Expression  = Inh_Expression { allPatterns_Inh_Expression :: !([((Expression, [String]), Core_TypingStrategy)]), allTypeSchemes_Inh_Expression :: !(M.Map NameWithRange TpScheme), ambiguousConflicts_Inh_Expression :: !([[Name]]), availablePredicates_Inh_Expression :: !([PredicateWithSource]), betaUnique_Inh_Expression :: !(Int), classEnvironment_Inh_Expression :: !(ClassEnvironment), classMemberEnv_Inh_Expression :: !(ClassMemberEnvironment), classMemberTypeSchemes_Inh_Expression :: !(Maybe [(Name, TpScheme)]), classNamesEnv_Inh_Expression :: !(ClassNameEnvironment), classPredicate_Inh_Expression :: !(Maybe (Name, Names)), classTypeSchemes_Inh_Expression :: !(M.Map Name TpScheme), collectErrors_Inh_Expression :: !(TypeErrors), collectWarnings_Inh_Expression :: !(Warnings), counter_Inh_Expression :: !(Int), curClassPred_Inh_Expression :: !(Maybe Predicate), curPred_Inh_Expression :: !(Maybe Predicate), currentChunk_Inh_Expression :: !(Int), dictionaryEnvironment_Inh_Expression :: !(DictionaryEnvironment), importEnvironment_Inh_Expression :: !(ImportEnvironment), instanceName_Inh_Expression :: !(Maybe Name), instanceTypes_Inh_Expression :: !([(Name, TpScheme)]), matchIO_Inh_Expression :: !(IO ()), moduleName_Inh_Expression :: !(Maybe Name), monos_Inh_Expression :: !(Monos), namesInScope_Inh_Expression :: !(Names), orderedTypeSynonyms_Inh_Expression :: !(OrderedTypeSynonyms), parentTree_Inh_Expression :: !(InfoTree), patternMatchWarnings_Inh_Expression :: !([Warning]), requiredPredicates_Inh_Expression :: !(Predicates), substitution_Inh_Expression :: !(FixpointSubstitution), tryPatterns_Inh_Expression :: !([(Expression     , [String])]), typeConstructors_Inh_Expression :: !(TypeConstructorEnvironment), typeschemeMap_Inh_Expression :: !(M.Map Int (Scheme Predicates)), uniqueChunk_Inh_Expression :: !(Int), uniqueSecondRound_Inh_Expression :: !(Int), variableMapping_Inh_Expression :: !(Maybe [(Name, Tp)]) }
data Syn_Expression  = Syn_Expression { assumptions_Syn_Expression :: !(Assumptions), beta_Syn_Expression :: !(Tp), betaUnique_Syn_Expression :: !(Int), collectErrors_Syn_Expression :: !(TypeErrors), collectInstances_Syn_Expression :: !([(Name, Instance)]), collectWarnings_Syn_Expression :: !(Warnings), constraints_Syn_Expression :: !(ConstraintSet), counter_Syn_Expression :: !(Int), dictionaryEnvironment_Syn_Expression :: !(DictionaryEnvironment), infoTree_Syn_Expression :: !(InfoTree), matchIO_Syn_Expression :: !(IO ()), matches_Syn_Expression :: !([Maybe MetaVariableTable]), patternMatchWarnings_Syn_Expression :: !([Warning]), self_Syn_Expression :: !(Expression), unboundNames_Syn_Expression :: !(Names), uniqueChunk_Syn_Expression :: !(Int), uniqueSecondRound_Syn_Expression :: !(Int) }
{-# INLINABLE wrap_Expression #-}
wrap_Expression :: T_Expression  -> Inh_Expression  -> (Syn_Expression )
wrap_Expression !(T_Expression act) !(Inh_Expression _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItryPatterns _lhsItypeConstructors _lhsItypeschemeMap _lhsIuniqueChunk _lhsIuniqueSecondRound _lhsIvariableMapping) =
   Control.Monad.Identity.runIdentity (
     do !sem <- act
        let arg40 = T_Expression_vIn40 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItryPatterns _lhsItypeConstructors _lhsItypeschemeMap _lhsIuniqueChunk _lhsIuniqueSecondRound _lhsIvariableMapping
        !(T_Expression_vOut40 _lhsOassumptions _lhsObeta _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraints _lhsOcounter _lhsOdictionaryEnvironment _lhsOinfoTree _lhsOmatchIO _lhsOmatches _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOuniqueSecondRound) <- return (inv_Expression_s41 sem arg40)
        return (Syn_Expression _lhsOassumptions _lhsObeta _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraints _lhsOcounter _lhsOdictionaryEnvironment _lhsOinfoTree _lhsOmatchIO _lhsOmatches _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOuniqueSecondRound)
   )

-- cata
{-# NOINLINE sem_Expression #-}
sem_Expression :: Expression  -> T_Expression 
sem_Expression ( Expression_Hole range_ !id_ ) = sem_Expression_Hole ( sem_Range range_ ) id_
sem_Expression ( Expression_Feedback range_ !feedback_ expression_ ) = sem_Expression_Feedback ( sem_Range range_ ) feedback_ ( sem_Expression expression_ )
sem_Expression ( Expression_MustUse range_ expression_ ) = sem_Expression_MustUse ( sem_Range range_ ) ( sem_Expression expression_ )
sem_Expression ( Expression_Eta range_ !expansion_ expression_ ) = sem_Expression_Eta ( sem_Range range_ ) expansion_ ( sem_Expression expression_ )
sem_Expression ( Expression_Literal range_ literal_ ) = sem_Expression_Literal ( sem_Range range_ ) ( sem_Literal literal_ )
sem_Expression ( Expression_Variable range_ name_ ) = sem_Expression_Variable ( sem_Range range_ ) ( sem_Name name_ )
sem_Expression ( Expression_Constructor range_ name_ ) = sem_Expression_Constructor ( sem_Range range_ ) ( sem_Name name_ )
sem_Expression ( Expression_Parenthesized range_ expression_ ) = sem_Expression_Parenthesized ( sem_Range range_ ) ( sem_Expression expression_ )
sem_Expression ( Expression_NormalApplication range_ function_ arguments_ ) = sem_Expression_NormalApplication ( sem_Range range_ ) ( sem_Expression function_ ) ( sem_Expressions arguments_ )
sem_Expression ( Expression_InfixApplication range_ leftExpression_ operator_ rightExpression_ ) = sem_Expression_InfixApplication ( sem_Range range_ ) ( sem_MaybeExpression leftExpression_ ) ( sem_Expression operator_ ) ( sem_MaybeExpression rightExpression_ )
sem_Expression ( Expression_If range_ guardExpression_ thenExpression_ elseExpression_ ) = sem_Expression_If ( sem_Range range_ ) ( sem_Expression guardExpression_ ) ( sem_Expression thenExpression_ ) ( sem_Expression elseExpression_ )
sem_Expression ( Expression_Lambda range_ patterns_ expression_ ) = sem_Expression_Lambda ( sem_Range range_ ) ( sem_Patterns patterns_ ) ( sem_Expression expression_ )
sem_Expression ( Expression_Case range_ expression_ alternatives_ ) = sem_Expression_Case ( sem_Range range_ ) ( sem_Expression expression_ ) ( sem_Alternatives alternatives_ )
sem_Expression ( Expression_Let range_ declarations_ expression_ ) = sem_Expression_Let ( sem_Range range_ ) ( sem_Declarations declarations_ ) ( sem_Expression expression_ )
sem_Expression ( Expression_Do range_ statements_ ) = sem_Expression_Do ( sem_Range range_ ) ( sem_Statements statements_ )
sem_Expression ( Expression_List range_ expressions_ ) = sem_Expression_List ( sem_Range range_ ) ( sem_Expressions expressions_ )
sem_Expression ( Expression_Tuple range_ expressions_ ) = sem_Expression_Tuple ( sem_Range range_ ) ( sem_Expressions expressions_ )
sem_Expression ( Expression_Comprehension range_ expression_ qualifiers_ ) = sem_Expression_Comprehension ( sem_Range range_ ) ( sem_Expression expression_ ) ( sem_Qualifiers qualifiers_ )
sem_Expression ( Expression_Typed range_ expression_ type_ ) = sem_Expression_Typed ( sem_Range range_ ) ( sem_Expression expression_ ) ( sem_Type type_ )
sem_Expression ( Expression_RecordConstruction range_ name_ recordExpressionBindings_ ) = sem_Expression_RecordConstruction ( sem_Range range_ ) ( sem_Name name_ ) ( sem_RecordExpressionBindings recordExpressionBindings_ )
sem_Expression ( Expression_RecordUpdate range_ expression_ recordExpressionBindings_ ) = sem_Expression_RecordUpdate ( sem_Range range_ ) ( sem_Expression expression_ ) ( sem_RecordExpressionBindings recordExpressionBindings_ )
sem_Expression ( Expression_Enum range_ from_ then_ to_ ) = sem_Expression_Enum ( sem_Range range_ ) ( sem_Expression from_ ) ( sem_MaybeExpression then_ ) ( sem_MaybeExpression to_ )
sem_Expression ( Expression_Negate range_ expression_ ) = sem_Expression_Negate ( sem_Range range_ ) ( sem_Expression expression_ )
sem_Expression ( Expression_NegateFloat range_ expression_ ) = sem_Expression_NegateFloat ( sem_Range range_ ) ( sem_Expression expression_ )

-- semantic domain
newtype T_Expression  = T_Expression {
                                     attach_T_Expression :: Identity (T_Expression_s41 )
                                     }
newtype T_Expression_s41  = C_Expression_s41 {
                                             inv_Expression_s41 :: (T_Expression_v40 )
                                             }
data T_Expression_s42  = C_Expression_s42
type T_Expression_v40  = (T_Expression_vIn40 ) -> (T_Expression_vOut40 )
data T_Expression_vIn40  = T_Expression_vIn40 ([((Expression, [String]), Core_TypingStrategy)]) (M.Map NameWithRange TpScheme) ([[Name]]) ([PredicateWithSource]) (Int) (ClassEnvironment) (ClassMemberEnvironment) (Maybe [(Name, TpScheme)]) (ClassNameEnvironment) (Maybe (Name, Names)) (M.Map Name TpScheme) (TypeErrors) (Warnings) (Int) (Maybe Predicate) (Maybe Predicate) (Int) (DictionaryEnvironment) (ImportEnvironment) (Maybe Name) ([(Name, TpScheme)]) (IO ()) (Maybe Name) (Monos) (Names) (OrderedTypeSynonyms) (InfoTree) ([Warning]) (Predicates) (FixpointSubstitution) ([(Expression     , [String])]) (TypeConstructorEnvironment) (M.Map Int (Scheme Predicates)) (Int) (Int) (Maybe [(Name, Tp)])
data T_Expression_vOut40  = T_Expression_vOut40 (Assumptions) (Tp) (Int) (TypeErrors) ([(Name, Instance)]) (Warnings) (ConstraintSet) (Int) (DictionaryEnvironment) (InfoTree) (IO ()) ([Maybe MetaVariableTable]) ([Warning]) (Expression) (Names) (Int) (Int)
{-# NOINLINE sem_Expression_Hole #-}
sem_Expression_Hole :: T_Range  -> (String) -> T_Expression 
sem_Expression_Hole arg_range_ !arg_id_ = T_Expression (return st41) where
   {-# NOINLINE st41 #-}
   !st41 = let
      v40 :: T_Expression_v40 
      v40 = \ !(T_Expression_vIn40 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItryPatterns _lhsItypeConstructors _lhsItypeschemeMap _lhsIuniqueChunk _lhsIuniqueSecondRound _lhsIvariableMapping) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         _lhsOmatches :: [Maybe MetaVariableTable]
         _lhsOconstraints :: ConstraintSet
         _lhsOassumptions :: Assumptions
         _lhsOuniqueSecondRound :: Int
         ((),_lhsOmatches,_lhsOconstraints,_lhsOassumptions,_lhsOuniqueSecondRound,_ioMatch) = rule1048 _assumptions _constraints _lhsIallPatterns _lhsItryPatterns _lhsIuniqueSecondRound _localInfo
         _parentTree = rule1049 _lhsIparentTree _localInfo
         _lhsOinfoTree :: InfoTree
         _lhsOinfoTree = rule1050 _parentTree
         _localInfo = rule1051 _beta _lhsImonos _self
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule1052 _lhsIbetaUnique
         _assumptions = rule1053  ()
         _constraints = rule1054  ()
         _beta = rule1055 _lhsIbetaUnique
         _lhsOcollectInstances :: [(Name, Instance)]
         _lhsOcollectInstances = rule1056  ()
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule1057  ()
         _self = rule1058 _rangeIself arg_id_
         _lhsOself :: Expression
         _lhsOself = rule1059 _self
         _lhsObeta :: Tp
         _lhsObeta = rule1060 _beta
         _lhsOcollectErrors :: TypeErrors
         _lhsOcollectErrors = rule1061 _lhsIcollectErrors
         _lhsOcollectWarnings :: Warnings
         _lhsOcollectWarnings = rule1062 _lhsIcollectWarnings
         _lhsOcounter :: Int
         _lhsOcounter = rule1063 _lhsIcounter
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule1064 _lhsIdictionaryEnvironment
         _lhsOmatchIO :: IO ()
         _lhsOmatchIO = rule1065 _lhsImatchIO
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule1066 _lhsIpatternMatchWarnings
         _lhsOuniqueChunk :: Int
         _lhsOuniqueChunk = rule1067 _lhsIuniqueChunk
         !__result_ = T_Expression_vOut40 _lhsOassumptions _lhsObeta _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraints _lhsOcounter _lhsOdictionaryEnvironment _lhsOinfoTree _lhsOmatchIO _lhsOmatches _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOuniqueSecondRound
         in __result_ )
     in C_Expression_s41 v40
   {-# INLINE rule1048 #-}
   rule1048 = \ _assumptions _constraints ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ((_lhsItryPatterns) :: [(Expression     , [String])]) ((_lhsIuniqueSecondRound) :: Int) _localInfo ->
            let infoTuple = metaVarInfo _constraints _assumptions _localInfo
            in match0 infoTuple _lhsIuniqueSecondRound
                      (const Nothing)
                      _lhsItryPatterns _lhsIallPatterns
                      []
   {-# INLINE rule1049 #-}
   rule1049 = \ ((_lhsIparentTree) :: InfoTree) _localInfo ->
                            node _lhsIparentTree _localInfo []
   {-# INLINE rule1050 #-}
   rule1050 = \ _parentTree ->
                            _parentTree
   {-# INLINE rule1051 #-}
   rule1051 = \ _beta ((_lhsImonos) :: Monos) _self ->
                            LocalInfo { self = UHA_Expr _self
                                      , assignedType = Just _beta
                                      , monos = _lhsImonos
                                      }
   {-# INLINE rule1052 #-}
   rule1052 = \ ((_lhsIbetaUnique) :: Int) ->
                            _lhsIbetaUnique + 1
   {-# INLINE rule1053 #-}
   rule1053 = \  (_ :: ()) ->
                            noAssumptions
   {-# INLINE rule1054 #-}
   rule1054 = \  (_ :: ()) ->
                            emptyTree
   {-# INLINE rule1055 #-}
   rule1055 = \ ((_lhsIbetaUnique) :: Int) ->
                            TVar _lhsIbetaUnique
   {-# INLINE rule1056 #-}
   rule1056 = \  (_ :: ()) ->
     []
   {-# INLINE rule1057 #-}
   rule1057 = \  (_ :: ()) ->
     []
   {-# INLINE rule1058 #-}
   rule1058 = \ ((_rangeIself) :: Range) id_ ->
     Expression_Hole _rangeIself id_
   {-# INLINE rule1059 #-}
   rule1059 = \ _self ->
     _self
   {-# INLINE rule1060 #-}
   rule1060 = \ _beta ->
     _beta
   {-# INLINE rule1061 #-}
   rule1061 = \ ((_lhsIcollectErrors) :: TypeErrors) ->
     _lhsIcollectErrors
   {-# INLINE rule1062 #-}
   rule1062 = \ ((_lhsIcollectWarnings) :: Warnings) ->
     _lhsIcollectWarnings
   {-# INLINE rule1063 #-}
   rule1063 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule1064 #-}
   rule1064 = \ ((_lhsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _lhsIdictionaryEnvironment
   {-# INLINE rule1065 #-}
   rule1065 = \ ((_lhsImatchIO) :: IO ()) ->
     _lhsImatchIO
   {-# INLINE rule1066 #-}
   rule1066 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule1067 #-}
   rule1067 = \ ((_lhsIuniqueChunk) :: Int) ->
     _lhsIuniqueChunk
{-# NOINLINE sem_Expression_Feedback #-}
sem_Expression_Feedback :: T_Range  -> (String) -> T_Expression  -> T_Expression 
sem_Expression_Feedback arg_range_ !arg_feedback_ arg_expression_ = T_Expression (return st41) where
   {-# NOINLINE st41 #-}
   !st41 = let
      v40 :: T_Expression_v40 
      v40 = \ !(T_Expression_vIn40 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItryPatterns _lhsItypeConstructors _lhsItypeschemeMap _lhsIuniqueChunk _lhsIuniqueSecondRound _lhsIvariableMapping) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _expressionX41 = Control.Monad.Identity.runIdentity (attach_T_Expression (arg_expression_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_Expression_vOut40 _expressionIassumptions _expressionIbeta _expressionIbetaUnique _expressionIcollectErrors _expressionIcollectInstances _expressionIcollectWarnings _expressionIconstraints _expressionIcounter _expressionIdictionaryEnvironment _expressionIinfoTree _expressionImatchIO _expressionImatches _expressionIpatternMatchWarnings _expressionIself _expressionIunboundNames _expressionIuniqueChunk _expressionIuniqueSecondRound) = inv_Expression_s41 _expressionX41 (T_Expression_vIn40 _expressionOallPatterns _expressionOallTypeSchemes _expressionOambiguousConflicts _expressionOavailablePredicates _expressionObetaUnique _expressionOclassEnvironment _expressionOclassMemberEnv _expressionOclassMemberTypeSchemes _expressionOclassNamesEnv _expressionOclassPredicate _expressionOclassTypeSchemes _expressionOcollectErrors _expressionOcollectWarnings _expressionOcounter _expressionOcurClassPred _expressionOcurPred _expressionOcurrentChunk _expressionOdictionaryEnvironment _expressionOimportEnvironment _expressionOinstanceName _expressionOinstanceTypes _expressionOmatchIO _expressionOmoduleName _expressionOmonos _expressionOnamesInScope _expressionOorderedTypeSynonyms _expressionOparentTree _expressionOpatternMatchWarnings _expressionOrequiredPredicates _expressionOsubstitution _expressionOtryPatterns _expressionOtypeConstructors _expressionOtypeschemeMap _expressionOuniqueChunk _expressionOuniqueSecondRound _expressionOvariableMapping)
         _lhsOcollectInstances :: [(Name, Instance)]
         _lhsOcollectInstances = rule1068 _expressionIcollectInstances
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule1069 _expressionIunboundNames
         _self = rule1070 _expressionIself _rangeIself arg_feedback_
         _lhsOself :: Expression
         _lhsOself = rule1071 _self
         _lhsOassumptions :: Assumptions
         _lhsOassumptions = rule1072 _expressionIassumptions
         _lhsObeta :: Tp
         _lhsObeta = rule1073 _expressionIbeta
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule1074 _expressionIbetaUnique
         _lhsOcollectErrors :: TypeErrors
         _lhsOcollectErrors = rule1075 _expressionIcollectErrors
         _lhsOcollectWarnings :: Warnings
         _lhsOcollectWarnings = rule1076 _expressionIcollectWarnings
         _lhsOconstraints :: ConstraintSet
         _lhsOconstraints = rule1077 _expressionIconstraints
         _lhsOcounter :: Int
         _lhsOcounter = rule1078 _expressionIcounter
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule1079 _expressionIdictionaryEnvironment
         _lhsOinfoTree :: InfoTree
         _lhsOinfoTree = rule1080 _expressionIinfoTree
         _lhsOmatchIO :: IO ()
         _lhsOmatchIO = rule1081 _expressionImatchIO
         _lhsOmatches :: [Maybe MetaVariableTable]
         _lhsOmatches = rule1082 _expressionImatches
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule1083 _expressionIpatternMatchWarnings
         _lhsOuniqueChunk :: Int
         _lhsOuniqueChunk = rule1084 _expressionIuniqueChunk
         _lhsOuniqueSecondRound :: Int
         _lhsOuniqueSecondRound = rule1085 _expressionIuniqueSecondRound
         _expressionOallPatterns = rule1086 _lhsIallPatterns
         _expressionOallTypeSchemes = rule1087 _lhsIallTypeSchemes
         _expressionOambiguousConflicts = rule1088 _lhsIambiguousConflicts
         _expressionOavailablePredicates = rule1089 _lhsIavailablePredicates
         _expressionObetaUnique = rule1090 _lhsIbetaUnique
         _expressionOclassEnvironment = rule1091 _lhsIclassEnvironment
         _expressionOclassMemberEnv = rule1092 _lhsIclassMemberEnv
         _expressionOclassMemberTypeSchemes = rule1093 _lhsIclassMemberTypeSchemes
         _expressionOclassNamesEnv = rule1094 _lhsIclassNamesEnv
         _expressionOclassPredicate = rule1095 _lhsIclassPredicate
         _expressionOclassTypeSchemes = rule1096 _lhsIclassTypeSchemes
         _expressionOcollectErrors = rule1097 _lhsIcollectErrors
         _expressionOcollectWarnings = rule1098 _lhsIcollectWarnings
         _expressionOcounter = rule1099 _lhsIcounter
         _expressionOcurClassPred = rule1100 _lhsIcurClassPred
         _expressionOcurPred = rule1101 _lhsIcurPred
         _expressionOcurrentChunk = rule1102 _lhsIcurrentChunk
         _expressionOdictionaryEnvironment = rule1103 _lhsIdictionaryEnvironment
         _expressionOimportEnvironment = rule1104 _lhsIimportEnvironment
         _expressionOinstanceName = rule1105 _lhsIinstanceName
         _expressionOinstanceTypes = rule1106 _lhsIinstanceTypes
         _expressionOmatchIO = rule1107 _lhsImatchIO
         _expressionOmoduleName = rule1108 _lhsImoduleName
         _expressionOmonos = rule1109 _lhsImonos
         _expressionOnamesInScope = rule1110 _lhsInamesInScope
         _expressionOorderedTypeSynonyms = rule1111 _lhsIorderedTypeSynonyms
         _expressionOparentTree = rule1112 _lhsIparentTree
         _expressionOpatternMatchWarnings = rule1113 _lhsIpatternMatchWarnings
         _expressionOrequiredPredicates = rule1114 _lhsIrequiredPredicates
         _expressionOsubstitution = rule1115 _lhsIsubstitution
         _expressionOtryPatterns = rule1116 _lhsItryPatterns
         _expressionOtypeConstructors = rule1117 _lhsItypeConstructors
         _expressionOtypeschemeMap = rule1118 _lhsItypeschemeMap
         _expressionOuniqueChunk = rule1119 _lhsIuniqueChunk
         _expressionOuniqueSecondRound = rule1120 _lhsIuniqueSecondRound
         _expressionOvariableMapping = rule1121 _lhsIvariableMapping
         !__result_ = T_Expression_vOut40 _lhsOassumptions _lhsObeta _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraints _lhsOcounter _lhsOdictionaryEnvironment _lhsOinfoTree _lhsOmatchIO _lhsOmatches _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOuniqueSecondRound
         in __result_ )
     in C_Expression_s41 v40
   {-# INLINE rule1068 #-}
   rule1068 = \ ((_expressionIcollectInstances) :: [(Name, Instance)]) ->
     _expressionIcollectInstances
   {-# INLINE rule1069 #-}
   rule1069 = \ ((_expressionIunboundNames) :: Names) ->
     _expressionIunboundNames
   {-# INLINE rule1070 #-}
   rule1070 = \ ((_expressionIself) :: Expression) ((_rangeIself) :: Range) feedback_ ->
     Expression_Feedback _rangeIself feedback_ _expressionIself
   {-# INLINE rule1071 #-}
   rule1071 = \ _self ->
     _self
   {-# INLINE rule1072 #-}
   rule1072 = \ ((_expressionIassumptions) :: Assumptions) ->
     _expressionIassumptions
   {-# INLINE rule1073 #-}
   rule1073 = \ ((_expressionIbeta) :: Tp) ->
     _expressionIbeta
   {-# INLINE rule1074 #-}
   rule1074 = \ ((_expressionIbetaUnique) :: Int) ->
     _expressionIbetaUnique
   {-# INLINE rule1075 #-}
   rule1075 = \ ((_expressionIcollectErrors) :: TypeErrors) ->
     _expressionIcollectErrors
   {-# INLINE rule1076 #-}
   rule1076 = \ ((_expressionIcollectWarnings) :: Warnings) ->
     _expressionIcollectWarnings
   {-# INLINE rule1077 #-}
   rule1077 = \ ((_expressionIconstraints) :: ConstraintSet) ->
     _expressionIconstraints
   {-# INLINE rule1078 #-}
   rule1078 = \ ((_expressionIcounter) :: Int) ->
     _expressionIcounter
   {-# INLINE rule1079 #-}
   rule1079 = \ ((_expressionIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _expressionIdictionaryEnvironment
   {-# INLINE rule1080 #-}
   rule1080 = \ ((_expressionIinfoTree) :: InfoTree) ->
     _expressionIinfoTree
   {-# INLINE rule1081 #-}
   rule1081 = \ ((_expressionImatchIO) :: IO ()) ->
     _expressionImatchIO
   {-# INLINE rule1082 #-}
   rule1082 = \ ((_expressionImatches) :: [Maybe MetaVariableTable]) ->
     _expressionImatches
   {-# INLINE rule1083 #-}
   rule1083 = \ ((_expressionIpatternMatchWarnings) :: [Warning]) ->
     _expressionIpatternMatchWarnings
   {-# INLINE rule1084 #-}
   rule1084 = \ ((_expressionIuniqueChunk) :: Int) ->
     _expressionIuniqueChunk
   {-# INLINE rule1085 #-}
   rule1085 = \ ((_expressionIuniqueSecondRound) :: Int) ->
     _expressionIuniqueSecondRound
   {-# INLINE rule1086 #-}
   rule1086 = \ ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ->
     _lhsIallPatterns
   {-# INLINE rule1087 #-}
   rule1087 = \ ((_lhsIallTypeSchemes) :: M.Map NameWithRange TpScheme) ->
     _lhsIallTypeSchemes
   {-# INLINE rule1088 #-}
   rule1088 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule1089 #-}
   rule1089 = \ ((_lhsIavailablePredicates) :: [PredicateWithSource]) ->
     _lhsIavailablePredicates
   {-# INLINE rule1090 #-}
   rule1090 = \ ((_lhsIbetaUnique) :: Int) ->
     _lhsIbetaUnique
   {-# INLINE rule1091 #-}
   rule1091 = \ ((_lhsIclassEnvironment) :: ClassEnvironment) ->
     _lhsIclassEnvironment
   {-# INLINE rule1092 #-}
   rule1092 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule1093 #-}
   rule1093 = \ ((_lhsIclassMemberTypeSchemes) :: Maybe [(Name, TpScheme)]) ->
     _lhsIclassMemberTypeSchemes
   {-# INLINE rule1094 #-}
   rule1094 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule1095 #-}
   rule1095 = \ ((_lhsIclassPredicate) :: Maybe (Name, Names)) ->
     _lhsIclassPredicate
   {-# INLINE rule1096 #-}
   rule1096 = \ ((_lhsIclassTypeSchemes) :: M.Map Name TpScheme) ->
     _lhsIclassTypeSchemes
   {-# INLINE rule1097 #-}
   rule1097 = \ ((_lhsIcollectErrors) :: TypeErrors) ->
     _lhsIcollectErrors
   {-# INLINE rule1098 #-}
   rule1098 = \ ((_lhsIcollectWarnings) :: Warnings) ->
     _lhsIcollectWarnings
   {-# INLINE rule1099 #-}
   rule1099 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule1100 #-}
   rule1100 = \ ((_lhsIcurClassPred) :: Maybe Predicate) ->
     _lhsIcurClassPred
   {-# INLINE rule1101 #-}
   rule1101 = \ ((_lhsIcurPred) :: Maybe Predicate) ->
     _lhsIcurPred
   {-# INLINE rule1102 #-}
   rule1102 = \ ((_lhsIcurrentChunk) :: Int) ->
     _lhsIcurrentChunk
   {-# INLINE rule1103 #-}
   rule1103 = \ ((_lhsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _lhsIdictionaryEnvironment
   {-# INLINE rule1104 #-}
   rule1104 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule1105 #-}
   rule1105 = \ ((_lhsIinstanceName) :: Maybe Name) ->
     _lhsIinstanceName
   {-# INLINE rule1106 #-}
   rule1106 = \ ((_lhsIinstanceTypes) :: [(Name, TpScheme)]) ->
     _lhsIinstanceTypes
   {-# INLINE rule1107 #-}
   rule1107 = \ ((_lhsImatchIO) :: IO ()) ->
     _lhsImatchIO
   {-# INLINE rule1108 #-}
   rule1108 = \ ((_lhsImoduleName) :: Maybe Name) ->
     _lhsImoduleName
   {-# INLINE rule1109 #-}
   rule1109 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule1110 #-}
   rule1110 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule1111 #-}
   rule1111 = \ ((_lhsIorderedTypeSynonyms) :: OrderedTypeSynonyms) ->
     _lhsIorderedTypeSynonyms
   {-# INLINE rule1112 #-}
   rule1112 = \ ((_lhsIparentTree) :: InfoTree) ->
     _lhsIparentTree
   {-# INLINE rule1113 #-}
   rule1113 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule1114 #-}
   rule1114 = \ ((_lhsIrequiredPredicates) :: Predicates) ->
     _lhsIrequiredPredicates
   {-# INLINE rule1115 #-}
   rule1115 = \ ((_lhsIsubstitution) :: FixpointSubstitution) ->
     _lhsIsubstitution
   {-# INLINE rule1116 #-}
   rule1116 = \ ((_lhsItryPatterns) :: [(Expression     , [String])]) ->
     _lhsItryPatterns
   {-# INLINE rule1117 #-}
   rule1117 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
   {-# INLINE rule1118 #-}
   rule1118 = \ ((_lhsItypeschemeMap) :: M.Map Int (Scheme Predicates)) ->
     _lhsItypeschemeMap
   {-# INLINE rule1119 #-}
   rule1119 = \ ((_lhsIuniqueChunk) :: Int) ->
     _lhsIuniqueChunk
   {-# INLINE rule1120 #-}
   rule1120 = \ ((_lhsIuniqueSecondRound) :: Int) ->
     _lhsIuniqueSecondRound
   {-# INLINE rule1121 #-}
   rule1121 = \ ((_lhsIvariableMapping) :: Maybe [(Name, Tp)]) ->
     _lhsIvariableMapping
{-# NOINLINE sem_Expression_MustUse #-}
sem_Expression_MustUse :: T_Range  -> T_Expression  -> T_Expression 
sem_Expression_MustUse arg_range_ arg_expression_ = T_Expression (return st41) where
   {-# NOINLINE st41 #-}
   !st41 = let
      v40 :: T_Expression_v40 
      v40 = \ !(T_Expression_vIn40 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItryPatterns _lhsItypeConstructors _lhsItypeschemeMap _lhsIuniqueChunk _lhsIuniqueSecondRound _lhsIvariableMapping) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _expressionX41 = Control.Monad.Identity.runIdentity (attach_T_Expression (arg_expression_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_Expression_vOut40 _expressionIassumptions _expressionIbeta _expressionIbetaUnique _expressionIcollectErrors _expressionIcollectInstances _expressionIcollectWarnings _expressionIconstraints _expressionIcounter _expressionIdictionaryEnvironment _expressionIinfoTree _expressionImatchIO _expressionImatches _expressionIpatternMatchWarnings _expressionIself _expressionIunboundNames _expressionIuniqueChunk _expressionIuniqueSecondRound) = inv_Expression_s41 _expressionX41 (T_Expression_vIn40 _expressionOallPatterns _expressionOallTypeSchemes _expressionOambiguousConflicts _expressionOavailablePredicates _expressionObetaUnique _expressionOclassEnvironment _expressionOclassMemberEnv _expressionOclassMemberTypeSchemes _expressionOclassNamesEnv _expressionOclassPredicate _expressionOclassTypeSchemes _expressionOcollectErrors _expressionOcollectWarnings _expressionOcounter _expressionOcurClassPred _expressionOcurPred _expressionOcurrentChunk _expressionOdictionaryEnvironment _expressionOimportEnvironment _expressionOinstanceName _expressionOinstanceTypes _expressionOmatchIO _expressionOmoduleName _expressionOmonos _expressionOnamesInScope _expressionOorderedTypeSynonyms _expressionOparentTree _expressionOpatternMatchWarnings _expressionOrequiredPredicates _expressionOsubstitution _expressionOtryPatterns _expressionOtypeConstructors _expressionOtypeschemeMap _expressionOuniqueChunk _expressionOuniqueSecondRound _expressionOvariableMapping)
         _lhsOcollectInstances :: [(Name, Instance)]
         _lhsOcollectInstances = rule1122 _expressionIcollectInstances
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule1123 _expressionIunboundNames
         _self = rule1124 _expressionIself _rangeIself
         _lhsOself :: Expression
         _lhsOself = rule1125 _self
         _lhsOassumptions :: Assumptions
         _lhsOassumptions = rule1126 _expressionIassumptions
         _lhsObeta :: Tp
         _lhsObeta = rule1127 _expressionIbeta
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule1128 _expressionIbetaUnique
         _lhsOcollectErrors :: TypeErrors
         _lhsOcollectErrors = rule1129 _expressionIcollectErrors
         _lhsOcollectWarnings :: Warnings
         _lhsOcollectWarnings = rule1130 _expressionIcollectWarnings
         _lhsOconstraints :: ConstraintSet
         _lhsOconstraints = rule1131 _expressionIconstraints
         _lhsOcounter :: Int
         _lhsOcounter = rule1132 _expressionIcounter
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule1133 _expressionIdictionaryEnvironment
         _lhsOinfoTree :: InfoTree
         _lhsOinfoTree = rule1134 _expressionIinfoTree
         _lhsOmatchIO :: IO ()
         _lhsOmatchIO = rule1135 _expressionImatchIO
         _lhsOmatches :: [Maybe MetaVariableTable]
         _lhsOmatches = rule1136 _expressionImatches
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule1137 _expressionIpatternMatchWarnings
         _lhsOuniqueChunk :: Int
         _lhsOuniqueChunk = rule1138 _expressionIuniqueChunk
         _lhsOuniqueSecondRound :: Int
         _lhsOuniqueSecondRound = rule1139 _expressionIuniqueSecondRound
         _expressionOallPatterns = rule1140 _lhsIallPatterns
         _expressionOallTypeSchemes = rule1141 _lhsIallTypeSchemes
         _expressionOambiguousConflicts = rule1142 _lhsIambiguousConflicts
         _expressionOavailablePredicates = rule1143 _lhsIavailablePredicates
         _expressionObetaUnique = rule1144 _lhsIbetaUnique
         _expressionOclassEnvironment = rule1145 _lhsIclassEnvironment
         _expressionOclassMemberEnv = rule1146 _lhsIclassMemberEnv
         _expressionOclassMemberTypeSchemes = rule1147 _lhsIclassMemberTypeSchemes
         _expressionOclassNamesEnv = rule1148 _lhsIclassNamesEnv
         _expressionOclassPredicate = rule1149 _lhsIclassPredicate
         _expressionOclassTypeSchemes = rule1150 _lhsIclassTypeSchemes
         _expressionOcollectErrors = rule1151 _lhsIcollectErrors
         _expressionOcollectWarnings = rule1152 _lhsIcollectWarnings
         _expressionOcounter = rule1153 _lhsIcounter
         _expressionOcurClassPred = rule1154 _lhsIcurClassPred
         _expressionOcurPred = rule1155 _lhsIcurPred
         _expressionOcurrentChunk = rule1156 _lhsIcurrentChunk
         _expressionOdictionaryEnvironment = rule1157 _lhsIdictionaryEnvironment
         _expressionOimportEnvironment = rule1158 _lhsIimportEnvironment
         _expressionOinstanceName = rule1159 _lhsIinstanceName
         _expressionOinstanceTypes = rule1160 _lhsIinstanceTypes
         _expressionOmatchIO = rule1161 _lhsImatchIO
         _expressionOmoduleName = rule1162 _lhsImoduleName
         _expressionOmonos = rule1163 _lhsImonos
         _expressionOnamesInScope = rule1164 _lhsInamesInScope
         _expressionOorderedTypeSynonyms = rule1165 _lhsIorderedTypeSynonyms
         _expressionOparentTree = rule1166 _lhsIparentTree
         _expressionOpatternMatchWarnings = rule1167 _lhsIpatternMatchWarnings
         _expressionOrequiredPredicates = rule1168 _lhsIrequiredPredicates
         _expressionOsubstitution = rule1169 _lhsIsubstitution
         _expressionOtryPatterns = rule1170 _lhsItryPatterns
         _expressionOtypeConstructors = rule1171 _lhsItypeConstructors
         _expressionOtypeschemeMap = rule1172 _lhsItypeschemeMap
         _expressionOuniqueChunk = rule1173 _lhsIuniqueChunk
         _expressionOuniqueSecondRound = rule1174 _lhsIuniqueSecondRound
         _expressionOvariableMapping = rule1175 _lhsIvariableMapping
         !__result_ = T_Expression_vOut40 _lhsOassumptions _lhsObeta _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraints _lhsOcounter _lhsOdictionaryEnvironment _lhsOinfoTree _lhsOmatchIO _lhsOmatches _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOuniqueSecondRound
         in __result_ )
     in C_Expression_s41 v40
   {-# INLINE rule1122 #-}
   rule1122 = \ ((_expressionIcollectInstances) :: [(Name, Instance)]) ->
     _expressionIcollectInstances
   {-# INLINE rule1123 #-}
   rule1123 = \ ((_expressionIunboundNames) :: Names) ->
     _expressionIunboundNames
   {-# INLINE rule1124 #-}
   rule1124 = \ ((_expressionIself) :: Expression) ((_rangeIself) :: Range) ->
     Expression_MustUse _rangeIself _expressionIself
   {-# INLINE rule1125 #-}
   rule1125 = \ _self ->
     _self
   {-# INLINE rule1126 #-}
   rule1126 = \ ((_expressionIassumptions) :: Assumptions) ->
     _expressionIassumptions
   {-# INLINE rule1127 #-}
   rule1127 = \ ((_expressionIbeta) :: Tp) ->
     _expressionIbeta
   {-# INLINE rule1128 #-}
   rule1128 = \ ((_expressionIbetaUnique) :: Int) ->
     _expressionIbetaUnique
   {-# INLINE rule1129 #-}
   rule1129 = \ ((_expressionIcollectErrors) :: TypeErrors) ->
     _expressionIcollectErrors
   {-# INLINE rule1130 #-}
   rule1130 = \ ((_expressionIcollectWarnings) :: Warnings) ->
     _expressionIcollectWarnings
   {-# INLINE rule1131 #-}
   rule1131 = \ ((_expressionIconstraints) :: ConstraintSet) ->
     _expressionIconstraints
   {-# INLINE rule1132 #-}
   rule1132 = \ ((_expressionIcounter) :: Int) ->
     _expressionIcounter
   {-# INLINE rule1133 #-}
   rule1133 = \ ((_expressionIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _expressionIdictionaryEnvironment
   {-# INLINE rule1134 #-}
   rule1134 = \ ((_expressionIinfoTree) :: InfoTree) ->
     _expressionIinfoTree
   {-# INLINE rule1135 #-}
   rule1135 = \ ((_expressionImatchIO) :: IO ()) ->
     _expressionImatchIO
   {-# INLINE rule1136 #-}
   rule1136 = \ ((_expressionImatches) :: [Maybe MetaVariableTable]) ->
     _expressionImatches
   {-# INLINE rule1137 #-}
   rule1137 = \ ((_expressionIpatternMatchWarnings) :: [Warning]) ->
     _expressionIpatternMatchWarnings
   {-# INLINE rule1138 #-}
   rule1138 = \ ((_expressionIuniqueChunk) :: Int) ->
     _expressionIuniqueChunk
   {-# INLINE rule1139 #-}
   rule1139 = \ ((_expressionIuniqueSecondRound) :: Int) ->
     _expressionIuniqueSecondRound
   {-# INLINE rule1140 #-}
   rule1140 = \ ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ->
     _lhsIallPatterns
   {-# INLINE rule1141 #-}
   rule1141 = \ ((_lhsIallTypeSchemes) :: M.Map NameWithRange TpScheme) ->
     _lhsIallTypeSchemes
   {-# INLINE rule1142 #-}
   rule1142 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule1143 #-}
   rule1143 = \ ((_lhsIavailablePredicates) :: [PredicateWithSource]) ->
     _lhsIavailablePredicates
   {-# INLINE rule1144 #-}
   rule1144 = \ ((_lhsIbetaUnique) :: Int) ->
     _lhsIbetaUnique
   {-# INLINE rule1145 #-}
   rule1145 = \ ((_lhsIclassEnvironment) :: ClassEnvironment) ->
     _lhsIclassEnvironment
   {-# INLINE rule1146 #-}
   rule1146 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule1147 #-}
   rule1147 = \ ((_lhsIclassMemberTypeSchemes) :: Maybe [(Name, TpScheme)]) ->
     _lhsIclassMemberTypeSchemes
   {-# INLINE rule1148 #-}
   rule1148 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule1149 #-}
   rule1149 = \ ((_lhsIclassPredicate) :: Maybe (Name, Names)) ->
     _lhsIclassPredicate
   {-# INLINE rule1150 #-}
   rule1150 = \ ((_lhsIclassTypeSchemes) :: M.Map Name TpScheme) ->
     _lhsIclassTypeSchemes
   {-# INLINE rule1151 #-}
   rule1151 = \ ((_lhsIcollectErrors) :: TypeErrors) ->
     _lhsIcollectErrors
   {-# INLINE rule1152 #-}
   rule1152 = \ ((_lhsIcollectWarnings) :: Warnings) ->
     _lhsIcollectWarnings
   {-# INLINE rule1153 #-}
   rule1153 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule1154 #-}
   rule1154 = \ ((_lhsIcurClassPred) :: Maybe Predicate) ->
     _lhsIcurClassPred
   {-# INLINE rule1155 #-}
   rule1155 = \ ((_lhsIcurPred) :: Maybe Predicate) ->
     _lhsIcurPred
   {-# INLINE rule1156 #-}
   rule1156 = \ ((_lhsIcurrentChunk) :: Int) ->
     _lhsIcurrentChunk
   {-# INLINE rule1157 #-}
   rule1157 = \ ((_lhsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _lhsIdictionaryEnvironment
   {-# INLINE rule1158 #-}
   rule1158 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule1159 #-}
   rule1159 = \ ((_lhsIinstanceName) :: Maybe Name) ->
     _lhsIinstanceName
   {-# INLINE rule1160 #-}
   rule1160 = \ ((_lhsIinstanceTypes) :: [(Name, TpScheme)]) ->
     _lhsIinstanceTypes
   {-# INLINE rule1161 #-}
   rule1161 = \ ((_lhsImatchIO) :: IO ()) ->
     _lhsImatchIO
   {-# INLINE rule1162 #-}
   rule1162 = \ ((_lhsImoduleName) :: Maybe Name) ->
     _lhsImoduleName
   {-# INLINE rule1163 #-}
   rule1163 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule1164 #-}
   rule1164 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule1165 #-}
   rule1165 = \ ((_lhsIorderedTypeSynonyms) :: OrderedTypeSynonyms) ->
     _lhsIorderedTypeSynonyms
   {-# INLINE rule1166 #-}
   rule1166 = \ ((_lhsIparentTree) :: InfoTree) ->
     _lhsIparentTree
   {-# INLINE rule1167 #-}
   rule1167 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule1168 #-}
   rule1168 = \ ((_lhsIrequiredPredicates) :: Predicates) ->
     _lhsIrequiredPredicates
   {-# INLINE rule1169 #-}
   rule1169 = \ ((_lhsIsubstitution) :: FixpointSubstitution) ->
     _lhsIsubstitution
   {-# INLINE rule1170 #-}
   rule1170 = \ ((_lhsItryPatterns) :: [(Expression     , [String])]) ->
     _lhsItryPatterns
   {-# INLINE rule1171 #-}
   rule1171 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
   {-# INLINE rule1172 #-}
   rule1172 = \ ((_lhsItypeschemeMap) :: M.Map Int (Scheme Predicates)) ->
     _lhsItypeschemeMap
   {-# INLINE rule1173 #-}
   rule1173 = \ ((_lhsIuniqueChunk) :: Int) ->
     _lhsIuniqueChunk
   {-# INLINE rule1174 #-}
   rule1174 = \ ((_lhsIuniqueSecondRound) :: Int) ->
     _lhsIuniqueSecondRound
   {-# INLINE rule1175 #-}
   rule1175 = \ ((_lhsIvariableMapping) :: Maybe [(Name, Tp)]) ->
     _lhsIvariableMapping
{-# NOINLINE sem_Expression_Eta #-}
sem_Expression_Eta :: T_Range  -> (Int) -> T_Expression  -> T_Expression 
sem_Expression_Eta arg_range_ !arg_expansion_ arg_expression_ = T_Expression (return st41) where
   {-# NOINLINE st41 #-}
   !st41 = let
      v40 :: T_Expression_v40 
      v40 = \ !(T_Expression_vIn40 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItryPatterns _lhsItypeConstructors _lhsItypeschemeMap _lhsIuniqueChunk _lhsIuniqueSecondRound _lhsIvariableMapping) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _expressionX41 = Control.Monad.Identity.runIdentity (attach_T_Expression (arg_expression_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_Expression_vOut40 _expressionIassumptions _expressionIbeta _expressionIbetaUnique _expressionIcollectErrors _expressionIcollectInstances _expressionIcollectWarnings _expressionIconstraints _expressionIcounter _expressionIdictionaryEnvironment _expressionIinfoTree _expressionImatchIO _expressionImatches _expressionIpatternMatchWarnings _expressionIself _expressionIunboundNames _expressionIuniqueChunk _expressionIuniqueSecondRound) = inv_Expression_s41 _expressionX41 (T_Expression_vIn40 _expressionOallPatterns _expressionOallTypeSchemes _expressionOambiguousConflicts _expressionOavailablePredicates _expressionObetaUnique _expressionOclassEnvironment _expressionOclassMemberEnv _expressionOclassMemberTypeSchemes _expressionOclassNamesEnv _expressionOclassPredicate _expressionOclassTypeSchemes _expressionOcollectErrors _expressionOcollectWarnings _expressionOcounter _expressionOcurClassPred _expressionOcurPred _expressionOcurrentChunk _expressionOdictionaryEnvironment _expressionOimportEnvironment _expressionOinstanceName _expressionOinstanceTypes _expressionOmatchIO _expressionOmoduleName _expressionOmonos _expressionOnamesInScope _expressionOorderedTypeSynonyms _expressionOparentTree _expressionOpatternMatchWarnings _expressionOrequiredPredicates _expressionOsubstitution _expressionOtryPatterns _expressionOtypeConstructors _expressionOtypeschemeMap _expressionOuniqueChunk _expressionOuniqueSecondRound _expressionOvariableMapping)
         _lhsOcollectInstances :: [(Name, Instance)]
         _lhsOcollectInstances = rule1176 _expressionIcollectInstances
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule1177 _expressionIunboundNames
         _self = rule1178 _expressionIself _rangeIself arg_expansion_
         _lhsOself :: Expression
         _lhsOself = rule1179 _self
         _lhsOassumptions :: Assumptions
         _lhsOassumptions = rule1180 _expressionIassumptions
         _lhsObeta :: Tp
         _lhsObeta = rule1181 _expressionIbeta
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule1182 _expressionIbetaUnique
         _lhsOcollectErrors :: TypeErrors
         _lhsOcollectErrors = rule1183 _expressionIcollectErrors
         _lhsOcollectWarnings :: Warnings
         _lhsOcollectWarnings = rule1184 _expressionIcollectWarnings
         _lhsOconstraints :: ConstraintSet
         _lhsOconstraints = rule1185 _expressionIconstraints
         _lhsOcounter :: Int
         _lhsOcounter = rule1186 _expressionIcounter
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule1187 _expressionIdictionaryEnvironment
         _lhsOinfoTree :: InfoTree
         _lhsOinfoTree = rule1188 _expressionIinfoTree
         _lhsOmatchIO :: IO ()
         _lhsOmatchIO = rule1189 _expressionImatchIO
         _lhsOmatches :: [Maybe MetaVariableTable]
         _lhsOmatches = rule1190 _expressionImatches
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule1191 _expressionIpatternMatchWarnings
         _lhsOuniqueChunk :: Int
         _lhsOuniqueChunk = rule1192 _expressionIuniqueChunk
         _lhsOuniqueSecondRound :: Int
         _lhsOuniqueSecondRound = rule1193 _expressionIuniqueSecondRound
         _expressionOallPatterns = rule1194 _lhsIallPatterns
         _expressionOallTypeSchemes = rule1195 _lhsIallTypeSchemes
         _expressionOambiguousConflicts = rule1196 _lhsIambiguousConflicts
         _expressionOavailablePredicates = rule1197 _lhsIavailablePredicates
         _expressionObetaUnique = rule1198 _lhsIbetaUnique
         _expressionOclassEnvironment = rule1199 _lhsIclassEnvironment
         _expressionOclassMemberEnv = rule1200 _lhsIclassMemberEnv
         _expressionOclassMemberTypeSchemes = rule1201 _lhsIclassMemberTypeSchemes
         _expressionOclassNamesEnv = rule1202 _lhsIclassNamesEnv
         _expressionOclassPredicate = rule1203 _lhsIclassPredicate
         _expressionOclassTypeSchemes = rule1204 _lhsIclassTypeSchemes
         _expressionOcollectErrors = rule1205 _lhsIcollectErrors
         _expressionOcollectWarnings = rule1206 _lhsIcollectWarnings
         _expressionOcounter = rule1207 _lhsIcounter
         _expressionOcurClassPred = rule1208 _lhsIcurClassPred
         _expressionOcurPred = rule1209 _lhsIcurPred
         _expressionOcurrentChunk = rule1210 _lhsIcurrentChunk
         _expressionOdictionaryEnvironment = rule1211 _lhsIdictionaryEnvironment
         _expressionOimportEnvironment = rule1212 _lhsIimportEnvironment
         _expressionOinstanceName = rule1213 _lhsIinstanceName
         _expressionOinstanceTypes = rule1214 _lhsIinstanceTypes
         _expressionOmatchIO = rule1215 _lhsImatchIO
         _expressionOmoduleName = rule1216 _lhsImoduleName
         _expressionOmonos = rule1217 _lhsImonos
         _expressionOnamesInScope = rule1218 _lhsInamesInScope
         _expressionOorderedTypeSynonyms = rule1219 _lhsIorderedTypeSynonyms
         _expressionOparentTree = rule1220 _lhsIparentTree
         _expressionOpatternMatchWarnings = rule1221 _lhsIpatternMatchWarnings
         _expressionOrequiredPredicates = rule1222 _lhsIrequiredPredicates
         _expressionOsubstitution = rule1223 _lhsIsubstitution
         _expressionOtryPatterns = rule1224 _lhsItryPatterns
         _expressionOtypeConstructors = rule1225 _lhsItypeConstructors
         _expressionOtypeschemeMap = rule1226 _lhsItypeschemeMap
         _expressionOuniqueChunk = rule1227 _lhsIuniqueChunk
         _expressionOuniqueSecondRound = rule1228 _lhsIuniqueSecondRound
         _expressionOvariableMapping = rule1229 _lhsIvariableMapping
         !__result_ = T_Expression_vOut40 _lhsOassumptions _lhsObeta _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraints _lhsOcounter _lhsOdictionaryEnvironment _lhsOinfoTree _lhsOmatchIO _lhsOmatches _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOuniqueSecondRound
         in __result_ )
     in C_Expression_s41 v40
   {-# INLINE rule1176 #-}
   rule1176 = \ ((_expressionIcollectInstances) :: [(Name, Instance)]) ->
     _expressionIcollectInstances
   {-# INLINE rule1177 #-}
   rule1177 = \ ((_expressionIunboundNames) :: Names) ->
     _expressionIunboundNames
   {-# INLINE rule1178 #-}
   rule1178 = \ ((_expressionIself) :: Expression) ((_rangeIself) :: Range) expansion_ ->
     Expression_Eta _rangeIself expansion_ _expressionIself
   {-# INLINE rule1179 #-}
   rule1179 = \ _self ->
     _self
   {-# INLINE rule1180 #-}
   rule1180 = \ ((_expressionIassumptions) :: Assumptions) ->
     _expressionIassumptions
   {-# INLINE rule1181 #-}
   rule1181 = \ ((_expressionIbeta) :: Tp) ->
     _expressionIbeta
   {-# INLINE rule1182 #-}
   rule1182 = \ ((_expressionIbetaUnique) :: Int) ->
     _expressionIbetaUnique
   {-# INLINE rule1183 #-}
   rule1183 = \ ((_expressionIcollectErrors) :: TypeErrors) ->
     _expressionIcollectErrors
   {-# INLINE rule1184 #-}
   rule1184 = \ ((_expressionIcollectWarnings) :: Warnings) ->
     _expressionIcollectWarnings
   {-# INLINE rule1185 #-}
   rule1185 = \ ((_expressionIconstraints) :: ConstraintSet) ->
     _expressionIconstraints
   {-# INLINE rule1186 #-}
   rule1186 = \ ((_expressionIcounter) :: Int) ->
     _expressionIcounter
   {-# INLINE rule1187 #-}
   rule1187 = \ ((_expressionIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _expressionIdictionaryEnvironment
   {-# INLINE rule1188 #-}
   rule1188 = \ ((_expressionIinfoTree) :: InfoTree) ->
     _expressionIinfoTree
   {-# INLINE rule1189 #-}
   rule1189 = \ ((_expressionImatchIO) :: IO ()) ->
     _expressionImatchIO
   {-# INLINE rule1190 #-}
   rule1190 = \ ((_expressionImatches) :: [Maybe MetaVariableTable]) ->
     _expressionImatches
   {-# INLINE rule1191 #-}
   rule1191 = \ ((_expressionIpatternMatchWarnings) :: [Warning]) ->
     _expressionIpatternMatchWarnings
   {-# INLINE rule1192 #-}
   rule1192 = \ ((_expressionIuniqueChunk) :: Int) ->
     _expressionIuniqueChunk
   {-# INLINE rule1193 #-}
   rule1193 = \ ((_expressionIuniqueSecondRound) :: Int) ->
     _expressionIuniqueSecondRound
   {-# INLINE rule1194 #-}
   rule1194 = \ ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ->
     _lhsIallPatterns
   {-# INLINE rule1195 #-}
   rule1195 = \ ((_lhsIallTypeSchemes) :: M.Map NameWithRange TpScheme) ->
     _lhsIallTypeSchemes
   {-# INLINE rule1196 #-}
   rule1196 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule1197 #-}
   rule1197 = \ ((_lhsIavailablePredicates) :: [PredicateWithSource]) ->
     _lhsIavailablePredicates
   {-# INLINE rule1198 #-}
   rule1198 = \ ((_lhsIbetaUnique) :: Int) ->
     _lhsIbetaUnique
   {-# INLINE rule1199 #-}
   rule1199 = \ ((_lhsIclassEnvironment) :: ClassEnvironment) ->
     _lhsIclassEnvironment
   {-# INLINE rule1200 #-}
   rule1200 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule1201 #-}
   rule1201 = \ ((_lhsIclassMemberTypeSchemes) :: Maybe [(Name, TpScheme)]) ->
     _lhsIclassMemberTypeSchemes
   {-# INLINE rule1202 #-}
   rule1202 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule1203 #-}
   rule1203 = \ ((_lhsIclassPredicate) :: Maybe (Name, Names)) ->
     _lhsIclassPredicate
   {-# INLINE rule1204 #-}
   rule1204 = \ ((_lhsIclassTypeSchemes) :: M.Map Name TpScheme) ->
     _lhsIclassTypeSchemes
   {-# INLINE rule1205 #-}
   rule1205 = \ ((_lhsIcollectErrors) :: TypeErrors) ->
     _lhsIcollectErrors
   {-# INLINE rule1206 #-}
   rule1206 = \ ((_lhsIcollectWarnings) :: Warnings) ->
     _lhsIcollectWarnings
   {-# INLINE rule1207 #-}
   rule1207 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule1208 #-}
   rule1208 = \ ((_lhsIcurClassPred) :: Maybe Predicate) ->
     _lhsIcurClassPred
   {-# INLINE rule1209 #-}
   rule1209 = \ ((_lhsIcurPred) :: Maybe Predicate) ->
     _lhsIcurPred
   {-# INLINE rule1210 #-}
   rule1210 = \ ((_lhsIcurrentChunk) :: Int) ->
     _lhsIcurrentChunk
   {-# INLINE rule1211 #-}
   rule1211 = \ ((_lhsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _lhsIdictionaryEnvironment
   {-# INLINE rule1212 #-}
   rule1212 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule1213 #-}
   rule1213 = \ ((_lhsIinstanceName) :: Maybe Name) ->
     _lhsIinstanceName
   {-# INLINE rule1214 #-}
   rule1214 = \ ((_lhsIinstanceTypes) :: [(Name, TpScheme)]) ->
     _lhsIinstanceTypes
   {-# INLINE rule1215 #-}
   rule1215 = \ ((_lhsImatchIO) :: IO ()) ->
     _lhsImatchIO
   {-# INLINE rule1216 #-}
   rule1216 = \ ((_lhsImoduleName) :: Maybe Name) ->
     _lhsImoduleName
   {-# INLINE rule1217 #-}
   rule1217 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule1218 #-}
   rule1218 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule1219 #-}
   rule1219 = \ ((_lhsIorderedTypeSynonyms) :: OrderedTypeSynonyms) ->
     _lhsIorderedTypeSynonyms
   {-# INLINE rule1220 #-}
   rule1220 = \ ((_lhsIparentTree) :: InfoTree) ->
     _lhsIparentTree
   {-# INLINE rule1221 #-}
   rule1221 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule1222 #-}
   rule1222 = \ ((_lhsIrequiredPredicates) :: Predicates) ->
     _lhsIrequiredPredicates
   {-# INLINE rule1223 #-}
   rule1223 = \ ((_lhsIsubstitution) :: FixpointSubstitution) ->
     _lhsIsubstitution
   {-# INLINE rule1224 #-}
   rule1224 = \ ((_lhsItryPatterns) :: [(Expression     , [String])]) ->
     _lhsItryPatterns
   {-# INLINE rule1225 #-}
   rule1225 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
   {-# INLINE rule1226 #-}
   rule1226 = \ ((_lhsItypeschemeMap) :: M.Map Int (Scheme Predicates)) ->
     _lhsItypeschemeMap
   {-# INLINE rule1227 #-}
   rule1227 = \ ((_lhsIuniqueChunk) :: Int) ->
     _lhsIuniqueChunk
   {-# INLINE rule1228 #-}
   rule1228 = \ ((_lhsIuniqueSecondRound) :: Int) ->
     _lhsIuniqueSecondRound
   {-# INLINE rule1229 #-}
   rule1229 = \ ((_lhsIvariableMapping) :: Maybe [(Name, Tp)]) ->
     _lhsIvariableMapping
{-# NOINLINE sem_Expression_Literal #-}
sem_Expression_Literal :: T_Range  -> T_Literal  -> T_Expression 
sem_Expression_Literal arg_range_ arg_literal_ = T_Expression (return st41) where
   {-# NOINLINE st41 #-}
   !st41 = let
      v40 :: T_Expression_v40 
      v40 = \ !(T_Expression_vIn40 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItryPatterns _lhsItypeConstructors _lhsItypeschemeMap _lhsIuniqueChunk _lhsIuniqueSecondRound _lhsIvariableMapping) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _literalX86 = Control.Monad.Identity.runIdentity (attach_T_Literal (arg_literal_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_Literal_vOut85 _literalIelements _literalIliteralType _literalIself) = inv_Literal_s86 _literalX86 (T_Literal_vIn85 )
         _lhsOmatches :: [Maybe MetaVariableTable]
         _lhsOconstraints :: ConstraintSet
         _lhsOassumptions :: Assumptions
         _lhsOuniqueSecondRound :: Int
         ((),_lhsOmatches,_lhsOconstraints,_lhsOassumptions,_lhsOuniqueSecondRound,_ioMatch) = rule1230 _assumptions _constraints _lhsIallPatterns _lhsItryPatterns _lhsIuniqueSecondRound _literalIself _localInfo
         _lhsOmatchIO :: IO ()
         _lhsOmatchIO = rule1231 _ioMatch _lhsImatchIO
         _parentTree = rule1232 _lhsIparentTree _localInfo
         _lhsOinfoTree :: InfoTree
         _lhsOinfoTree = rule1233 _parentTree
         _localInfo = rule1234 _beta _lhsImonos _self
         _cinfo = rule1235 _parentTree
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule1236 _lhsIbetaUnique
         _assumptions = rule1237  ()
         _constraints = rule1238 _beta _cinfo _literalIliteralType
         _beta = rule1239 _lhsIbetaUnique
         _lhsOcollectInstances :: [(Name, Instance)]
         _lhsOcollectInstances = rule1240  ()
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule1241  ()
         _self = rule1242 _literalIself _rangeIself
         _lhsOself :: Expression
         _lhsOself = rule1243 _self
         _lhsObeta :: Tp
         _lhsObeta = rule1244 _beta
         _lhsOcollectErrors :: TypeErrors
         _lhsOcollectErrors = rule1245 _lhsIcollectErrors
         _lhsOcollectWarnings :: Warnings
         _lhsOcollectWarnings = rule1246 _lhsIcollectWarnings
         _lhsOcounter :: Int
         _lhsOcounter = rule1247 _lhsIcounter
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule1248 _lhsIdictionaryEnvironment
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule1249 _lhsIpatternMatchWarnings
         _lhsOuniqueChunk :: Int
         _lhsOuniqueChunk = rule1250 _lhsIuniqueChunk
         !__result_ = T_Expression_vOut40 _lhsOassumptions _lhsObeta _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraints _lhsOcounter _lhsOdictionaryEnvironment _lhsOinfoTree _lhsOmatchIO _lhsOmatches _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOuniqueSecondRound
         in __result_ )
     in C_Expression_s41 v40
   {-# INLINE rule1230 #-}
   rule1230 = \ _assumptions _constraints ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ((_lhsItryPatterns) :: [(Expression     , [String])]) ((_lhsIuniqueSecondRound) :: Int) ((_literalIself) :: Literal) _localInfo ->
            let infoTuple = metaVarInfo _constraints _assumptions _localInfo
            in match0 infoTuple _lhsIuniqueSecondRound
                      (match_Expression_Literal _literalIself)
                      _lhsItryPatterns _lhsIallPatterns
                      []
   {-# INLINE rule1231 #-}
   rule1231 = \ _ioMatch ((_lhsImatchIO) :: IO ()) ->
                                       _lhsImatchIO             >> _ioMatch
   {-# INLINE rule1232 #-}
   rule1232 = \ ((_lhsIparentTree) :: InfoTree) _localInfo ->
                            node _lhsIparentTree _localInfo []
   {-# INLINE rule1233 #-}
   rule1233 = \ _parentTree ->
                            _parentTree
   {-# INLINE rule1234 #-}
   rule1234 = \ _beta ((_lhsImonos) :: Monos) _self ->
                            LocalInfo { self = UHA_Expr _self
                                      , assignedType = Just _beta
                                      , monos = _lhsImonos
                                      }
   {-# INLINE rule1235 #-}
   rule1235 = \ _parentTree ->
     resultConstraint "literal" _parentTree
        [ FolkloreConstraint, HasTrustFactor 10.0 ]
   {-# INLINE rule1236 #-}
   rule1236 = \ ((_lhsIbetaUnique) :: Int) ->
                            _lhsIbetaUnique + 1
   {-# INLINE rule1237 #-}
   rule1237 = \  (_ :: ()) ->
                            noAssumptions
   {-# INLINE rule1238 #-}
   rule1238 = \ _beta _cinfo ((_literalIliteralType) :: Tp) ->
                            unitTree ((_literalIliteralType .==. _beta) _cinfo)
   {-# INLINE rule1239 #-}
   rule1239 = \ ((_lhsIbetaUnique) :: Int) ->
                            TVar _lhsIbetaUnique
   {-# INLINE rule1240 #-}
   rule1240 = \  (_ :: ()) ->
     []
   {-# INLINE rule1241 #-}
   rule1241 = \  (_ :: ()) ->
     []
   {-# INLINE rule1242 #-}
   rule1242 = \ ((_literalIself) :: Literal) ((_rangeIself) :: Range) ->
     Expression_Literal _rangeIself _literalIself
   {-# INLINE rule1243 #-}
   rule1243 = \ _self ->
     _self
   {-# INLINE rule1244 #-}
   rule1244 = \ _beta ->
     _beta
   {-# INLINE rule1245 #-}
   rule1245 = \ ((_lhsIcollectErrors) :: TypeErrors) ->
     _lhsIcollectErrors
   {-# INLINE rule1246 #-}
   rule1246 = \ ((_lhsIcollectWarnings) :: Warnings) ->
     _lhsIcollectWarnings
   {-# INLINE rule1247 #-}
   rule1247 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule1248 #-}
   rule1248 = \ ((_lhsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _lhsIdictionaryEnvironment
   {-# INLINE rule1249 #-}
   rule1249 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule1250 #-}
   rule1250 = \ ((_lhsIuniqueChunk) :: Int) ->
     _lhsIuniqueChunk
{-# NOINLINE sem_Expression_Variable #-}
sem_Expression_Variable :: T_Range  -> T_Name  -> T_Expression 
sem_Expression_Variable arg_range_ arg_name_ = T_Expression (return st41) where
   {-# NOINLINE st41 #-}
   !st41 = let
      v40 :: T_Expression_v40 
      v40 = \ !(T_Expression_vIn40 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItryPatterns _lhsItypeConstructors _lhsItypeschemeMap _lhsIuniqueChunk _lhsIuniqueSecondRound _lhsIvariableMapping) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _nameX113 = Control.Monad.Identity.runIdentity (attach_T_Name (arg_name_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_Name_vOut112 _nameIself) = inv_Name_s113 _nameX113 (T_Name_vIn112 )
         _lhsOmatches :: [Maybe MetaVariableTable]
         _lhsOconstraints :: ConstraintSet
         _lhsOassumptions :: Assumptions
         _lhsOuniqueSecondRound :: Int
         ((),_lhsOmatches,_lhsOconstraints,_lhsOassumptions,_lhsOuniqueSecondRound,_ioMatch) = rule1251 _assumptions _constraints _lhsIallPatterns _lhsItryPatterns _lhsIuniqueSecondRound _localInfo _nameIself
         _lhsOmatchIO :: IO ()
         _lhsOmatchIO = rule1252 _ioMatch _lhsImatchIO
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule1253 _nameIself
         _parentTree = rule1254 _lhsIparentTree _localInfo
         _lhsOinfoTree :: InfoTree
         _lhsOinfoTree = rule1255 _parentTree
         _localInfo = rule1256 _beta _lhsImonos _self
         _cinfo = rule1257 _nameIself
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule1258 _newDEnv
         _nameInScope = rule1259 _lhsInamesInScope _nameIself
         _maybeInferredType = rule1260 _lhsIallTypeSchemes _nameInScope
         _requiredDictionaries = rule1261 _lhsIimportEnvironment _lhsIinstanceName _lhsIsubstitution _maybeInferredType _nameIself _usedAsType
         _newDEnv = rule1262 _lhsIavailablePredicates _lhsIclassEnvironment _lhsIcurPred _lhsIdictionaryEnvironment _lhsIinstanceName _lhsIsubstitution _nameIself _requiredDictionaries
         _usedAsType = rule1263 _beta _lhsIsubstitution
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule1264 _updatedType
         _updatedType = rule1265 _lhsIbetaUnique _lhsIimportEnvironment _nameIself
         _assumptions = rule1266 _beta _nameIself
         _constraints = rule1267 _beta _cinfo _lhsIbetaUnique _lhsIimportEnvironment _nameIself _updatedType
         _beta = rule1268 _lhsIbetaUnique
         _lhsOcollectInstances :: [(Name, Instance)]
         _lhsOcollectInstances = rule1269  ()
         _self = rule1270 _nameIself _rangeIself
         _lhsOself :: Expression
         _lhsOself = rule1271 _self
         _lhsObeta :: Tp
         _lhsObeta = rule1272 _beta
         _lhsOcollectErrors :: TypeErrors
         _lhsOcollectErrors = rule1273 _lhsIcollectErrors
         _lhsOcollectWarnings :: Warnings
         _lhsOcollectWarnings = rule1274 _lhsIcollectWarnings
         _lhsOcounter :: Int
         _lhsOcounter = rule1275 _lhsIcounter
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule1276 _lhsIpatternMatchWarnings
         _lhsOuniqueChunk :: Int
         _lhsOuniqueChunk = rule1277 _lhsIuniqueChunk
         !__result_ = T_Expression_vOut40 _lhsOassumptions _lhsObeta _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraints _lhsOcounter _lhsOdictionaryEnvironment _lhsOinfoTree _lhsOmatchIO _lhsOmatches _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOuniqueSecondRound
         in __result_ )
     in C_Expression_s41 v40
   {-# INLINE rule1251 #-}
   rule1251 = \ _assumptions _constraints ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ((_lhsItryPatterns) :: [(Expression     , [String])]) ((_lhsIuniqueSecondRound) :: Int) _localInfo ((_nameIself) :: Name) ->
            let infoTuple = metaVarInfo _constraints _assumptions _localInfo
            in match0 infoTuple _lhsIuniqueSecondRound
                      (match_Expression_Variable _nameIself)
                      _lhsItryPatterns _lhsIallPatterns
                      []
   {-# INLINE rule1252 #-}
   rule1252 = \ _ioMatch ((_lhsImatchIO) :: IO ()) ->
                                       _lhsImatchIO             >> _ioMatch
   {-# INLINE rule1253 #-}
   rule1253 = \ ((_nameIself) :: Name) ->
                                      [ _nameIself ]
   {-# INLINE rule1254 #-}
   rule1254 = \ ((_lhsIparentTree) :: InfoTree) _localInfo ->
                            node _lhsIparentTree _localInfo []
   {-# INLINE rule1255 #-}
   rule1255 = \ _parentTree ->
                            _parentTree
   {-# INLINE rule1256 #-}
   rule1256 = \ _beta ((_lhsImonos) :: Monos) _self ->
                            LocalInfo { self = UHA_Expr _self
                                      , assignedType = Just _beta
                                      , monos = _lhsImonos
                                      }
   {-# INLINE rule1257 #-}
   rule1257 = \ ((_nameIself) :: Name) ->
     variableConstraint "variable" (nameToUHA_Expr _nameIself)
        [ FolkloreConstraint
        ]
   {-# INLINE rule1258 #-}
   rule1258 = \ _newDEnv ->
                                               _newDEnv
   {-# INLINE rule1259 #-}
   rule1259 = \ ((_lhsInamesInScope) :: Names) ((_nameIself) :: Name) ->
                                               case filter (_nameIself==) _lhsInamesInScope of
                                                  [name] -> NameWithRange name
                                                  _      -> internalError "TypeInferenceOverloading.ag" "n/a" ("name not in scope: " ++ (show.show) _nameIself)
   {-# INLINE rule1260 #-}
   rule1260 = \ ((_lhsIallTypeSchemes) :: M.Map NameWithRange TpScheme) _nameInScope ->
                                               M.lookup _nameInScope _lhsIallTypeSchemes
   {-# INLINE rule1261 #-}
   rule1261 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ((_lhsIinstanceName) :: Maybe Name) ((_lhsIsubstitution) :: FixpointSubstitution) _maybeInferredType ((_nameIself) :: Name) _usedAsType ->
                                               case _maybeInferredType of
                                                  Nothing     -> maybe [] (\className ->
                                                                      let
                                                                          classMembers = classMemberEnvironmentAddContext className $ fromJust $ M.lookup className (classMemberEnvironment _lhsIimportEnvironment)
                                                                          classFunctions = map (\(n, tps, _, _)->(n, tps)) $ snd classMembers
                                                                      in maybe [] (\scheme ->
                                                                          map PredicateFunction $ getRequiredDictionaries
                                                                              (getOrderedTypeSynonyms _lhsIimportEnvironment)
                                                                              (_lhsIsubstitution |-> _usedAsType)
                                                                              (_lhsIsubstitution |-> scheme)
                                                                      ) (lookup _nameIself classFunctions)
                                                                  ) _lhsIinstanceName
                                                  Just scheme -> map PredicateFunction $ getRequiredDictionaries
                                                                    (getOrderedTypeSynonyms _lhsIimportEnvironment)
                                                                    (_lhsIsubstitution |-> _usedAsType)
                                                                    (_lhsIsubstitution |-> scheme)
   {-# INLINE rule1262 #-}
   rule1262 = \ ((_lhsIavailablePredicates) :: [PredicateWithSource]) ((_lhsIclassEnvironment) :: ClassEnvironment) ((_lhsIcurPred) :: Maybe Predicate) ((_lhsIdictionaryEnvironment) :: DictionaryEnvironment) ((_lhsIinstanceName) :: Maybe Name) ((_lhsIsubstitution) :: FixpointSubstitution) ((_nameIself) :: Name) _requiredDictionaries ->
                                               resolveOverloading (_lhsIclassEnvironment)
                                                                  _nameIself
                                                                  (_lhsIsubstitution |-> _lhsIavailablePredicates)
                                                                  (_lhsIsubstitution |-> _requiredDictionaries)
                                                                  (fmap getNameName _lhsIinstanceName)
                                                                  (_lhsIcurPred)
                                                                  _lhsIdictionaryEnvironment
   {-# INLINE rule1263 #-}
   rule1263 = \ _beta ((_lhsIsubstitution) :: FixpointSubstitution) ->
                                               _lhsIsubstitution |-> _beta
   {-# INLINE rule1264 #-}
   rule1264 = \ _updatedType ->
                            snd _updatedType
   {-# INLINE rule1265 #-}
   rule1265 = \ ((_lhsIbetaUnique) :: Int) ((_lhsIimportEnvironment) :: ImportEnvironment) ((_nameIself) :: Name) ->
                            maybe (undefined, _lhsIbetaUnique + 1) (freshen (_lhsIbetaUnique + 1) . unquantify)
                              $ M.lookup _nameIself $ typeEnvironment _lhsIimportEnvironment
   {-# INLINE rule1266 #-}
   rule1266 = \ _beta ((_nameIself) :: Name) ->
                            _nameIself `single` _beta
   {-# INLINE rule1267 #-}
   rule1267 = \ _beta _cinfo ((_lhsIbetaUnique) :: Int) ((_lhsIimportEnvironment) :: ImportEnvironment) ((_nameIself) :: Name) _updatedType ->
                            if isJust (M.lookup _nameIself $ typeEnvironment _lhsIimportEnvironment) then
                                  let (preds, tp) = split (fst _updatedType) in
                                  Node $ [[(_beta .==. tp) _cinfo] .>. Node[], Receive _lhsIbetaUnique] ++ [(unitTree $ TC2 $ Prove p _cinfo) | p <- preds ]
                              else
                                  Node [ Receive _lhsIbetaUnique ]
   {-# INLINE rule1268 #-}
   rule1268 = \ ((_lhsIbetaUnique) :: Int) ->
                            TVar _lhsIbetaUnique
   {-# INLINE rule1269 #-}
   rule1269 = \  (_ :: ()) ->
     []
   {-# INLINE rule1270 #-}
   rule1270 = \ ((_nameIself) :: Name) ((_rangeIself) :: Range) ->
     Expression_Variable _rangeIself _nameIself
   {-# INLINE rule1271 #-}
   rule1271 = \ _self ->
     _self
   {-# INLINE rule1272 #-}
   rule1272 = \ _beta ->
     _beta
   {-# INLINE rule1273 #-}
   rule1273 = \ ((_lhsIcollectErrors) :: TypeErrors) ->
     _lhsIcollectErrors
   {-# INLINE rule1274 #-}
   rule1274 = \ ((_lhsIcollectWarnings) :: Warnings) ->
     _lhsIcollectWarnings
   {-# INLINE rule1275 #-}
   rule1275 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule1276 #-}
   rule1276 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule1277 #-}
   rule1277 = \ ((_lhsIuniqueChunk) :: Int) ->
     _lhsIuniqueChunk
{-# NOINLINE sem_Expression_Constructor #-}
sem_Expression_Constructor :: T_Range  -> T_Name  -> T_Expression 
sem_Expression_Constructor arg_range_ arg_name_ = T_Expression (return st41) where
   {-# NOINLINE st41 #-}
   !st41 = let
      v40 :: T_Expression_v40 
      v40 = \ !(T_Expression_vIn40 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItryPatterns _lhsItypeConstructors _lhsItypeschemeMap _lhsIuniqueChunk _lhsIuniqueSecondRound _lhsIvariableMapping) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _nameX113 = Control.Monad.Identity.runIdentity (attach_T_Name (arg_name_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_Name_vOut112 _nameIself) = inv_Name_s113 _nameX113 (T_Name_vIn112 )
         _lhsOmatches :: [Maybe MetaVariableTable]
         _lhsOconstraints :: ConstraintSet
         _lhsOassumptions :: Assumptions
         _lhsOuniqueSecondRound :: Int
         ((),_lhsOmatches,_lhsOconstraints,_lhsOassumptions,_lhsOuniqueSecondRound,_ioMatch) = rule1278 _assumptions _constraints _lhsIallPatterns _lhsItryPatterns _lhsIuniqueSecondRound _localInfo _nameIself
         _lhsOmatchIO :: IO ()
         _lhsOmatchIO = rule1279 _ioMatch _lhsImatchIO
         _parentTree = rule1280 _lhsIparentTree _localInfo
         _lhsOinfoTree :: InfoTree
         _lhsOinfoTree = rule1281 _parentTree
         _localInfo = rule1282 _beta _lhsImonos _self
         _cinfo = rule1283 _nameIself _parentTree
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule1284 _lhsIbetaUnique
         _assumptions = rule1285  ()
         _constraints = rule1286 _newcon
         _beta = rule1287 _lhsIbetaUnique
         _newcon = rule1288 _beta _cinfo _lhsIimportEnvironment _nameIself
         _lhsOcollectInstances :: [(Name, Instance)]
         _lhsOcollectInstances = rule1289  ()
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule1290  ()
         _self = rule1291 _nameIself _rangeIself
         _lhsOself :: Expression
         _lhsOself = rule1292 _self
         _lhsObeta :: Tp
         _lhsObeta = rule1293 _beta
         _lhsOcollectErrors :: TypeErrors
         _lhsOcollectErrors = rule1294 _lhsIcollectErrors
         _lhsOcollectWarnings :: Warnings
         _lhsOcollectWarnings = rule1295 _lhsIcollectWarnings
         _lhsOcounter :: Int
         _lhsOcounter = rule1296 _lhsIcounter
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule1297 _lhsIdictionaryEnvironment
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule1298 _lhsIpatternMatchWarnings
         _lhsOuniqueChunk :: Int
         _lhsOuniqueChunk = rule1299 _lhsIuniqueChunk
         !__result_ = T_Expression_vOut40 _lhsOassumptions _lhsObeta _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraints _lhsOcounter _lhsOdictionaryEnvironment _lhsOinfoTree _lhsOmatchIO _lhsOmatches _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOuniqueSecondRound
         in __result_ )
     in C_Expression_s41 v40
   {-# INLINE rule1278 #-}
   rule1278 = \ _assumptions _constraints ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ((_lhsItryPatterns) :: [(Expression     , [String])]) ((_lhsIuniqueSecondRound) :: Int) _localInfo ((_nameIself) :: Name) ->
            let infoTuple = metaVarInfo _constraints _assumptions _localInfo
            in match0 infoTuple _lhsIuniqueSecondRound
                      (match_Expression_Constructor _nameIself)
                      _lhsItryPatterns _lhsIallPatterns
                      []
   {-# INLINE rule1279 #-}
   rule1279 = \ _ioMatch ((_lhsImatchIO) :: IO ()) ->
                                       _lhsImatchIO             >> _ioMatch
   {-# INLINE rule1280 #-}
   rule1280 = \ ((_lhsIparentTree) :: InfoTree) _localInfo ->
                            node _lhsIparentTree _localInfo []
   {-# INLINE rule1281 #-}
   rule1281 = \ _parentTree ->
                            _parentTree
   {-# INLINE rule1282 #-}
   rule1282 = \ _beta ((_lhsImonos) :: Monos) _self ->
                            LocalInfo { self = UHA_Expr _self
                                      , assignedType = Just _beta
                                      , monos = _lhsImonos
                                      }
   {-# INLINE rule1283 #-}
   rule1283 = \ ((_nameIself) :: Name) _parentTree ->
     resultConstraint "constructor" _parentTree
        [ FolkloreConstraint, HasTrustFactor 10.0, IsImported _nameIself ]
   {-# INLINE rule1284 #-}
   rule1284 = \ ((_lhsIbetaUnique) :: Int) ->
                             _lhsIbetaUnique + 1
   {-# INLINE rule1285 #-}
   rule1285 = \  (_ :: ()) ->
                             noAssumptions
   {-# INLINE rule1286 #-}
   rule1286 = \ _newcon ->
                             listTree _newcon
   {-# INLINE rule1287 #-}
   rule1287 = \ ((_lhsIbetaUnique) :: Int) ->
                             TVar _lhsIbetaUnique
   {-# INLINE rule1288 #-}
   rule1288 = \ _beta _cinfo ((_lhsIimportEnvironment) :: ImportEnvironment) ((_nameIself) :: Name) ->
                             case M.lookup _nameIself (valueConstructors _lhsIimportEnvironment) of
                                Nothing            -> []
                                Just (_, ctp) -> [ (_beta .::. ctp) _cinfo ]
   {-# INLINE rule1289 #-}
   rule1289 = \  (_ :: ()) ->
     []
   {-# INLINE rule1290 #-}
   rule1290 = \  (_ :: ()) ->
     []
   {-# INLINE rule1291 #-}
   rule1291 = \ ((_nameIself) :: Name) ((_rangeIself) :: Range) ->
     Expression_Constructor _rangeIself _nameIself
   {-# INLINE rule1292 #-}
   rule1292 = \ _self ->
     _self
   {-# INLINE rule1293 #-}
   rule1293 = \ _beta ->
     _beta
   {-# INLINE rule1294 #-}
   rule1294 = \ ((_lhsIcollectErrors) :: TypeErrors) ->
     _lhsIcollectErrors
   {-# INLINE rule1295 #-}
   rule1295 = \ ((_lhsIcollectWarnings) :: Warnings) ->
     _lhsIcollectWarnings
   {-# INLINE rule1296 #-}
   rule1296 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule1297 #-}
   rule1297 = \ ((_lhsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _lhsIdictionaryEnvironment
   {-# INLINE rule1298 #-}
   rule1298 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule1299 #-}
   rule1299 = \ ((_lhsIuniqueChunk) :: Int) ->
     _lhsIuniqueChunk
{-# NOINLINE sem_Expression_Parenthesized #-}
sem_Expression_Parenthesized :: T_Range  -> T_Expression  -> T_Expression 
sem_Expression_Parenthesized arg_range_ arg_expression_ = T_Expression (return st41) where
   {-# NOINLINE st41 #-}
   !st41 = let
      v40 :: T_Expression_v40 
      v40 = \ !(T_Expression_vIn40 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItryPatterns _lhsItypeConstructors _lhsItypeschemeMap _lhsIuniqueChunk _lhsIuniqueSecondRound _lhsIvariableMapping) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _expressionX41 = Control.Monad.Identity.runIdentity (attach_T_Expression (arg_expression_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_Expression_vOut40 _expressionIassumptions _expressionIbeta _expressionIbetaUnique _expressionIcollectErrors _expressionIcollectInstances _expressionIcollectWarnings _expressionIconstraints _expressionIcounter _expressionIdictionaryEnvironment _expressionIinfoTree _expressionImatchIO _expressionImatches _expressionIpatternMatchWarnings _expressionIself _expressionIunboundNames _expressionIuniqueChunk _expressionIuniqueSecondRound) = inv_Expression_s41 _expressionX41 (T_Expression_vIn40 _expressionOallPatterns _expressionOallTypeSchemes _expressionOambiguousConflicts _expressionOavailablePredicates _expressionObetaUnique _expressionOclassEnvironment _expressionOclassMemberEnv _expressionOclassMemberTypeSchemes _expressionOclassNamesEnv _expressionOclassPredicate _expressionOclassTypeSchemes _expressionOcollectErrors _expressionOcollectWarnings _expressionOcounter _expressionOcurClassPred _expressionOcurPred _expressionOcurrentChunk _expressionOdictionaryEnvironment _expressionOimportEnvironment _expressionOinstanceName _expressionOinstanceTypes _expressionOmatchIO _expressionOmoduleName _expressionOmonos _expressionOnamesInScope _expressionOorderedTypeSynonyms _expressionOparentTree _expressionOpatternMatchWarnings _expressionOrequiredPredicates _expressionOsubstitution _expressionOtryPatterns _expressionOtypeConstructors _expressionOtypeschemeMap _expressionOuniqueChunk _expressionOuniqueSecondRound _expressionOvariableMapping)
         _lhsOcollectInstances :: [(Name, Instance)]
         _lhsOcollectInstances = rule1300 _expressionIcollectInstances
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule1301 _expressionIunboundNames
         _self = rule1302 _expressionIself _rangeIself
         _lhsOself :: Expression
         _lhsOself = rule1303 _self
         _lhsOassumptions :: Assumptions
         _lhsOassumptions = rule1304 _expressionIassumptions
         _lhsObeta :: Tp
         _lhsObeta = rule1305 _expressionIbeta
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule1306 _expressionIbetaUnique
         _lhsOcollectErrors :: TypeErrors
         _lhsOcollectErrors = rule1307 _expressionIcollectErrors
         _lhsOcollectWarnings :: Warnings
         _lhsOcollectWarnings = rule1308 _expressionIcollectWarnings
         _lhsOconstraints :: ConstraintSet
         _lhsOconstraints = rule1309 _expressionIconstraints
         _lhsOcounter :: Int
         _lhsOcounter = rule1310 _expressionIcounter
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule1311 _expressionIdictionaryEnvironment
         _lhsOinfoTree :: InfoTree
         _lhsOinfoTree = rule1312 _expressionIinfoTree
         _lhsOmatchIO :: IO ()
         _lhsOmatchIO = rule1313 _expressionImatchIO
         _lhsOmatches :: [Maybe MetaVariableTable]
         _lhsOmatches = rule1314 _expressionImatches
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule1315 _expressionIpatternMatchWarnings
         _lhsOuniqueChunk :: Int
         _lhsOuniqueChunk = rule1316 _expressionIuniqueChunk
         _lhsOuniqueSecondRound :: Int
         _lhsOuniqueSecondRound = rule1317 _expressionIuniqueSecondRound
         _expressionOallPatterns = rule1318 _lhsIallPatterns
         _expressionOallTypeSchemes = rule1319 _lhsIallTypeSchemes
         _expressionOambiguousConflicts = rule1320 _lhsIambiguousConflicts
         _expressionOavailablePredicates = rule1321 _lhsIavailablePredicates
         _expressionObetaUnique = rule1322 _lhsIbetaUnique
         _expressionOclassEnvironment = rule1323 _lhsIclassEnvironment
         _expressionOclassMemberEnv = rule1324 _lhsIclassMemberEnv
         _expressionOclassMemberTypeSchemes = rule1325 _lhsIclassMemberTypeSchemes
         _expressionOclassNamesEnv = rule1326 _lhsIclassNamesEnv
         _expressionOclassPredicate = rule1327 _lhsIclassPredicate
         _expressionOclassTypeSchemes = rule1328 _lhsIclassTypeSchemes
         _expressionOcollectErrors = rule1329 _lhsIcollectErrors
         _expressionOcollectWarnings = rule1330 _lhsIcollectWarnings
         _expressionOcounter = rule1331 _lhsIcounter
         _expressionOcurClassPred = rule1332 _lhsIcurClassPred
         _expressionOcurPred = rule1333 _lhsIcurPred
         _expressionOcurrentChunk = rule1334 _lhsIcurrentChunk
         _expressionOdictionaryEnvironment = rule1335 _lhsIdictionaryEnvironment
         _expressionOimportEnvironment = rule1336 _lhsIimportEnvironment
         _expressionOinstanceName = rule1337 _lhsIinstanceName
         _expressionOinstanceTypes = rule1338 _lhsIinstanceTypes
         _expressionOmatchIO = rule1339 _lhsImatchIO
         _expressionOmoduleName = rule1340 _lhsImoduleName
         _expressionOmonos = rule1341 _lhsImonos
         _expressionOnamesInScope = rule1342 _lhsInamesInScope
         _expressionOorderedTypeSynonyms = rule1343 _lhsIorderedTypeSynonyms
         _expressionOparentTree = rule1344 _lhsIparentTree
         _expressionOpatternMatchWarnings = rule1345 _lhsIpatternMatchWarnings
         _expressionOrequiredPredicates = rule1346 _lhsIrequiredPredicates
         _expressionOsubstitution = rule1347 _lhsIsubstitution
         _expressionOtryPatterns = rule1348 _lhsItryPatterns
         _expressionOtypeConstructors = rule1349 _lhsItypeConstructors
         _expressionOtypeschemeMap = rule1350 _lhsItypeschemeMap
         _expressionOuniqueChunk = rule1351 _lhsIuniqueChunk
         _expressionOuniqueSecondRound = rule1352 _lhsIuniqueSecondRound
         _expressionOvariableMapping = rule1353 _lhsIvariableMapping
         !__result_ = T_Expression_vOut40 _lhsOassumptions _lhsObeta _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraints _lhsOcounter _lhsOdictionaryEnvironment _lhsOinfoTree _lhsOmatchIO _lhsOmatches _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOuniqueSecondRound
         in __result_ )
     in C_Expression_s41 v40
   {-# INLINE rule1300 #-}
   rule1300 = \ ((_expressionIcollectInstances) :: [(Name, Instance)]) ->
     _expressionIcollectInstances
   {-# INLINE rule1301 #-}
   rule1301 = \ ((_expressionIunboundNames) :: Names) ->
     _expressionIunboundNames
   {-# INLINE rule1302 #-}
   rule1302 = \ ((_expressionIself) :: Expression) ((_rangeIself) :: Range) ->
     Expression_Parenthesized _rangeIself _expressionIself
   {-# INLINE rule1303 #-}
   rule1303 = \ _self ->
     _self
   {-# INLINE rule1304 #-}
   rule1304 = \ ((_expressionIassumptions) :: Assumptions) ->
     _expressionIassumptions
   {-# INLINE rule1305 #-}
   rule1305 = \ ((_expressionIbeta) :: Tp) ->
     _expressionIbeta
   {-# INLINE rule1306 #-}
   rule1306 = \ ((_expressionIbetaUnique) :: Int) ->
     _expressionIbetaUnique
   {-# INLINE rule1307 #-}
   rule1307 = \ ((_expressionIcollectErrors) :: TypeErrors) ->
     _expressionIcollectErrors
   {-# INLINE rule1308 #-}
   rule1308 = \ ((_expressionIcollectWarnings) :: Warnings) ->
     _expressionIcollectWarnings
   {-# INLINE rule1309 #-}
   rule1309 = \ ((_expressionIconstraints) :: ConstraintSet) ->
     _expressionIconstraints
   {-# INLINE rule1310 #-}
   rule1310 = \ ((_expressionIcounter) :: Int) ->
     _expressionIcounter
   {-# INLINE rule1311 #-}
   rule1311 = \ ((_expressionIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _expressionIdictionaryEnvironment
   {-# INLINE rule1312 #-}
   rule1312 = \ ((_expressionIinfoTree) :: InfoTree) ->
     _expressionIinfoTree
   {-# INLINE rule1313 #-}
   rule1313 = \ ((_expressionImatchIO) :: IO ()) ->
     _expressionImatchIO
   {-# INLINE rule1314 #-}
   rule1314 = \ ((_expressionImatches) :: [Maybe MetaVariableTable]) ->
     _expressionImatches
   {-# INLINE rule1315 #-}
   rule1315 = \ ((_expressionIpatternMatchWarnings) :: [Warning]) ->
     _expressionIpatternMatchWarnings
   {-# INLINE rule1316 #-}
   rule1316 = \ ((_expressionIuniqueChunk) :: Int) ->
     _expressionIuniqueChunk
   {-# INLINE rule1317 #-}
   rule1317 = \ ((_expressionIuniqueSecondRound) :: Int) ->
     _expressionIuniqueSecondRound
   {-# INLINE rule1318 #-}
   rule1318 = \ ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ->
     _lhsIallPatterns
   {-# INLINE rule1319 #-}
   rule1319 = \ ((_lhsIallTypeSchemes) :: M.Map NameWithRange TpScheme) ->
     _lhsIallTypeSchemes
   {-# INLINE rule1320 #-}
   rule1320 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule1321 #-}
   rule1321 = \ ((_lhsIavailablePredicates) :: [PredicateWithSource]) ->
     _lhsIavailablePredicates
   {-# INLINE rule1322 #-}
   rule1322 = \ ((_lhsIbetaUnique) :: Int) ->
     _lhsIbetaUnique
   {-# INLINE rule1323 #-}
   rule1323 = \ ((_lhsIclassEnvironment) :: ClassEnvironment) ->
     _lhsIclassEnvironment
   {-# INLINE rule1324 #-}
   rule1324 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule1325 #-}
   rule1325 = \ ((_lhsIclassMemberTypeSchemes) :: Maybe [(Name, TpScheme)]) ->
     _lhsIclassMemberTypeSchemes
   {-# INLINE rule1326 #-}
   rule1326 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule1327 #-}
   rule1327 = \ ((_lhsIclassPredicate) :: Maybe (Name, Names)) ->
     _lhsIclassPredicate
   {-# INLINE rule1328 #-}
   rule1328 = \ ((_lhsIclassTypeSchemes) :: M.Map Name TpScheme) ->
     _lhsIclassTypeSchemes
   {-# INLINE rule1329 #-}
   rule1329 = \ ((_lhsIcollectErrors) :: TypeErrors) ->
     _lhsIcollectErrors
   {-# INLINE rule1330 #-}
   rule1330 = \ ((_lhsIcollectWarnings) :: Warnings) ->
     _lhsIcollectWarnings
   {-# INLINE rule1331 #-}
   rule1331 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule1332 #-}
   rule1332 = \ ((_lhsIcurClassPred) :: Maybe Predicate) ->
     _lhsIcurClassPred
   {-# INLINE rule1333 #-}
   rule1333 = \ ((_lhsIcurPred) :: Maybe Predicate) ->
     _lhsIcurPred
   {-# INLINE rule1334 #-}
   rule1334 = \ ((_lhsIcurrentChunk) :: Int) ->
     _lhsIcurrentChunk
   {-# INLINE rule1335 #-}
   rule1335 = \ ((_lhsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _lhsIdictionaryEnvironment
   {-# INLINE rule1336 #-}
   rule1336 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule1337 #-}
   rule1337 = \ ((_lhsIinstanceName) :: Maybe Name) ->
     _lhsIinstanceName
   {-# INLINE rule1338 #-}
   rule1338 = \ ((_lhsIinstanceTypes) :: [(Name, TpScheme)]) ->
     _lhsIinstanceTypes
   {-# INLINE rule1339 #-}
   rule1339 = \ ((_lhsImatchIO) :: IO ()) ->
     _lhsImatchIO
   {-# INLINE rule1340 #-}
   rule1340 = \ ((_lhsImoduleName) :: Maybe Name) ->
     _lhsImoduleName
   {-# INLINE rule1341 #-}
   rule1341 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule1342 #-}
   rule1342 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule1343 #-}
   rule1343 = \ ((_lhsIorderedTypeSynonyms) :: OrderedTypeSynonyms) ->
     _lhsIorderedTypeSynonyms
   {-# INLINE rule1344 #-}
   rule1344 = \ ((_lhsIparentTree) :: InfoTree) ->
     _lhsIparentTree
   {-# INLINE rule1345 #-}
   rule1345 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule1346 #-}
   rule1346 = \ ((_lhsIrequiredPredicates) :: Predicates) ->
     _lhsIrequiredPredicates
   {-# INLINE rule1347 #-}
   rule1347 = \ ((_lhsIsubstitution) :: FixpointSubstitution) ->
     _lhsIsubstitution
   {-# INLINE rule1348 #-}
   rule1348 = \ ((_lhsItryPatterns) :: [(Expression     , [String])]) ->
     _lhsItryPatterns
   {-# INLINE rule1349 #-}
   rule1349 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
   {-# INLINE rule1350 #-}
   rule1350 = \ ((_lhsItypeschemeMap) :: M.Map Int (Scheme Predicates)) ->
     _lhsItypeschemeMap
   {-# INLINE rule1351 #-}
   rule1351 = \ ((_lhsIuniqueChunk) :: Int) ->
     _lhsIuniqueChunk
   {-# INLINE rule1352 #-}
   rule1352 = \ ((_lhsIuniqueSecondRound) :: Int) ->
     _lhsIuniqueSecondRound
   {-# INLINE rule1353 #-}
   rule1353 = \ ((_lhsIvariableMapping) :: Maybe [(Name, Tp)]) ->
     _lhsIvariableMapping
{-# NOINLINE sem_Expression_NormalApplication #-}
sem_Expression_NormalApplication :: T_Range  -> T_Expression  -> T_Expressions  -> T_Expression 
sem_Expression_NormalApplication arg_range_ arg_function_ arg_arguments_ = T_Expression (return st41) where
   {-# NOINLINE st41 #-}
   !st41 = let
      v40 :: T_Expression_v40 
      v40 = \ !(T_Expression_vIn40 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItryPatterns _lhsItypeConstructors _lhsItypeschemeMap _lhsIuniqueChunk _lhsIuniqueSecondRound _lhsIvariableMapping) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _functionX41 = Control.Monad.Identity.runIdentity (attach_T_Expression (arg_function_))
         _argumentsX44 = Control.Monad.Identity.runIdentity (attach_T_Expressions (arg_arguments_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_Expression_vOut40 _functionIassumptions _functionIbeta _functionIbetaUnique _functionIcollectErrors _functionIcollectInstances _functionIcollectWarnings _functionIconstraints _functionIcounter _functionIdictionaryEnvironment _functionIinfoTree _functionImatchIO _functionImatches _functionIpatternMatchWarnings _functionIself _functionIunboundNames _functionIuniqueChunk _functionIuniqueSecondRound) = inv_Expression_s41 _functionX41 (T_Expression_vIn40 _functionOallPatterns _functionOallTypeSchemes _functionOambiguousConflicts _functionOavailablePredicates _functionObetaUnique _functionOclassEnvironment _functionOclassMemberEnv _functionOclassMemberTypeSchemes _functionOclassNamesEnv _functionOclassPredicate _functionOclassTypeSchemes _functionOcollectErrors _functionOcollectWarnings _functionOcounter _functionOcurClassPred _functionOcurPred _functionOcurrentChunk _functionOdictionaryEnvironment _functionOimportEnvironment _functionOinstanceName _functionOinstanceTypes _functionOmatchIO _functionOmoduleName _functionOmonos _functionOnamesInScope _functionOorderedTypeSynonyms _functionOparentTree _functionOpatternMatchWarnings _functionOrequiredPredicates _functionOsubstitution _functionOtryPatterns _functionOtypeConstructors _functionOtypeschemeMap _functionOuniqueChunk _functionOuniqueSecondRound _functionOvariableMapping)
         (T_Expressions_vOut43 _argumentsIassumptions _argumentsIbetaUnique _argumentsIbetas _argumentsIcollectErrors _argumentsIcollectInstances _argumentsIcollectWarnings _argumentsIconstraintslist _argumentsIcounter _argumentsIdictionaryEnvironment _argumentsIinfoTrees _argumentsImatchIO _argumentsImatches _argumentsIpatternMatchWarnings _argumentsIself _argumentsIunboundNames _argumentsIuniqueChunk _argumentsIuniqueSecondRound) = inv_Expressions_s44 _argumentsX44 (T_Expressions_vIn43 _argumentsOallPatterns _argumentsOallTypeSchemes _argumentsOambiguousConflicts _argumentsOavailablePredicates _argumentsObetaUnique _argumentsOclassEnvironment _argumentsOclassMemberEnv _argumentsOclassMemberTypeSchemes _argumentsOclassNamesEnv _argumentsOclassPredicate _argumentsOclassTypeSchemes _argumentsOcollectErrors _argumentsOcollectWarnings _argumentsOcounter _argumentsOcurClassPred _argumentsOcurPred _argumentsOcurrentChunk _argumentsOdictionaryEnvironment _argumentsOimportEnvironment _argumentsOinstanceName _argumentsOinstanceTypes _argumentsOmatchIO _argumentsOmoduleName _argumentsOmonos _argumentsOnamesInScope _argumentsOorderedTypeSynonyms _argumentsOparentTree _argumentsOpatternMatchWarnings _argumentsOrequiredPredicates _argumentsOsubstitution _argumentsOtryPatterns _argumentsOtypeConstructors _argumentsOtypeschemeMap _argumentsOuniqueChunk _argumentsOuniqueSecondRound _argumentsOvariableMapping)
         _lhsOmatches :: [Maybe MetaVariableTable]
         _lhsOconstraints :: ConstraintSet
         _lhsOassumptions :: Assumptions
         _lhsOuniqueSecondRound :: Int
         ((_functionOtryPatterns,_argumentsOtryPatterns),_lhsOmatches,_lhsOconstraints,_lhsOassumptions,_lhsOuniqueSecondRound,_ioMatch) = rule1354 _argumentsImatches _argumentsIuniqueSecondRound _assumptions _constraints _functionImatches _lhsIallPatterns _lhsItryPatterns _localInfo
         _lhsOmatchIO :: IO ()
         _lhsOmatchIO = rule1355 _argumentsImatchIO _ioMatch
         _parentTree = rule1356 _argumentsIinfoTrees _functionIinfoTree _lhsIparentTree _localInfo
         _lhsOinfoTree :: InfoTree
         _lhsOinfoTree = rule1357 _parentTree
         _localInfo = rule1358 _beta _lhsImonos _self
         _cinfo = rule1359 _argumentsIinfoTrees _parentTree
         _functionObetaUnique = rule1360 _lhsIbetaUnique
         _assumptions = rule1361 _argumentsIassumptions _functionIassumptions
         _constraints = rule1362 _argumentsIconstraintslist _functionIconstraints _newcon
         _beta = rule1363 _lhsIbetaUnique
         _newcon = rule1364 _argumentsIbetas _beta _cinfo _functionIbeta
         _lhsOcollectInstances :: [(Name, Instance)]
         _lhsOcollectInstances = rule1365 _argumentsIcollectInstances _functionIcollectInstances
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule1366 _argumentsIunboundNames _functionIunboundNames
         _self = rule1367 _argumentsIself _functionIself _rangeIself
         _lhsOself :: Expression
         _lhsOself = rule1368 _self
         _lhsObeta :: Tp
         _lhsObeta = rule1369 _beta
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule1370 _argumentsIbetaUnique
         _lhsOcollectErrors :: TypeErrors
         _lhsOcollectErrors = rule1371 _argumentsIcollectErrors
         _lhsOcollectWarnings :: Warnings
         _lhsOcollectWarnings = rule1372 _argumentsIcollectWarnings
         _lhsOcounter :: Int
         _lhsOcounter = rule1373 _argumentsIcounter
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule1374 _argumentsIdictionaryEnvironment
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule1375 _argumentsIpatternMatchWarnings
         _lhsOuniqueChunk :: Int
         _lhsOuniqueChunk = rule1376 _argumentsIuniqueChunk
         _functionOallPatterns = rule1377 _lhsIallPatterns
         _functionOallTypeSchemes = rule1378 _lhsIallTypeSchemes
         _functionOambiguousConflicts = rule1379 _lhsIambiguousConflicts
         _functionOavailablePredicates = rule1380 _lhsIavailablePredicates
         _functionOclassEnvironment = rule1381 _lhsIclassEnvironment
         _functionOclassMemberEnv = rule1382 _lhsIclassMemberEnv
         _functionOclassMemberTypeSchemes = rule1383 _lhsIclassMemberTypeSchemes
         _functionOclassNamesEnv = rule1384 _lhsIclassNamesEnv
         _functionOclassPredicate = rule1385 _lhsIclassPredicate
         _functionOclassTypeSchemes = rule1386 _lhsIclassTypeSchemes
         _functionOcollectErrors = rule1387 _lhsIcollectErrors
         _functionOcollectWarnings = rule1388 _lhsIcollectWarnings
         _functionOcounter = rule1389 _lhsIcounter
         _functionOcurClassPred = rule1390 _lhsIcurClassPred
         _functionOcurPred = rule1391 _lhsIcurPred
         _functionOcurrentChunk = rule1392 _lhsIcurrentChunk
         _functionOdictionaryEnvironment = rule1393 _lhsIdictionaryEnvironment
         _functionOimportEnvironment = rule1394 _lhsIimportEnvironment
         _functionOinstanceName = rule1395 _lhsIinstanceName
         _functionOinstanceTypes = rule1396 _lhsIinstanceTypes
         _functionOmatchIO = rule1397 _lhsImatchIO
         _functionOmoduleName = rule1398 _lhsImoduleName
         _functionOmonos = rule1399 _lhsImonos
         _functionOnamesInScope = rule1400 _lhsInamesInScope
         _functionOorderedTypeSynonyms = rule1401 _lhsIorderedTypeSynonyms
         _functionOparentTree = rule1402 _parentTree
         _functionOpatternMatchWarnings = rule1403 _lhsIpatternMatchWarnings
         _functionOrequiredPredicates = rule1404 _lhsIrequiredPredicates
         _functionOsubstitution = rule1405 _lhsIsubstitution
         _functionOtypeConstructors = rule1406 _lhsItypeConstructors
         _functionOtypeschemeMap = rule1407 _lhsItypeschemeMap
         _functionOuniqueChunk = rule1408 _lhsIuniqueChunk
         _functionOuniqueSecondRound = rule1409 _lhsIuniqueSecondRound
         _functionOvariableMapping = rule1410 _lhsIvariableMapping
         _argumentsOallPatterns = rule1411 _lhsIallPatterns
         _argumentsOallTypeSchemes = rule1412 _lhsIallTypeSchemes
         _argumentsOambiguousConflicts = rule1413 _lhsIambiguousConflicts
         _argumentsOavailablePredicates = rule1414 _lhsIavailablePredicates
         _argumentsObetaUnique = rule1415 _functionIbetaUnique
         _argumentsOclassEnvironment = rule1416 _lhsIclassEnvironment
         _argumentsOclassMemberEnv = rule1417 _lhsIclassMemberEnv
         _argumentsOclassMemberTypeSchemes = rule1418 _lhsIclassMemberTypeSchemes
         _argumentsOclassNamesEnv = rule1419 _lhsIclassNamesEnv
         _argumentsOclassPredicate = rule1420 _lhsIclassPredicate
         _argumentsOclassTypeSchemes = rule1421 _lhsIclassTypeSchemes
         _argumentsOcollectErrors = rule1422 _functionIcollectErrors
         _argumentsOcollectWarnings = rule1423 _functionIcollectWarnings
         _argumentsOcounter = rule1424 _functionIcounter
         _argumentsOcurClassPred = rule1425 _lhsIcurClassPred
         _argumentsOcurPred = rule1426 _lhsIcurPred
         _argumentsOcurrentChunk = rule1427 _lhsIcurrentChunk
         _argumentsOdictionaryEnvironment = rule1428 _functionIdictionaryEnvironment
         _argumentsOimportEnvironment = rule1429 _lhsIimportEnvironment
         _argumentsOinstanceName = rule1430 _lhsIinstanceName
         _argumentsOinstanceTypes = rule1431 _lhsIinstanceTypes
         _argumentsOmatchIO = rule1432 _functionImatchIO
         _argumentsOmoduleName = rule1433 _lhsImoduleName
         _argumentsOmonos = rule1434 _lhsImonos
         _argumentsOnamesInScope = rule1435 _lhsInamesInScope
         _argumentsOorderedTypeSynonyms = rule1436 _lhsIorderedTypeSynonyms
         _argumentsOparentTree = rule1437 _parentTree
         _argumentsOpatternMatchWarnings = rule1438 _functionIpatternMatchWarnings
         _argumentsOrequiredPredicates = rule1439 _lhsIrequiredPredicates
         _argumentsOsubstitution = rule1440 _lhsIsubstitution
         _argumentsOtypeConstructors = rule1441 _lhsItypeConstructors
         _argumentsOtypeschemeMap = rule1442 _lhsItypeschemeMap
         _argumentsOuniqueChunk = rule1443 _functionIuniqueChunk
         _argumentsOuniqueSecondRound = rule1444 _functionIuniqueSecondRound
         _argumentsOvariableMapping = rule1445 _lhsIvariableMapping
         !__result_ = T_Expression_vOut40 _lhsOassumptions _lhsObeta _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraints _lhsOcounter _lhsOdictionaryEnvironment _lhsOinfoTree _lhsOmatchIO _lhsOmatches _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOuniqueSecondRound
         in __result_ )
     in C_Expression_s41 v40
   {-# INLINE rule1354 #-}
   rule1354 = \ ((_argumentsImatches) :: [Maybe MetaVariableTable]) ((_argumentsIuniqueSecondRound) :: Int) _assumptions _constraints ((_functionImatches) :: [Maybe MetaVariableTable]) ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ((_lhsItryPatterns) :: [(Expression     , [String])]) _localInfo ->
             let infoTuple = metaVarInfo _constraints _assumptions _localInfo
             in match2 infoTuple _argumentsIuniqueSecondRound
                       match_Expression_NormalApplication
                       _lhsItryPatterns _lhsIallPatterns
                       [_functionImatches, _argumentsImatches]
   {-# INLINE rule1355 #-}
   rule1355 = \ ((_argumentsImatchIO) :: IO ()) _ioMatch ->
                                       _argumentsImatchIO       >> _ioMatch
   {-# INLINE rule1356 #-}
   rule1356 = \ ((_argumentsIinfoTrees) :: InfoTrees) ((_functionIinfoTree) :: InfoTree) ((_lhsIparentTree) :: InfoTree) _localInfo ->
                            node _lhsIparentTree _localInfo (_functionIinfoTree : _argumentsIinfoTrees)
   {-# INLINE rule1357 #-}
   rule1357 = \ _parentTree ->
                            _parentTree
   {-# INLINE rule1358 #-}
   rule1358 = \ _beta ((_lhsImonos) :: Monos) _self ->
                            LocalInfo { self = UHA_Expr _self
                                      , assignedType = Just _beta
                                      , monos = _lhsImonos
                                      }
   {-# INLINE rule1359 #-}
   rule1359 = \ ((_argumentsIinfoTrees) :: InfoTrees) _parentTree ->
     childConstraint 0 "application" _parentTree
        [ ApplicationEdge False (map attribute _argumentsIinfoTrees) ]
   {-# INLINE rule1360 #-}
   rule1360 = \ ((_lhsIbetaUnique) :: Int) ->
                                 _lhsIbetaUnique + 1
   {-# INLINE rule1361 #-}
   rule1361 = \ ((_argumentsIassumptions) :: Assumptions) ((_functionIassumptions) :: Assumptions) ->
                                 _functionIassumptions `combine` _argumentsIassumptions
   {-# INLINE rule1362 #-}
   rule1362 = \ ((_argumentsIconstraintslist) :: ConstraintSets) ((_functionIconstraints) :: ConstraintSet) _newcon ->
                                 _newcon .>.
                                 Node [ _functionIconstraints
                                      , Node _argumentsIconstraintslist
                                      ]
   {-# INLINE rule1363 #-}
   rule1363 = \ ((_lhsIbetaUnique) :: Int) ->
                                 TVar _lhsIbetaUnique
   {-# INLINE rule1364 #-}
   rule1364 = \ ((_argumentsIbetas) :: Tps) _beta _cinfo ((_functionIbeta) :: Tp) ->
                                 [ (_functionIbeta .==. foldr (.->.) _beta _argumentsIbetas) _cinfo ]
   {-# INLINE rule1365 #-}
   rule1365 = \ ((_argumentsIcollectInstances) :: [(Name, Instance)]) ((_functionIcollectInstances) :: [(Name, Instance)]) ->
     _functionIcollectInstances  ++  _argumentsIcollectInstances
   {-# INLINE rule1366 #-}
   rule1366 = \ ((_argumentsIunboundNames) :: Names) ((_functionIunboundNames) :: Names) ->
     ((++) _functionIunboundNames _argumentsIunboundNames)
   {-# INLINE rule1367 #-}
   rule1367 = \ ((_argumentsIself) :: Expressions) ((_functionIself) :: Expression) ((_rangeIself) :: Range) ->
     Expression_NormalApplication _rangeIself _functionIself _argumentsIself
   {-# INLINE rule1368 #-}
   rule1368 = \ _self ->
     _self
   {-# INLINE rule1369 #-}
   rule1369 = \ _beta ->
     _beta
   {-# INLINE rule1370 #-}
   rule1370 = \ ((_argumentsIbetaUnique) :: Int) ->
     _argumentsIbetaUnique
   {-# INLINE rule1371 #-}
   rule1371 = \ ((_argumentsIcollectErrors) :: TypeErrors) ->
     _argumentsIcollectErrors
   {-# INLINE rule1372 #-}
   rule1372 = \ ((_argumentsIcollectWarnings) :: Warnings) ->
     _argumentsIcollectWarnings
   {-# INLINE rule1373 #-}
   rule1373 = \ ((_argumentsIcounter) :: Int) ->
     _argumentsIcounter
   {-# INLINE rule1374 #-}
   rule1374 = \ ((_argumentsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _argumentsIdictionaryEnvironment
   {-# INLINE rule1375 #-}
   rule1375 = \ ((_argumentsIpatternMatchWarnings) :: [Warning]) ->
     _argumentsIpatternMatchWarnings
   {-# INLINE rule1376 #-}
   rule1376 = \ ((_argumentsIuniqueChunk) :: Int) ->
     _argumentsIuniqueChunk
   {-# INLINE rule1377 #-}
   rule1377 = \ ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ->
     _lhsIallPatterns
   {-# INLINE rule1378 #-}
   rule1378 = \ ((_lhsIallTypeSchemes) :: M.Map NameWithRange TpScheme) ->
     _lhsIallTypeSchemes
   {-# INLINE rule1379 #-}
   rule1379 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule1380 #-}
   rule1380 = \ ((_lhsIavailablePredicates) :: [PredicateWithSource]) ->
     _lhsIavailablePredicates
   {-# INLINE rule1381 #-}
   rule1381 = \ ((_lhsIclassEnvironment) :: ClassEnvironment) ->
     _lhsIclassEnvironment
   {-# INLINE rule1382 #-}
   rule1382 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule1383 #-}
   rule1383 = \ ((_lhsIclassMemberTypeSchemes) :: Maybe [(Name, TpScheme)]) ->
     _lhsIclassMemberTypeSchemes
   {-# INLINE rule1384 #-}
   rule1384 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule1385 #-}
   rule1385 = \ ((_lhsIclassPredicate) :: Maybe (Name, Names)) ->
     _lhsIclassPredicate
   {-# INLINE rule1386 #-}
   rule1386 = \ ((_lhsIclassTypeSchemes) :: M.Map Name TpScheme) ->
     _lhsIclassTypeSchemes
   {-# INLINE rule1387 #-}
   rule1387 = \ ((_lhsIcollectErrors) :: TypeErrors) ->
     _lhsIcollectErrors
   {-# INLINE rule1388 #-}
   rule1388 = \ ((_lhsIcollectWarnings) :: Warnings) ->
     _lhsIcollectWarnings
   {-# INLINE rule1389 #-}
   rule1389 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule1390 #-}
   rule1390 = \ ((_lhsIcurClassPred) :: Maybe Predicate) ->
     _lhsIcurClassPred
   {-# INLINE rule1391 #-}
   rule1391 = \ ((_lhsIcurPred) :: Maybe Predicate) ->
     _lhsIcurPred
   {-# INLINE rule1392 #-}
   rule1392 = \ ((_lhsIcurrentChunk) :: Int) ->
     _lhsIcurrentChunk
   {-# INLINE rule1393 #-}
   rule1393 = \ ((_lhsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _lhsIdictionaryEnvironment
   {-# INLINE rule1394 #-}
   rule1394 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule1395 #-}
   rule1395 = \ ((_lhsIinstanceName) :: Maybe Name) ->
     _lhsIinstanceName
   {-# INLINE rule1396 #-}
   rule1396 = \ ((_lhsIinstanceTypes) :: [(Name, TpScheme)]) ->
     _lhsIinstanceTypes
   {-# INLINE rule1397 #-}
   rule1397 = \ ((_lhsImatchIO) :: IO ()) ->
     _lhsImatchIO
   {-# INLINE rule1398 #-}
   rule1398 = \ ((_lhsImoduleName) :: Maybe Name) ->
     _lhsImoduleName
   {-# INLINE rule1399 #-}
   rule1399 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule1400 #-}
   rule1400 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule1401 #-}
   rule1401 = \ ((_lhsIorderedTypeSynonyms) :: OrderedTypeSynonyms) ->
     _lhsIorderedTypeSynonyms
   {-# INLINE rule1402 #-}
   rule1402 = \ _parentTree ->
     _parentTree
   {-# INLINE rule1403 #-}
   rule1403 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule1404 #-}
   rule1404 = \ ((_lhsIrequiredPredicates) :: Predicates) ->
     _lhsIrequiredPredicates
   {-# INLINE rule1405 #-}
   rule1405 = \ ((_lhsIsubstitution) :: FixpointSubstitution) ->
     _lhsIsubstitution
   {-# INLINE rule1406 #-}
   rule1406 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
   {-# INLINE rule1407 #-}
   rule1407 = \ ((_lhsItypeschemeMap) :: M.Map Int (Scheme Predicates)) ->
     _lhsItypeschemeMap
   {-# INLINE rule1408 #-}
   rule1408 = \ ((_lhsIuniqueChunk) :: Int) ->
     _lhsIuniqueChunk
   {-# INLINE rule1409 #-}
   rule1409 = \ ((_lhsIuniqueSecondRound) :: Int) ->
     _lhsIuniqueSecondRound
   {-# INLINE rule1410 #-}
   rule1410 = \ ((_lhsIvariableMapping) :: Maybe [(Name, Tp)]) ->
     _lhsIvariableMapping
   {-# INLINE rule1411 #-}
   rule1411 = \ ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ->
     _lhsIallPatterns
   {-# INLINE rule1412 #-}
   rule1412 = \ ((_lhsIallTypeSchemes) :: M.Map NameWithRange TpScheme) ->
     _lhsIallTypeSchemes
   {-# INLINE rule1413 #-}
   rule1413 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule1414 #-}
   rule1414 = \ ((_lhsIavailablePredicates) :: [PredicateWithSource]) ->
     _lhsIavailablePredicates
   {-# INLINE rule1415 #-}
   rule1415 = \ ((_functionIbetaUnique) :: Int) ->
     _functionIbetaUnique
   {-# INLINE rule1416 #-}
   rule1416 = \ ((_lhsIclassEnvironment) :: ClassEnvironment) ->
     _lhsIclassEnvironment
   {-# INLINE rule1417 #-}
   rule1417 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule1418 #-}
   rule1418 = \ ((_lhsIclassMemberTypeSchemes) :: Maybe [(Name, TpScheme)]) ->
     _lhsIclassMemberTypeSchemes
   {-# INLINE rule1419 #-}
   rule1419 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule1420 #-}
   rule1420 = \ ((_lhsIclassPredicate) :: Maybe (Name, Names)) ->
     _lhsIclassPredicate
   {-# INLINE rule1421 #-}
   rule1421 = \ ((_lhsIclassTypeSchemes) :: M.Map Name TpScheme) ->
     _lhsIclassTypeSchemes
   {-# INLINE rule1422 #-}
   rule1422 = \ ((_functionIcollectErrors) :: TypeErrors) ->
     _functionIcollectErrors
   {-# INLINE rule1423 #-}
   rule1423 = \ ((_functionIcollectWarnings) :: Warnings) ->
     _functionIcollectWarnings
   {-# INLINE rule1424 #-}
   rule1424 = \ ((_functionIcounter) :: Int) ->
     _functionIcounter
   {-# INLINE rule1425 #-}
   rule1425 = \ ((_lhsIcurClassPred) :: Maybe Predicate) ->
     _lhsIcurClassPred
   {-# INLINE rule1426 #-}
   rule1426 = \ ((_lhsIcurPred) :: Maybe Predicate) ->
     _lhsIcurPred
   {-# INLINE rule1427 #-}
   rule1427 = \ ((_lhsIcurrentChunk) :: Int) ->
     _lhsIcurrentChunk
   {-# INLINE rule1428 #-}
   rule1428 = \ ((_functionIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _functionIdictionaryEnvironment
   {-# INLINE rule1429 #-}
   rule1429 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule1430 #-}
   rule1430 = \ ((_lhsIinstanceName) :: Maybe Name) ->
     _lhsIinstanceName
   {-# INLINE rule1431 #-}
   rule1431 = \ ((_lhsIinstanceTypes) :: [(Name, TpScheme)]) ->
     _lhsIinstanceTypes
   {-# INLINE rule1432 #-}
   rule1432 = \ ((_functionImatchIO) :: IO ()) ->
     _functionImatchIO
   {-# INLINE rule1433 #-}
   rule1433 = \ ((_lhsImoduleName) :: Maybe Name) ->
     _lhsImoduleName
   {-# INLINE rule1434 #-}
   rule1434 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule1435 #-}
   rule1435 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule1436 #-}
   rule1436 = \ ((_lhsIorderedTypeSynonyms) :: OrderedTypeSynonyms) ->
     _lhsIorderedTypeSynonyms
   {-# INLINE rule1437 #-}
   rule1437 = \ _parentTree ->
     _parentTree
   {-# INLINE rule1438 #-}
   rule1438 = \ ((_functionIpatternMatchWarnings) :: [Warning]) ->
     _functionIpatternMatchWarnings
   {-# INLINE rule1439 #-}
   rule1439 = \ ((_lhsIrequiredPredicates) :: Predicates) ->
     _lhsIrequiredPredicates
   {-# INLINE rule1440 #-}
   rule1440 = \ ((_lhsIsubstitution) :: FixpointSubstitution) ->
     _lhsIsubstitution
   {-# INLINE rule1441 #-}
   rule1441 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
   {-# INLINE rule1442 #-}
   rule1442 = \ ((_lhsItypeschemeMap) :: M.Map Int (Scheme Predicates)) ->
     _lhsItypeschemeMap
   {-# INLINE rule1443 #-}
   rule1443 = \ ((_functionIuniqueChunk) :: Int) ->
     _functionIuniqueChunk
   {-# INLINE rule1444 #-}
   rule1444 = \ ((_functionIuniqueSecondRound) :: Int) ->
     _functionIuniqueSecondRound
   {-# INLINE rule1445 #-}
   rule1445 = \ ((_lhsIvariableMapping) :: Maybe [(Name, Tp)]) ->
     _lhsIvariableMapping
{-# NOINLINE sem_Expression_InfixApplication #-}
sem_Expression_InfixApplication :: T_Range  -> T_MaybeExpression  -> T_Expression  -> T_MaybeExpression  -> T_Expression 
sem_Expression_InfixApplication arg_range_ arg_leftExpression_ arg_operator_ arg_rightExpression_ = T_Expression (return st41) where
   {-# NOINLINE st41 #-}
   !st41 = let
      v40 :: T_Expression_v40 
      v40 = \ !(T_Expression_vIn40 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItryPatterns _lhsItypeConstructors _lhsItypeschemeMap _lhsIuniqueChunk _lhsIuniqueSecondRound _lhsIvariableMapping) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _leftExpressionX95 = Control.Monad.Identity.runIdentity (attach_T_MaybeExpression (arg_leftExpression_))
         _operatorX41 = Control.Monad.Identity.runIdentity (attach_T_Expression (arg_operator_))
         _rightExpressionX95 = Control.Monad.Identity.runIdentity (attach_T_MaybeExpression (arg_rightExpression_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_MaybeExpression_vOut94 _leftExpressionIassumptions _leftExpressionIbeta _leftExpressionIbetaUnique _leftExpressionIcollectErrors _leftExpressionIcollectInstances _leftExpressionIcollectWarnings _leftExpressionIconstraints _leftExpressionIcounter _leftExpressionIdictionaryEnvironment _leftExpressionIinfoTrees _leftExpressionImatchIO _leftExpressionImatches _leftExpressionIpatternMatchWarnings _leftExpressionIsection _leftExpressionIself _leftExpressionIunboundNames _leftExpressionIuniqueChunk _leftExpressionIuniqueSecondRound) = inv_MaybeExpression_s95 _leftExpressionX95 (T_MaybeExpression_vIn94 _leftExpressionOallPatterns _leftExpressionOallTypeSchemes _leftExpressionOambiguousConflicts _leftExpressionOavailablePredicates _leftExpressionObetaUnique _leftExpressionOclassEnvironment _leftExpressionOclassMemberEnv _leftExpressionOclassMemberTypeSchemes _leftExpressionOclassNamesEnv _leftExpressionOclassPredicate _leftExpressionOclassTypeSchemes _leftExpressionOcollectErrors _leftExpressionOcollectWarnings _leftExpressionOcounter _leftExpressionOcurClassPred _leftExpressionOcurPred _leftExpressionOcurrentChunk _leftExpressionOdictionaryEnvironment _leftExpressionOimportEnvironment _leftExpressionOinstanceName _leftExpressionOinstanceTypes _leftExpressionOmatchIO _leftExpressionOmoduleName _leftExpressionOmonos _leftExpressionOnamesInScope _leftExpressionOorderedTypeSynonyms _leftExpressionOparentTree _leftExpressionOpatternMatchWarnings _leftExpressionOrequiredPredicates _leftExpressionOsubstitution _leftExpressionOtryPatterns _leftExpressionOtypeConstructors _leftExpressionOtypeschemeMap _leftExpressionOuniqueChunk _leftExpressionOuniqueSecondRound _leftExpressionOvariableMapping)
         (T_Expression_vOut40 _operatorIassumptions _operatorIbeta _operatorIbetaUnique _operatorIcollectErrors _operatorIcollectInstances _operatorIcollectWarnings _operatorIconstraints _operatorIcounter _operatorIdictionaryEnvironment _operatorIinfoTree _operatorImatchIO _operatorImatches _operatorIpatternMatchWarnings _operatorIself _operatorIunboundNames _operatorIuniqueChunk _operatorIuniqueSecondRound) = inv_Expression_s41 _operatorX41 (T_Expression_vIn40 _operatorOallPatterns _operatorOallTypeSchemes _operatorOambiguousConflicts _operatorOavailablePredicates _operatorObetaUnique _operatorOclassEnvironment _operatorOclassMemberEnv _operatorOclassMemberTypeSchemes _operatorOclassNamesEnv _operatorOclassPredicate _operatorOclassTypeSchemes _operatorOcollectErrors _operatorOcollectWarnings _operatorOcounter _operatorOcurClassPred _operatorOcurPred _operatorOcurrentChunk _operatorOdictionaryEnvironment _operatorOimportEnvironment _operatorOinstanceName _operatorOinstanceTypes _operatorOmatchIO _operatorOmoduleName _operatorOmonos _operatorOnamesInScope _operatorOorderedTypeSynonyms _operatorOparentTree _operatorOpatternMatchWarnings _operatorOrequiredPredicates _operatorOsubstitution _operatorOtryPatterns _operatorOtypeConstructors _operatorOtypeschemeMap _operatorOuniqueChunk _operatorOuniqueSecondRound _operatorOvariableMapping)
         (T_MaybeExpression_vOut94 _rightExpressionIassumptions _rightExpressionIbeta _rightExpressionIbetaUnique _rightExpressionIcollectErrors _rightExpressionIcollectInstances _rightExpressionIcollectWarnings _rightExpressionIconstraints _rightExpressionIcounter _rightExpressionIdictionaryEnvironment _rightExpressionIinfoTrees _rightExpressionImatchIO _rightExpressionImatches _rightExpressionIpatternMatchWarnings _rightExpressionIsection _rightExpressionIself _rightExpressionIunboundNames _rightExpressionIuniqueChunk _rightExpressionIuniqueSecondRound) = inv_MaybeExpression_s95 _rightExpressionX95 (T_MaybeExpression_vIn94 _rightExpressionOallPatterns _rightExpressionOallTypeSchemes _rightExpressionOambiguousConflicts _rightExpressionOavailablePredicates _rightExpressionObetaUnique _rightExpressionOclassEnvironment _rightExpressionOclassMemberEnv _rightExpressionOclassMemberTypeSchemes _rightExpressionOclassNamesEnv _rightExpressionOclassPredicate _rightExpressionOclassTypeSchemes _rightExpressionOcollectErrors _rightExpressionOcollectWarnings _rightExpressionOcounter _rightExpressionOcurClassPred _rightExpressionOcurPred _rightExpressionOcurrentChunk _rightExpressionOdictionaryEnvironment _rightExpressionOimportEnvironment _rightExpressionOinstanceName _rightExpressionOinstanceTypes _rightExpressionOmatchIO _rightExpressionOmoduleName _rightExpressionOmonos _rightExpressionOnamesInScope _rightExpressionOorderedTypeSynonyms _rightExpressionOparentTree _rightExpressionOpatternMatchWarnings _rightExpressionOrequiredPredicates _rightExpressionOsubstitution _rightExpressionOtryPatterns _rightExpressionOtypeConstructors _rightExpressionOtypeschemeMap _rightExpressionOuniqueChunk _rightExpressionOuniqueSecondRound _rightExpressionOvariableMapping)
         _lhsOmatches :: [Maybe MetaVariableTable]
         _lhsOconstraints :: ConstraintSet
         _lhsOassumptions :: Assumptions
         _lhsOuniqueSecondRound :: Int
         ((_leftExpressionOtryPatterns,_operatorOtryPatterns,_rightExpressionOtryPatterns),_lhsOmatches,_lhsOconstraints,_lhsOassumptions,_lhsOuniqueSecondRound,_ioMatch) = rule1446 _assumptions _constraints _leftExpressionImatches _lhsIallPatterns _lhsItryPatterns _localInfo _operatorImatches _rightExpressionImatches _rightExpressionIuniqueSecondRound
         _lhsOmatchIO :: IO ()
         _lhsOmatchIO = rule1447 _ioMatch _rightExpressionImatchIO
         _parentTree = rule1448 _leftExpressionIinfoTrees _lhsIparentTree _localInfo _operatorIinfoTree _rightExpressionIinfoTrees
         _lhsOinfoTree :: InfoTree
         _lhsOinfoTree = rule1449 _parentTree
         _localInfo = rule1450 _beta _lhsImonos _self
         _operatorNr = rule1451 _leftExpressionIinfoTrees
         _cinfoOperator = rule1452 _leftExpressionIinfoTrees _leftExpressionIsection _operatorNr _parentTree _rightExpressionIinfoTrees _rightExpressionIsection
         _cinfoComplete = rule1453 _localInfo _parentTree
         _cinfoLeftSection = rule1454 _localInfo _parentTree
         _cinfoRightSection = rule1455 _localInfo _parentTree
         _cinfoEmpty = rule1456 _localInfo _parentTree
         _leftExpressionObetaUnique = rule1457 _lhsIbetaUnique
         _assumptions = rule1458 _leftExpressionIassumptions _operatorIassumptions _rightExpressionIassumptions
         _constraints = rule1459 _conTotal _leftExpressionIconstraints _operatorIconstraints _rightExpressionIconstraints
         _beta = rule1460 _lhsIbetaUnique
         _betaResOp = rule1461 _lhsIbetaUnique
         _conOperator = rule1462 _betaResOp _cinfoOperator _leftExpressionIbeta _operatorIbeta _rightExpressionIbeta
         _conTotal = rule1463 _beta _betaResOp _cinfoComplete _cinfoEmpty _cinfoLeftSection _cinfoRightSection _conOperator _leftExpressionIbeta _leftExpressionIsection _operatorIbeta _rightExpressionIbeta _rightExpressionIsection
         _lhsOcollectInstances :: [(Name, Instance)]
         _lhsOcollectInstances = rule1464 _leftExpressionIcollectInstances _operatorIcollectInstances _rightExpressionIcollectInstances
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule1465 _leftExpressionIunboundNames _operatorIunboundNames _rightExpressionIunboundNames
         _self = rule1466 _leftExpressionIself _operatorIself _rangeIself _rightExpressionIself
         _lhsOself :: Expression
         _lhsOself = rule1467 _self
         _lhsObeta :: Tp
         _lhsObeta = rule1468 _beta
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule1469 _rightExpressionIbetaUnique
         _lhsOcollectErrors :: TypeErrors
         _lhsOcollectErrors = rule1470 _rightExpressionIcollectErrors
         _lhsOcollectWarnings :: Warnings
         _lhsOcollectWarnings = rule1471 _rightExpressionIcollectWarnings
         _lhsOcounter :: Int
         _lhsOcounter = rule1472 _rightExpressionIcounter
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule1473 _rightExpressionIdictionaryEnvironment
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule1474 _rightExpressionIpatternMatchWarnings
         _lhsOuniqueChunk :: Int
         _lhsOuniqueChunk = rule1475 _rightExpressionIuniqueChunk
         _leftExpressionOallPatterns = rule1476 _lhsIallPatterns
         _leftExpressionOallTypeSchemes = rule1477 _lhsIallTypeSchemes
         _leftExpressionOambiguousConflicts = rule1478 _lhsIambiguousConflicts
         _leftExpressionOavailablePredicates = rule1479 _lhsIavailablePredicates
         _leftExpressionOclassEnvironment = rule1480 _lhsIclassEnvironment
         _leftExpressionOclassMemberEnv = rule1481 _lhsIclassMemberEnv
         _leftExpressionOclassMemberTypeSchemes = rule1482 _lhsIclassMemberTypeSchemes
         _leftExpressionOclassNamesEnv = rule1483 _lhsIclassNamesEnv
         _leftExpressionOclassPredicate = rule1484 _lhsIclassPredicate
         _leftExpressionOclassTypeSchemes = rule1485 _lhsIclassTypeSchemes
         _leftExpressionOcollectErrors = rule1486 _lhsIcollectErrors
         _leftExpressionOcollectWarnings = rule1487 _lhsIcollectWarnings
         _leftExpressionOcounter = rule1488 _lhsIcounter
         _leftExpressionOcurClassPred = rule1489 _lhsIcurClassPred
         _leftExpressionOcurPred = rule1490 _lhsIcurPred
         _leftExpressionOcurrentChunk = rule1491 _lhsIcurrentChunk
         _leftExpressionOdictionaryEnvironment = rule1492 _lhsIdictionaryEnvironment
         _leftExpressionOimportEnvironment = rule1493 _lhsIimportEnvironment
         _leftExpressionOinstanceName = rule1494 _lhsIinstanceName
         _leftExpressionOinstanceTypes = rule1495 _lhsIinstanceTypes
         _leftExpressionOmatchIO = rule1496 _lhsImatchIO
         _leftExpressionOmoduleName = rule1497 _lhsImoduleName
         _leftExpressionOmonos = rule1498 _lhsImonos
         _leftExpressionOnamesInScope = rule1499 _lhsInamesInScope
         _leftExpressionOorderedTypeSynonyms = rule1500 _lhsIorderedTypeSynonyms
         _leftExpressionOparentTree = rule1501 _parentTree
         _leftExpressionOpatternMatchWarnings = rule1502 _lhsIpatternMatchWarnings
         _leftExpressionOrequiredPredicates = rule1503 _lhsIrequiredPredicates
         _leftExpressionOsubstitution = rule1504 _lhsIsubstitution
         _leftExpressionOtypeConstructors = rule1505 _lhsItypeConstructors
         _leftExpressionOtypeschemeMap = rule1506 _lhsItypeschemeMap
         _leftExpressionOuniqueChunk = rule1507 _lhsIuniqueChunk
         _leftExpressionOuniqueSecondRound = rule1508 _lhsIuniqueSecondRound
         _leftExpressionOvariableMapping = rule1509 _lhsIvariableMapping
         _operatorOallPatterns = rule1510 _lhsIallPatterns
         _operatorOallTypeSchemes = rule1511 _lhsIallTypeSchemes
         _operatorOambiguousConflicts = rule1512 _lhsIambiguousConflicts
         _operatorOavailablePredicates = rule1513 _lhsIavailablePredicates
         _operatorObetaUnique = rule1514 _leftExpressionIbetaUnique
         _operatorOclassEnvironment = rule1515 _lhsIclassEnvironment
         _operatorOclassMemberEnv = rule1516 _lhsIclassMemberEnv
         _operatorOclassMemberTypeSchemes = rule1517 _lhsIclassMemberTypeSchemes
         _operatorOclassNamesEnv = rule1518 _lhsIclassNamesEnv
         _operatorOclassPredicate = rule1519 _lhsIclassPredicate
         _operatorOclassTypeSchemes = rule1520 _lhsIclassTypeSchemes
         _operatorOcollectErrors = rule1521 _leftExpressionIcollectErrors
         _operatorOcollectWarnings = rule1522 _leftExpressionIcollectWarnings
         _operatorOcounter = rule1523 _leftExpressionIcounter
         _operatorOcurClassPred = rule1524 _lhsIcurClassPred
         _operatorOcurPred = rule1525 _lhsIcurPred
         _operatorOcurrentChunk = rule1526 _lhsIcurrentChunk
         _operatorOdictionaryEnvironment = rule1527 _leftExpressionIdictionaryEnvironment
         _operatorOimportEnvironment = rule1528 _lhsIimportEnvironment
         _operatorOinstanceName = rule1529 _lhsIinstanceName
         _operatorOinstanceTypes = rule1530 _lhsIinstanceTypes
         _operatorOmatchIO = rule1531 _leftExpressionImatchIO
         _operatorOmoduleName = rule1532 _lhsImoduleName
         _operatorOmonos = rule1533 _lhsImonos
         _operatorOnamesInScope = rule1534 _lhsInamesInScope
         _operatorOorderedTypeSynonyms = rule1535 _lhsIorderedTypeSynonyms
         _operatorOparentTree = rule1536 _parentTree
         _operatorOpatternMatchWarnings = rule1537 _leftExpressionIpatternMatchWarnings
         _operatorOrequiredPredicates = rule1538 _lhsIrequiredPredicates
         _operatorOsubstitution = rule1539 _lhsIsubstitution
         _operatorOtypeConstructors = rule1540 _lhsItypeConstructors
         _operatorOtypeschemeMap = rule1541 _lhsItypeschemeMap
         _operatorOuniqueChunk = rule1542 _leftExpressionIuniqueChunk
         _operatorOuniqueSecondRound = rule1543 _leftExpressionIuniqueSecondRound
         _operatorOvariableMapping = rule1544 _lhsIvariableMapping
         _rightExpressionOallPatterns = rule1545 _lhsIallPatterns
         _rightExpressionOallTypeSchemes = rule1546 _lhsIallTypeSchemes
         _rightExpressionOambiguousConflicts = rule1547 _lhsIambiguousConflicts
         _rightExpressionOavailablePredicates = rule1548 _lhsIavailablePredicates
         _rightExpressionObetaUnique = rule1549 _operatorIbetaUnique
         _rightExpressionOclassEnvironment = rule1550 _lhsIclassEnvironment
         _rightExpressionOclassMemberEnv = rule1551 _lhsIclassMemberEnv
         _rightExpressionOclassMemberTypeSchemes = rule1552 _lhsIclassMemberTypeSchemes
         _rightExpressionOclassNamesEnv = rule1553 _lhsIclassNamesEnv
         _rightExpressionOclassPredicate = rule1554 _lhsIclassPredicate
         _rightExpressionOclassTypeSchemes = rule1555 _lhsIclassTypeSchemes
         _rightExpressionOcollectErrors = rule1556 _operatorIcollectErrors
         _rightExpressionOcollectWarnings = rule1557 _operatorIcollectWarnings
         _rightExpressionOcounter = rule1558 _operatorIcounter
         _rightExpressionOcurClassPred = rule1559 _lhsIcurClassPred
         _rightExpressionOcurPred = rule1560 _lhsIcurPred
         _rightExpressionOcurrentChunk = rule1561 _lhsIcurrentChunk
         _rightExpressionOdictionaryEnvironment = rule1562 _operatorIdictionaryEnvironment
         _rightExpressionOimportEnvironment = rule1563 _lhsIimportEnvironment
         _rightExpressionOinstanceName = rule1564 _lhsIinstanceName
         _rightExpressionOinstanceTypes = rule1565 _lhsIinstanceTypes
         _rightExpressionOmatchIO = rule1566 _operatorImatchIO
         _rightExpressionOmoduleName = rule1567 _lhsImoduleName
         _rightExpressionOmonos = rule1568 _lhsImonos
         _rightExpressionOnamesInScope = rule1569 _lhsInamesInScope
         _rightExpressionOorderedTypeSynonyms = rule1570 _lhsIorderedTypeSynonyms
         _rightExpressionOparentTree = rule1571 _parentTree
         _rightExpressionOpatternMatchWarnings = rule1572 _operatorIpatternMatchWarnings
         _rightExpressionOrequiredPredicates = rule1573 _lhsIrequiredPredicates
         _rightExpressionOsubstitution = rule1574 _lhsIsubstitution
         _rightExpressionOtypeConstructors = rule1575 _lhsItypeConstructors
         _rightExpressionOtypeschemeMap = rule1576 _lhsItypeschemeMap
         _rightExpressionOuniqueChunk = rule1577 _operatorIuniqueChunk
         _rightExpressionOuniqueSecondRound = rule1578 _operatorIuniqueSecondRound
         _rightExpressionOvariableMapping = rule1579 _lhsIvariableMapping
         !__result_ = T_Expression_vOut40 _lhsOassumptions _lhsObeta _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraints _lhsOcounter _lhsOdictionaryEnvironment _lhsOinfoTree _lhsOmatchIO _lhsOmatches _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOuniqueSecondRound
         in __result_ )
     in C_Expression_s41 v40
   {-# INLINE rule1446 #-}
   rule1446 = \ _assumptions _constraints ((_leftExpressionImatches) :: [Maybe MetaVariableTable]) ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ((_lhsItryPatterns) :: [(Expression     , [String])]) _localInfo ((_operatorImatches) :: [Maybe MetaVariableTable]) ((_rightExpressionImatches) :: [Maybe MetaVariableTable]) ((_rightExpressionIuniqueSecondRound) :: Int) ->
             let infoTuple = metaVarInfo _constraints _assumptions _localInfo
             in match3 infoTuple _rightExpressionIuniqueSecondRound
                       match_Expression_InfixApplication
                       _lhsItryPatterns _lhsIallPatterns
                       [_leftExpressionImatches, _operatorImatches,_rightExpressionImatches]
   {-# INLINE rule1447 #-}
   rule1447 = \ _ioMatch ((_rightExpressionImatchIO) :: IO ()) ->
                                       _rightExpressionImatchIO >> _ioMatch
   {-# INLINE rule1448 #-}
   rule1448 = \ ((_leftExpressionIinfoTrees) :: InfoTrees) ((_lhsIparentTree) :: InfoTree) _localInfo ((_operatorIinfoTree) :: InfoTree) ((_rightExpressionIinfoTrees) :: InfoTrees) ->
                            node _lhsIparentTree _localInfo
                              (_leftExpressionIinfoTrees ++ [_operatorIinfoTree] ++ _rightExpressionIinfoTrees)
   {-# INLINE rule1449 #-}
   rule1449 = \ _parentTree ->
                            _parentTree
   {-# INLINE rule1450 #-}
   rule1450 = \ _beta ((_lhsImonos) :: Monos) _self ->
                            LocalInfo { self = UHA_Expr _self
                                      , assignedType = Just _beta
                                      , monos = _lhsImonos
                                      }
   {-# INLINE rule1451 #-}
   rule1451 = \ ((_leftExpressionIinfoTrees) :: InfoTrees) ->
                                                          length _leftExpressionIinfoTrees
   {-# INLINE rule1452 #-}
   rule1452 = \ ((_leftExpressionIinfoTrees) :: InfoTrees) ((_leftExpressionIsection) :: Bool) _operatorNr _parentTree ((_rightExpressionIinfoTrees) :: InfoTrees) ((_rightExpressionIsection) :: Bool) ->
     childConstraint _operatorNr "infix application" _parentTree $
        if _leftExpressionIsection || _rightExpressionIsection
        then [ HasTrustFactor 10.0 ]
        else [ ApplicationEdge True (map attribute (_leftExpressionIinfoTrees ++ _rightExpressionIinfoTrees)) ]
   {-# INLINE rule1453 #-}
   rule1453 = \ _localInfo _parentTree ->
     specialConstraint "infix application (INTERNAL ERROR)" _parentTree
        (self _localInfo, Nothing)
        [ FolkloreConstraint, highlyTrusted ]
   {-# INLINE rule1454 #-}
   rule1454 = \ _localInfo _parentTree ->
     specialConstraint "left section" _parentTree
        (self _localInfo, Nothing)
        [  ]
   {-# INLINE rule1455 #-}
   rule1455 = \ _localInfo _parentTree ->
     specialConstraint "right section" _parentTree
        (self _localInfo, Nothing)
        [ ]
   {-# INLINE rule1456 #-}
   rule1456 = \ _localInfo _parentTree ->
     specialConstraint "infix application" _parentTree
       (self _localInfo, Nothing)
       [ FolkloreConstraint, HasTrustFactor 10.0 ]
   {-# INLINE rule1457 #-}
   rule1457 = \ ((_lhsIbetaUnique) :: Int) ->
                                       _lhsIbetaUnique + 2
   {-# INLINE rule1458 #-}
   rule1458 = \ ((_leftExpressionIassumptions) :: Assumptions) ((_operatorIassumptions) :: Assumptions) ((_rightExpressionIassumptions) :: Assumptions) ->
                                       _leftExpressionIassumptions `combine` _operatorIassumptions `combine` _rightExpressionIassumptions
   {-# INLINE rule1459 #-}
   rule1459 = \ _conTotal ((_leftExpressionIconstraints) :: ConstraintSet) ((_operatorIconstraints) :: ConstraintSet) ((_rightExpressionIconstraints) :: ConstraintSet) ->
                                       _conTotal .>.
                                       Node [ _operatorIconstraints
                                            , _leftExpressionIconstraints
                                            , _rightExpressionIconstraints
                                            ]
   {-# INLINE rule1460 #-}
   rule1460 = \ ((_lhsIbetaUnique) :: Int) ->
                                       TVar _lhsIbetaUnique
   {-# INLINE rule1461 #-}
   rule1461 = \ ((_lhsIbetaUnique) :: Int) ->
                                       TVar (_lhsIbetaUnique + 1)
   {-# INLINE rule1462 #-}
   rule1462 = \ _betaResOp _cinfoOperator ((_leftExpressionIbeta) :: Tp) ((_operatorIbeta) :: Tp) ((_rightExpressionIbeta) :: Tp) ->
                                       (_operatorIbeta .==. _leftExpressionIbeta .->. _rightExpressionIbeta .->. _betaResOp) _cinfoOperator
   {-# INLINE rule1463 #-}
   rule1463 = \ _beta _betaResOp _cinfoComplete _cinfoEmpty _cinfoLeftSection _cinfoRightSection _conOperator ((_leftExpressionIbeta) :: Tp) ((_leftExpressionIsection) :: Bool) ((_operatorIbeta) :: Tp) ((_rightExpressionIbeta) :: Tp) ((_rightExpressionIsection) :: Bool) ->
                                       case (_leftExpressionIsection,_rightExpressionIsection) of
                                              (False,False) -> [ _conOperator, (_betaResOp     .==. _beta)                        _cinfoComplete     ]
                                              (True ,True ) -> [               (_operatorIbeta .==. _beta)                        _cinfoEmpty        ]
                                              (False,True ) -> [ _conOperator, (_rightExpressionIbeta .->. _betaResOp .==. _beta) _cinfoRightSection ]
                                              (True ,False) -> [ _conOperator, (_leftExpressionIbeta  .->. _betaResOp .==. _beta) _cinfoLeftSection  ]
   {-# INLINE rule1464 #-}
   rule1464 = \ ((_leftExpressionIcollectInstances) :: [(Name, Instance)]) ((_operatorIcollectInstances) :: [(Name, Instance)]) ((_rightExpressionIcollectInstances) :: [(Name, Instance)]) ->
     _leftExpressionIcollectInstances  ++  _operatorIcollectInstances  ++  _rightExpressionIcollectInstances
   {-# INLINE rule1465 #-}
   rule1465 = \ ((_leftExpressionIunboundNames) :: Names) ((_operatorIunboundNames) :: Names) ((_rightExpressionIunboundNames) :: Names) ->
     ((++) _leftExpressionIunboundNames ((++) _operatorIunboundNames _rightExpressionIunboundNames))
   {-# INLINE rule1466 #-}
   rule1466 = \ ((_leftExpressionIself) :: MaybeExpression) ((_operatorIself) :: Expression) ((_rangeIself) :: Range) ((_rightExpressionIself) :: MaybeExpression) ->
     Expression_InfixApplication _rangeIself _leftExpressionIself _operatorIself _rightExpressionIself
   {-# INLINE rule1467 #-}
   rule1467 = \ _self ->
     _self
   {-# INLINE rule1468 #-}
   rule1468 = \ _beta ->
     _beta
   {-# INLINE rule1469 #-}
   rule1469 = \ ((_rightExpressionIbetaUnique) :: Int) ->
     _rightExpressionIbetaUnique
   {-# INLINE rule1470 #-}
   rule1470 = \ ((_rightExpressionIcollectErrors) :: TypeErrors) ->
     _rightExpressionIcollectErrors
   {-# INLINE rule1471 #-}
   rule1471 = \ ((_rightExpressionIcollectWarnings) :: Warnings) ->
     _rightExpressionIcollectWarnings
   {-# INLINE rule1472 #-}
   rule1472 = \ ((_rightExpressionIcounter) :: Int) ->
     _rightExpressionIcounter
   {-# INLINE rule1473 #-}
   rule1473 = \ ((_rightExpressionIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _rightExpressionIdictionaryEnvironment
   {-# INLINE rule1474 #-}
   rule1474 = \ ((_rightExpressionIpatternMatchWarnings) :: [Warning]) ->
     _rightExpressionIpatternMatchWarnings
   {-# INLINE rule1475 #-}
   rule1475 = \ ((_rightExpressionIuniqueChunk) :: Int) ->
     _rightExpressionIuniqueChunk
   {-# INLINE rule1476 #-}
   rule1476 = \ ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ->
     _lhsIallPatterns
   {-# INLINE rule1477 #-}
   rule1477 = \ ((_lhsIallTypeSchemes) :: M.Map NameWithRange TpScheme) ->
     _lhsIallTypeSchemes
   {-# INLINE rule1478 #-}
   rule1478 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule1479 #-}
   rule1479 = \ ((_lhsIavailablePredicates) :: [PredicateWithSource]) ->
     _lhsIavailablePredicates
   {-# INLINE rule1480 #-}
   rule1480 = \ ((_lhsIclassEnvironment) :: ClassEnvironment) ->
     _lhsIclassEnvironment
   {-# INLINE rule1481 #-}
   rule1481 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule1482 #-}
   rule1482 = \ ((_lhsIclassMemberTypeSchemes) :: Maybe [(Name, TpScheme)]) ->
     _lhsIclassMemberTypeSchemes
   {-# INLINE rule1483 #-}
   rule1483 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule1484 #-}
   rule1484 = \ ((_lhsIclassPredicate) :: Maybe (Name, Names)) ->
     _lhsIclassPredicate
   {-# INLINE rule1485 #-}
   rule1485 = \ ((_lhsIclassTypeSchemes) :: M.Map Name TpScheme) ->
     _lhsIclassTypeSchemes
   {-# INLINE rule1486 #-}
   rule1486 = \ ((_lhsIcollectErrors) :: TypeErrors) ->
     _lhsIcollectErrors
   {-# INLINE rule1487 #-}
   rule1487 = \ ((_lhsIcollectWarnings) :: Warnings) ->
     _lhsIcollectWarnings
   {-# INLINE rule1488 #-}
   rule1488 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule1489 #-}
   rule1489 = \ ((_lhsIcurClassPred) :: Maybe Predicate) ->
     _lhsIcurClassPred
   {-# INLINE rule1490 #-}
   rule1490 = \ ((_lhsIcurPred) :: Maybe Predicate) ->
     _lhsIcurPred
   {-# INLINE rule1491 #-}
   rule1491 = \ ((_lhsIcurrentChunk) :: Int) ->
     _lhsIcurrentChunk
   {-# INLINE rule1492 #-}
   rule1492 = \ ((_lhsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _lhsIdictionaryEnvironment
   {-# INLINE rule1493 #-}
   rule1493 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule1494 #-}
   rule1494 = \ ((_lhsIinstanceName) :: Maybe Name) ->
     _lhsIinstanceName
   {-# INLINE rule1495 #-}
   rule1495 = \ ((_lhsIinstanceTypes) :: [(Name, TpScheme)]) ->
     _lhsIinstanceTypes
   {-# INLINE rule1496 #-}
   rule1496 = \ ((_lhsImatchIO) :: IO ()) ->
     _lhsImatchIO
   {-# INLINE rule1497 #-}
   rule1497 = \ ((_lhsImoduleName) :: Maybe Name) ->
     _lhsImoduleName
   {-# INLINE rule1498 #-}
   rule1498 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule1499 #-}
   rule1499 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule1500 #-}
   rule1500 = \ ((_lhsIorderedTypeSynonyms) :: OrderedTypeSynonyms) ->
     _lhsIorderedTypeSynonyms
   {-# INLINE rule1501 #-}
   rule1501 = \ _parentTree ->
     _parentTree
   {-# INLINE rule1502 #-}
   rule1502 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule1503 #-}
   rule1503 = \ ((_lhsIrequiredPredicates) :: Predicates) ->
     _lhsIrequiredPredicates
   {-# INLINE rule1504 #-}
   rule1504 = \ ((_lhsIsubstitution) :: FixpointSubstitution) ->
     _lhsIsubstitution
   {-# INLINE rule1505 #-}
   rule1505 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
   {-# INLINE rule1506 #-}
   rule1506 = \ ((_lhsItypeschemeMap) :: M.Map Int (Scheme Predicates)) ->
     _lhsItypeschemeMap
   {-# INLINE rule1507 #-}
   rule1507 = \ ((_lhsIuniqueChunk) :: Int) ->
     _lhsIuniqueChunk
   {-# INLINE rule1508 #-}
   rule1508 = \ ((_lhsIuniqueSecondRound) :: Int) ->
     _lhsIuniqueSecondRound
   {-# INLINE rule1509 #-}
   rule1509 = \ ((_lhsIvariableMapping) :: Maybe [(Name, Tp)]) ->
     _lhsIvariableMapping
   {-# INLINE rule1510 #-}
   rule1510 = \ ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ->
     _lhsIallPatterns
   {-# INLINE rule1511 #-}
   rule1511 = \ ((_lhsIallTypeSchemes) :: M.Map NameWithRange TpScheme) ->
     _lhsIallTypeSchemes
   {-# INLINE rule1512 #-}
   rule1512 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule1513 #-}
   rule1513 = \ ((_lhsIavailablePredicates) :: [PredicateWithSource]) ->
     _lhsIavailablePredicates
   {-# INLINE rule1514 #-}
   rule1514 = \ ((_leftExpressionIbetaUnique) :: Int) ->
     _leftExpressionIbetaUnique
   {-# INLINE rule1515 #-}
   rule1515 = \ ((_lhsIclassEnvironment) :: ClassEnvironment) ->
     _lhsIclassEnvironment
   {-# INLINE rule1516 #-}
   rule1516 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule1517 #-}
   rule1517 = \ ((_lhsIclassMemberTypeSchemes) :: Maybe [(Name, TpScheme)]) ->
     _lhsIclassMemberTypeSchemes
   {-# INLINE rule1518 #-}
   rule1518 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule1519 #-}
   rule1519 = \ ((_lhsIclassPredicate) :: Maybe (Name, Names)) ->
     _lhsIclassPredicate
   {-# INLINE rule1520 #-}
   rule1520 = \ ((_lhsIclassTypeSchemes) :: M.Map Name TpScheme) ->
     _lhsIclassTypeSchemes
   {-# INLINE rule1521 #-}
   rule1521 = \ ((_leftExpressionIcollectErrors) :: TypeErrors) ->
     _leftExpressionIcollectErrors
   {-# INLINE rule1522 #-}
   rule1522 = \ ((_leftExpressionIcollectWarnings) :: Warnings) ->
     _leftExpressionIcollectWarnings
   {-# INLINE rule1523 #-}
   rule1523 = \ ((_leftExpressionIcounter) :: Int) ->
     _leftExpressionIcounter
   {-# INLINE rule1524 #-}
   rule1524 = \ ((_lhsIcurClassPred) :: Maybe Predicate) ->
     _lhsIcurClassPred
   {-# INLINE rule1525 #-}
   rule1525 = \ ((_lhsIcurPred) :: Maybe Predicate) ->
     _lhsIcurPred
   {-# INLINE rule1526 #-}
   rule1526 = \ ((_lhsIcurrentChunk) :: Int) ->
     _lhsIcurrentChunk
   {-# INLINE rule1527 #-}
   rule1527 = \ ((_leftExpressionIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _leftExpressionIdictionaryEnvironment
   {-# INLINE rule1528 #-}
   rule1528 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule1529 #-}
   rule1529 = \ ((_lhsIinstanceName) :: Maybe Name) ->
     _lhsIinstanceName
   {-# INLINE rule1530 #-}
   rule1530 = \ ((_lhsIinstanceTypes) :: [(Name, TpScheme)]) ->
     _lhsIinstanceTypes
   {-# INLINE rule1531 #-}
   rule1531 = \ ((_leftExpressionImatchIO) :: IO ()) ->
     _leftExpressionImatchIO
   {-# INLINE rule1532 #-}
   rule1532 = \ ((_lhsImoduleName) :: Maybe Name) ->
     _lhsImoduleName
   {-# INLINE rule1533 #-}
   rule1533 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule1534 #-}
   rule1534 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule1535 #-}
   rule1535 = \ ((_lhsIorderedTypeSynonyms) :: OrderedTypeSynonyms) ->
     _lhsIorderedTypeSynonyms
   {-# INLINE rule1536 #-}
   rule1536 = \ _parentTree ->
     _parentTree
   {-# INLINE rule1537 #-}
   rule1537 = \ ((_leftExpressionIpatternMatchWarnings) :: [Warning]) ->
     _leftExpressionIpatternMatchWarnings
   {-# INLINE rule1538 #-}
   rule1538 = \ ((_lhsIrequiredPredicates) :: Predicates) ->
     _lhsIrequiredPredicates
   {-# INLINE rule1539 #-}
   rule1539 = \ ((_lhsIsubstitution) :: FixpointSubstitution) ->
     _lhsIsubstitution
   {-# INLINE rule1540 #-}
   rule1540 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
   {-# INLINE rule1541 #-}
   rule1541 = \ ((_lhsItypeschemeMap) :: M.Map Int (Scheme Predicates)) ->
     _lhsItypeschemeMap
   {-# INLINE rule1542 #-}
   rule1542 = \ ((_leftExpressionIuniqueChunk) :: Int) ->
     _leftExpressionIuniqueChunk
   {-# INLINE rule1543 #-}
   rule1543 = \ ((_leftExpressionIuniqueSecondRound) :: Int) ->
     _leftExpressionIuniqueSecondRound
   {-# INLINE rule1544 #-}
   rule1544 = \ ((_lhsIvariableMapping) :: Maybe [(Name, Tp)]) ->
     _lhsIvariableMapping
   {-# INLINE rule1545 #-}
   rule1545 = \ ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ->
     _lhsIallPatterns
   {-# INLINE rule1546 #-}
   rule1546 = \ ((_lhsIallTypeSchemes) :: M.Map NameWithRange TpScheme) ->
     _lhsIallTypeSchemes
   {-# INLINE rule1547 #-}
   rule1547 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule1548 #-}
   rule1548 = \ ((_lhsIavailablePredicates) :: [PredicateWithSource]) ->
     _lhsIavailablePredicates
   {-# INLINE rule1549 #-}
   rule1549 = \ ((_operatorIbetaUnique) :: Int) ->
     _operatorIbetaUnique
   {-# INLINE rule1550 #-}
   rule1550 = \ ((_lhsIclassEnvironment) :: ClassEnvironment) ->
     _lhsIclassEnvironment
   {-# INLINE rule1551 #-}
   rule1551 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule1552 #-}
   rule1552 = \ ((_lhsIclassMemberTypeSchemes) :: Maybe [(Name, TpScheme)]) ->
     _lhsIclassMemberTypeSchemes
   {-# INLINE rule1553 #-}
   rule1553 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule1554 #-}
   rule1554 = \ ((_lhsIclassPredicate) :: Maybe (Name, Names)) ->
     _lhsIclassPredicate
   {-# INLINE rule1555 #-}
   rule1555 = \ ((_lhsIclassTypeSchemes) :: M.Map Name TpScheme) ->
     _lhsIclassTypeSchemes
   {-# INLINE rule1556 #-}
   rule1556 = \ ((_operatorIcollectErrors) :: TypeErrors) ->
     _operatorIcollectErrors
   {-# INLINE rule1557 #-}
   rule1557 = \ ((_operatorIcollectWarnings) :: Warnings) ->
     _operatorIcollectWarnings
   {-# INLINE rule1558 #-}
   rule1558 = \ ((_operatorIcounter) :: Int) ->
     _operatorIcounter
   {-# INLINE rule1559 #-}
   rule1559 = \ ((_lhsIcurClassPred) :: Maybe Predicate) ->
     _lhsIcurClassPred
   {-# INLINE rule1560 #-}
   rule1560 = \ ((_lhsIcurPred) :: Maybe Predicate) ->
     _lhsIcurPred
   {-# INLINE rule1561 #-}
   rule1561 = \ ((_lhsIcurrentChunk) :: Int) ->
     _lhsIcurrentChunk
   {-# INLINE rule1562 #-}
   rule1562 = \ ((_operatorIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _operatorIdictionaryEnvironment
   {-# INLINE rule1563 #-}
   rule1563 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule1564 #-}
   rule1564 = \ ((_lhsIinstanceName) :: Maybe Name) ->
     _lhsIinstanceName
   {-# INLINE rule1565 #-}
   rule1565 = \ ((_lhsIinstanceTypes) :: [(Name, TpScheme)]) ->
     _lhsIinstanceTypes
   {-# INLINE rule1566 #-}
   rule1566 = \ ((_operatorImatchIO) :: IO ()) ->
     _operatorImatchIO
   {-# INLINE rule1567 #-}
   rule1567 = \ ((_lhsImoduleName) :: Maybe Name) ->
     _lhsImoduleName
   {-# INLINE rule1568 #-}
   rule1568 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule1569 #-}
   rule1569 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule1570 #-}
   rule1570 = \ ((_lhsIorderedTypeSynonyms) :: OrderedTypeSynonyms) ->
     _lhsIorderedTypeSynonyms
   {-# INLINE rule1571 #-}
   rule1571 = \ _parentTree ->
     _parentTree
   {-# INLINE rule1572 #-}
   rule1572 = \ ((_operatorIpatternMatchWarnings) :: [Warning]) ->
     _operatorIpatternMatchWarnings
   {-# INLINE rule1573 #-}
   rule1573 = \ ((_lhsIrequiredPredicates) :: Predicates) ->
     _lhsIrequiredPredicates
   {-# INLINE rule1574 #-}
   rule1574 = \ ((_lhsIsubstitution) :: FixpointSubstitution) ->
     _lhsIsubstitution
   {-# INLINE rule1575 #-}
   rule1575 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
   {-# INLINE rule1576 #-}
   rule1576 = \ ((_lhsItypeschemeMap) :: M.Map Int (Scheme Predicates)) ->
     _lhsItypeschemeMap
   {-# INLINE rule1577 #-}
   rule1577 = \ ((_operatorIuniqueChunk) :: Int) ->
     _operatorIuniqueChunk
   {-# INLINE rule1578 #-}
   rule1578 = \ ((_operatorIuniqueSecondRound) :: Int) ->
     _operatorIuniqueSecondRound
   {-# INLINE rule1579 #-}
   rule1579 = \ ((_lhsIvariableMapping) :: Maybe [(Name, Tp)]) ->
     _lhsIvariableMapping
{-# NOINLINE sem_Expression_If #-}
sem_Expression_If :: T_Range  -> T_Expression  -> T_Expression  -> T_Expression  -> T_Expression 
sem_Expression_If arg_range_ arg_guardExpression_ arg_thenExpression_ arg_elseExpression_ = T_Expression (return st41) where
   {-# NOINLINE st41 #-}
   !st41 = let
      v40 :: T_Expression_v40 
      v40 = \ !(T_Expression_vIn40 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItryPatterns _lhsItypeConstructors _lhsItypeschemeMap _lhsIuniqueChunk _lhsIuniqueSecondRound _lhsIvariableMapping) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _guardExpressionX41 = Control.Monad.Identity.runIdentity (attach_T_Expression (arg_guardExpression_))
         _thenExpressionX41 = Control.Monad.Identity.runIdentity (attach_T_Expression (arg_thenExpression_))
         _elseExpressionX41 = Control.Monad.Identity.runIdentity (attach_T_Expression (arg_elseExpression_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_Expression_vOut40 _guardExpressionIassumptions _guardExpressionIbeta _guardExpressionIbetaUnique _guardExpressionIcollectErrors _guardExpressionIcollectInstances _guardExpressionIcollectWarnings _guardExpressionIconstraints _guardExpressionIcounter _guardExpressionIdictionaryEnvironment _guardExpressionIinfoTree _guardExpressionImatchIO _guardExpressionImatches _guardExpressionIpatternMatchWarnings _guardExpressionIself _guardExpressionIunboundNames _guardExpressionIuniqueChunk _guardExpressionIuniqueSecondRound) = inv_Expression_s41 _guardExpressionX41 (T_Expression_vIn40 _guardExpressionOallPatterns _guardExpressionOallTypeSchemes _guardExpressionOambiguousConflicts _guardExpressionOavailablePredicates _guardExpressionObetaUnique _guardExpressionOclassEnvironment _guardExpressionOclassMemberEnv _guardExpressionOclassMemberTypeSchemes _guardExpressionOclassNamesEnv _guardExpressionOclassPredicate _guardExpressionOclassTypeSchemes _guardExpressionOcollectErrors _guardExpressionOcollectWarnings _guardExpressionOcounter _guardExpressionOcurClassPred _guardExpressionOcurPred _guardExpressionOcurrentChunk _guardExpressionOdictionaryEnvironment _guardExpressionOimportEnvironment _guardExpressionOinstanceName _guardExpressionOinstanceTypes _guardExpressionOmatchIO _guardExpressionOmoduleName _guardExpressionOmonos _guardExpressionOnamesInScope _guardExpressionOorderedTypeSynonyms _guardExpressionOparentTree _guardExpressionOpatternMatchWarnings _guardExpressionOrequiredPredicates _guardExpressionOsubstitution _guardExpressionOtryPatterns _guardExpressionOtypeConstructors _guardExpressionOtypeschemeMap _guardExpressionOuniqueChunk _guardExpressionOuniqueSecondRound _guardExpressionOvariableMapping)
         (T_Expression_vOut40 _thenExpressionIassumptions _thenExpressionIbeta _thenExpressionIbetaUnique _thenExpressionIcollectErrors _thenExpressionIcollectInstances _thenExpressionIcollectWarnings _thenExpressionIconstraints _thenExpressionIcounter _thenExpressionIdictionaryEnvironment _thenExpressionIinfoTree _thenExpressionImatchIO _thenExpressionImatches _thenExpressionIpatternMatchWarnings _thenExpressionIself _thenExpressionIunboundNames _thenExpressionIuniqueChunk _thenExpressionIuniqueSecondRound) = inv_Expression_s41 _thenExpressionX41 (T_Expression_vIn40 _thenExpressionOallPatterns _thenExpressionOallTypeSchemes _thenExpressionOambiguousConflicts _thenExpressionOavailablePredicates _thenExpressionObetaUnique _thenExpressionOclassEnvironment _thenExpressionOclassMemberEnv _thenExpressionOclassMemberTypeSchemes _thenExpressionOclassNamesEnv _thenExpressionOclassPredicate _thenExpressionOclassTypeSchemes _thenExpressionOcollectErrors _thenExpressionOcollectWarnings _thenExpressionOcounter _thenExpressionOcurClassPred _thenExpressionOcurPred _thenExpressionOcurrentChunk _thenExpressionOdictionaryEnvironment _thenExpressionOimportEnvironment _thenExpressionOinstanceName _thenExpressionOinstanceTypes _thenExpressionOmatchIO _thenExpressionOmoduleName _thenExpressionOmonos _thenExpressionOnamesInScope _thenExpressionOorderedTypeSynonyms _thenExpressionOparentTree _thenExpressionOpatternMatchWarnings _thenExpressionOrequiredPredicates _thenExpressionOsubstitution _thenExpressionOtryPatterns _thenExpressionOtypeConstructors _thenExpressionOtypeschemeMap _thenExpressionOuniqueChunk _thenExpressionOuniqueSecondRound _thenExpressionOvariableMapping)
         (T_Expression_vOut40 _elseExpressionIassumptions _elseExpressionIbeta _elseExpressionIbetaUnique _elseExpressionIcollectErrors _elseExpressionIcollectInstances _elseExpressionIcollectWarnings _elseExpressionIconstraints _elseExpressionIcounter _elseExpressionIdictionaryEnvironment _elseExpressionIinfoTree _elseExpressionImatchIO _elseExpressionImatches _elseExpressionIpatternMatchWarnings _elseExpressionIself _elseExpressionIunboundNames _elseExpressionIuniqueChunk _elseExpressionIuniqueSecondRound) = inv_Expression_s41 _elseExpressionX41 (T_Expression_vIn40 _elseExpressionOallPatterns _elseExpressionOallTypeSchemes _elseExpressionOambiguousConflicts _elseExpressionOavailablePredicates _elseExpressionObetaUnique _elseExpressionOclassEnvironment _elseExpressionOclassMemberEnv _elseExpressionOclassMemberTypeSchemes _elseExpressionOclassNamesEnv _elseExpressionOclassPredicate _elseExpressionOclassTypeSchemes _elseExpressionOcollectErrors _elseExpressionOcollectWarnings _elseExpressionOcounter _elseExpressionOcurClassPred _elseExpressionOcurPred _elseExpressionOcurrentChunk _elseExpressionOdictionaryEnvironment _elseExpressionOimportEnvironment _elseExpressionOinstanceName _elseExpressionOinstanceTypes _elseExpressionOmatchIO _elseExpressionOmoduleName _elseExpressionOmonos _elseExpressionOnamesInScope _elseExpressionOorderedTypeSynonyms _elseExpressionOparentTree _elseExpressionOpatternMatchWarnings _elseExpressionOrequiredPredicates _elseExpressionOsubstitution _elseExpressionOtryPatterns _elseExpressionOtypeConstructors _elseExpressionOtypeschemeMap _elseExpressionOuniqueChunk _elseExpressionOuniqueSecondRound _elseExpressionOvariableMapping)
         _lhsOmatches :: [Maybe MetaVariableTable]
         _lhsOconstraints :: ConstraintSet
         _lhsOassumptions :: Assumptions
         _lhsOuniqueSecondRound :: Int
         ((_guardExpressionOtryPatterns,_thenExpressionOtryPatterns,_elseExpressionOtryPatterns),_lhsOmatches,_lhsOconstraints,_lhsOassumptions,_lhsOuniqueSecondRound,_ioMatch) = rule1580 _assumptions _constraints _elseExpressionImatches _elseExpressionIuniqueSecondRound _guardExpressionImatches _lhsIallPatterns _lhsItryPatterns _localInfo _thenExpressionImatches
         _lhsOmatchIO :: IO ()
         _lhsOmatchIO = rule1581 _elseExpressionImatchIO _ioMatch
         _parentTree = rule1582 _elseExpressionIinfoTree _guardExpressionIinfoTree _lhsIparentTree _localInfo _thenExpressionIinfoTree
         _lhsOinfoTree :: InfoTree
         _lhsOinfoTree = rule1583 _parentTree
         _localInfo = rule1584 _beta _lhsImonos _self
         _cinfoGuard = rule1585 _parentTree
         _cinfoThen = rule1586 _beta _localInfo _parentTree
         _cinfoElse = rule1587 _beta _localInfo _parentTree
         _guardExpressionObetaUnique = rule1588 _lhsIbetaUnique
         _assumptions = rule1589 _elseExpressionIassumptions _guardExpressionIassumptions _thenExpressionIassumptions
         _constraints = rule1590 _conElse _conGuard _conThen _elseExpressionIconstraints _guardExpressionIconstraints _thenExpressionIconstraints
         _beta = rule1591 _lhsIbetaUnique
         _conGuard = rule1592 _cinfoGuard _guardExpressionIbeta
         _conThen = rule1593 _beta _cinfoThen _thenExpressionIbeta
         _conElse = rule1594 _beta _cinfoElse _elseExpressionIbeta
         _lhsOcollectInstances :: [(Name, Instance)]
         _lhsOcollectInstances = rule1595 _elseExpressionIcollectInstances _guardExpressionIcollectInstances _thenExpressionIcollectInstances
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule1596 _elseExpressionIunboundNames _guardExpressionIunboundNames _thenExpressionIunboundNames
         _self = rule1597 _elseExpressionIself _guardExpressionIself _rangeIself _thenExpressionIself
         _lhsOself :: Expression
         _lhsOself = rule1598 _self
         _lhsObeta :: Tp
         _lhsObeta = rule1599 _beta
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule1600 _elseExpressionIbetaUnique
         _lhsOcollectErrors :: TypeErrors
         _lhsOcollectErrors = rule1601 _elseExpressionIcollectErrors
         _lhsOcollectWarnings :: Warnings
         _lhsOcollectWarnings = rule1602 _elseExpressionIcollectWarnings
         _lhsOcounter :: Int
         _lhsOcounter = rule1603 _elseExpressionIcounter
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule1604 _elseExpressionIdictionaryEnvironment
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule1605 _elseExpressionIpatternMatchWarnings
         _lhsOuniqueChunk :: Int
         _lhsOuniqueChunk = rule1606 _elseExpressionIuniqueChunk
         _guardExpressionOallPatterns = rule1607 _lhsIallPatterns
         _guardExpressionOallTypeSchemes = rule1608 _lhsIallTypeSchemes
         _guardExpressionOambiguousConflicts = rule1609 _lhsIambiguousConflicts
         _guardExpressionOavailablePredicates = rule1610 _lhsIavailablePredicates
         _guardExpressionOclassEnvironment = rule1611 _lhsIclassEnvironment
         _guardExpressionOclassMemberEnv = rule1612 _lhsIclassMemberEnv
         _guardExpressionOclassMemberTypeSchemes = rule1613 _lhsIclassMemberTypeSchemes
         _guardExpressionOclassNamesEnv = rule1614 _lhsIclassNamesEnv
         _guardExpressionOclassPredicate = rule1615 _lhsIclassPredicate
         _guardExpressionOclassTypeSchemes = rule1616 _lhsIclassTypeSchemes
         _guardExpressionOcollectErrors = rule1617 _lhsIcollectErrors
         _guardExpressionOcollectWarnings = rule1618 _lhsIcollectWarnings
         _guardExpressionOcounter = rule1619 _lhsIcounter
         _guardExpressionOcurClassPred = rule1620 _lhsIcurClassPred
         _guardExpressionOcurPred = rule1621 _lhsIcurPred
         _guardExpressionOcurrentChunk = rule1622 _lhsIcurrentChunk
         _guardExpressionOdictionaryEnvironment = rule1623 _lhsIdictionaryEnvironment
         _guardExpressionOimportEnvironment = rule1624 _lhsIimportEnvironment
         _guardExpressionOinstanceName = rule1625 _lhsIinstanceName
         _guardExpressionOinstanceTypes = rule1626 _lhsIinstanceTypes
         _guardExpressionOmatchIO = rule1627 _lhsImatchIO
         _guardExpressionOmoduleName = rule1628 _lhsImoduleName
         _guardExpressionOmonos = rule1629 _lhsImonos
         _guardExpressionOnamesInScope = rule1630 _lhsInamesInScope
         _guardExpressionOorderedTypeSynonyms = rule1631 _lhsIorderedTypeSynonyms
         _guardExpressionOparentTree = rule1632 _parentTree
         _guardExpressionOpatternMatchWarnings = rule1633 _lhsIpatternMatchWarnings
         _guardExpressionOrequiredPredicates = rule1634 _lhsIrequiredPredicates
         _guardExpressionOsubstitution = rule1635 _lhsIsubstitution
         _guardExpressionOtypeConstructors = rule1636 _lhsItypeConstructors
         _guardExpressionOtypeschemeMap = rule1637 _lhsItypeschemeMap
         _guardExpressionOuniqueChunk = rule1638 _lhsIuniqueChunk
         _guardExpressionOuniqueSecondRound = rule1639 _lhsIuniqueSecondRound
         _guardExpressionOvariableMapping = rule1640 _lhsIvariableMapping
         _thenExpressionOallPatterns = rule1641 _lhsIallPatterns
         _thenExpressionOallTypeSchemes = rule1642 _lhsIallTypeSchemes
         _thenExpressionOambiguousConflicts = rule1643 _lhsIambiguousConflicts
         _thenExpressionOavailablePredicates = rule1644 _lhsIavailablePredicates
         _thenExpressionObetaUnique = rule1645 _guardExpressionIbetaUnique
         _thenExpressionOclassEnvironment = rule1646 _lhsIclassEnvironment
         _thenExpressionOclassMemberEnv = rule1647 _lhsIclassMemberEnv
         _thenExpressionOclassMemberTypeSchemes = rule1648 _lhsIclassMemberTypeSchemes
         _thenExpressionOclassNamesEnv = rule1649 _lhsIclassNamesEnv
         _thenExpressionOclassPredicate = rule1650 _lhsIclassPredicate
         _thenExpressionOclassTypeSchemes = rule1651 _lhsIclassTypeSchemes
         _thenExpressionOcollectErrors = rule1652 _guardExpressionIcollectErrors
         _thenExpressionOcollectWarnings = rule1653 _guardExpressionIcollectWarnings
         _thenExpressionOcounter = rule1654 _guardExpressionIcounter
         _thenExpressionOcurClassPred = rule1655 _lhsIcurClassPred
         _thenExpressionOcurPred = rule1656 _lhsIcurPred
         _thenExpressionOcurrentChunk = rule1657 _lhsIcurrentChunk
         _thenExpressionOdictionaryEnvironment = rule1658 _guardExpressionIdictionaryEnvironment
         _thenExpressionOimportEnvironment = rule1659 _lhsIimportEnvironment
         _thenExpressionOinstanceName = rule1660 _lhsIinstanceName
         _thenExpressionOinstanceTypes = rule1661 _lhsIinstanceTypes
         _thenExpressionOmatchIO = rule1662 _guardExpressionImatchIO
         _thenExpressionOmoduleName = rule1663 _lhsImoduleName
         _thenExpressionOmonos = rule1664 _lhsImonos
         _thenExpressionOnamesInScope = rule1665 _lhsInamesInScope
         _thenExpressionOorderedTypeSynonyms = rule1666 _lhsIorderedTypeSynonyms
         _thenExpressionOparentTree = rule1667 _parentTree
         _thenExpressionOpatternMatchWarnings = rule1668 _guardExpressionIpatternMatchWarnings
         _thenExpressionOrequiredPredicates = rule1669 _lhsIrequiredPredicates
         _thenExpressionOsubstitution = rule1670 _lhsIsubstitution
         _thenExpressionOtypeConstructors = rule1671 _lhsItypeConstructors
         _thenExpressionOtypeschemeMap = rule1672 _lhsItypeschemeMap
         _thenExpressionOuniqueChunk = rule1673 _guardExpressionIuniqueChunk
         _thenExpressionOuniqueSecondRound = rule1674 _guardExpressionIuniqueSecondRound
         _thenExpressionOvariableMapping = rule1675 _lhsIvariableMapping
         _elseExpressionOallPatterns = rule1676 _lhsIallPatterns
         _elseExpressionOallTypeSchemes = rule1677 _lhsIallTypeSchemes
         _elseExpressionOambiguousConflicts = rule1678 _lhsIambiguousConflicts
         _elseExpressionOavailablePredicates = rule1679 _lhsIavailablePredicates
         _elseExpressionObetaUnique = rule1680 _thenExpressionIbetaUnique
         _elseExpressionOclassEnvironment = rule1681 _lhsIclassEnvironment
         _elseExpressionOclassMemberEnv = rule1682 _lhsIclassMemberEnv
         _elseExpressionOclassMemberTypeSchemes = rule1683 _lhsIclassMemberTypeSchemes
         _elseExpressionOclassNamesEnv = rule1684 _lhsIclassNamesEnv
         _elseExpressionOclassPredicate = rule1685 _lhsIclassPredicate
         _elseExpressionOclassTypeSchemes = rule1686 _lhsIclassTypeSchemes
         _elseExpressionOcollectErrors = rule1687 _thenExpressionIcollectErrors
         _elseExpressionOcollectWarnings = rule1688 _thenExpressionIcollectWarnings
         _elseExpressionOcounter = rule1689 _thenExpressionIcounter
         _elseExpressionOcurClassPred = rule1690 _lhsIcurClassPred
         _elseExpressionOcurPred = rule1691 _lhsIcurPred
         _elseExpressionOcurrentChunk = rule1692 _lhsIcurrentChunk
         _elseExpressionOdictionaryEnvironment = rule1693 _thenExpressionIdictionaryEnvironment
         _elseExpressionOimportEnvironment = rule1694 _lhsIimportEnvironment
         _elseExpressionOinstanceName = rule1695 _lhsIinstanceName
         _elseExpressionOinstanceTypes = rule1696 _lhsIinstanceTypes
         _elseExpressionOmatchIO = rule1697 _thenExpressionImatchIO
         _elseExpressionOmoduleName = rule1698 _lhsImoduleName
         _elseExpressionOmonos = rule1699 _lhsImonos
         _elseExpressionOnamesInScope = rule1700 _lhsInamesInScope
         _elseExpressionOorderedTypeSynonyms = rule1701 _lhsIorderedTypeSynonyms
         _elseExpressionOparentTree = rule1702 _parentTree
         _elseExpressionOpatternMatchWarnings = rule1703 _thenExpressionIpatternMatchWarnings
         _elseExpressionOrequiredPredicates = rule1704 _lhsIrequiredPredicates
         _elseExpressionOsubstitution = rule1705 _lhsIsubstitution
         _elseExpressionOtypeConstructors = rule1706 _lhsItypeConstructors
         _elseExpressionOtypeschemeMap = rule1707 _lhsItypeschemeMap
         _elseExpressionOuniqueChunk = rule1708 _thenExpressionIuniqueChunk
         _elseExpressionOuniqueSecondRound = rule1709 _thenExpressionIuniqueSecondRound
         _elseExpressionOvariableMapping = rule1710 _lhsIvariableMapping
         !__result_ = T_Expression_vOut40 _lhsOassumptions _lhsObeta _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraints _lhsOcounter _lhsOdictionaryEnvironment _lhsOinfoTree _lhsOmatchIO _lhsOmatches _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOuniqueSecondRound
         in __result_ )
     in C_Expression_s41 v40
   {-# INLINE rule1580 #-}
   rule1580 = \ _assumptions _constraints ((_elseExpressionImatches) :: [Maybe MetaVariableTable]) ((_elseExpressionIuniqueSecondRound) :: Int) ((_guardExpressionImatches) :: [Maybe MetaVariableTable]) ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ((_lhsItryPatterns) :: [(Expression     , [String])]) _localInfo ((_thenExpressionImatches) :: [Maybe MetaVariableTable]) ->
             let infoTuple = metaVarInfo _constraints _assumptions _localInfo
             in match3 infoTuple _elseExpressionIuniqueSecondRound
                       match_Expression_If
                       _lhsItryPatterns _lhsIallPatterns
                       [_guardExpressionImatches,_thenExpressionImatches,_elseExpressionImatches]
   {-# INLINE rule1581 #-}
   rule1581 = \ ((_elseExpressionImatchIO) :: IO ()) _ioMatch ->
                                       _elseExpressionImatchIO  >> _ioMatch
   {-# INLINE rule1582 #-}
   rule1582 = \ ((_elseExpressionIinfoTree) :: InfoTree) ((_guardExpressionIinfoTree) :: InfoTree) ((_lhsIparentTree) :: InfoTree) _localInfo ((_thenExpressionIinfoTree) :: InfoTree) ->
                            node _lhsIparentTree _localInfo [_guardExpressionIinfoTree, _thenExpressionIinfoTree, _elseExpressionIinfoTree]
   {-# INLINE rule1583 #-}
   rule1583 = \ _parentTree ->
                            _parentTree
   {-# INLINE rule1584 #-}
   rule1584 = \ _beta ((_lhsImonos) :: Monos) _self ->
                            LocalInfo { self = UHA_Expr _self
                                      , assignedType = Just _beta
                                      , monos = _lhsImonos
                                      }
   {-# INLINE rule1585 #-}
   rule1585 = \ _parentTree ->
     childConstraint 0 "conditional" _parentTree
        []
   {-# INLINE rule1586 #-}
   rule1586 = \ _beta _localInfo _parentTree ->
     childConstraint 1 "then branch of conditional" _parentTree
        [ Unifier (head (ftv _beta)) ("conditional", _localInfo, "then branch") ]
   {-# INLINE rule1587 #-}
   rule1587 = \ _beta _localInfo _parentTree ->
     childConstraint 2 "else branch of conditional" _parentTree
        [ Unifier (head (ftv _beta)) ("conditional", _localInfo, "else branch") ]
   {-# INLINE rule1588 #-}
   rule1588 = \ ((_lhsIbetaUnique) :: Int) ->
                                        _lhsIbetaUnique + 1
   {-# INLINE rule1589 #-}
   rule1589 = \ ((_elseExpressionIassumptions) :: Assumptions) ((_guardExpressionIassumptions) :: Assumptions) ((_thenExpressionIassumptions) :: Assumptions) ->
                                        _guardExpressionIassumptions `combine` _thenExpressionIassumptions `combine` _elseExpressionIassumptions
   {-# INLINE rule1590 #-}
   rule1590 = \ _conElse _conGuard _conThen ((_elseExpressionIconstraints) :: ConstraintSet) ((_guardExpressionIconstraints) :: ConstraintSet) ((_thenExpressionIconstraints) :: ConstraintSet) ->
                                        Node [ _conGuard .<. _guardExpressionIconstraints
                                             , _conThen  .<. _thenExpressionIconstraints
                                             , _conElse  .<. _elseExpressionIconstraints
                                             ]
   {-# INLINE rule1591 #-}
   rule1591 = \ ((_lhsIbetaUnique) :: Int) ->
                                        TVar _lhsIbetaUnique
   {-# INLINE rule1592 #-}
   rule1592 = \ _cinfoGuard ((_guardExpressionIbeta) :: Tp) ->
                                        [ (_guardExpressionIbeta .==. boolQualType) _cinfoGuard ]
   {-# INLINE rule1593 #-}
   rule1593 = \ _beta _cinfoThen ((_thenExpressionIbeta) :: Tp) ->
                                        [ (_thenExpressionIbeta  .==. _beta   ) _cinfoThen  ]
   {-# INLINE rule1594 #-}
   rule1594 = \ _beta _cinfoElse ((_elseExpressionIbeta) :: Tp) ->
                                        [ (_elseExpressionIbeta  .==. _beta   ) _cinfoElse  ]
   {-# INLINE rule1595 #-}
   rule1595 = \ ((_elseExpressionIcollectInstances) :: [(Name, Instance)]) ((_guardExpressionIcollectInstances) :: [(Name, Instance)]) ((_thenExpressionIcollectInstances) :: [(Name, Instance)]) ->
     _guardExpressionIcollectInstances  ++  _thenExpressionIcollectInstances  ++  _elseExpressionIcollectInstances
   {-# INLINE rule1596 #-}
   rule1596 = \ ((_elseExpressionIunboundNames) :: Names) ((_guardExpressionIunboundNames) :: Names) ((_thenExpressionIunboundNames) :: Names) ->
     ((++) _guardExpressionIunboundNames ((++) _thenExpressionIunboundNames _elseExpressionIunboundNames))
   {-# INLINE rule1597 #-}
   rule1597 = \ ((_elseExpressionIself) :: Expression) ((_guardExpressionIself) :: Expression) ((_rangeIself) :: Range) ((_thenExpressionIself) :: Expression) ->
     Expression_If _rangeIself _guardExpressionIself _thenExpressionIself _elseExpressionIself
   {-# INLINE rule1598 #-}
   rule1598 = \ _self ->
     _self
   {-# INLINE rule1599 #-}
   rule1599 = \ _beta ->
     _beta
   {-# INLINE rule1600 #-}
   rule1600 = \ ((_elseExpressionIbetaUnique) :: Int) ->
     _elseExpressionIbetaUnique
   {-# INLINE rule1601 #-}
   rule1601 = \ ((_elseExpressionIcollectErrors) :: TypeErrors) ->
     _elseExpressionIcollectErrors
   {-# INLINE rule1602 #-}
   rule1602 = \ ((_elseExpressionIcollectWarnings) :: Warnings) ->
     _elseExpressionIcollectWarnings
   {-# INLINE rule1603 #-}
   rule1603 = \ ((_elseExpressionIcounter) :: Int) ->
     _elseExpressionIcounter
   {-# INLINE rule1604 #-}
   rule1604 = \ ((_elseExpressionIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _elseExpressionIdictionaryEnvironment
   {-# INLINE rule1605 #-}
   rule1605 = \ ((_elseExpressionIpatternMatchWarnings) :: [Warning]) ->
     _elseExpressionIpatternMatchWarnings
   {-# INLINE rule1606 #-}
   rule1606 = \ ((_elseExpressionIuniqueChunk) :: Int) ->
     _elseExpressionIuniqueChunk
   {-# INLINE rule1607 #-}
   rule1607 = \ ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ->
     _lhsIallPatterns
   {-# INLINE rule1608 #-}
   rule1608 = \ ((_lhsIallTypeSchemes) :: M.Map NameWithRange TpScheme) ->
     _lhsIallTypeSchemes
   {-# INLINE rule1609 #-}
   rule1609 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule1610 #-}
   rule1610 = \ ((_lhsIavailablePredicates) :: [PredicateWithSource]) ->
     _lhsIavailablePredicates
   {-# INLINE rule1611 #-}
   rule1611 = \ ((_lhsIclassEnvironment) :: ClassEnvironment) ->
     _lhsIclassEnvironment
   {-# INLINE rule1612 #-}
   rule1612 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule1613 #-}
   rule1613 = \ ((_lhsIclassMemberTypeSchemes) :: Maybe [(Name, TpScheme)]) ->
     _lhsIclassMemberTypeSchemes
   {-# INLINE rule1614 #-}
   rule1614 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule1615 #-}
   rule1615 = \ ((_lhsIclassPredicate) :: Maybe (Name, Names)) ->
     _lhsIclassPredicate
   {-# INLINE rule1616 #-}
   rule1616 = \ ((_lhsIclassTypeSchemes) :: M.Map Name TpScheme) ->
     _lhsIclassTypeSchemes
   {-# INLINE rule1617 #-}
   rule1617 = \ ((_lhsIcollectErrors) :: TypeErrors) ->
     _lhsIcollectErrors
   {-# INLINE rule1618 #-}
   rule1618 = \ ((_lhsIcollectWarnings) :: Warnings) ->
     _lhsIcollectWarnings
   {-# INLINE rule1619 #-}
   rule1619 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule1620 #-}
   rule1620 = \ ((_lhsIcurClassPred) :: Maybe Predicate) ->
     _lhsIcurClassPred
   {-# INLINE rule1621 #-}
   rule1621 = \ ((_lhsIcurPred) :: Maybe Predicate) ->
     _lhsIcurPred
   {-# INLINE rule1622 #-}
   rule1622 = \ ((_lhsIcurrentChunk) :: Int) ->
     _lhsIcurrentChunk
   {-# INLINE rule1623 #-}
   rule1623 = \ ((_lhsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _lhsIdictionaryEnvironment
   {-# INLINE rule1624 #-}
   rule1624 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule1625 #-}
   rule1625 = \ ((_lhsIinstanceName) :: Maybe Name) ->
     _lhsIinstanceName
   {-# INLINE rule1626 #-}
   rule1626 = \ ((_lhsIinstanceTypes) :: [(Name, TpScheme)]) ->
     _lhsIinstanceTypes
   {-# INLINE rule1627 #-}
   rule1627 = \ ((_lhsImatchIO) :: IO ()) ->
     _lhsImatchIO
   {-# INLINE rule1628 #-}
   rule1628 = \ ((_lhsImoduleName) :: Maybe Name) ->
     _lhsImoduleName
   {-# INLINE rule1629 #-}
   rule1629 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule1630 #-}
   rule1630 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule1631 #-}
   rule1631 = \ ((_lhsIorderedTypeSynonyms) :: OrderedTypeSynonyms) ->
     _lhsIorderedTypeSynonyms
   {-# INLINE rule1632 #-}
   rule1632 = \ _parentTree ->
     _parentTree
   {-# INLINE rule1633 #-}
   rule1633 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule1634 #-}
   rule1634 = \ ((_lhsIrequiredPredicates) :: Predicates) ->
     _lhsIrequiredPredicates
   {-# INLINE rule1635 #-}
   rule1635 = \ ((_lhsIsubstitution) :: FixpointSubstitution) ->
     _lhsIsubstitution
   {-# INLINE rule1636 #-}
   rule1636 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
   {-# INLINE rule1637 #-}
   rule1637 = \ ((_lhsItypeschemeMap) :: M.Map Int (Scheme Predicates)) ->
     _lhsItypeschemeMap
   {-# INLINE rule1638 #-}
   rule1638 = \ ((_lhsIuniqueChunk) :: Int) ->
     _lhsIuniqueChunk
   {-# INLINE rule1639 #-}
   rule1639 = \ ((_lhsIuniqueSecondRound) :: Int) ->
     _lhsIuniqueSecondRound
   {-# INLINE rule1640 #-}
   rule1640 = \ ((_lhsIvariableMapping) :: Maybe [(Name, Tp)]) ->
     _lhsIvariableMapping
   {-# INLINE rule1641 #-}
   rule1641 = \ ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ->
     _lhsIallPatterns
   {-# INLINE rule1642 #-}
   rule1642 = \ ((_lhsIallTypeSchemes) :: M.Map NameWithRange TpScheme) ->
     _lhsIallTypeSchemes
   {-# INLINE rule1643 #-}
   rule1643 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule1644 #-}
   rule1644 = \ ((_lhsIavailablePredicates) :: [PredicateWithSource]) ->
     _lhsIavailablePredicates
   {-# INLINE rule1645 #-}
   rule1645 = \ ((_guardExpressionIbetaUnique) :: Int) ->
     _guardExpressionIbetaUnique
   {-# INLINE rule1646 #-}
   rule1646 = \ ((_lhsIclassEnvironment) :: ClassEnvironment) ->
     _lhsIclassEnvironment
   {-# INLINE rule1647 #-}
   rule1647 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule1648 #-}
   rule1648 = \ ((_lhsIclassMemberTypeSchemes) :: Maybe [(Name, TpScheme)]) ->
     _lhsIclassMemberTypeSchemes
   {-# INLINE rule1649 #-}
   rule1649 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule1650 #-}
   rule1650 = \ ((_lhsIclassPredicate) :: Maybe (Name, Names)) ->
     _lhsIclassPredicate
   {-# INLINE rule1651 #-}
   rule1651 = \ ((_lhsIclassTypeSchemes) :: M.Map Name TpScheme) ->
     _lhsIclassTypeSchemes
   {-# INLINE rule1652 #-}
   rule1652 = \ ((_guardExpressionIcollectErrors) :: TypeErrors) ->
     _guardExpressionIcollectErrors
   {-# INLINE rule1653 #-}
   rule1653 = \ ((_guardExpressionIcollectWarnings) :: Warnings) ->
     _guardExpressionIcollectWarnings
   {-# INLINE rule1654 #-}
   rule1654 = \ ((_guardExpressionIcounter) :: Int) ->
     _guardExpressionIcounter
   {-# INLINE rule1655 #-}
   rule1655 = \ ((_lhsIcurClassPred) :: Maybe Predicate) ->
     _lhsIcurClassPred
   {-# INLINE rule1656 #-}
   rule1656 = \ ((_lhsIcurPred) :: Maybe Predicate) ->
     _lhsIcurPred
   {-# INLINE rule1657 #-}
   rule1657 = \ ((_lhsIcurrentChunk) :: Int) ->
     _lhsIcurrentChunk
   {-# INLINE rule1658 #-}
   rule1658 = \ ((_guardExpressionIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _guardExpressionIdictionaryEnvironment
   {-# INLINE rule1659 #-}
   rule1659 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule1660 #-}
   rule1660 = \ ((_lhsIinstanceName) :: Maybe Name) ->
     _lhsIinstanceName
   {-# INLINE rule1661 #-}
   rule1661 = \ ((_lhsIinstanceTypes) :: [(Name, TpScheme)]) ->
     _lhsIinstanceTypes
   {-# INLINE rule1662 #-}
   rule1662 = \ ((_guardExpressionImatchIO) :: IO ()) ->
     _guardExpressionImatchIO
   {-# INLINE rule1663 #-}
   rule1663 = \ ((_lhsImoduleName) :: Maybe Name) ->
     _lhsImoduleName
   {-# INLINE rule1664 #-}
   rule1664 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule1665 #-}
   rule1665 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule1666 #-}
   rule1666 = \ ((_lhsIorderedTypeSynonyms) :: OrderedTypeSynonyms) ->
     _lhsIorderedTypeSynonyms
   {-# INLINE rule1667 #-}
   rule1667 = \ _parentTree ->
     _parentTree
   {-# INLINE rule1668 #-}
   rule1668 = \ ((_guardExpressionIpatternMatchWarnings) :: [Warning]) ->
     _guardExpressionIpatternMatchWarnings
   {-# INLINE rule1669 #-}
   rule1669 = \ ((_lhsIrequiredPredicates) :: Predicates) ->
     _lhsIrequiredPredicates
   {-# INLINE rule1670 #-}
   rule1670 = \ ((_lhsIsubstitution) :: FixpointSubstitution) ->
     _lhsIsubstitution
   {-# INLINE rule1671 #-}
   rule1671 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
   {-# INLINE rule1672 #-}
   rule1672 = \ ((_lhsItypeschemeMap) :: M.Map Int (Scheme Predicates)) ->
     _lhsItypeschemeMap
   {-# INLINE rule1673 #-}
   rule1673 = \ ((_guardExpressionIuniqueChunk) :: Int) ->
     _guardExpressionIuniqueChunk
   {-# INLINE rule1674 #-}
   rule1674 = \ ((_guardExpressionIuniqueSecondRound) :: Int) ->
     _guardExpressionIuniqueSecondRound
   {-# INLINE rule1675 #-}
   rule1675 = \ ((_lhsIvariableMapping) :: Maybe [(Name, Tp)]) ->
     _lhsIvariableMapping
   {-# INLINE rule1676 #-}
   rule1676 = \ ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ->
     _lhsIallPatterns
   {-# INLINE rule1677 #-}
   rule1677 = \ ((_lhsIallTypeSchemes) :: M.Map NameWithRange TpScheme) ->
     _lhsIallTypeSchemes
   {-# INLINE rule1678 #-}
   rule1678 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule1679 #-}
   rule1679 = \ ((_lhsIavailablePredicates) :: [PredicateWithSource]) ->
     _lhsIavailablePredicates
   {-# INLINE rule1680 #-}
   rule1680 = \ ((_thenExpressionIbetaUnique) :: Int) ->
     _thenExpressionIbetaUnique
   {-# INLINE rule1681 #-}
   rule1681 = \ ((_lhsIclassEnvironment) :: ClassEnvironment) ->
     _lhsIclassEnvironment
   {-# INLINE rule1682 #-}
   rule1682 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule1683 #-}
   rule1683 = \ ((_lhsIclassMemberTypeSchemes) :: Maybe [(Name, TpScheme)]) ->
     _lhsIclassMemberTypeSchemes
   {-# INLINE rule1684 #-}
   rule1684 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule1685 #-}
   rule1685 = \ ((_lhsIclassPredicate) :: Maybe (Name, Names)) ->
     _lhsIclassPredicate
   {-# INLINE rule1686 #-}
   rule1686 = \ ((_lhsIclassTypeSchemes) :: M.Map Name TpScheme) ->
     _lhsIclassTypeSchemes
   {-# INLINE rule1687 #-}
   rule1687 = \ ((_thenExpressionIcollectErrors) :: TypeErrors) ->
     _thenExpressionIcollectErrors
   {-# INLINE rule1688 #-}
   rule1688 = \ ((_thenExpressionIcollectWarnings) :: Warnings) ->
     _thenExpressionIcollectWarnings
   {-# INLINE rule1689 #-}
   rule1689 = \ ((_thenExpressionIcounter) :: Int) ->
     _thenExpressionIcounter
   {-# INLINE rule1690 #-}
   rule1690 = \ ((_lhsIcurClassPred) :: Maybe Predicate) ->
     _lhsIcurClassPred
   {-# INLINE rule1691 #-}
   rule1691 = \ ((_lhsIcurPred) :: Maybe Predicate) ->
     _lhsIcurPred
   {-# INLINE rule1692 #-}
   rule1692 = \ ((_lhsIcurrentChunk) :: Int) ->
     _lhsIcurrentChunk
   {-# INLINE rule1693 #-}
   rule1693 = \ ((_thenExpressionIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _thenExpressionIdictionaryEnvironment
   {-# INLINE rule1694 #-}
   rule1694 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule1695 #-}
   rule1695 = \ ((_lhsIinstanceName) :: Maybe Name) ->
     _lhsIinstanceName
   {-# INLINE rule1696 #-}
   rule1696 = \ ((_lhsIinstanceTypes) :: [(Name, TpScheme)]) ->
     _lhsIinstanceTypes
   {-# INLINE rule1697 #-}
   rule1697 = \ ((_thenExpressionImatchIO) :: IO ()) ->
     _thenExpressionImatchIO
   {-# INLINE rule1698 #-}
   rule1698 = \ ((_lhsImoduleName) :: Maybe Name) ->
     _lhsImoduleName
   {-# INLINE rule1699 #-}
   rule1699 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule1700 #-}
   rule1700 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule1701 #-}
   rule1701 = \ ((_lhsIorderedTypeSynonyms) :: OrderedTypeSynonyms) ->
     _lhsIorderedTypeSynonyms
   {-# INLINE rule1702 #-}
   rule1702 = \ _parentTree ->
     _parentTree
   {-# INLINE rule1703 #-}
   rule1703 = \ ((_thenExpressionIpatternMatchWarnings) :: [Warning]) ->
     _thenExpressionIpatternMatchWarnings
   {-# INLINE rule1704 #-}
   rule1704 = \ ((_lhsIrequiredPredicates) :: Predicates) ->
     _lhsIrequiredPredicates
   {-# INLINE rule1705 #-}
   rule1705 = \ ((_lhsIsubstitution) :: FixpointSubstitution) ->
     _lhsIsubstitution
   {-# INLINE rule1706 #-}
   rule1706 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
   {-# INLINE rule1707 #-}
   rule1707 = \ ((_lhsItypeschemeMap) :: M.Map Int (Scheme Predicates)) ->
     _lhsItypeschemeMap
   {-# INLINE rule1708 #-}
   rule1708 = \ ((_thenExpressionIuniqueChunk) :: Int) ->
     _thenExpressionIuniqueChunk
   {-# INLINE rule1709 #-}
   rule1709 = \ ((_thenExpressionIuniqueSecondRound) :: Int) ->
     _thenExpressionIuniqueSecondRound
   {-# INLINE rule1710 #-}
   rule1710 = \ ((_lhsIvariableMapping) :: Maybe [(Name, Tp)]) ->
     _lhsIvariableMapping
{-# NOINLINE sem_Expression_Lambda #-}
sem_Expression_Lambda :: T_Range  -> T_Patterns  -> T_Expression  -> T_Expression 
sem_Expression_Lambda arg_range_ arg_patterns_ arg_expression_ = T_Expression (return st41) where
   {-# NOINLINE st41 #-}
   !st41 = let
      v40 :: T_Expression_v40 
      v40 = \ !(T_Expression_vIn40 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItryPatterns _lhsItypeConstructors _lhsItypeschemeMap _lhsIuniqueChunk _lhsIuniqueSecondRound _lhsIvariableMapping) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _patternsX122 = Control.Monad.Identity.runIdentity (attach_T_Patterns (arg_patterns_))
         _expressionX41 = Control.Monad.Identity.runIdentity (attach_T_Expression (arg_expression_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_Patterns_vOut121 _patternsIbetaUnique _patternsIbetas _patternsIconstraintslist _patternsIcounter _patternsIelementss _patternsIenvironment _patternsIinfoTrees _patternsInumberOfPatterns _patternsIpatVarNames _patternsIpatternMatchWarnings _patternsIself _patternsIunboundNames) = inv_Patterns_s122 _patternsX122 (T_Patterns_vIn121 _patternsOambiguousConflicts _patternsObetaUnique _patternsOcounter _patternsOimportEnvironment _patternsOmonos _patternsOnamesInScope _patternsOparentTree _patternsOpatternMatchWarnings _patternsOtypeConstructors)
         (T_Expression_vOut40 _expressionIassumptions _expressionIbeta _expressionIbetaUnique _expressionIcollectErrors _expressionIcollectInstances _expressionIcollectWarnings _expressionIconstraints _expressionIcounter _expressionIdictionaryEnvironment _expressionIinfoTree _expressionImatchIO _expressionImatches _expressionIpatternMatchWarnings _expressionIself _expressionIunboundNames _expressionIuniqueChunk _expressionIuniqueSecondRound) = inv_Expression_s41 _expressionX41 (T_Expression_vIn40 _expressionOallPatterns _expressionOallTypeSchemes _expressionOambiguousConflicts _expressionOavailablePredicates _expressionObetaUnique _expressionOclassEnvironment _expressionOclassMemberEnv _expressionOclassMemberTypeSchemes _expressionOclassNamesEnv _expressionOclassPredicate _expressionOclassTypeSchemes _expressionOcollectErrors _expressionOcollectWarnings _expressionOcounter _expressionOcurClassPred _expressionOcurPred _expressionOcurrentChunk _expressionOdictionaryEnvironment _expressionOimportEnvironment _expressionOinstanceName _expressionOinstanceTypes _expressionOmatchIO _expressionOmoduleName _expressionOmonos _expressionOnamesInScope _expressionOorderedTypeSynonyms _expressionOparentTree _expressionOpatternMatchWarnings _expressionOrequiredPredicates _expressionOsubstitution _expressionOtryPatterns _expressionOtypeConstructors _expressionOtypeschemeMap _expressionOuniqueChunk _expressionOuniqueSecondRound _expressionOvariableMapping)
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule1711 _beta _expressionIpatternMatchWarnings _lhsIimportEnvironment _lhsIsubstitution _patternsIelementss _patternsIself _rangeIself
         _lhsOmatches :: [Maybe MetaVariableTable]
         _lhsOmatches = rule1712 _assumptions _constraints _lhsItryPatterns _localInfo
         _expressionOtryPatterns = rule1713  ()
         (_namesInScope,_unboundNames,_scopeInfo) = rule1714 _expressionIunboundNames _lhsInamesInScope _patternsIpatVarNames
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule1715 _unboundNames
         _parentTree = rule1716 _expressionIinfoTree _lhsIparentTree _localInfo _patternsIinfoTrees
         _lhsOinfoTree :: InfoTree
         _lhsOinfoTree = rule1717 _parentTree
         _localInfo = rule1718 _beta _lhsImonos _self
         _cinfoBind = rule1719 _parentTree _patternsIenvironment
         _cinfoType = rule1720 _parentTree
         _patternsObetaUnique = rule1721 _lhsIbetaUnique
         _expressionOmonos = rule1722 _csetBinds _lhsImonos _patternsIenvironment
         _constraints = rule1723 _csetBinds _expressionIconstraints _newcon _patternsIconstraintslist
         _beta = rule1724 _lhsIbetaUnique
         _newcon = rule1725 _beta _cinfoType _expressionIbeta _patternsIbetas
         (_csetBinds,_assumptions) = rule1726 _cinfoBind _expressionIassumptions _patternsIenvironment
         _lhsOcollectInstances :: [(Name, Instance)]
         _lhsOcollectInstances = rule1727 _expressionIcollectInstances
         _self = rule1728 _expressionIself _patternsIself _rangeIself
         _lhsOself :: Expression
         _lhsOself = rule1729 _self
         _lhsOassumptions :: Assumptions
         _lhsOassumptions = rule1730 _assumptions
         _lhsObeta :: Tp
         _lhsObeta = rule1731 _beta
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule1732 _expressionIbetaUnique
         _lhsOcollectErrors :: TypeErrors
         _lhsOcollectErrors = rule1733 _expressionIcollectErrors
         _lhsOcollectWarnings :: Warnings
         _lhsOcollectWarnings = rule1734 _expressionIcollectWarnings
         _lhsOconstraints :: ConstraintSet
         _lhsOconstraints = rule1735 _constraints
         _lhsOcounter :: Int
         _lhsOcounter = rule1736 _expressionIcounter
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule1737 _expressionIdictionaryEnvironment
         _lhsOmatchIO :: IO ()
         _lhsOmatchIO = rule1738 _expressionImatchIO
         _lhsOuniqueChunk :: Int
         _lhsOuniqueChunk = rule1739 _expressionIuniqueChunk
         _lhsOuniqueSecondRound :: Int
         _lhsOuniqueSecondRound = rule1740 _expressionIuniqueSecondRound
         _patternsOambiguousConflicts = rule1741 _lhsIambiguousConflicts
         _patternsOcounter = rule1742 _lhsIcounter
         _patternsOimportEnvironment = rule1743 _lhsIimportEnvironment
         _patternsOmonos = rule1744 _lhsImonos
         _patternsOnamesInScope = rule1745 _namesInScope
         _patternsOparentTree = rule1746 _parentTree
         _patternsOpatternMatchWarnings = rule1747 _lhsIpatternMatchWarnings
         _patternsOtypeConstructors = rule1748 _lhsItypeConstructors
         _expressionOallPatterns = rule1749 _lhsIallPatterns
         _expressionOallTypeSchemes = rule1750 _lhsIallTypeSchemes
         _expressionOambiguousConflicts = rule1751 _lhsIambiguousConflicts
         _expressionOavailablePredicates = rule1752 _lhsIavailablePredicates
         _expressionObetaUnique = rule1753 _patternsIbetaUnique
         _expressionOclassEnvironment = rule1754 _lhsIclassEnvironment
         _expressionOclassMemberEnv = rule1755 _lhsIclassMemberEnv
         _expressionOclassMemberTypeSchemes = rule1756 _lhsIclassMemberTypeSchemes
         _expressionOclassNamesEnv = rule1757 _lhsIclassNamesEnv
         _expressionOclassPredicate = rule1758 _lhsIclassPredicate
         _expressionOclassTypeSchemes = rule1759 _lhsIclassTypeSchemes
         _expressionOcollectErrors = rule1760 _lhsIcollectErrors
         _expressionOcollectWarnings = rule1761 _lhsIcollectWarnings
         _expressionOcounter = rule1762 _patternsIcounter
         _expressionOcurClassPred = rule1763 _lhsIcurClassPred
         _expressionOcurPred = rule1764 _lhsIcurPred
         _expressionOcurrentChunk = rule1765 _lhsIcurrentChunk
         _expressionOdictionaryEnvironment = rule1766 _lhsIdictionaryEnvironment
         _expressionOimportEnvironment = rule1767 _lhsIimportEnvironment
         _expressionOinstanceName = rule1768 _lhsIinstanceName
         _expressionOinstanceTypes = rule1769 _lhsIinstanceTypes
         _expressionOmatchIO = rule1770 _lhsImatchIO
         _expressionOmoduleName = rule1771 _lhsImoduleName
         _expressionOnamesInScope = rule1772 _namesInScope
         _expressionOorderedTypeSynonyms = rule1773 _lhsIorderedTypeSynonyms
         _expressionOparentTree = rule1774 _parentTree
         _expressionOpatternMatchWarnings = rule1775 _patternsIpatternMatchWarnings
         _expressionOrequiredPredicates = rule1776 _lhsIrequiredPredicates
         _expressionOsubstitution = rule1777 _lhsIsubstitution
         _expressionOtypeConstructors = rule1778 _lhsItypeConstructors
         _expressionOtypeschemeMap = rule1779 _lhsItypeschemeMap
         _expressionOuniqueChunk = rule1780 _lhsIuniqueChunk
         _expressionOuniqueSecondRound = rule1781 _lhsIuniqueSecondRound
         _expressionOvariableMapping = rule1782 _lhsIvariableMapping
         !__result_ = T_Expression_vOut40 _lhsOassumptions _lhsObeta _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraints _lhsOcounter _lhsOdictionaryEnvironment _lhsOinfoTree _lhsOmatchIO _lhsOmatches _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOuniqueSecondRound
         in __result_ )
     in C_Expression_s41 v40
   {-# INLINE rule1711 #-}
   rule1711 = \ _beta ((_expressionIpatternMatchWarnings) :: [Warning]) ((_lhsIimportEnvironment) :: ImportEnvironment) ((_lhsIsubstitution) :: FixpointSubstitution) ((_patternsIelementss) :: [ [PatternElement]       ]) ((_patternsIself) :: Patterns) ((_rangeIself) :: Range) ->
                                                    patternMatchWarnings _lhsIimportEnvironment
                                                                         _lhsIsubstitution
                                                                         _beta
                                                                         (take (length _patternsIself) . fst . functionSpine)
                                                                         [(concat _patternsIelementss, False)]
                                                                         _rangeIself
                                                                         (Just $ Name_Special noRange [] [] "\\")
                                                                         True
                                                                         []
                                                                         "lambda expression"
                                                                         "->"
                                                    ++ _expressionIpatternMatchWarnings
   {-# INLINE rule1712 #-}
   rule1712 = \ _assumptions _constraints ((_lhsItryPatterns) :: [(Expression     , [String])]) _localInfo ->
            let infoTuple = metaVarInfo _constraints _assumptions _localInfo
            in matchOnlyVariable infoTuple _lhsItryPatterns
   {-# INLINE rule1713 #-}
   rule1713 = \  (_ :: ()) ->
                                                     []
   {-# INLINE rule1714 #-}
   rule1714 = \ ((_expressionIunboundNames) :: Names) ((_lhsInamesInScope) :: Names) ((_patternsIpatVarNames) :: Names) ->
                                                                        changeOfScope _patternsIpatVarNames _expressionIunboundNames _lhsInamesInScope
   {-# INLINE rule1715 #-}
   rule1715 = \ _unboundNames ->
                                             _unboundNames
   {-# INLINE rule1716 #-}
   rule1716 = \ ((_expressionIinfoTree) :: InfoTree) ((_lhsIparentTree) :: InfoTree) _localInfo ((_patternsIinfoTrees) :: InfoTrees) ->
                            node _lhsIparentTree _localInfo (_patternsIinfoTrees ++ [_expressionIinfoTree])
   {-# INLINE rule1717 #-}
   rule1717 = \ _parentTree ->
                            _parentTree
   {-# INLINE rule1718 #-}
   rule1718 = \ _beta ((_lhsImonos) :: Monos) _self ->
                            LocalInfo { self = UHA_Expr _self
                                      , assignedType = Just _beta
                                      , monos = _lhsImonos
                                      }
   {-# INLINE rule1719 #-}
   rule1719 = \ _parentTree ((_patternsIenvironment) :: PatternAssumptions) ->
     \name -> variableConstraint "variable" (nameToUHA_Expr name)
        [ FolkloreConstraint
        , makeUnifier name "lambda abstraction" _patternsIenvironment _parentTree
        ]
   {-# INLINE rule1720 #-}
   rule1720 = \ _parentTree ->
     resultConstraint "lambda abstraction" _parentTree
        [ FolkloreConstraint ]
   {-# INLINE rule1721 #-}
   rule1721 = \ ((_lhsIbetaUnique) :: Int) ->
                                   _lhsIbetaUnique + 1
   {-# INLINE rule1722 #-}
   rule1722 = \ _csetBinds ((_lhsImonos) :: Monos) ((_patternsIenvironment) :: PatternAssumptions) ->
                                   M.elems _patternsIenvironment ++ getMonos _csetBinds ++ _lhsImonos
   {-# INLINE rule1723 #-}
   rule1723 = \ _csetBinds ((_expressionIconstraints) :: ConstraintSet) _newcon ((_patternsIconstraintslist) :: ConstraintSets) ->
                                   _newcon .>. _csetBinds .>>.
                                   Node [ Node _patternsIconstraintslist
                                        , _expressionIconstraints
                                        ]
   {-# INLINE rule1724 #-}
   rule1724 = \ ((_lhsIbetaUnique) :: Int) ->
                                   TVar _lhsIbetaUnique
   {-# INLINE rule1725 #-}
   rule1725 = \ _beta _cinfoType ((_expressionIbeta) :: Tp) ((_patternsIbetas) :: Tps) ->
                                   [ (foldr (.->.) _expressionIbeta _patternsIbetas .==. _beta) _cinfoType ]
   {-# INLINE rule1726 #-}
   rule1726 = \ _cinfoBind ((_expressionIassumptions) :: Assumptions) ((_patternsIenvironment) :: PatternAssumptions) ->
                                           (_patternsIenvironment .===. _expressionIassumptions) _cinfoBind
   {-# INLINE rule1727 #-}
   rule1727 = \ ((_expressionIcollectInstances) :: [(Name, Instance)]) ->
     _expressionIcollectInstances
   {-# INLINE rule1728 #-}
   rule1728 = \ ((_expressionIself) :: Expression) ((_patternsIself) :: Patterns) ((_rangeIself) :: Range) ->
     Expression_Lambda _rangeIself _patternsIself _expressionIself
   {-# INLINE rule1729 #-}
   rule1729 = \ _self ->
     _self
   {-# INLINE rule1730 #-}
   rule1730 = \ _assumptions ->
     _assumptions
   {-# INLINE rule1731 #-}
   rule1731 = \ _beta ->
     _beta
   {-# INLINE rule1732 #-}
   rule1732 = \ ((_expressionIbetaUnique) :: Int) ->
     _expressionIbetaUnique
   {-# INLINE rule1733 #-}
   rule1733 = \ ((_expressionIcollectErrors) :: TypeErrors) ->
     _expressionIcollectErrors
   {-# INLINE rule1734 #-}
   rule1734 = \ ((_expressionIcollectWarnings) :: Warnings) ->
     _expressionIcollectWarnings
   {-# INLINE rule1735 #-}
   rule1735 = \ _constraints ->
     _constraints
   {-# INLINE rule1736 #-}
   rule1736 = \ ((_expressionIcounter) :: Int) ->
     _expressionIcounter
   {-# INLINE rule1737 #-}
   rule1737 = \ ((_expressionIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _expressionIdictionaryEnvironment
   {-# INLINE rule1738 #-}
   rule1738 = \ ((_expressionImatchIO) :: IO ()) ->
     _expressionImatchIO
   {-# INLINE rule1739 #-}
   rule1739 = \ ((_expressionIuniqueChunk) :: Int) ->
     _expressionIuniqueChunk
   {-# INLINE rule1740 #-}
   rule1740 = \ ((_expressionIuniqueSecondRound) :: Int) ->
     _expressionIuniqueSecondRound
   {-# INLINE rule1741 #-}
   rule1741 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule1742 #-}
   rule1742 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule1743 #-}
   rule1743 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule1744 #-}
   rule1744 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule1745 #-}
   rule1745 = \ _namesInScope ->
     _namesInScope
   {-# INLINE rule1746 #-}
   rule1746 = \ _parentTree ->
     _parentTree
   {-# INLINE rule1747 #-}
   rule1747 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule1748 #-}
   rule1748 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
   {-# INLINE rule1749 #-}
   rule1749 = \ ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ->
     _lhsIallPatterns
   {-# INLINE rule1750 #-}
   rule1750 = \ ((_lhsIallTypeSchemes) :: M.Map NameWithRange TpScheme) ->
     _lhsIallTypeSchemes
   {-# INLINE rule1751 #-}
   rule1751 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule1752 #-}
   rule1752 = \ ((_lhsIavailablePredicates) :: [PredicateWithSource]) ->
     _lhsIavailablePredicates
   {-# INLINE rule1753 #-}
   rule1753 = \ ((_patternsIbetaUnique) :: Int) ->
     _patternsIbetaUnique
   {-# INLINE rule1754 #-}
   rule1754 = \ ((_lhsIclassEnvironment) :: ClassEnvironment) ->
     _lhsIclassEnvironment
   {-# INLINE rule1755 #-}
   rule1755 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule1756 #-}
   rule1756 = \ ((_lhsIclassMemberTypeSchemes) :: Maybe [(Name, TpScheme)]) ->
     _lhsIclassMemberTypeSchemes
   {-# INLINE rule1757 #-}
   rule1757 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule1758 #-}
   rule1758 = \ ((_lhsIclassPredicate) :: Maybe (Name, Names)) ->
     _lhsIclassPredicate
   {-# INLINE rule1759 #-}
   rule1759 = \ ((_lhsIclassTypeSchemes) :: M.Map Name TpScheme) ->
     _lhsIclassTypeSchemes
   {-# INLINE rule1760 #-}
   rule1760 = \ ((_lhsIcollectErrors) :: TypeErrors) ->
     _lhsIcollectErrors
   {-# INLINE rule1761 #-}
   rule1761 = \ ((_lhsIcollectWarnings) :: Warnings) ->
     _lhsIcollectWarnings
   {-# INLINE rule1762 #-}
   rule1762 = \ ((_patternsIcounter) :: Int) ->
     _patternsIcounter
   {-# INLINE rule1763 #-}
   rule1763 = \ ((_lhsIcurClassPred) :: Maybe Predicate) ->
     _lhsIcurClassPred
   {-# INLINE rule1764 #-}
   rule1764 = \ ((_lhsIcurPred) :: Maybe Predicate) ->
     _lhsIcurPred
   {-# INLINE rule1765 #-}
   rule1765 = \ ((_lhsIcurrentChunk) :: Int) ->
     _lhsIcurrentChunk
   {-# INLINE rule1766 #-}
   rule1766 = \ ((_lhsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _lhsIdictionaryEnvironment
   {-# INLINE rule1767 #-}
   rule1767 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule1768 #-}
   rule1768 = \ ((_lhsIinstanceName) :: Maybe Name) ->
     _lhsIinstanceName
   {-# INLINE rule1769 #-}
   rule1769 = \ ((_lhsIinstanceTypes) :: [(Name, TpScheme)]) ->
     _lhsIinstanceTypes
   {-# INLINE rule1770 #-}
   rule1770 = \ ((_lhsImatchIO) :: IO ()) ->
     _lhsImatchIO
   {-# INLINE rule1771 #-}
   rule1771 = \ ((_lhsImoduleName) :: Maybe Name) ->
     _lhsImoduleName
   {-# INLINE rule1772 #-}
   rule1772 = \ _namesInScope ->
     _namesInScope
   {-# INLINE rule1773 #-}
   rule1773 = \ ((_lhsIorderedTypeSynonyms) :: OrderedTypeSynonyms) ->
     _lhsIorderedTypeSynonyms
   {-# INLINE rule1774 #-}
   rule1774 = \ _parentTree ->
     _parentTree
   {-# INLINE rule1775 #-}
   rule1775 = \ ((_patternsIpatternMatchWarnings) :: [Warning]) ->
     _patternsIpatternMatchWarnings
   {-# INLINE rule1776 #-}
   rule1776 = \ ((_lhsIrequiredPredicates) :: Predicates) ->
     _lhsIrequiredPredicates
   {-# INLINE rule1777 #-}
   rule1777 = \ ((_lhsIsubstitution) :: FixpointSubstitution) ->
     _lhsIsubstitution
   {-# INLINE rule1778 #-}
   rule1778 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
   {-# INLINE rule1779 #-}
   rule1779 = \ ((_lhsItypeschemeMap) :: M.Map Int (Scheme Predicates)) ->
     _lhsItypeschemeMap
   {-# INLINE rule1780 #-}
   rule1780 = \ ((_lhsIuniqueChunk) :: Int) ->
     _lhsIuniqueChunk
   {-# INLINE rule1781 #-}
   rule1781 = \ ((_lhsIuniqueSecondRound) :: Int) ->
     _lhsIuniqueSecondRound
   {-# INLINE rule1782 #-}
   rule1782 = \ ((_lhsIvariableMapping) :: Maybe [(Name, Tp)]) ->
     _lhsIvariableMapping
{-# NOINLINE sem_Expression_Case #-}
sem_Expression_Case :: T_Range  -> T_Expression  -> T_Alternatives  -> T_Expression 
sem_Expression_Case arg_range_ arg_expression_ arg_alternatives_ = T_Expression (return st41) where
   {-# NOINLINE st41 #-}
   !st41 = let
      v40 :: T_Expression_v40 
      v40 = \ !(T_Expression_vIn40 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItryPatterns _lhsItypeConstructors _lhsItypeschemeMap _lhsIuniqueChunk _lhsIuniqueSecondRound _lhsIvariableMapping) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _expressionX41 = Control.Monad.Identity.runIdentity (attach_T_Expression (arg_expression_))
         _alternativesX5 = Control.Monad.Identity.runIdentity (attach_T_Alternatives (arg_alternatives_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_Expression_vOut40 _expressionIassumptions _expressionIbeta _expressionIbetaUnique _expressionIcollectErrors _expressionIcollectInstances _expressionIcollectWarnings _expressionIconstraints _expressionIcounter _expressionIdictionaryEnvironment _expressionIinfoTree _expressionImatchIO _expressionImatches _expressionIpatternMatchWarnings _expressionIself _expressionIunboundNames _expressionIuniqueChunk _expressionIuniqueSecondRound) = inv_Expression_s41 _expressionX41 (T_Expression_vIn40 _expressionOallPatterns _expressionOallTypeSchemes _expressionOambiguousConflicts _expressionOavailablePredicates _expressionObetaUnique _expressionOclassEnvironment _expressionOclassMemberEnv _expressionOclassMemberTypeSchemes _expressionOclassNamesEnv _expressionOclassPredicate _expressionOclassTypeSchemes _expressionOcollectErrors _expressionOcollectWarnings _expressionOcounter _expressionOcurClassPred _expressionOcurPred _expressionOcurrentChunk _expressionOdictionaryEnvironment _expressionOimportEnvironment _expressionOinstanceName _expressionOinstanceTypes _expressionOmatchIO _expressionOmoduleName _expressionOmonos _expressionOnamesInScope _expressionOorderedTypeSynonyms _expressionOparentTree _expressionOpatternMatchWarnings _expressionOrequiredPredicates _expressionOsubstitution _expressionOtryPatterns _expressionOtypeConstructors _expressionOtypeschemeMap _expressionOuniqueChunk _expressionOuniqueSecondRound _expressionOvariableMapping)
         (T_Alternatives_vOut4 _alternativesIassumptions _alternativesIbetaUnique _alternativesIcollectErrors _alternativesIcollectInstances _alternativesIcollectWarnings _alternativesIconstraintslist _alternativesIcounter _alternativesIdictionaryEnvironment _alternativesIelementss _alternativesIinfoTrees _alternativesImatchIO _alternativesIpatternMatchWarnings _alternativesIself _alternativesIunboundNames _alternativesIuniqueChunk _alternativesIunrwars) = inv_Alternatives_s5 _alternativesX5 (T_Alternatives_vIn4 _alternativesOallPatterns _alternativesOallTypeSchemes _alternativesOambiguousConflicts _alternativesOavailablePredicates _alternativesObetaLeft _alternativesObetaRight _alternativesObetaUnique _alternativesOclassEnvironment _alternativesOclassMemberEnv _alternativesOclassMemberTypeSchemes _alternativesOclassNamesEnv _alternativesOclassPredicate _alternativesOclassTypeSchemes _alternativesOcollectErrors _alternativesOcollectWarnings _alternativesOcounter _alternativesOcurClassPred _alternativesOcurPred _alternativesOcurrentChunk _alternativesOdictionaryEnvironment _alternativesOimportEnvironment _alternativesOinstanceName _alternativesOinstanceTypes _alternativesOmatchIO _alternativesOmoduleName _alternativesOmonos _alternativesOnamesInScope _alternativesOorderedTypeSynonyms _alternativesOparentTree _alternativesOpatternMatchWarnings _alternativesOrequiredPredicates _alternativesOsubstitution _alternativesOtypeConstructors _alternativesOtypeschemeMap _alternativesOuniqueChunk _alternativesOvariableMapping)
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule1783 _alternativesIelementss _alternativesIpatternMatchWarnings _alternativesIunrwars _expressionIbeta _lhsIimportEnvironment _lhsIsubstitution _rangeIself
         _lhsOmatches :: [Maybe MetaVariableTable]
         _lhsOmatches = rule1784 _assumptions _constraints _lhsItryPatterns _localInfo
         _expressionOtryPatterns = rule1785  ()
         _parentTree = rule1786 _alternativesIinfoTrees _expressionIinfoTree _lhsIparentTree _localInfo
         _lhsOinfoTree :: InfoTree
         _lhsOinfoTree = rule1787 _parentTree
         _localInfo = rule1788 _beta _lhsImonos _self
         _cinfo = rule1789 _beta' _localInfo _parentTree
         _expressionObetaUnique = rule1790 _lhsIbetaUnique
         _alternativesObetaLeft = rule1791 _beta'
         _alternativesObetaRight = rule1792 _beta
         _assumptions = rule1793 _alternativesIassumptions _expressionIassumptions
         _constraints = rule1794 _alternativesIconstraintslist _expressionIconstraints _newcon
         _beta = rule1795 _lhsIbetaUnique
         _beta' = rule1796 _lhsIbetaUnique
         _newcon = rule1797 _beta' _cinfo _expressionIbeta
         _lhsOcollectInstances :: [(Name, Instance)]
         _lhsOcollectInstances = rule1798 _alternativesIcollectInstances _expressionIcollectInstances
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule1799 _alternativesIunboundNames _expressionIunboundNames
         _self = rule1800 _alternativesIself _expressionIself _rangeIself
         _lhsOself :: Expression
         _lhsOself = rule1801 _self
         _lhsOassumptions :: Assumptions
         _lhsOassumptions = rule1802 _assumptions
         _lhsObeta :: Tp
         _lhsObeta = rule1803 _beta
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule1804 _alternativesIbetaUnique
         _lhsOcollectErrors :: TypeErrors
         _lhsOcollectErrors = rule1805 _alternativesIcollectErrors
         _lhsOcollectWarnings :: Warnings
         _lhsOcollectWarnings = rule1806 _alternativesIcollectWarnings
         _lhsOconstraints :: ConstraintSet
         _lhsOconstraints = rule1807 _constraints
         _lhsOcounter :: Int
         _lhsOcounter = rule1808 _alternativesIcounter
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule1809 _alternativesIdictionaryEnvironment
         _lhsOmatchIO :: IO ()
         _lhsOmatchIO = rule1810 _alternativesImatchIO
         _lhsOuniqueChunk :: Int
         _lhsOuniqueChunk = rule1811 _alternativesIuniqueChunk
         _lhsOuniqueSecondRound :: Int
         _lhsOuniqueSecondRound = rule1812 _expressionIuniqueSecondRound
         _expressionOallPatterns = rule1813 _lhsIallPatterns
         _expressionOallTypeSchemes = rule1814 _lhsIallTypeSchemes
         _expressionOambiguousConflicts = rule1815 _lhsIambiguousConflicts
         _expressionOavailablePredicates = rule1816 _lhsIavailablePredicates
         _expressionOclassEnvironment = rule1817 _lhsIclassEnvironment
         _expressionOclassMemberEnv = rule1818 _lhsIclassMemberEnv
         _expressionOclassMemberTypeSchemes = rule1819 _lhsIclassMemberTypeSchemes
         _expressionOclassNamesEnv = rule1820 _lhsIclassNamesEnv
         _expressionOclassPredicate = rule1821 _lhsIclassPredicate
         _expressionOclassTypeSchemes = rule1822 _lhsIclassTypeSchemes
         _expressionOcollectErrors = rule1823 _lhsIcollectErrors
         _expressionOcollectWarnings = rule1824 _lhsIcollectWarnings
         _expressionOcounter = rule1825 _lhsIcounter
         _expressionOcurClassPred = rule1826 _lhsIcurClassPred
         _expressionOcurPred = rule1827 _lhsIcurPred
         _expressionOcurrentChunk = rule1828 _lhsIcurrentChunk
         _expressionOdictionaryEnvironment = rule1829 _lhsIdictionaryEnvironment
         _expressionOimportEnvironment = rule1830 _lhsIimportEnvironment
         _expressionOinstanceName = rule1831 _lhsIinstanceName
         _expressionOinstanceTypes = rule1832 _lhsIinstanceTypes
         _expressionOmatchIO = rule1833 _lhsImatchIO
         _expressionOmoduleName = rule1834 _lhsImoduleName
         _expressionOmonos = rule1835 _lhsImonos
         _expressionOnamesInScope = rule1836 _lhsInamesInScope
         _expressionOorderedTypeSynonyms = rule1837 _lhsIorderedTypeSynonyms
         _expressionOparentTree = rule1838 _parentTree
         _expressionOpatternMatchWarnings = rule1839 _lhsIpatternMatchWarnings
         _expressionOrequiredPredicates = rule1840 _lhsIrequiredPredicates
         _expressionOsubstitution = rule1841 _lhsIsubstitution
         _expressionOtypeConstructors = rule1842 _lhsItypeConstructors
         _expressionOtypeschemeMap = rule1843 _lhsItypeschemeMap
         _expressionOuniqueChunk = rule1844 _lhsIuniqueChunk
         _expressionOuniqueSecondRound = rule1845 _lhsIuniqueSecondRound
         _expressionOvariableMapping = rule1846 _lhsIvariableMapping
         _alternativesOallPatterns = rule1847 _lhsIallPatterns
         _alternativesOallTypeSchemes = rule1848 _lhsIallTypeSchemes
         _alternativesOambiguousConflicts = rule1849 _lhsIambiguousConflicts
         _alternativesOavailablePredicates = rule1850 _lhsIavailablePredicates
         _alternativesObetaUnique = rule1851 _expressionIbetaUnique
         _alternativesOclassEnvironment = rule1852 _lhsIclassEnvironment
         _alternativesOclassMemberEnv = rule1853 _lhsIclassMemberEnv
         _alternativesOclassMemberTypeSchemes = rule1854 _lhsIclassMemberTypeSchemes
         _alternativesOclassNamesEnv = rule1855 _lhsIclassNamesEnv
         _alternativesOclassPredicate = rule1856 _lhsIclassPredicate
         _alternativesOclassTypeSchemes = rule1857 _lhsIclassTypeSchemes
         _alternativesOcollectErrors = rule1858 _expressionIcollectErrors
         _alternativesOcollectWarnings = rule1859 _expressionIcollectWarnings
         _alternativesOcounter = rule1860 _expressionIcounter
         _alternativesOcurClassPred = rule1861 _lhsIcurClassPred
         _alternativesOcurPred = rule1862 _lhsIcurPred
         _alternativesOcurrentChunk = rule1863 _lhsIcurrentChunk
         _alternativesOdictionaryEnvironment = rule1864 _expressionIdictionaryEnvironment
         _alternativesOimportEnvironment = rule1865 _lhsIimportEnvironment
         _alternativesOinstanceName = rule1866 _lhsIinstanceName
         _alternativesOinstanceTypes = rule1867 _lhsIinstanceTypes
         _alternativesOmatchIO = rule1868 _expressionImatchIO
         _alternativesOmoduleName = rule1869 _lhsImoduleName
         _alternativesOmonos = rule1870 _lhsImonos
         _alternativesOnamesInScope = rule1871 _lhsInamesInScope
         _alternativesOorderedTypeSynonyms = rule1872 _lhsIorderedTypeSynonyms
         _alternativesOparentTree = rule1873 _parentTree
         _alternativesOpatternMatchWarnings = rule1874 _expressionIpatternMatchWarnings
         _alternativesOrequiredPredicates = rule1875 _lhsIrequiredPredicates
         _alternativesOsubstitution = rule1876 _lhsIsubstitution
         _alternativesOtypeConstructors = rule1877 _lhsItypeConstructors
         _alternativesOtypeschemeMap = rule1878 _lhsItypeschemeMap
         _alternativesOuniqueChunk = rule1879 _expressionIuniqueChunk
         _alternativesOvariableMapping = rule1880 _lhsIvariableMapping
         !__result_ = T_Expression_vOut40 _lhsOassumptions _lhsObeta _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraints _lhsOcounter _lhsOdictionaryEnvironment _lhsOinfoTree _lhsOmatchIO _lhsOmatches _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOuniqueSecondRound
         in __result_ )
     in C_Expression_s41 v40
   {-# INLINE rule1783 #-}
   rule1783 = \ ((_alternativesIelementss) :: [([PatternElement], Bool)]) ((_alternativesIpatternMatchWarnings) :: [Warning]) ((_alternativesIunrwars) :: [Warning]) ((_expressionIbeta) :: Tp) ((_lhsIimportEnvironment) :: ImportEnvironment) ((_lhsIsubstitution) :: FixpointSubstitution) ((_rangeIself) :: Range) ->
                                                    patternMatchWarnings _lhsIimportEnvironment
                                                                         _lhsIsubstitution
                                                                         _expressionIbeta
                                                                         (:[])
                                                                         _alternativesIelementss
                                                                         _rangeIself
                                                                         Nothing
                                                                         False
                                                                         _alternativesIunrwars
                                                                         "case expression"
                                                                         "->"
                                                    ++ _alternativesIpatternMatchWarnings
   {-# INLINE rule1784 #-}
   rule1784 = \ _assumptions _constraints ((_lhsItryPatterns) :: [(Expression     , [String])]) _localInfo ->
            let infoTuple = metaVarInfo _constraints _assumptions _localInfo
            in matchOnlyVariable infoTuple _lhsItryPatterns
   {-# INLINE rule1785 #-}
   rule1785 = \  (_ :: ()) ->
                                                     []
   {-# INLINE rule1786 #-}
   rule1786 = \ ((_alternativesIinfoTrees) :: InfoTrees) ((_expressionIinfoTree) :: InfoTree) ((_lhsIparentTree) :: InfoTree) _localInfo ->
                            node _lhsIparentTree _localInfo (_expressionIinfoTree : _alternativesIinfoTrees)
   {-# INLINE rule1787 #-}
   rule1787 = \ _parentTree ->
                            _parentTree
   {-# INLINE rule1788 #-}
   rule1788 = \ _beta ((_lhsImonos) :: Monos) _self ->
                            LocalInfo { self = UHA_Expr _self
                                      , assignedType = Just _beta
                                      , monos = _lhsImonos
                                      }
   {-# INLINE rule1789 #-}
   rule1789 = \ _beta' _localInfo _parentTree ->
     childConstraint 0 "scrutinee of case expression" _parentTree
        [ Unifier (head (ftv _beta')) ("case patterns", _localInfo, "scrutinee") ]
   {-# INLINE rule1790 #-}
   rule1790 = \ ((_lhsIbetaUnique) :: Int) ->
                                     _lhsIbetaUnique + 2
   {-# INLINE rule1791 #-}
   rule1791 = \ _beta' ->
                                     _beta'
   {-# INLINE rule1792 #-}
   rule1792 = \ _beta ->
                                     _beta
   {-# INLINE rule1793 #-}
   rule1793 = \ ((_alternativesIassumptions) :: Assumptions) ((_expressionIassumptions) :: Assumptions) ->
                                     _expressionIassumptions `combine` _alternativesIassumptions
   {-# INLINE rule1794 #-}
   rule1794 = \ ((_alternativesIconstraintslist) :: ConstraintSets) ((_expressionIconstraints) :: ConstraintSet) _newcon ->
                                     Node [ _newcon .<. _expressionIconstraints
                                          , Node _alternativesIconstraintslist
                                          ]
   {-# INLINE rule1795 #-}
   rule1795 = \ ((_lhsIbetaUnique) :: Int) ->
                                     TVar _lhsIbetaUnique
   {-# INLINE rule1796 #-}
   rule1796 = \ ((_lhsIbetaUnique) :: Int) ->
                                     TVar (_lhsIbetaUnique + 1)
   {-# INLINE rule1797 #-}
   rule1797 = \ _beta' _cinfo ((_expressionIbeta) :: Tp) ->
                                     [ (_expressionIbeta .==. _beta') _cinfo ]
   {-# INLINE rule1798 #-}
   rule1798 = \ ((_alternativesIcollectInstances) :: [(Name, Instance)]) ((_expressionIcollectInstances) :: [(Name, Instance)]) ->
     _expressionIcollectInstances  ++  _alternativesIcollectInstances
   {-# INLINE rule1799 #-}
   rule1799 = \ ((_alternativesIunboundNames) :: Names) ((_expressionIunboundNames) :: Names) ->
     ((++) _expressionIunboundNames _alternativesIunboundNames)
   {-# INLINE rule1800 #-}
   rule1800 = \ ((_alternativesIself) :: Alternatives) ((_expressionIself) :: Expression) ((_rangeIself) :: Range) ->
     Expression_Case _rangeIself _expressionIself _alternativesIself
   {-# INLINE rule1801 #-}
   rule1801 = \ _self ->
     _self
   {-# INLINE rule1802 #-}
   rule1802 = \ _assumptions ->
     _assumptions
   {-# INLINE rule1803 #-}
   rule1803 = \ _beta ->
     _beta
   {-# INLINE rule1804 #-}
   rule1804 = \ ((_alternativesIbetaUnique) :: Int) ->
     _alternativesIbetaUnique
   {-# INLINE rule1805 #-}
   rule1805 = \ ((_alternativesIcollectErrors) :: TypeErrors) ->
     _alternativesIcollectErrors
   {-# INLINE rule1806 #-}
   rule1806 = \ ((_alternativesIcollectWarnings) :: Warnings) ->
     _alternativesIcollectWarnings
   {-# INLINE rule1807 #-}
   rule1807 = \ _constraints ->
     _constraints
   {-# INLINE rule1808 #-}
   rule1808 = \ ((_alternativesIcounter) :: Int) ->
     _alternativesIcounter
   {-# INLINE rule1809 #-}
   rule1809 = \ ((_alternativesIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _alternativesIdictionaryEnvironment
   {-# INLINE rule1810 #-}
   rule1810 = \ ((_alternativesImatchIO) :: IO ()) ->
     _alternativesImatchIO
   {-# INLINE rule1811 #-}
   rule1811 = \ ((_alternativesIuniqueChunk) :: Int) ->
     _alternativesIuniqueChunk
   {-# INLINE rule1812 #-}
   rule1812 = \ ((_expressionIuniqueSecondRound) :: Int) ->
     _expressionIuniqueSecondRound
   {-# INLINE rule1813 #-}
   rule1813 = \ ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ->
     _lhsIallPatterns
   {-# INLINE rule1814 #-}
   rule1814 = \ ((_lhsIallTypeSchemes) :: M.Map NameWithRange TpScheme) ->
     _lhsIallTypeSchemes
   {-# INLINE rule1815 #-}
   rule1815 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule1816 #-}
   rule1816 = \ ((_lhsIavailablePredicates) :: [PredicateWithSource]) ->
     _lhsIavailablePredicates
   {-# INLINE rule1817 #-}
   rule1817 = \ ((_lhsIclassEnvironment) :: ClassEnvironment) ->
     _lhsIclassEnvironment
   {-# INLINE rule1818 #-}
   rule1818 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule1819 #-}
   rule1819 = \ ((_lhsIclassMemberTypeSchemes) :: Maybe [(Name, TpScheme)]) ->
     _lhsIclassMemberTypeSchemes
   {-# INLINE rule1820 #-}
   rule1820 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule1821 #-}
   rule1821 = \ ((_lhsIclassPredicate) :: Maybe (Name, Names)) ->
     _lhsIclassPredicate
   {-# INLINE rule1822 #-}
   rule1822 = \ ((_lhsIclassTypeSchemes) :: M.Map Name TpScheme) ->
     _lhsIclassTypeSchemes
   {-# INLINE rule1823 #-}
   rule1823 = \ ((_lhsIcollectErrors) :: TypeErrors) ->
     _lhsIcollectErrors
   {-# INLINE rule1824 #-}
   rule1824 = \ ((_lhsIcollectWarnings) :: Warnings) ->
     _lhsIcollectWarnings
   {-# INLINE rule1825 #-}
   rule1825 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule1826 #-}
   rule1826 = \ ((_lhsIcurClassPred) :: Maybe Predicate) ->
     _lhsIcurClassPred
   {-# INLINE rule1827 #-}
   rule1827 = \ ((_lhsIcurPred) :: Maybe Predicate) ->
     _lhsIcurPred
   {-# INLINE rule1828 #-}
   rule1828 = \ ((_lhsIcurrentChunk) :: Int) ->
     _lhsIcurrentChunk
   {-# INLINE rule1829 #-}
   rule1829 = \ ((_lhsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _lhsIdictionaryEnvironment
   {-# INLINE rule1830 #-}
   rule1830 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule1831 #-}
   rule1831 = \ ((_lhsIinstanceName) :: Maybe Name) ->
     _lhsIinstanceName
   {-# INLINE rule1832 #-}
   rule1832 = \ ((_lhsIinstanceTypes) :: [(Name, TpScheme)]) ->
     _lhsIinstanceTypes
   {-# INLINE rule1833 #-}
   rule1833 = \ ((_lhsImatchIO) :: IO ()) ->
     _lhsImatchIO
   {-# INLINE rule1834 #-}
   rule1834 = \ ((_lhsImoduleName) :: Maybe Name) ->
     _lhsImoduleName
   {-# INLINE rule1835 #-}
   rule1835 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule1836 #-}
   rule1836 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule1837 #-}
   rule1837 = \ ((_lhsIorderedTypeSynonyms) :: OrderedTypeSynonyms) ->
     _lhsIorderedTypeSynonyms
   {-# INLINE rule1838 #-}
   rule1838 = \ _parentTree ->
     _parentTree
   {-# INLINE rule1839 #-}
   rule1839 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule1840 #-}
   rule1840 = \ ((_lhsIrequiredPredicates) :: Predicates) ->
     _lhsIrequiredPredicates
   {-# INLINE rule1841 #-}
   rule1841 = \ ((_lhsIsubstitution) :: FixpointSubstitution) ->
     _lhsIsubstitution
   {-# INLINE rule1842 #-}
   rule1842 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
   {-# INLINE rule1843 #-}
   rule1843 = \ ((_lhsItypeschemeMap) :: M.Map Int (Scheme Predicates)) ->
     _lhsItypeschemeMap
   {-# INLINE rule1844 #-}
   rule1844 = \ ((_lhsIuniqueChunk) :: Int) ->
     _lhsIuniqueChunk
   {-# INLINE rule1845 #-}
   rule1845 = \ ((_lhsIuniqueSecondRound) :: Int) ->
     _lhsIuniqueSecondRound
   {-# INLINE rule1846 #-}
   rule1846 = \ ((_lhsIvariableMapping) :: Maybe [(Name, Tp)]) ->
     _lhsIvariableMapping
   {-# INLINE rule1847 #-}
   rule1847 = \ ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ->
     _lhsIallPatterns
   {-# INLINE rule1848 #-}
   rule1848 = \ ((_lhsIallTypeSchemes) :: M.Map NameWithRange TpScheme) ->
     _lhsIallTypeSchemes
   {-# INLINE rule1849 #-}
   rule1849 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule1850 #-}
   rule1850 = \ ((_lhsIavailablePredicates) :: [PredicateWithSource]) ->
     _lhsIavailablePredicates
   {-# INLINE rule1851 #-}
   rule1851 = \ ((_expressionIbetaUnique) :: Int) ->
     _expressionIbetaUnique
   {-# INLINE rule1852 #-}
   rule1852 = \ ((_lhsIclassEnvironment) :: ClassEnvironment) ->
     _lhsIclassEnvironment
   {-# INLINE rule1853 #-}
   rule1853 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule1854 #-}
   rule1854 = \ ((_lhsIclassMemberTypeSchemes) :: Maybe [(Name, TpScheme)]) ->
     _lhsIclassMemberTypeSchemes
   {-# INLINE rule1855 #-}
   rule1855 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule1856 #-}
   rule1856 = \ ((_lhsIclassPredicate) :: Maybe (Name, Names)) ->
     _lhsIclassPredicate
   {-# INLINE rule1857 #-}
   rule1857 = \ ((_lhsIclassTypeSchemes) :: M.Map Name TpScheme) ->
     _lhsIclassTypeSchemes
   {-# INLINE rule1858 #-}
   rule1858 = \ ((_expressionIcollectErrors) :: TypeErrors) ->
     _expressionIcollectErrors
   {-# INLINE rule1859 #-}
   rule1859 = \ ((_expressionIcollectWarnings) :: Warnings) ->
     _expressionIcollectWarnings
   {-# INLINE rule1860 #-}
   rule1860 = \ ((_expressionIcounter) :: Int) ->
     _expressionIcounter
   {-# INLINE rule1861 #-}
   rule1861 = \ ((_lhsIcurClassPred) :: Maybe Predicate) ->
     _lhsIcurClassPred
   {-# INLINE rule1862 #-}
   rule1862 = \ ((_lhsIcurPred) :: Maybe Predicate) ->
     _lhsIcurPred
   {-# INLINE rule1863 #-}
   rule1863 = \ ((_lhsIcurrentChunk) :: Int) ->
     _lhsIcurrentChunk
   {-# INLINE rule1864 #-}
   rule1864 = \ ((_expressionIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _expressionIdictionaryEnvironment
   {-# INLINE rule1865 #-}
   rule1865 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule1866 #-}
   rule1866 = \ ((_lhsIinstanceName) :: Maybe Name) ->
     _lhsIinstanceName
   {-# INLINE rule1867 #-}
   rule1867 = \ ((_lhsIinstanceTypes) :: [(Name, TpScheme)]) ->
     _lhsIinstanceTypes
   {-# INLINE rule1868 #-}
   rule1868 = \ ((_expressionImatchIO) :: IO ()) ->
     _expressionImatchIO
   {-# INLINE rule1869 #-}
   rule1869 = \ ((_lhsImoduleName) :: Maybe Name) ->
     _lhsImoduleName
   {-# INLINE rule1870 #-}
   rule1870 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule1871 #-}
   rule1871 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule1872 #-}
   rule1872 = \ ((_lhsIorderedTypeSynonyms) :: OrderedTypeSynonyms) ->
     _lhsIorderedTypeSynonyms
   {-# INLINE rule1873 #-}
   rule1873 = \ _parentTree ->
     _parentTree
   {-# INLINE rule1874 #-}
   rule1874 = \ ((_expressionIpatternMatchWarnings) :: [Warning]) ->
     _expressionIpatternMatchWarnings
   {-# INLINE rule1875 #-}
   rule1875 = \ ((_lhsIrequiredPredicates) :: Predicates) ->
     _lhsIrequiredPredicates
   {-# INLINE rule1876 #-}
   rule1876 = \ ((_lhsIsubstitution) :: FixpointSubstitution) ->
     _lhsIsubstitution
   {-# INLINE rule1877 #-}
   rule1877 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
   {-# INLINE rule1878 #-}
   rule1878 = \ ((_lhsItypeschemeMap) :: M.Map Int (Scheme Predicates)) ->
     _lhsItypeschemeMap
   {-# INLINE rule1879 #-}
   rule1879 = \ ((_expressionIuniqueChunk) :: Int) ->
     _expressionIuniqueChunk
   {-# INLINE rule1880 #-}
   rule1880 = \ ((_lhsIvariableMapping) :: Maybe [(Name, Tp)]) ->
     _lhsIvariableMapping
{-# NOINLINE sem_Expression_Let #-}
sem_Expression_Let :: T_Range  -> T_Declarations  -> T_Expression  -> T_Expression 
sem_Expression_Let arg_range_ arg_declarations_ arg_expression_ = T_Expression (return st41) where
   {-# NOINLINE st41 #-}
   !st41 = let
      v40 :: T_Expression_v40 
      v40 = \ !(T_Expression_vIn40 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItryPatterns _lhsItypeConstructors _lhsItypeschemeMap _lhsIuniqueChunk _lhsIuniqueSecondRound _lhsIvariableMapping) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _declarationsX32 = Control.Monad.Identity.runIdentity (attach_T_Declarations (arg_declarations_))
         _expressionX41 = Control.Monad.Identity.runIdentity (attach_T_Expression (arg_expression_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_Declarations_vOut31 _declarationsIbetaUnique _declarationsIbindingGroups _declarationsIboundBetas _declarationsIclassMemberNames _declarationsIcollectErrors _declarationsIcollectInstances _declarationsIcollectWarnings _declarationsIcounter _declarationsIdeclVarNames _declarationsIdictionaryEnvironment _declarationsIinfoTrees _declarationsImatchIO _declarationsIpatternMatchWarnings _declarationsIrestrictedNames _declarationsIself _declarationsIsimplePatNames _declarationsItypeMemberBindings _declarationsItypeSignatures _declarationsIunboundNames _declarationsIuniqueChunk) = inv_Declarations_s32 _declarationsX32 (T_Declarations_vIn31 _declarationsOallPatterns _declarationsOallTypeSchemes _declarationsOambiguousConflicts _declarationsOavailablePredicates _declarationsObetaUnique _declarationsObindingGroups _declarationsOclassEnvironment _declarationsOclassMemberEnv _declarationsOclassMemberTypeSchemes _declarationsOclassNamesEnv _declarationsOclassPredicate _declarationsOclassTypeSchemes _declarationsOcollectErrors _declarationsOcollectWarnings _declarationsOcounter _declarationsOcurClassPred _declarationsOcurPred _declarationsOcurrentChunk _declarationsOdictionaryEnvironment _declarationsOimportEnvironment _declarationsOinheritedBDG _declarationsOinstanceName _declarationsOinstanceTypes _declarationsOisTopLevel _declarationsOmatchIO _declarationsOmoduleName _declarationsOmoduleQual _declarationsOmonos _declarationsOnamesInScope _declarationsOorderedTypeSynonyms _declarationsOparentTree _declarationsOpatternMatchWarnings _declarationsOrequiredPredicates _declarationsOsubstitution _declarationsOtypeConstructors _declarationsOtypeSignatures _declarationsOtypeschemeMap _declarationsOuniqueChunk _declarationsOvariableMapping)
         (T_Expression_vOut40 _expressionIassumptions _expressionIbeta _expressionIbetaUnique _expressionIcollectErrors _expressionIcollectInstances _expressionIcollectWarnings _expressionIconstraints _expressionIcounter _expressionIdictionaryEnvironment _expressionIinfoTree _expressionImatchIO _expressionImatches _expressionIpatternMatchWarnings _expressionIself _expressionIunboundNames _expressionIuniqueChunk _expressionIuniqueSecondRound) = inv_Expression_s41 _expressionX41 (T_Expression_vIn40 _expressionOallPatterns _expressionOallTypeSchemes _expressionOambiguousConflicts _expressionOavailablePredicates _expressionObetaUnique _expressionOclassEnvironment _expressionOclassMemberEnv _expressionOclassMemberTypeSchemes _expressionOclassNamesEnv _expressionOclassPredicate _expressionOclassTypeSchemes _expressionOcollectErrors _expressionOcollectWarnings _expressionOcounter _expressionOcurClassPred _expressionOcurPred _expressionOcurrentChunk _expressionOdictionaryEnvironment _expressionOimportEnvironment _expressionOinstanceName _expressionOinstanceTypes _expressionOmatchIO _expressionOmoduleName _expressionOmonos _expressionOnamesInScope _expressionOorderedTypeSynonyms _expressionOparentTree _expressionOpatternMatchWarnings _expressionOrequiredPredicates _expressionOsubstitution _expressionOtryPatterns _expressionOtypeConstructors _expressionOtypeschemeMap _expressionOuniqueChunk _expressionOuniqueSecondRound _expressionOvariableMapping)
         _lhsOmatches :: [Maybe MetaVariableTable]
         _lhsOmatches = rule1881 _assumptions _constraints _lhsItryPatterns _localInfo
         _expressionOtryPatterns = rule1882  ()
         (_namesInScope,_unboundNames,_scopeInfo) = rule1883 _declarationsIdeclVarNames _declarationsIunboundNames _expressionIunboundNames _lhsInamesInScope
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule1884 _unboundNames
         (_collectTypeConstructors,_collectValueConstructors,_collectTypeSynonyms,_collectConstructorEnv,_derivedFunctions,_operatorFixities,_moduleQual) = rule1885  ()
         _thisTree = rule1886 _declTree _expressionIinfoTree _lhsIparentTree _localInfo
         _declTree = rule1887 _declInfo _declarationsIinfoTrees _thisTree
         _lhsOinfoTree :: InfoTree
         _lhsOinfoTree = rule1888 _thisTree
         _expressionOparentTree = rule1889 _thisTree
         _declarationsOparentTree = rule1890 _declTree
         _localInfo = rule1891 _beta _lhsImonos _self
         _declInfo = rule1892 _declarationsIself _lhsImonos
         _cinfoType = rule1893 _thisTree
         _inferredTypes = rule1894 _implicitsFM _lhsItypeschemeMap
         _lhsOcollectWarnings :: Warnings
         _lhsOcollectWarnings = rule1895 _declarationsIsimplePatNames _expressionIcollectWarnings _inferredTypes _lhsIimportEnvironment
         _lhsOcollectErrors :: TypeErrors
         _lhsOcollectErrors = rule1896 _declarationsIcollectErrors _declarationsIrestrictedNames _inferredTypes _lhsIimportEnvironment
         _allTypeSchemes = rule1897 _lhsIallTypeSchemes _localTypes
         _localTypes = rule1898 _declarationsIbindingGroups _declarationsItypeSignatures _inferredTypes
         _declarationsOtypeSignatures = rule1899  ()
         _lhsOuniqueChunk :: Int
         _lhsOuniqueChunk = rule1900 _chunkNr
         _declarationsObetaUnique = rule1901 _lhsIbetaUnique
         _declarationsObindingGroups = rule1902  ()
         _constraints = rule1903 _beta _cinfoType _cset _expressionIbeta
         _beta = rule1904 _lhsIbetaUnique
         _lhsObetaUnique :: Int
         (_assumptions,_cset,_inheritedBDG,_chunkNr,_lhsObetaUnique,_implicitsFM) = rule1905 _declarationsIbindingGroups _declarationsItypeSignatures _expressionIassumptions _expressionIbetaUnique _expressionIconstraints _expressionIuniqueChunk _lhsIcurrentChunk _lhsImonos
         _isTopLevel = rule1906  ()
         _lhsOcollectInstances :: [(Name, Instance)]
         _lhsOcollectInstances = rule1907 _declarationsIcollectInstances _expressionIcollectInstances
         _self = rule1908 _declarationsIself _expressionIself _rangeIself
         _lhsOself :: Expression
         _lhsOself = rule1909 _self
         _lhsOassumptions :: Assumptions
         _lhsOassumptions = rule1910 _assumptions
         _lhsObeta :: Tp
         _lhsObeta = rule1911 _beta
         _lhsOconstraints :: ConstraintSet
         _lhsOconstraints = rule1912 _constraints
         _lhsOcounter :: Int
         _lhsOcounter = rule1913 _expressionIcounter
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule1914 _expressionIdictionaryEnvironment
         _lhsOmatchIO :: IO ()
         _lhsOmatchIO = rule1915 _expressionImatchIO
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule1916 _expressionIpatternMatchWarnings
         _lhsOuniqueSecondRound :: Int
         _lhsOuniqueSecondRound = rule1917 _expressionIuniqueSecondRound
         _declarationsOallPatterns = rule1918 _lhsIallPatterns
         _declarationsOallTypeSchemes = rule1919 _allTypeSchemes
         _declarationsOambiguousConflicts = rule1920 _lhsIambiguousConflicts
         _declarationsOavailablePredicates = rule1921 _lhsIavailablePredicates
         _declarationsOclassEnvironment = rule1922 _lhsIclassEnvironment
         _declarationsOclassMemberEnv = rule1923 _lhsIclassMemberEnv
         _declarationsOclassMemberTypeSchemes = rule1924 _lhsIclassMemberTypeSchemes
         _declarationsOclassNamesEnv = rule1925 _lhsIclassNamesEnv
         _declarationsOclassPredicate = rule1926 _lhsIclassPredicate
         _declarationsOclassTypeSchemes = rule1927 _lhsIclassTypeSchemes
         _declarationsOcollectErrors = rule1928 _lhsIcollectErrors
         _declarationsOcollectWarnings = rule1929 _lhsIcollectWarnings
         _declarationsOcounter = rule1930 _lhsIcounter
         _declarationsOcurClassPred = rule1931 _lhsIcurClassPred
         _declarationsOcurPred = rule1932 _lhsIcurPred
         _declarationsOcurrentChunk = rule1933 _lhsIcurrentChunk
         _declarationsOdictionaryEnvironment = rule1934 _lhsIdictionaryEnvironment
         _declarationsOimportEnvironment = rule1935 _lhsIimportEnvironment
         _declarationsOinheritedBDG = rule1936 _inheritedBDG
         _declarationsOinstanceName = rule1937 _lhsIinstanceName
         _declarationsOinstanceTypes = rule1938 _lhsIinstanceTypes
         _declarationsOisTopLevel = rule1939 _isTopLevel
         _declarationsOmatchIO = rule1940 _lhsImatchIO
         _declarationsOmoduleName = rule1941 _lhsImoduleName
         _declarationsOmoduleQual = rule1942 _moduleQual
         _declarationsOmonos = rule1943 _lhsImonos
         _declarationsOnamesInScope = rule1944 _namesInScope
         _declarationsOorderedTypeSynonyms = rule1945 _lhsIorderedTypeSynonyms
         _declarationsOpatternMatchWarnings = rule1946 _lhsIpatternMatchWarnings
         _declarationsOrequiredPredicates = rule1947 _lhsIrequiredPredicates
         _declarationsOsubstitution = rule1948 _lhsIsubstitution
         _declarationsOtypeConstructors = rule1949 _lhsItypeConstructors
         _declarationsOtypeschemeMap = rule1950 _lhsItypeschemeMap
         _declarationsOuniqueChunk = rule1951 _lhsIuniqueChunk
         _declarationsOvariableMapping = rule1952 _lhsIvariableMapping
         _expressionOallPatterns = rule1953 _lhsIallPatterns
         _expressionOallTypeSchemes = rule1954 _allTypeSchemes
         _expressionOambiguousConflicts = rule1955 _lhsIambiguousConflicts
         _expressionOavailablePredicates = rule1956 _lhsIavailablePredicates
         _expressionObetaUnique = rule1957 _declarationsIbetaUnique
         _expressionOclassEnvironment = rule1958 _lhsIclassEnvironment
         _expressionOclassMemberEnv = rule1959 _lhsIclassMemberEnv
         _expressionOclassMemberTypeSchemes = rule1960 _lhsIclassMemberTypeSchemes
         _expressionOclassNamesEnv = rule1961 _lhsIclassNamesEnv
         _expressionOclassPredicate = rule1962 _lhsIclassPredicate
         _expressionOclassTypeSchemes = rule1963 _lhsIclassTypeSchemes
         _expressionOcollectErrors = rule1964 _declarationsIcollectErrors
         _expressionOcollectWarnings = rule1965 _declarationsIcollectWarnings
         _expressionOcounter = rule1966 _declarationsIcounter
         _expressionOcurClassPred = rule1967 _lhsIcurClassPred
         _expressionOcurPred = rule1968 _lhsIcurPred
         _expressionOcurrentChunk = rule1969 _lhsIcurrentChunk
         _expressionOdictionaryEnvironment = rule1970 _declarationsIdictionaryEnvironment
         _expressionOimportEnvironment = rule1971 _lhsIimportEnvironment
         _expressionOinstanceName = rule1972 _lhsIinstanceName
         _expressionOinstanceTypes = rule1973 _lhsIinstanceTypes
         _expressionOmatchIO = rule1974 _declarationsImatchIO
         _expressionOmoduleName = rule1975 _lhsImoduleName
         _expressionOmonos = rule1976 _lhsImonos
         _expressionOnamesInScope = rule1977 _namesInScope
         _expressionOorderedTypeSynonyms = rule1978 _lhsIorderedTypeSynonyms
         _expressionOpatternMatchWarnings = rule1979 _declarationsIpatternMatchWarnings
         _expressionOrequiredPredicates = rule1980 _lhsIrequiredPredicates
         _expressionOsubstitution = rule1981 _lhsIsubstitution
         _expressionOtypeConstructors = rule1982 _lhsItypeConstructors
         _expressionOtypeschemeMap = rule1983 _lhsItypeschemeMap
         _expressionOuniqueChunk = rule1984 _declarationsIuniqueChunk
         _expressionOuniqueSecondRound = rule1985 _lhsIuniqueSecondRound
         _expressionOvariableMapping = rule1986 _lhsIvariableMapping
         !__result_ = T_Expression_vOut40 _lhsOassumptions _lhsObeta _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraints _lhsOcounter _lhsOdictionaryEnvironment _lhsOinfoTree _lhsOmatchIO _lhsOmatches _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOuniqueSecondRound
         in __result_ )
     in C_Expression_s41 v40
   {-# INLINE rule1881 #-}
   rule1881 = \ _assumptions _constraints ((_lhsItryPatterns) :: [(Expression     , [String])]) _localInfo ->
            let infoTuple = metaVarInfo _constraints _assumptions _localInfo
            in matchOnlyVariable infoTuple _lhsItryPatterns
   {-# INLINE rule1882 #-}
   rule1882 = \  (_ :: ()) ->
                                                     []
   {-# INLINE rule1883 #-}
   rule1883 = \ ((_declarationsIdeclVarNames) :: Names) ((_declarationsIunboundNames) :: Names) ((_expressionIunboundNames) :: Names) ((_lhsInamesInScope) :: Names) ->
                                                             changeOfScope _declarationsIdeclVarNames (_declarationsIunboundNames ++ _expressionIunboundNames) _lhsInamesInScope
   {-# INLINE rule1884 #-}
   rule1884 = \ _unboundNames ->
                                  _unboundNames
   {-# INLINE rule1885 #-}
   rule1885 = \  (_ :: ()) ->
                                                                                                                                                               internalError "PartialSyntax.ag" "n/a" "toplevel Expression"
   {-# INLINE rule1886 #-}
   rule1886 = \ _declTree ((_expressionIinfoTree) :: InfoTree) ((_lhsIparentTree) :: InfoTree) _localInfo ->
                            node _lhsIparentTree _localInfo [_declTree, _expressionIinfoTree]
   {-# INLINE rule1887 #-}
   rule1887 = \ _declInfo ((_declarationsIinfoTrees) :: InfoTrees) _thisTree ->
                            node _thisTree _declInfo _declarationsIinfoTrees
   {-# INLINE rule1888 #-}
   rule1888 = \ _thisTree ->
                            _thisTree
   {-# INLINE rule1889 #-}
   rule1889 = \ _thisTree ->
                                     _thisTree
   {-# INLINE rule1890 #-}
   rule1890 = \ _declTree ->
                                     _declTree
   {-# INLINE rule1891 #-}
   rule1891 = \ _beta ((_lhsImonos) :: Monos) _self ->
                            LocalInfo { self = UHA_Expr _self
                                      , assignedType = Just _beta
                                      , monos = _lhsImonos
                                      }
   {-# INLINE rule1892 #-}
   rule1892 = \ ((_declarationsIself) :: Declarations) ((_lhsImonos) :: Monos) ->
                          LocalInfo { self = UHA_Decls _declarationsIself
                                    , assignedType = Nothing
                                    , monos = _lhsImonos
                                    }
   {-# INLINE rule1893 #-}
   rule1893 = \ _thisTree ->
     resultConstraint "let expression (INTERNAL ERROR)" _thisTree
        [ FolkloreConstraint, highlyTrusted ]
   {-# INLINE rule1894 #-}
   rule1894 = \ _implicitsFM ((_lhsItypeschemeMap) :: M.Map Int (Scheme Predicates)) ->
                                        findInferredTypes _lhsItypeschemeMap _implicitsFM
   {-# INLINE rule1895 #-}
   rule1895 = \ ((_declarationsIsimplePatNames) :: Names) ((_expressionIcollectWarnings) :: Warnings) _inferredTypes ((_lhsIimportEnvironment) :: ImportEnvironment) ->
                                        missingTypeSignature False _declarationsIsimplePatNames  _inferredTypes _lhsIimportEnvironment
                                        ++ _expressionIcollectWarnings
   {-# INLINE rule1896 #-}
   rule1896 = \ ((_declarationsIcollectErrors) :: TypeErrors) ((_declarationsIrestrictedNames) :: Names) _inferredTypes ((_lhsIimportEnvironment) :: ImportEnvironment) ->
                                        restrictedNameErrors _lhsIimportEnvironment _inferredTypes _declarationsIrestrictedNames
                                        ++ _declarationsIcollectErrors
   {-# INLINE rule1897 #-}
   rule1897 = \ ((_lhsIallTypeSchemes) :: M.Map NameWithRange TpScheme) _localTypes ->
                                    _localTypes `M.union` _lhsIallTypeSchemes
   {-# INLINE rule1898 #-}
   rule1898 = \ ((_declarationsIbindingGroups) :: BindingGroups) ((_declarationsItypeSignatures) :: TypeEnvironment) _inferredTypes ->
                                    makeLocalTypeEnv (_declarationsItypeSignatures `M.union` _inferredTypes) _declarationsIbindingGroups
   {-# INLINE rule1899 #-}
   rule1899 = \  (_ :: ()) ->
                                                                  M.empty
   {-# INLINE rule1900 #-}
   rule1900 = \ _chunkNr ->
                                                     _chunkNr
   {-# INLINE rule1901 #-}
   rule1901 = \ ((_lhsIbetaUnique) :: Int) ->
                                        _lhsIbetaUnique + 1
   {-# INLINE rule1902 #-}
   rule1902 = \  (_ :: ()) ->
                                        []
   {-# INLINE rule1903 #-}
   rule1903 = \ _beta _cinfoType _cset ((_expressionIbeta) :: Tp) ->
                                        [ (_expressionIbeta .==. _beta) _cinfoType ] .>. _cset
   {-# INLINE rule1904 #-}
   rule1904 = \ ((_lhsIbetaUnique) :: Int) ->
                                        TVar _lhsIbetaUnique
   {-# INLINE rule1905 #-}
   rule1905 = \ ((_declarationsIbindingGroups) :: BindingGroups) ((_declarationsItypeSignatures) :: TypeEnvironment) ((_expressionIassumptions) :: Assumptions) ((_expressionIbetaUnique) :: Int) ((_expressionIconstraints) :: ConstraintSet) ((_expressionIuniqueChunk) :: Int) ((_lhsIcurrentChunk) :: Int) ((_lhsImonos) :: Monos) ->
           let inputBDG   = (False, _lhsIcurrentChunk, _expressionIuniqueChunk, _lhsImonos, _declarationsItypeSignatures, mybdggroup, _expressionIbetaUnique)
               mybdggroup = Just (_expressionIassumptions, [_expressionIconstraints])
           in performBindingGroup inputBDG _declarationsIbindingGroups
   {-# INLINE rule1906 #-}
   rule1906 = \  (_ :: ()) ->
                              False
   {-# INLINE rule1907 #-}
   rule1907 = \ ((_declarationsIcollectInstances) :: [(Name, Instance)]) ((_expressionIcollectInstances) :: [(Name, Instance)]) ->
     _declarationsIcollectInstances  ++  _expressionIcollectInstances
   {-# INLINE rule1908 #-}
   rule1908 = \ ((_declarationsIself) :: Declarations) ((_expressionIself) :: Expression) ((_rangeIself) :: Range) ->
     Expression_Let _rangeIself _declarationsIself _expressionIself
   {-# INLINE rule1909 #-}
   rule1909 = \ _self ->
     _self
   {-# INLINE rule1910 #-}
   rule1910 = \ _assumptions ->
     _assumptions
   {-# INLINE rule1911 #-}
   rule1911 = \ _beta ->
     _beta
   {-# INLINE rule1912 #-}
   rule1912 = \ _constraints ->
     _constraints
   {-# INLINE rule1913 #-}
   rule1913 = \ ((_expressionIcounter) :: Int) ->
     _expressionIcounter
   {-# INLINE rule1914 #-}
   rule1914 = \ ((_expressionIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _expressionIdictionaryEnvironment
   {-# INLINE rule1915 #-}
   rule1915 = \ ((_expressionImatchIO) :: IO ()) ->
     _expressionImatchIO
   {-# INLINE rule1916 #-}
   rule1916 = \ ((_expressionIpatternMatchWarnings) :: [Warning]) ->
     _expressionIpatternMatchWarnings
   {-# INLINE rule1917 #-}
   rule1917 = \ ((_expressionIuniqueSecondRound) :: Int) ->
     _expressionIuniqueSecondRound
   {-# INLINE rule1918 #-}
   rule1918 = \ ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ->
     _lhsIallPatterns
   {-# INLINE rule1919 #-}
   rule1919 = \ _allTypeSchemes ->
     _allTypeSchemes
   {-# INLINE rule1920 #-}
   rule1920 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule1921 #-}
   rule1921 = \ ((_lhsIavailablePredicates) :: [PredicateWithSource]) ->
     _lhsIavailablePredicates
   {-# INLINE rule1922 #-}
   rule1922 = \ ((_lhsIclassEnvironment) :: ClassEnvironment) ->
     _lhsIclassEnvironment
   {-# INLINE rule1923 #-}
   rule1923 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule1924 #-}
   rule1924 = \ ((_lhsIclassMemberTypeSchemes) :: Maybe [(Name, TpScheme)]) ->
     _lhsIclassMemberTypeSchemes
   {-# INLINE rule1925 #-}
   rule1925 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule1926 #-}
   rule1926 = \ ((_lhsIclassPredicate) :: Maybe (Name, Names)) ->
     _lhsIclassPredicate
   {-# INLINE rule1927 #-}
   rule1927 = \ ((_lhsIclassTypeSchemes) :: M.Map Name TpScheme) ->
     _lhsIclassTypeSchemes
   {-# INLINE rule1928 #-}
   rule1928 = \ ((_lhsIcollectErrors) :: TypeErrors) ->
     _lhsIcollectErrors
   {-# INLINE rule1929 #-}
   rule1929 = \ ((_lhsIcollectWarnings) :: Warnings) ->
     _lhsIcollectWarnings
   {-# INLINE rule1930 #-}
   rule1930 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule1931 #-}
   rule1931 = \ ((_lhsIcurClassPred) :: Maybe Predicate) ->
     _lhsIcurClassPred
   {-# INLINE rule1932 #-}
   rule1932 = \ ((_lhsIcurPred) :: Maybe Predicate) ->
     _lhsIcurPred
   {-# INLINE rule1933 #-}
   rule1933 = \ ((_lhsIcurrentChunk) :: Int) ->
     _lhsIcurrentChunk
   {-# INLINE rule1934 #-}
   rule1934 = \ ((_lhsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _lhsIdictionaryEnvironment
   {-# INLINE rule1935 #-}
   rule1935 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule1936 #-}
   rule1936 = \ _inheritedBDG ->
     _inheritedBDG
   {-# INLINE rule1937 #-}
   rule1937 = \ ((_lhsIinstanceName) :: Maybe Name) ->
     _lhsIinstanceName
   {-# INLINE rule1938 #-}
   rule1938 = \ ((_lhsIinstanceTypes) :: [(Name, TpScheme)]) ->
     _lhsIinstanceTypes
   {-# INLINE rule1939 #-}
   rule1939 = \ _isTopLevel ->
     _isTopLevel
   {-# INLINE rule1940 #-}
   rule1940 = \ ((_lhsImatchIO) :: IO ()) ->
     _lhsImatchIO
   {-# INLINE rule1941 #-}
   rule1941 = \ ((_lhsImoduleName) :: Maybe Name) ->
     _lhsImoduleName
   {-# INLINE rule1942 #-}
   rule1942 = \ _moduleQual ->
     _moduleQual
   {-# INLINE rule1943 #-}
   rule1943 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule1944 #-}
   rule1944 = \ _namesInScope ->
     _namesInScope
   {-# INLINE rule1945 #-}
   rule1945 = \ ((_lhsIorderedTypeSynonyms) :: OrderedTypeSynonyms) ->
     _lhsIorderedTypeSynonyms
   {-# INLINE rule1946 #-}
   rule1946 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule1947 #-}
   rule1947 = \ ((_lhsIrequiredPredicates) :: Predicates) ->
     _lhsIrequiredPredicates
   {-# INLINE rule1948 #-}
   rule1948 = \ ((_lhsIsubstitution) :: FixpointSubstitution) ->
     _lhsIsubstitution
   {-# INLINE rule1949 #-}
   rule1949 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
   {-# INLINE rule1950 #-}
   rule1950 = \ ((_lhsItypeschemeMap) :: M.Map Int (Scheme Predicates)) ->
     _lhsItypeschemeMap
   {-# INLINE rule1951 #-}
   rule1951 = \ ((_lhsIuniqueChunk) :: Int) ->
     _lhsIuniqueChunk
   {-# INLINE rule1952 #-}
   rule1952 = \ ((_lhsIvariableMapping) :: Maybe [(Name, Tp)]) ->
     _lhsIvariableMapping
   {-# INLINE rule1953 #-}
   rule1953 = \ ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ->
     _lhsIallPatterns
   {-# INLINE rule1954 #-}
   rule1954 = \ _allTypeSchemes ->
     _allTypeSchemes
   {-# INLINE rule1955 #-}
   rule1955 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule1956 #-}
   rule1956 = \ ((_lhsIavailablePredicates) :: [PredicateWithSource]) ->
     _lhsIavailablePredicates
   {-# INLINE rule1957 #-}
   rule1957 = \ ((_declarationsIbetaUnique) :: Int) ->
     _declarationsIbetaUnique
   {-# INLINE rule1958 #-}
   rule1958 = \ ((_lhsIclassEnvironment) :: ClassEnvironment) ->
     _lhsIclassEnvironment
   {-# INLINE rule1959 #-}
   rule1959 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule1960 #-}
   rule1960 = \ ((_lhsIclassMemberTypeSchemes) :: Maybe [(Name, TpScheme)]) ->
     _lhsIclassMemberTypeSchemes
   {-# INLINE rule1961 #-}
   rule1961 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule1962 #-}
   rule1962 = \ ((_lhsIclassPredicate) :: Maybe (Name, Names)) ->
     _lhsIclassPredicate
   {-# INLINE rule1963 #-}
   rule1963 = \ ((_lhsIclassTypeSchemes) :: M.Map Name TpScheme) ->
     _lhsIclassTypeSchemes
   {-# INLINE rule1964 #-}
   rule1964 = \ ((_declarationsIcollectErrors) :: TypeErrors) ->
     _declarationsIcollectErrors
   {-# INLINE rule1965 #-}
   rule1965 = \ ((_declarationsIcollectWarnings) :: Warnings) ->
     _declarationsIcollectWarnings
   {-# INLINE rule1966 #-}
   rule1966 = \ ((_declarationsIcounter) :: Int) ->
     _declarationsIcounter
   {-# INLINE rule1967 #-}
   rule1967 = \ ((_lhsIcurClassPred) :: Maybe Predicate) ->
     _lhsIcurClassPred
   {-# INLINE rule1968 #-}
   rule1968 = \ ((_lhsIcurPred) :: Maybe Predicate) ->
     _lhsIcurPred
   {-# INLINE rule1969 #-}
   rule1969 = \ ((_lhsIcurrentChunk) :: Int) ->
     _lhsIcurrentChunk
   {-# INLINE rule1970 #-}
   rule1970 = \ ((_declarationsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _declarationsIdictionaryEnvironment
   {-# INLINE rule1971 #-}
   rule1971 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule1972 #-}
   rule1972 = \ ((_lhsIinstanceName) :: Maybe Name) ->
     _lhsIinstanceName
   {-# INLINE rule1973 #-}
   rule1973 = \ ((_lhsIinstanceTypes) :: [(Name, TpScheme)]) ->
     _lhsIinstanceTypes
   {-# INLINE rule1974 #-}
   rule1974 = \ ((_declarationsImatchIO) :: IO ()) ->
     _declarationsImatchIO
   {-# INLINE rule1975 #-}
   rule1975 = \ ((_lhsImoduleName) :: Maybe Name) ->
     _lhsImoduleName
   {-# INLINE rule1976 #-}
   rule1976 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule1977 #-}
   rule1977 = \ _namesInScope ->
     _namesInScope
   {-# INLINE rule1978 #-}
   rule1978 = \ ((_lhsIorderedTypeSynonyms) :: OrderedTypeSynonyms) ->
     _lhsIorderedTypeSynonyms
   {-# INLINE rule1979 #-}
   rule1979 = \ ((_declarationsIpatternMatchWarnings) :: [Warning]) ->
     _declarationsIpatternMatchWarnings
   {-# INLINE rule1980 #-}
   rule1980 = \ ((_lhsIrequiredPredicates) :: Predicates) ->
     _lhsIrequiredPredicates
   {-# INLINE rule1981 #-}
   rule1981 = \ ((_lhsIsubstitution) :: FixpointSubstitution) ->
     _lhsIsubstitution
   {-# INLINE rule1982 #-}
   rule1982 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
   {-# INLINE rule1983 #-}
   rule1983 = \ ((_lhsItypeschemeMap) :: M.Map Int (Scheme Predicates)) ->
     _lhsItypeschemeMap
   {-# INLINE rule1984 #-}
   rule1984 = \ ((_declarationsIuniqueChunk) :: Int) ->
     _declarationsIuniqueChunk
   {-# INLINE rule1985 #-}
   rule1985 = \ ((_lhsIuniqueSecondRound) :: Int) ->
     _lhsIuniqueSecondRound
   {-# INLINE rule1986 #-}
   rule1986 = \ ((_lhsIvariableMapping) :: Maybe [(Name, Tp)]) ->
     _lhsIvariableMapping
{-# NOINLINE sem_Expression_Do #-}
sem_Expression_Do :: T_Range  -> T_Statements  -> T_Expression 
sem_Expression_Do arg_range_ arg_statements_ = T_Expression (return st41) where
   {-# NOINLINE st41 #-}
   !st41 = let
      v40 :: T_Expression_v40 
      v40 = \ !(T_Expression_vIn40 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItryPatterns _lhsItypeConstructors _lhsItypeschemeMap _lhsIuniqueChunk _lhsIuniqueSecondRound _lhsIvariableMapping) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _statementsX158 = Control.Monad.Identity.runIdentity (attach_T_Statements (arg_statements_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_Statements_vOut157 _statementsIassumptions _statementsIbetaUnique _statementsIcollectErrors _statementsIcollectInstances _statementsIcollectWarnings _statementsIconstraints _statementsIcounter _statementsIdictionaryEnvironment _statementsIgeneratorBeta _statementsIinfoTrees _statementsImatchIO _statementsInamesInScope _statementsIpatternMatchWarnings _statementsIself _statementsIunboundNames _statementsIuniqueChunk _statementsIuniqueSecondRound) = inv_Statements_s158 _statementsX158 (T_Statements_vIn157 _statementsOallPatterns _statementsOallTypeSchemes _statementsOambiguousConflicts _statementsOassumptions _statementsOavailablePredicates _statementsObetaUnique _statementsOclassEnvironment _statementsOclassMemberEnv _statementsOclassMemberTypeSchemes _statementsOclassNamesEnv _statementsOclassPredicate _statementsOclassTypeSchemes _statementsOcollectErrors _statementsOcollectWarnings _statementsOconstraints _statementsOcounter _statementsOcurClassPred _statementsOcurPred _statementsOcurrentChunk _statementsOdictionaryEnvironment _statementsOgeneratorBeta _statementsOimportEnvironment _statementsOinstanceName _statementsOinstanceTypes _statementsOmatchIO _statementsOmoduleName _statementsOmonadBeta _statementsOmonos _statementsOnamesInScope _statementsOorderedTypeSynonyms _statementsOparentTree _statementsOpatternMatchWarnings _statementsOrequiredPredicates _statementsOsubstitution _statementsOtypeConstructors _statementsOtypeschemeMap _statementsOunboundNames _statementsOuniqueChunk _statementsOuniqueSecondRound _statementsOvariableMapping)
         _lhsOmatches :: [Maybe MetaVariableTable]
         _lhsOmatches = rule1987 _assumptions _constraints _lhsItryPatterns _localInfo
         _statementsOunboundNames = rule1988  ()
         _parentTree = rule1989 _lhsIparentTree _localInfo _statementsIinfoTrees
         _lhsOinfoTree :: InfoTree
         _lhsOinfoTree = rule1990 _parentTree
         _localInfo = rule1991 _beta _lhsImonos _self
         _cinfo = rule1992 _parentTree
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule1993 _newDEnv
         _usedAsType = rule1994 _beta _lhsIsubstitution
         _usedAsMonad = rule1995 _betaMonad _lhsIsubstitution
         _requiredDictionaries = rule1996 _lhsIimportEnvironment _lhsIsubstitution _monadBeta _usedAsType
         _localName = rule1997 _rangeIself
         _newDEnv = rule1998 _lhsIavailablePredicates _lhsIclassEnvironment _lhsIcurPred _lhsIinstanceName _lhsIsubstitution _localName _requiredDictionaries _statementsIdictionaryEnvironment
         _lhsOconstraints :: ConstraintSet
         _lhsOconstraints = rule1999 _newcon _statementsIconstraints
         _statementsObetaUnique = rule2000 _lhsIbetaUnique
         _statementsOgeneratorBeta = rule2001  ()
         _statementsOassumptions = rule2002  ()
         _statementsOmonadBeta = rule2003 _betaMonad
         _assumptions = rule2004 _statementsIassumptions
         _constraints = rule2005  ()
         _beta = rule2006 _lhsIbetaUnique
         _betaMonad = rule2007 _lhsIbetaUnique
         _betaVar = rule2008 _lhsIbetaUnique
         _betaReturn = rule2009 _lhsIbetaUnique
         _monadPredicate = rule2010 _betaMonad
         _monadType = rule2011 _betaMonad _betaVar
         _monadBeta = rule2012 _monadPredicate _monadType
         _newcon = rule2013 _beta _cinfo _monadBeta _statementsIgeneratorBeta
         _lhsOcollectInstances :: [(Name, Instance)]
         _lhsOcollectInstances = rule2014 _statementsIcollectInstances
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule2015 _statementsIunboundNames
         _self = rule2016 _rangeIself _statementsIself
         _lhsOself :: Expression
         _lhsOself = rule2017 _self
         _lhsOassumptions :: Assumptions
         _lhsOassumptions = rule2018 _assumptions
         _lhsObeta :: Tp
         _lhsObeta = rule2019 _beta
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule2020 _statementsIbetaUnique
         _lhsOcollectErrors :: TypeErrors
         _lhsOcollectErrors = rule2021 _statementsIcollectErrors
         _lhsOcollectWarnings :: Warnings
         _lhsOcollectWarnings = rule2022 _statementsIcollectWarnings
         _lhsOcounter :: Int
         _lhsOcounter = rule2023 _statementsIcounter
         _lhsOmatchIO :: IO ()
         _lhsOmatchIO = rule2024 _statementsImatchIO
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule2025 _statementsIpatternMatchWarnings
         _lhsOuniqueChunk :: Int
         _lhsOuniqueChunk = rule2026 _statementsIuniqueChunk
         _lhsOuniqueSecondRound :: Int
         _lhsOuniqueSecondRound = rule2027 _statementsIuniqueSecondRound
         _statementsOallPatterns = rule2028 _lhsIallPatterns
         _statementsOallTypeSchemes = rule2029 _lhsIallTypeSchemes
         _statementsOambiguousConflicts = rule2030 _lhsIambiguousConflicts
         _statementsOavailablePredicates = rule2031 _lhsIavailablePredicates
         _statementsOclassEnvironment = rule2032 _lhsIclassEnvironment
         _statementsOclassMemberEnv = rule2033 _lhsIclassMemberEnv
         _statementsOclassMemberTypeSchemes = rule2034 _lhsIclassMemberTypeSchemes
         _statementsOclassNamesEnv = rule2035 _lhsIclassNamesEnv
         _statementsOclassPredicate = rule2036 _lhsIclassPredicate
         _statementsOclassTypeSchemes = rule2037 _lhsIclassTypeSchemes
         _statementsOcollectErrors = rule2038 _lhsIcollectErrors
         _statementsOcollectWarnings = rule2039 _lhsIcollectWarnings
         _statementsOconstraints = rule2040 _constraints
         _statementsOcounter = rule2041 _lhsIcounter
         _statementsOcurClassPred = rule2042 _lhsIcurClassPred
         _statementsOcurPred = rule2043 _lhsIcurPred
         _statementsOcurrentChunk = rule2044 _lhsIcurrentChunk
         _statementsOdictionaryEnvironment = rule2045 _lhsIdictionaryEnvironment
         _statementsOimportEnvironment = rule2046 _lhsIimportEnvironment
         _statementsOinstanceName = rule2047 _lhsIinstanceName
         _statementsOinstanceTypes = rule2048 _lhsIinstanceTypes
         _statementsOmatchIO = rule2049 _lhsImatchIO
         _statementsOmoduleName = rule2050 _lhsImoduleName
         _statementsOmonos = rule2051 _lhsImonos
         _statementsOnamesInScope = rule2052 _lhsInamesInScope
         _statementsOorderedTypeSynonyms = rule2053 _lhsIorderedTypeSynonyms
         _statementsOparentTree = rule2054 _parentTree
         _statementsOpatternMatchWarnings = rule2055 _lhsIpatternMatchWarnings
         _statementsOrequiredPredicates = rule2056 _lhsIrequiredPredicates
         _statementsOsubstitution = rule2057 _lhsIsubstitution
         _statementsOtypeConstructors = rule2058 _lhsItypeConstructors
         _statementsOtypeschemeMap = rule2059 _lhsItypeschemeMap
         _statementsOuniqueChunk = rule2060 _lhsIuniqueChunk
         _statementsOuniqueSecondRound = rule2061 _lhsIuniqueSecondRound
         _statementsOvariableMapping = rule2062 _lhsIvariableMapping
         !__result_ = T_Expression_vOut40 _lhsOassumptions _lhsObeta _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraints _lhsOcounter _lhsOdictionaryEnvironment _lhsOinfoTree _lhsOmatchIO _lhsOmatches _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOuniqueSecondRound
         in __result_ )
     in C_Expression_s41 v40
   {-# INLINE rule1987 #-}
   rule1987 = \ _assumptions _constraints ((_lhsItryPatterns) :: [(Expression     , [String])]) _localInfo ->
            let infoTuple = metaVarInfo _constraints _assumptions _localInfo
            in matchOnlyVariable infoTuple _lhsItryPatterns
   {-# INLINE rule1988 #-}
   rule1988 = \  (_ :: ()) ->
                                      []
   {-# INLINE rule1989 #-}
   rule1989 = \ ((_lhsIparentTree) :: InfoTree) _localInfo ((_statementsIinfoTrees) :: InfoTrees) ->
                            node _lhsIparentTree _localInfo _statementsIinfoTrees
   {-# INLINE rule1990 #-}
   rule1990 = \ _parentTree ->
                            _parentTree
   {-# INLINE rule1991 #-}
   rule1991 = \ _beta ((_lhsImonos) :: Monos) _self ->
                            LocalInfo { self = UHA_Expr _self
                                      , assignedType = Just _beta
                                      , monos = _lhsImonos
                                      }
   {-# INLINE rule1992 #-}
   rule1992 = \ _parentTree ->
     resultConstraint "do-expression" _parentTree
        [ FolkloreConstraint ]
   {-# INLINE rule1993 #-}
   rule1993 = \ _newDEnv ->
                                            _newDEnv
   {-# INLINE rule1994 #-}
   rule1994 = \ _beta ((_lhsIsubstitution) :: FixpointSubstitution) ->
                                            _lhsIsubstitution |-> _beta
   {-# INLINE rule1995 #-}
   rule1995 = \ _betaMonad ((_lhsIsubstitution) :: FixpointSubstitution) ->
                                            _lhsIsubstitution |-> _betaMonad
   {-# INLINE rule1996 #-}
   rule1996 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ((_lhsIsubstitution) :: FixpointSubstitution) _monadBeta _usedAsType ->
                                            map PredicateFunction $ getRequiredDictionaries
                                                (getOrderedTypeSynonyms _lhsIimportEnvironment)
                                                (_lhsIsubstitution |-> _usedAsType)
                                                (_lhsIsubstitution |-> _monadBeta)
   {-# INLINE rule1997 #-}
   rule1997 = \ ((_rangeIself) :: Range) ->
                                            setNameRange (nameFromString $ "do-" ++ show _rangeIself) _rangeIself
   {-# INLINE rule1998 #-}
   rule1998 = \ ((_lhsIavailablePredicates) :: [PredicateWithSource]) ((_lhsIclassEnvironment) :: ClassEnvironment) ((_lhsIcurPred) :: Maybe Predicate) ((_lhsIinstanceName) :: Maybe Name) ((_lhsIsubstitution) :: FixpointSubstitution) _localName _requiredDictionaries ((_statementsIdictionaryEnvironment) :: DictionaryEnvironment) ->
                                            resolveOverloading (_lhsIclassEnvironment)  _localName
                                                                (_lhsIsubstitution |-> _lhsIavailablePredicates)
                                                                (_lhsIsubstitution |-> _requiredDictionaries)
                                                                (fmap getNameName _lhsIinstanceName)
                                                                _lhsIcurPred
                                                                _statementsIdictionaryEnvironment
   {-# INLINE rule1999 #-}
   rule1999 = \ _newcon ((_statementsIconstraints) :: ConstraintSet) ->
                                     Node [ _newcon .<. _statementsIconstraints ]
   {-# INLINE rule2000 #-}
   rule2000 = \ ((_lhsIbetaUnique) :: Int) ->
                                     _lhsIbetaUnique + 4
   {-# INLINE rule2001 #-}
   rule2001 = \  (_ :: ()) ->
                                     Nothing
   {-# INLINE rule2002 #-}
   rule2002 = \  (_ :: ()) ->
                                     noAssumptions
   {-# INLINE rule2003 #-}
   rule2003 = \ _betaMonad ->
                                     _betaMonad
   {-# INLINE rule2004 #-}
   rule2004 = \ ((_statementsIassumptions) :: Assumptions) ->
                                     _statementsIassumptions
   {-# INLINE rule2005 #-}
   rule2005 = \  (_ :: ()) ->
                                     emptyTree
   {-# INLINE rule2006 #-}
   rule2006 = \ ((_lhsIbetaUnique) :: Int) ->
                                     TVar _lhsIbetaUnique
   {-# INLINE rule2007 #-}
   rule2007 = \ ((_lhsIbetaUnique) :: Int) ->
                                     TVar $ _lhsIbetaUnique + 1
   {-# INLINE rule2008 #-}
   rule2008 = \ ((_lhsIbetaUnique) :: Int) ->
                                     TVar $ _lhsIbetaUnique + 2
   {-# INLINE rule2009 #-}
   rule2009 = \ ((_lhsIbetaUnique) :: Int) ->
                                     TVar $ _lhsIbetaUnique + 3
   {-# INLINE rule2010 #-}
   rule2010 = \ _betaMonad ->
                                      Predicate "Prelude.Monad" _betaMonad
   {-# INLINE rule2011 #-}
   rule2011 = \ _betaMonad _betaVar ->
                                     TApp _betaMonad _betaVar
   {-# INLINE rule2012 #-}
   rule2012 = \ _monadPredicate _monadType ->
                                     quantify [] ([_monadPredicate] .=>. _monadType)
   {-# INLINE rule2013 #-}
   rule2013 = \ _beta _cinfo _monadBeta ((_statementsIgeneratorBeta) :: Maybe Tp) ->
                                     case _statementsIgeneratorBeta of
                                        Nothing -> []
                                        Just b  -> [ (b .==. _beta) _cinfo, (_beta .::. _monadBeta) _cinfo ]
   {-# INLINE rule2014 #-}
   rule2014 = \ ((_statementsIcollectInstances) :: [(Name, Instance)]) ->
     _statementsIcollectInstances
   {-# INLINE rule2015 #-}
   rule2015 = \ ((_statementsIunboundNames) :: Names) ->
     _statementsIunboundNames
   {-# INLINE rule2016 #-}
   rule2016 = \ ((_rangeIself) :: Range) ((_statementsIself) :: Statements) ->
     Expression_Do _rangeIself _statementsIself
   {-# INLINE rule2017 #-}
   rule2017 = \ _self ->
     _self
   {-# INLINE rule2018 #-}
   rule2018 = \ _assumptions ->
     _assumptions
   {-# INLINE rule2019 #-}
   rule2019 = \ _beta ->
     _beta
   {-# INLINE rule2020 #-}
   rule2020 = \ ((_statementsIbetaUnique) :: Int) ->
     _statementsIbetaUnique
   {-# INLINE rule2021 #-}
   rule2021 = \ ((_statementsIcollectErrors) :: TypeErrors) ->
     _statementsIcollectErrors
   {-# INLINE rule2022 #-}
   rule2022 = \ ((_statementsIcollectWarnings) :: Warnings) ->
     _statementsIcollectWarnings
   {-# INLINE rule2023 #-}
   rule2023 = \ ((_statementsIcounter) :: Int) ->
     _statementsIcounter
   {-# INLINE rule2024 #-}
   rule2024 = \ ((_statementsImatchIO) :: IO ()) ->
     _statementsImatchIO
   {-# INLINE rule2025 #-}
   rule2025 = \ ((_statementsIpatternMatchWarnings) :: [Warning]) ->
     _statementsIpatternMatchWarnings
   {-# INLINE rule2026 #-}
   rule2026 = \ ((_statementsIuniqueChunk) :: Int) ->
     _statementsIuniqueChunk
   {-# INLINE rule2027 #-}
   rule2027 = \ ((_statementsIuniqueSecondRound) :: Int) ->
     _statementsIuniqueSecondRound
   {-# INLINE rule2028 #-}
   rule2028 = \ ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ->
     _lhsIallPatterns
   {-# INLINE rule2029 #-}
   rule2029 = \ ((_lhsIallTypeSchemes) :: M.Map NameWithRange TpScheme) ->
     _lhsIallTypeSchemes
   {-# INLINE rule2030 #-}
   rule2030 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule2031 #-}
   rule2031 = \ ((_lhsIavailablePredicates) :: [PredicateWithSource]) ->
     _lhsIavailablePredicates
   {-# INLINE rule2032 #-}
   rule2032 = \ ((_lhsIclassEnvironment) :: ClassEnvironment) ->
     _lhsIclassEnvironment
   {-# INLINE rule2033 #-}
   rule2033 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule2034 #-}
   rule2034 = \ ((_lhsIclassMemberTypeSchemes) :: Maybe [(Name, TpScheme)]) ->
     _lhsIclassMemberTypeSchemes
   {-# INLINE rule2035 #-}
   rule2035 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule2036 #-}
   rule2036 = \ ((_lhsIclassPredicate) :: Maybe (Name, Names)) ->
     _lhsIclassPredicate
   {-# INLINE rule2037 #-}
   rule2037 = \ ((_lhsIclassTypeSchemes) :: M.Map Name TpScheme) ->
     _lhsIclassTypeSchemes
   {-# INLINE rule2038 #-}
   rule2038 = \ ((_lhsIcollectErrors) :: TypeErrors) ->
     _lhsIcollectErrors
   {-# INLINE rule2039 #-}
   rule2039 = \ ((_lhsIcollectWarnings) :: Warnings) ->
     _lhsIcollectWarnings
   {-# INLINE rule2040 #-}
   rule2040 = \ _constraints ->
     _constraints
   {-# INLINE rule2041 #-}
   rule2041 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule2042 #-}
   rule2042 = \ ((_lhsIcurClassPred) :: Maybe Predicate) ->
     _lhsIcurClassPred
   {-# INLINE rule2043 #-}
   rule2043 = \ ((_lhsIcurPred) :: Maybe Predicate) ->
     _lhsIcurPred
   {-# INLINE rule2044 #-}
   rule2044 = \ ((_lhsIcurrentChunk) :: Int) ->
     _lhsIcurrentChunk
   {-# INLINE rule2045 #-}
   rule2045 = \ ((_lhsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _lhsIdictionaryEnvironment
   {-# INLINE rule2046 #-}
   rule2046 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule2047 #-}
   rule2047 = \ ((_lhsIinstanceName) :: Maybe Name) ->
     _lhsIinstanceName
   {-# INLINE rule2048 #-}
   rule2048 = \ ((_lhsIinstanceTypes) :: [(Name, TpScheme)]) ->
     _lhsIinstanceTypes
   {-# INLINE rule2049 #-}
   rule2049 = \ ((_lhsImatchIO) :: IO ()) ->
     _lhsImatchIO
   {-# INLINE rule2050 #-}
   rule2050 = \ ((_lhsImoduleName) :: Maybe Name) ->
     _lhsImoduleName
   {-# INLINE rule2051 #-}
   rule2051 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule2052 #-}
   rule2052 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule2053 #-}
   rule2053 = \ ((_lhsIorderedTypeSynonyms) :: OrderedTypeSynonyms) ->
     _lhsIorderedTypeSynonyms
   {-# INLINE rule2054 #-}
   rule2054 = \ _parentTree ->
     _parentTree
   {-# INLINE rule2055 #-}
   rule2055 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule2056 #-}
   rule2056 = \ ((_lhsIrequiredPredicates) :: Predicates) ->
     _lhsIrequiredPredicates
   {-# INLINE rule2057 #-}
   rule2057 = \ ((_lhsIsubstitution) :: FixpointSubstitution) ->
     _lhsIsubstitution
   {-# INLINE rule2058 #-}
   rule2058 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
   {-# INLINE rule2059 #-}
   rule2059 = \ ((_lhsItypeschemeMap) :: M.Map Int (Scheme Predicates)) ->
     _lhsItypeschemeMap
   {-# INLINE rule2060 #-}
   rule2060 = \ ((_lhsIuniqueChunk) :: Int) ->
     _lhsIuniqueChunk
   {-# INLINE rule2061 #-}
   rule2061 = \ ((_lhsIuniqueSecondRound) :: Int) ->
     _lhsIuniqueSecondRound
   {-# INLINE rule2062 #-}
   rule2062 = \ ((_lhsIvariableMapping) :: Maybe [(Name, Tp)]) ->
     _lhsIvariableMapping
{-# NOINLINE sem_Expression_List #-}
sem_Expression_List :: T_Range  -> T_Expressions  -> T_Expression 
sem_Expression_List arg_range_ arg_expressions_ = T_Expression (return st41) where
   {-# NOINLINE st41 #-}
   !st41 = let
      v40 :: T_Expression_v40 
      v40 = \ !(T_Expression_vIn40 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItryPatterns _lhsItypeConstructors _lhsItypeschemeMap _lhsIuniqueChunk _lhsIuniqueSecondRound _lhsIvariableMapping) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _expressionsX44 = Control.Monad.Identity.runIdentity (attach_T_Expressions (arg_expressions_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_Expressions_vOut43 _expressionsIassumptions _expressionsIbetaUnique _expressionsIbetas _expressionsIcollectErrors _expressionsIcollectInstances _expressionsIcollectWarnings _expressionsIconstraintslist _expressionsIcounter _expressionsIdictionaryEnvironment _expressionsIinfoTrees _expressionsImatchIO _expressionsImatches _expressionsIpatternMatchWarnings _expressionsIself _expressionsIunboundNames _expressionsIuniqueChunk _expressionsIuniqueSecondRound) = inv_Expressions_s44 _expressionsX44 (T_Expressions_vIn43 _expressionsOallPatterns _expressionsOallTypeSchemes _expressionsOambiguousConflicts _expressionsOavailablePredicates _expressionsObetaUnique _expressionsOclassEnvironment _expressionsOclassMemberEnv _expressionsOclassMemberTypeSchemes _expressionsOclassNamesEnv _expressionsOclassPredicate _expressionsOclassTypeSchemes _expressionsOcollectErrors _expressionsOcollectWarnings _expressionsOcounter _expressionsOcurClassPred _expressionsOcurPred _expressionsOcurrentChunk _expressionsOdictionaryEnvironment _expressionsOimportEnvironment _expressionsOinstanceName _expressionsOinstanceTypes _expressionsOmatchIO _expressionsOmoduleName _expressionsOmonos _expressionsOnamesInScope _expressionsOorderedTypeSynonyms _expressionsOparentTree _expressionsOpatternMatchWarnings _expressionsOrequiredPredicates _expressionsOsubstitution _expressionsOtryPatterns _expressionsOtypeConstructors _expressionsOtypeschemeMap _expressionsOuniqueChunk _expressionsOuniqueSecondRound _expressionsOvariableMapping)
         _lhsOmatches :: [Maybe MetaVariableTable]
         _lhsOconstraints :: ConstraintSet
         _lhsOassumptions :: Assumptions
         _lhsOuniqueSecondRound :: Int
         (_expressionsOtryPatterns,_lhsOmatches,_lhsOconstraints,_lhsOassumptions,_lhsOuniqueSecondRound,_ioMatch) = rule2063 _constraints _expressionsIassumptions _expressionsImatches _expressionsIuniqueSecondRound _lhsIallPatterns _lhsItryPatterns _localInfo
         _lhsOmatchIO :: IO ()
         _lhsOmatchIO = rule2064 _expressionsImatchIO _ioMatch
         _parentTree = rule2065 _expressionsIinfoTrees _lhsIparentTree _localInfo
         _lhsOinfoTree :: InfoTree
         _lhsOinfoTree = rule2066 _parentTree
         _localInfo = rule2067 _beta _lhsImonos _self
         _cinfoElem = rule2068 _beta' _expressionsIbetas _localInfo _parentTree
         _cinfoResult = rule2069 _parentTree
         _expressionsObetaUnique = rule2070 _lhsIbetaUnique
         _constraints = rule2071 _expressionsIbetas _expressionsIconstraintslist _newcon _zipf
         _beta = rule2072 _lhsIbetaUnique
         _beta' = rule2073 _lhsIbetaUnique
         _newcon = rule2074 _beta _beta' _cinfoResult
         _zipf = rule2075 _beta' _cinfoElem
         _lhsOcollectInstances :: [(Name, Instance)]
         _lhsOcollectInstances = rule2076 _expressionsIcollectInstances
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule2077 _expressionsIunboundNames
         _self = rule2078 _expressionsIself _rangeIself
         _lhsOself :: Expression
         _lhsOself = rule2079 _self
         _lhsObeta :: Tp
         _lhsObeta = rule2080 _beta
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule2081 _expressionsIbetaUnique
         _lhsOcollectErrors :: TypeErrors
         _lhsOcollectErrors = rule2082 _expressionsIcollectErrors
         _lhsOcollectWarnings :: Warnings
         _lhsOcollectWarnings = rule2083 _expressionsIcollectWarnings
         _lhsOcounter :: Int
         _lhsOcounter = rule2084 _expressionsIcounter
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule2085 _expressionsIdictionaryEnvironment
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule2086 _expressionsIpatternMatchWarnings
         _lhsOuniqueChunk :: Int
         _lhsOuniqueChunk = rule2087 _expressionsIuniqueChunk
         _expressionsOallPatterns = rule2088 _lhsIallPatterns
         _expressionsOallTypeSchemes = rule2089 _lhsIallTypeSchemes
         _expressionsOambiguousConflicts = rule2090 _lhsIambiguousConflicts
         _expressionsOavailablePredicates = rule2091 _lhsIavailablePredicates
         _expressionsOclassEnvironment = rule2092 _lhsIclassEnvironment
         _expressionsOclassMemberEnv = rule2093 _lhsIclassMemberEnv
         _expressionsOclassMemberTypeSchemes = rule2094 _lhsIclassMemberTypeSchemes
         _expressionsOclassNamesEnv = rule2095 _lhsIclassNamesEnv
         _expressionsOclassPredicate = rule2096 _lhsIclassPredicate
         _expressionsOclassTypeSchemes = rule2097 _lhsIclassTypeSchemes
         _expressionsOcollectErrors = rule2098 _lhsIcollectErrors
         _expressionsOcollectWarnings = rule2099 _lhsIcollectWarnings
         _expressionsOcounter = rule2100 _lhsIcounter
         _expressionsOcurClassPred = rule2101 _lhsIcurClassPred
         _expressionsOcurPred = rule2102 _lhsIcurPred
         _expressionsOcurrentChunk = rule2103 _lhsIcurrentChunk
         _expressionsOdictionaryEnvironment = rule2104 _lhsIdictionaryEnvironment
         _expressionsOimportEnvironment = rule2105 _lhsIimportEnvironment
         _expressionsOinstanceName = rule2106 _lhsIinstanceName
         _expressionsOinstanceTypes = rule2107 _lhsIinstanceTypes
         _expressionsOmatchIO = rule2108 _lhsImatchIO
         _expressionsOmoduleName = rule2109 _lhsImoduleName
         _expressionsOmonos = rule2110 _lhsImonos
         _expressionsOnamesInScope = rule2111 _lhsInamesInScope
         _expressionsOorderedTypeSynonyms = rule2112 _lhsIorderedTypeSynonyms
         _expressionsOparentTree = rule2113 _parentTree
         _expressionsOpatternMatchWarnings = rule2114 _lhsIpatternMatchWarnings
         _expressionsOrequiredPredicates = rule2115 _lhsIrequiredPredicates
         _expressionsOsubstitution = rule2116 _lhsIsubstitution
         _expressionsOtypeConstructors = rule2117 _lhsItypeConstructors
         _expressionsOtypeschemeMap = rule2118 _lhsItypeschemeMap
         _expressionsOuniqueChunk = rule2119 _lhsIuniqueChunk
         _expressionsOuniqueSecondRound = rule2120 _lhsIuniqueSecondRound
         _expressionsOvariableMapping = rule2121 _lhsIvariableMapping
         !__result_ = T_Expression_vOut40 _lhsOassumptions _lhsObeta _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraints _lhsOcounter _lhsOdictionaryEnvironment _lhsOinfoTree _lhsOmatchIO _lhsOmatches _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOuniqueSecondRound
         in __result_ )
     in C_Expression_s41 v40
   {-# INLINE rule2063 #-}
   rule2063 = \ _constraints ((_expressionsIassumptions) :: Assumptions) ((_expressionsImatches) :: [Maybe MetaVariableTable]) ((_expressionsIuniqueSecondRound) :: Int) ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ((_lhsItryPatterns) :: [(Expression     , [String])]) _localInfo ->
            let infoTuple = metaVarInfo _constraints _expressionsIassumptions _localInfo
            in match1 infoTuple _expressionsIuniqueSecondRound
                      match_Expression_List
                      _lhsItryPatterns _lhsIallPatterns
                      [_expressionsImatches]
   {-# INLINE rule2064 #-}
   rule2064 = \ ((_expressionsImatchIO) :: IO ()) _ioMatch ->
                                       _expressionsImatchIO     >> _ioMatch
   {-# INLINE rule2065 #-}
   rule2065 = \ ((_expressionsIinfoTrees) :: InfoTrees) ((_lhsIparentTree) :: InfoTree) _localInfo ->
                            node _lhsIparentTree _localInfo (_expressionsIinfoTrees)
   {-# INLINE rule2066 #-}
   rule2066 = \ _parentTree ->
                            _parentTree
   {-# INLINE rule2067 #-}
   rule2067 = \ _beta ((_lhsImonos) :: Monos) _self ->
                            LocalInfo { self = UHA_Expr _self
                                      , assignedType = Just _beta
                                      , monos = _lhsImonos
                                      }
   {-# INLINE rule2068 #-}
   rule2068 = \ _beta' ((_expressionsIbetas) :: Tps) _localInfo _parentTree ->
     \elemNr ->
     childConstraint elemNr "element of list" _parentTree $
        [ HasTrustFactor 10.0 | length _expressionsIbetas < 2 ] ++
        [ Unifier (head (ftv _beta')) ("list", _localInfo, ordinal False (elemNr+1) ++ " element") ]
   {-# INLINE rule2069 #-}
   rule2069 = \ _parentTree ->
     resultConstraint "list" _parentTree
     [ FolkloreConstraint ]
   {-# INLINE rule2070 #-}
   rule2070 = \ ((_lhsIbetaUnique) :: Int) ->
                                     _lhsIbetaUnique + 2
   {-# INLINE rule2071 #-}
   rule2071 = \ ((_expressionsIbetas) :: Tps) ((_expressionsIconstraintslist) :: ConstraintSets) _newcon _zipf ->
                                     _newcon .>.
                                      Node (zipWith3 _zipf _expressionsIbetas [0..] _expressionsIconstraintslist)
   {-# INLINE rule2072 #-}
   rule2072 = \ ((_lhsIbetaUnique) :: Int) ->
                                     TVar _lhsIbetaUnique
   {-# INLINE rule2073 #-}
   rule2073 = \ ((_lhsIbetaUnique) :: Int) ->
                                     TVar (_lhsIbetaUnique + 1)
   {-# INLINE rule2074 #-}
   rule2074 = \ _beta _beta' _cinfoResult ->
                                     [ (listType _beta' .==. _beta) _cinfoResult ]
   {-# INLINE rule2075 #-}
   rule2075 = \ _beta' _cinfoElem ->
                                     \tp childNr ctree -> [ (tp .==. _beta') (_cinfoElem childNr) ] .<. ctree
   {-# INLINE rule2076 #-}
   rule2076 = \ ((_expressionsIcollectInstances) :: [(Name, Instance)]) ->
     _expressionsIcollectInstances
   {-# INLINE rule2077 #-}
   rule2077 = \ ((_expressionsIunboundNames) :: Names) ->
     _expressionsIunboundNames
   {-# INLINE rule2078 #-}
   rule2078 = \ ((_expressionsIself) :: Expressions) ((_rangeIself) :: Range) ->
     Expression_List _rangeIself _expressionsIself
   {-# INLINE rule2079 #-}
   rule2079 = \ _self ->
     _self
   {-# INLINE rule2080 #-}
   rule2080 = \ _beta ->
     _beta
   {-# INLINE rule2081 #-}
   rule2081 = \ ((_expressionsIbetaUnique) :: Int) ->
     _expressionsIbetaUnique
   {-# INLINE rule2082 #-}
   rule2082 = \ ((_expressionsIcollectErrors) :: TypeErrors) ->
     _expressionsIcollectErrors
   {-# INLINE rule2083 #-}
   rule2083 = \ ((_expressionsIcollectWarnings) :: Warnings) ->
     _expressionsIcollectWarnings
   {-# INLINE rule2084 #-}
   rule2084 = \ ((_expressionsIcounter) :: Int) ->
     _expressionsIcounter
   {-# INLINE rule2085 #-}
   rule2085 = \ ((_expressionsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _expressionsIdictionaryEnvironment
   {-# INLINE rule2086 #-}
   rule2086 = \ ((_expressionsIpatternMatchWarnings) :: [Warning]) ->
     _expressionsIpatternMatchWarnings
   {-# INLINE rule2087 #-}
   rule2087 = \ ((_expressionsIuniqueChunk) :: Int) ->
     _expressionsIuniqueChunk
   {-# INLINE rule2088 #-}
   rule2088 = \ ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ->
     _lhsIallPatterns
   {-# INLINE rule2089 #-}
   rule2089 = \ ((_lhsIallTypeSchemes) :: M.Map NameWithRange TpScheme) ->
     _lhsIallTypeSchemes
   {-# INLINE rule2090 #-}
   rule2090 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule2091 #-}
   rule2091 = \ ((_lhsIavailablePredicates) :: [PredicateWithSource]) ->
     _lhsIavailablePredicates
   {-# INLINE rule2092 #-}
   rule2092 = \ ((_lhsIclassEnvironment) :: ClassEnvironment) ->
     _lhsIclassEnvironment
   {-# INLINE rule2093 #-}
   rule2093 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule2094 #-}
   rule2094 = \ ((_lhsIclassMemberTypeSchemes) :: Maybe [(Name, TpScheme)]) ->
     _lhsIclassMemberTypeSchemes
   {-# INLINE rule2095 #-}
   rule2095 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule2096 #-}
   rule2096 = \ ((_lhsIclassPredicate) :: Maybe (Name, Names)) ->
     _lhsIclassPredicate
   {-# INLINE rule2097 #-}
   rule2097 = \ ((_lhsIclassTypeSchemes) :: M.Map Name TpScheme) ->
     _lhsIclassTypeSchemes
   {-# INLINE rule2098 #-}
   rule2098 = \ ((_lhsIcollectErrors) :: TypeErrors) ->
     _lhsIcollectErrors
   {-# INLINE rule2099 #-}
   rule2099 = \ ((_lhsIcollectWarnings) :: Warnings) ->
     _lhsIcollectWarnings
   {-# INLINE rule2100 #-}
   rule2100 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule2101 #-}
   rule2101 = \ ((_lhsIcurClassPred) :: Maybe Predicate) ->
     _lhsIcurClassPred
   {-# INLINE rule2102 #-}
   rule2102 = \ ((_lhsIcurPred) :: Maybe Predicate) ->
     _lhsIcurPred
   {-# INLINE rule2103 #-}
   rule2103 = \ ((_lhsIcurrentChunk) :: Int) ->
     _lhsIcurrentChunk
   {-# INLINE rule2104 #-}
   rule2104 = \ ((_lhsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _lhsIdictionaryEnvironment
   {-# INLINE rule2105 #-}
   rule2105 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule2106 #-}
   rule2106 = \ ((_lhsIinstanceName) :: Maybe Name) ->
     _lhsIinstanceName
   {-# INLINE rule2107 #-}
   rule2107 = \ ((_lhsIinstanceTypes) :: [(Name, TpScheme)]) ->
     _lhsIinstanceTypes
   {-# INLINE rule2108 #-}
   rule2108 = \ ((_lhsImatchIO) :: IO ()) ->
     _lhsImatchIO
   {-# INLINE rule2109 #-}
   rule2109 = \ ((_lhsImoduleName) :: Maybe Name) ->
     _lhsImoduleName
   {-# INLINE rule2110 #-}
   rule2110 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule2111 #-}
   rule2111 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule2112 #-}
   rule2112 = \ ((_lhsIorderedTypeSynonyms) :: OrderedTypeSynonyms) ->
     _lhsIorderedTypeSynonyms
   {-# INLINE rule2113 #-}
   rule2113 = \ _parentTree ->
     _parentTree
   {-# INLINE rule2114 #-}
   rule2114 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule2115 #-}
   rule2115 = \ ((_lhsIrequiredPredicates) :: Predicates) ->
     _lhsIrequiredPredicates
   {-# INLINE rule2116 #-}
   rule2116 = \ ((_lhsIsubstitution) :: FixpointSubstitution) ->
     _lhsIsubstitution
   {-# INLINE rule2117 #-}
   rule2117 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
   {-# INLINE rule2118 #-}
   rule2118 = \ ((_lhsItypeschemeMap) :: M.Map Int (Scheme Predicates)) ->
     _lhsItypeschemeMap
   {-# INLINE rule2119 #-}
   rule2119 = \ ((_lhsIuniqueChunk) :: Int) ->
     _lhsIuniqueChunk
   {-# INLINE rule2120 #-}
   rule2120 = \ ((_lhsIuniqueSecondRound) :: Int) ->
     _lhsIuniqueSecondRound
   {-# INLINE rule2121 #-}
   rule2121 = \ ((_lhsIvariableMapping) :: Maybe [(Name, Tp)]) ->
     _lhsIvariableMapping
{-# NOINLINE sem_Expression_Tuple #-}
sem_Expression_Tuple :: T_Range  -> T_Expressions  -> T_Expression 
sem_Expression_Tuple arg_range_ arg_expressions_ = T_Expression (return st41) where
   {-# NOINLINE st41 #-}
   !st41 = let
      v40 :: T_Expression_v40 
      v40 = \ !(T_Expression_vIn40 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItryPatterns _lhsItypeConstructors _lhsItypeschemeMap _lhsIuniqueChunk _lhsIuniqueSecondRound _lhsIvariableMapping) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _expressionsX44 = Control.Monad.Identity.runIdentity (attach_T_Expressions (arg_expressions_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_Expressions_vOut43 _expressionsIassumptions _expressionsIbetaUnique _expressionsIbetas _expressionsIcollectErrors _expressionsIcollectInstances _expressionsIcollectWarnings _expressionsIconstraintslist _expressionsIcounter _expressionsIdictionaryEnvironment _expressionsIinfoTrees _expressionsImatchIO _expressionsImatches _expressionsIpatternMatchWarnings _expressionsIself _expressionsIunboundNames _expressionsIuniqueChunk _expressionsIuniqueSecondRound) = inv_Expressions_s44 _expressionsX44 (T_Expressions_vIn43 _expressionsOallPatterns _expressionsOallTypeSchemes _expressionsOambiguousConflicts _expressionsOavailablePredicates _expressionsObetaUnique _expressionsOclassEnvironment _expressionsOclassMemberEnv _expressionsOclassMemberTypeSchemes _expressionsOclassNamesEnv _expressionsOclassPredicate _expressionsOclassTypeSchemes _expressionsOcollectErrors _expressionsOcollectWarnings _expressionsOcounter _expressionsOcurClassPred _expressionsOcurPred _expressionsOcurrentChunk _expressionsOdictionaryEnvironment _expressionsOimportEnvironment _expressionsOinstanceName _expressionsOinstanceTypes _expressionsOmatchIO _expressionsOmoduleName _expressionsOmonos _expressionsOnamesInScope _expressionsOorderedTypeSynonyms _expressionsOparentTree _expressionsOpatternMatchWarnings _expressionsOrequiredPredicates _expressionsOsubstitution _expressionsOtryPatterns _expressionsOtypeConstructors _expressionsOtypeschemeMap _expressionsOuniqueChunk _expressionsOuniqueSecondRound _expressionsOvariableMapping)
         _lhsOmatches :: [Maybe MetaVariableTable]
         _lhsOconstraints :: ConstraintSet
         _lhsOassumptions :: Assumptions
         _lhsOuniqueSecondRound :: Int
         (_expressionsOtryPatterns,_lhsOmatches,_lhsOconstraints,_lhsOassumptions,_lhsOuniqueSecondRound,_ioMatch) = rule2122 _constraints _expressionsIassumptions _expressionsImatches _expressionsIuniqueSecondRound _lhsIallPatterns _lhsItryPatterns _localInfo
         _lhsOmatchIO :: IO ()
         _lhsOmatchIO = rule2123 _expressionsImatchIO _ioMatch
         _parentTree = rule2124 _expressionsIinfoTrees _lhsIparentTree _localInfo
         _lhsOinfoTree :: InfoTree
         _lhsOinfoTree = rule2125 _parentTree
         _localInfo = rule2126 _beta _lhsImonos _self
         _cinfo = rule2127 _parentTree
         _expressionsObetaUnique = rule2128 _lhsIbetaUnique
         _constraints = rule2129 _expressionsIconstraintslist _newcon
         _beta = rule2130 _lhsIbetaUnique
         _newcon = rule2131 _beta _cinfo _expressionsIbetas
         _lhsOcollectInstances :: [(Name, Instance)]
         _lhsOcollectInstances = rule2132 _expressionsIcollectInstances
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule2133 _expressionsIunboundNames
         _self = rule2134 _expressionsIself _rangeIself
         _lhsOself :: Expression
         _lhsOself = rule2135 _self
         _lhsObeta :: Tp
         _lhsObeta = rule2136 _beta
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule2137 _expressionsIbetaUnique
         _lhsOcollectErrors :: TypeErrors
         _lhsOcollectErrors = rule2138 _expressionsIcollectErrors
         _lhsOcollectWarnings :: Warnings
         _lhsOcollectWarnings = rule2139 _expressionsIcollectWarnings
         _lhsOcounter :: Int
         _lhsOcounter = rule2140 _expressionsIcounter
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule2141 _expressionsIdictionaryEnvironment
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule2142 _expressionsIpatternMatchWarnings
         _lhsOuniqueChunk :: Int
         _lhsOuniqueChunk = rule2143 _expressionsIuniqueChunk
         _expressionsOallPatterns = rule2144 _lhsIallPatterns
         _expressionsOallTypeSchemes = rule2145 _lhsIallTypeSchemes
         _expressionsOambiguousConflicts = rule2146 _lhsIambiguousConflicts
         _expressionsOavailablePredicates = rule2147 _lhsIavailablePredicates
         _expressionsOclassEnvironment = rule2148 _lhsIclassEnvironment
         _expressionsOclassMemberEnv = rule2149 _lhsIclassMemberEnv
         _expressionsOclassMemberTypeSchemes = rule2150 _lhsIclassMemberTypeSchemes
         _expressionsOclassNamesEnv = rule2151 _lhsIclassNamesEnv
         _expressionsOclassPredicate = rule2152 _lhsIclassPredicate
         _expressionsOclassTypeSchemes = rule2153 _lhsIclassTypeSchemes
         _expressionsOcollectErrors = rule2154 _lhsIcollectErrors
         _expressionsOcollectWarnings = rule2155 _lhsIcollectWarnings
         _expressionsOcounter = rule2156 _lhsIcounter
         _expressionsOcurClassPred = rule2157 _lhsIcurClassPred
         _expressionsOcurPred = rule2158 _lhsIcurPred
         _expressionsOcurrentChunk = rule2159 _lhsIcurrentChunk
         _expressionsOdictionaryEnvironment = rule2160 _lhsIdictionaryEnvironment
         _expressionsOimportEnvironment = rule2161 _lhsIimportEnvironment
         _expressionsOinstanceName = rule2162 _lhsIinstanceName
         _expressionsOinstanceTypes = rule2163 _lhsIinstanceTypes
         _expressionsOmatchIO = rule2164 _lhsImatchIO
         _expressionsOmoduleName = rule2165 _lhsImoduleName
         _expressionsOmonos = rule2166 _lhsImonos
         _expressionsOnamesInScope = rule2167 _lhsInamesInScope
         _expressionsOorderedTypeSynonyms = rule2168 _lhsIorderedTypeSynonyms
         _expressionsOparentTree = rule2169 _parentTree
         _expressionsOpatternMatchWarnings = rule2170 _lhsIpatternMatchWarnings
         _expressionsOrequiredPredicates = rule2171 _lhsIrequiredPredicates
         _expressionsOsubstitution = rule2172 _lhsIsubstitution
         _expressionsOtypeConstructors = rule2173 _lhsItypeConstructors
         _expressionsOtypeschemeMap = rule2174 _lhsItypeschemeMap
         _expressionsOuniqueChunk = rule2175 _lhsIuniqueChunk
         _expressionsOuniqueSecondRound = rule2176 _lhsIuniqueSecondRound
         _expressionsOvariableMapping = rule2177 _lhsIvariableMapping
         !__result_ = T_Expression_vOut40 _lhsOassumptions _lhsObeta _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraints _lhsOcounter _lhsOdictionaryEnvironment _lhsOinfoTree _lhsOmatchIO _lhsOmatches _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOuniqueSecondRound
         in __result_ )
     in C_Expression_s41 v40
   {-# INLINE rule2122 #-}
   rule2122 = \ _constraints ((_expressionsIassumptions) :: Assumptions) ((_expressionsImatches) :: [Maybe MetaVariableTable]) ((_expressionsIuniqueSecondRound) :: Int) ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ((_lhsItryPatterns) :: [(Expression     , [String])]) _localInfo ->
            let infoTuple = metaVarInfo _constraints _expressionsIassumptions _localInfo
            in match1 infoTuple _expressionsIuniqueSecondRound
                      match_Expression_Tuple
                      _lhsItryPatterns _lhsIallPatterns
                      [_expressionsImatches]
   {-# INLINE rule2123 #-}
   rule2123 = \ ((_expressionsImatchIO) :: IO ()) _ioMatch ->
                                       _expressionsImatchIO     >> _ioMatch
   {-# INLINE rule2124 #-}
   rule2124 = \ ((_expressionsIinfoTrees) :: InfoTrees) ((_lhsIparentTree) :: InfoTree) _localInfo ->
                            node _lhsIparentTree _localInfo (_expressionsIinfoTrees)
   {-# INLINE rule2125 #-}
   rule2125 = \ _parentTree ->
                            _parentTree
   {-# INLINE rule2126 #-}
   rule2126 = \ _beta ((_lhsImonos) :: Monos) _self ->
                            LocalInfo { self = UHA_Expr _self
                                      , assignedType = Just _beta
                                      , monos = _lhsImonos
                                      }
   {-# INLINE rule2127 #-}
   rule2127 = \ _parentTree ->
     resultConstraint "tuple" _parentTree
        [ FolkloreConstraint ]
   {-# INLINE rule2128 #-}
   rule2128 = \ ((_lhsIbetaUnique) :: Int) ->
                                    _lhsIbetaUnique + 1
   {-# INLINE rule2129 #-}
   rule2129 = \ ((_expressionsIconstraintslist) :: ConstraintSets) _newcon ->
                                    _newcon .>. Node _expressionsIconstraintslist
   {-# INLINE rule2130 #-}
   rule2130 = \ ((_lhsIbetaUnique) :: Int) ->
                                    TVar _lhsIbetaUnique
   {-# INLINE rule2131 #-}
   rule2131 = \ _beta _cinfo ((_expressionsIbetas) :: Tps) ->
                                    [ (tupleType _expressionsIbetas .==. _beta) _cinfo ]
   {-# INLINE rule2132 #-}
   rule2132 = \ ((_expressionsIcollectInstances) :: [(Name, Instance)]) ->
     _expressionsIcollectInstances
   {-# INLINE rule2133 #-}
   rule2133 = \ ((_expressionsIunboundNames) :: Names) ->
     _expressionsIunboundNames
   {-# INLINE rule2134 #-}
   rule2134 = \ ((_expressionsIself) :: Expressions) ((_rangeIself) :: Range) ->
     Expression_Tuple _rangeIself _expressionsIself
   {-# INLINE rule2135 #-}
   rule2135 = \ _self ->
     _self
   {-# INLINE rule2136 #-}
   rule2136 = \ _beta ->
     _beta
   {-# INLINE rule2137 #-}
   rule2137 = \ ((_expressionsIbetaUnique) :: Int) ->
     _expressionsIbetaUnique
   {-# INLINE rule2138 #-}
   rule2138 = \ ((_expressionsIcollectErrors) :: TypeErrors) ->
     _expressionsIcollectErrors
   {-# INLINE rule2139 #-}
   rule2139 = \ ((_expressionsIcollectWarnings) :: Warnings) ->
     _expressionsIcollectWarnings
   {-# INLINE rule2140 #-}
   rule2140 = \ ((_expressionsIcounter) :: Int) ->
     _expressionsIcounter
   {-# INLINE rule2141 #-}
   rule2141 = \ ((_expressionsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _expressionsIdictionaryEnvironment
   {-# INLINE rule2142 #-}
   rule2142 = \ ((_expressionsIpatternMatchWarnings) :: [Warning]) ->
     _expressionsIpatternMatchWarnings
   {-# INLINE rule2143 #-}
   rule2143 = \ ((_expressionsIuniqueChunk) :: Int) ->
     _expressionsIuniqueChunk
   {-# INLINE rule2144 #-}
   rule2144 = \ ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ->
     _lhsIallPatterns
   {-# INLINE rule2145 #-}
   rule2145 = \ ((_lhsIallTypeSchemes) :: M.Map NameWithRange TpScheme) ->
     _lhsIallTypeSchemes
   {-# INLINE rule2146 #-}
   rule2146 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule2147 #-}
   rule2147 = \ ((_lhsIavailablePredicates) :: [PredicateWithSource]) ->
     _lhsIavailablePredicates
   {-# INLINE rule2148 #-}
   rule2148 = \ ((_lhsIclassEnvironment) :: ClassEnvironment) ->
     _lhsIclassEnvironment
   {-# INLINE rule2149 #-}
   rule2149 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule2150 #-}
   rule2150 = \ ((_lhsIclassMemberTypeSchemes) :: Maybe [(Name, TpScheme)]) ->
     _lhsIclassMemberTypeSchemes
   {-# INLINE rule2151 #-}
   rule2151 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule2152 #-}
   rule2152 = \ ((_lhsIclassPredicate) :: Maybe (Name, Names)) ->
     _lhsIclassPredicate
   {-# INLINE rule2153 #-}
   rule2153 = \ ((_lhsIclassTypeSchemes) :: M.Map Name TpScheme) ->
     _lhsIclassTypeSchemes
   {-# INLINE rule2154 #-}
   rule2154 = \ ((_lhsIcollectErrors) :: TypeErrors) ->
     _lhsIcollectErrors
   {-# INLINE rule2155 #-}
   rule2155 = \ ((_lhsIcollectWarnings) :: Warnings) ->
     _lhsIcollectWarnings
   {-# INLINE rule2156 #-}
   rule2156 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule2157 #-}
   rule2157 = \ ((_lhsIcurClassPred) :: Maybe Predicate) ->
     _lhsIcurClassPred
   {-# INLINE rule2158 #-}
   rule2158 = \ ((_lhsIcurPred) :: Maybe Predicate) ->
     _lhsIcurPred
   {-# INLINE rule2159 #-}
   rule2159 = \ ((_lhsIcurrentChunk) :: Int) ->
     _lhsIcurrentChunk
   {-# INLINE rule2160 #-}
   rule2160 = \ ((_lhsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _lhsIdictionaryEnvironment
   {-# INLINE rule2161 #-}
   rule2161 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule2162 #-}
   rule2162 = \ ((_lhsIinstanceName) :: Maybe Name) ->
     _lhsIinstanceName
   {-# INLINE rule2163 #-}
   rule2163 = \ ((_lhsIinstanceTypes) :: [(Name, TpScheme)]) ->
     _lhsIinstanceTypes
   {-# INLINE rule2164 #-}
   rule2164 = \ ((_lhsImatchIO) :: IO ()) ->
     _lhsImatchIO
   {-# INLINE rule2165 #-}
   rule2165 = \ ((_lhsImoduleName) :: Maybe Name) ->
     _lhsImoduleName
   {-# INLINE rule2166 #-}
   rule2166 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule2167 #-}
   rule2167 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule2168 #-}
   rule2168 = \ ((_lhsIorderedTypeSynonyms) :: OrderedTypeSynonyms) ->
     _lhsIorderedTypeSynonyms
   {-# INLINE rule2169 #-}
   rule2169 = \ _parentTree ->
     _parentTree
   {-# INLINE rule2170 #-}
   rule2170 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule2171 #-}
   rule2171 = \ ((_lhsIrequiredPredicates) :: Predicates) ->
     _lhsIrequiredPredicates
   {-# INLINE rule2172 #-}
   rule2172 = \ ((_lhsIsubstitution) :: FixpointSubstitution) ->
     _lhsIsubstitution
   {-# INLINE rule2173 #-}
   rule2173 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
   {-# INLINE rule2174 #-}
   rule2174 = \ ((_lhsItypeschemeMap) :: M.Map Int (Scheme Predicates)) ->
     _lhsItypeschemeMap
   {-# INLINE rule2175 #-}
   rule2175 = \ ((_lhsIuniqueChunk) :: Int) ->
     _lhsIuniqueChunk
   {-# INLINE rule2176 #-}
   rule2176 = \ ((_lhsIuniqueSecondRound) :: Int) ->
     _lhsIuniqueSecondRound
   {-# INLINE rule2177 #-}
   rule2177 = \ ((_lhsIvariableMapping) :: Maybe [(Name, Tp)]) ->
     _lhsIvariableMapping
{-# NOINLINE sem_Expression_Comprehension #-}
sem_Expression_Comprehension :: T_Range  -> T_Expression  -> T_Qualifiers  -> T_Expression 
sem_Expression_Comprehension arg_range_ arg_expression_ arg_qualifiers_ = T_Expression (return st41) where
   {-# NOINLINE st41 #-}
   !st41 = let
      v40 :: T_Expression_v40 
      v40 = \ !(T_Expression_vIn40 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItryPatterns _lhsItypeConstructors _lhsItypeschemeMap _lhsIuniqueChunk _lhsIuniqueSecondRound _lhsIvariableMapping) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _expressionX41 = Control.Monad.Identity.runIdentity (attach_T_Expression (arg_expression_))
         _qualifiersX131 = Control.Monad.Identity.runIdentity (attach_T_Qualifiers (arg_qualifiers_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_Expression_vOut40 _expressionIassumptions _expressionIbeta _expressionIbetaUnique _expressionIcollectErrors _expressionIcollectInstances _expressionIcollectWarnings _expressionIconstraints _expressionIcounter _expressionIdictionaryEnvironment _expressionIinfoTree _expressionImatchIO _expressionImatches _expressionIpatternMatchWarnings _expressionIself _expressionIunboundNames _expressionIuniqueChunk _expressionIuniqueSecondRound) = inv_Expression_s41 _expressionX41 (T_Expression_vIn40 _expressionOallPatterns _expressionOallTypeSchemes _expressionOambiguousConflicts _expressionOavailablePredicates _expressionObetaUnique _expressionOclassEnvironment _expressionOclassMemberEnv _expressionOclassMemberTypeSchemes _expressionOclassNamesEnv _expressionOclassPredicate _expressionOclassTypeSchemes _expressionOcollectErrors _expressionOcollectWarnings _expressionOcounter _expressionOcurClassPred _expressionOcurPred _expressionOcurrentChunk _expressionOdictionaryEnvironment _expressionOimportEnvironment _expressionOinstanceName _expressionOinstanceTypes _expressionOmatchIO _expressionOmoduleName _expressionOmonos _expressionOnamesInScope _expressionOorderedTypeSynonyms _expressionOparentTree _expressionOpatternMatchWarnings _expressionOrequiredPredicates _expressionOsubstitution _expressionOtryPatterns _expressionOtypeConstructors _expressionOtypeschemeMap _expressionOuniqueChunk _expressionOuniqueSecondRound _expressionOvariableMapping)
         (T_Qualifiers_vOut130 _qualifiersIassumptions _qualifiersIbetaUnique _qualifiersIcollectErrors _qualifiersIcollectInstances _qualifiersIcollectWarnings _qualifiersIconstraints _qualifiersIcounter _qualifiersIdictionaryEnvironment _qualifiersIinfoTrees _qualifiersImatchIO _qualifiersImonos _qualifiersInamesInScope _qualifiersIpatternMatchWarnings _qualifiersIself _qualifiersIunboundNames _qualifiersIuniqueChunk _qualifiersIuniqueSecondRound) = inv_Qualifiers_s131 _qualifiersX131 (T_Qualifiers_vIn130 _qualifiersOallPatterns _qualifiersOallTypeSchemes _qualifiersOambiguousConflicts _qualifiersOassumptions _qualifiersOavailablePredicates _qualifiersObetaUnique _qualifiersOclassEnvironment _qualifiersOclassMemberEnv _qualifiersOclassMemberTypeSchemes _qualifiersOclassNamesEnv _qualifiersOclassPredicate _qualifiersOclassTypeSchemes _qualifiersOcollectErrors _qualifiersOcollectWarnings _qualifiersOconstraints _qualifiersOcounter _qualifiersOcurClassPred _qualifiersOcurPred _qualifiersOcurrentChunk _qualifiersOdictionaryEnvironment _qualifiersOimportEnvironment _qualifiersOinstanceName _qualifiersOinstanceTypes _qualifiersOmatchIO _qualifiersOmoduleName _qualifiersOmonos _qualifiersOnamesInScope _qualifiersOorderedTypeSynonyms _qualifiersOparentTree _qualifiersOpatternMatchWarnings _qualifiersOrequiredPredicates _qualifiersOsubstitution _qualifiersOtypeConstructors _qualifiersOtypeschemeMap _qualifiersOunboundNames _qualifiersOuniqueChunk _qualifiersOuniqueSecondRound _qualifiersOvariableMapping)
         _lhsOmatches :: [Maybe MetaVariableTable]
         _lhsOmatches = rule2178 _assumptions _constraints _lhsItryPatterns _localInfo
         _expressionOtryPatterns = rule2179  ()
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule2180 _qualifiersIunboundNames
         _expressionOnamesInScope = rule2181 _qualifiersInamesInScope
         _qualifiersOnamesInScope = rule2182 _lhsInamesInScope
         _qualifiersOunboundNames = rule2183 _expressionIunboundNames
         _parentTree = rule2184 _lhsIparentTree _localInfo _qualifiersIinfoTrees
         _lhsOinfoTree :: InfoTree
         _lhsOinfoTree = rule2185 _parentTree
         _localInfo = rule2186 _beta _lhsImonos _self
         _cinfo = rule2187 _parentTree
         _expressionObetaUnique = rule2188 _lhsIbetaUnique
         _expressionOmonos = rule2189 _qualifiersImonos
         _qualifiersOassumptions = rule2190 _expressionIassumptions
         _qualifiersOconstraints = rule2191 _expressionIconstraints
         _qualifiersOmonos = rule2192 _lhsImonos
         _assumptions = rule2193 _qualifiersIassumptions
         _constraints = rule2194 _newcon _qualifiersIconstraints
         _beta = rule2195 _lhsIbetaUnique
         _newcon = rule2196 _beta _cinfo _expressionIbeta
         _lhsOcollectInstances :: [(Name, Instance)]
         _lhsOcollectInstances = rule2197 _expressionIcollectInstances _qualifiersIcollectInstances
         _self = rule2198 _expressionIself _qualifiersIself _rangeIself
         _lhsOself :: Expression
         _lhsOself = rule2199 _self
         _lhsOassumptions :: Assumptions
         _lhsOassumptions = rule2200 _assumptions
         _lhsObeta :: Tp
         _lhsObeta = rule2201 _beta
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule2202 _qualifiersIbetaUnique
         _lhsOcollectErrors :: TypeErrors
         _lhsOcollectErrors = rule2203 _qualifiersIcollectErrors
         _lhsOcollectWarnings :: Warnings
         _lhsOcollectWarnings = rule2204 _qualifiersIcollectWarnings
         _lhsOconstraints :: ConstraintSet
         _lhsOconstraints = rule2205 _constraints
         _lhsOcounter :: Int
         _lhsOcounter = rule2206 _qualifiersIcounter
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule2207 _qualifiersIdictionaryEnvironment
         _lhsOmatchIO :: IO ()
         _lhsOmatchIO = rule2208 _qualifiersImatchIO
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule2209 _qualifiersIpatternMatchWarnings
         _lhsOuniqueChunk :: Int
         _lhsOuniqueChunk = rule2210 _qualifiersIuniqueChunk
         _lhsOuniqueSecondRound :: Int
         _lhsOuniqueSecondRound = rule2211 _qualifiersIuniqueSecondRound
         _expressionOallPatterns = rule2212 _lhsIallPatterns
         _expressionOallTypeSchemes = rule2213 _lhsIallTypeSchemes
         _expressionOambiguousConflicts = rule2214 _lhsIambiguousConflicts
         _expressionOavailablePredicates = rule2215 _lhsIavailablePredicates
         _expressionOclassEnvironment = rule2216 _lhsIclassEnvironment
         _expressionOclassMemberEnv = rule2217 _lhsIclassMemberEnv
         _expressionOclassMemberTypeSchemes = rule2218 _lhsIclassMemberTypeSchemes
         _expressionOclassNamesEnv = rule2219 _lhsIclassNamesEnv
         _expressionOclassPredicate = rule2220 _lhsIclassPredicate
         _expressionOclassTypeSchemes = rule2221 _lhsIclassTypeSchemes
         _expressionOcollectErrors = rule2222 _lhsIcollectErrors
         _expressionOcollectWarnings = rule2223 _lhsIcollectWarnings
         _expressionOcounter = rule2224 _lhsIcounter
         _expressionOcurClassPred = rule2225 _lhsIcurClassPred
         _expressionOcurPred = rule2226 _lhsIcurPred
         _expressionOcurrentChunk = rule2227 _lhsIcurrentChunk
         _expressionOdictionaryEnvironment = rule2228 _lhsIdictionaryEnvironment
         _expressionOimportEnvironment = rule2229 _lhsIimportEnvironment
         _expressionOinstanceName = rule2230 _lhsIinstanceName
         _expressionOinstanceTypes = rule2231 _lhsIinstanceTypes
         _expressionOmatchIO = rule2232 _lhsImatchIO
         _expressionOmoduleName = rule2233 _lhsImoduleName
         _expressionOorderedTypeSynonyms = rule2234 _lhsIorderedTypeSynonyms
         _expressionOparentTree = rule2235 _parentTree
         _expressionOpatternMatchWarnings = rule2236 _lhsIpatternMatchWarnings
         _expressionOrequiredPredicates = rule2237 _lhsIrequiredPredicates
         _expressionOsubstitution = rule2238 _lhsIsubstitution
         _expressionOtypeConstructors = rule2239 _lhsItypeConstructors
         _expressionOtypeschemeMap = rule2240 _lhsItypeschemeMap
         _expressionOuniqueChunk = rule2241 _lhsIuniqueChunk
         _expressionOuniqueSecondRound = rule2242 _lhsIuniqueSecondRound
         _expressionOvariableMapping = rule2243 _lhsIvariableMapping
         _qualifiersOallPatterns = rule2244 _lhsIallPatterns
         _qualifiersOallTypeSchemes = rule2245 _lhsIallTypeSchemes
         _qualifiersOambiguousConflicts = rule2246 _lhsIambiguousConflicts
         _qualifiersOavailablePredicates = rule2247 _lhsIavailablePredicates
         _qualifiersObetaUnique = rule2248 _expressionIbetaUnique
         _qualifiersOclassEnvironment = rule2249 _lhsIclassEnvironment
         _qualifiersOclassMemberEnv = rule2250 _lhsIclassMemberEnv
         _qualifiersOclassMemberTypeSchemes = rule2251 _lhsIclassMemberTypeSchemes
         _qualifiersOclassNamesEnv = rule2252 _lhsIclassNamesEnv
         _qualifiersOclassPredicate = rule2253 _lhsIclassPredicate
         _qualifiersOclassTypeSchemes = rule2254 _lhsIclassTypeSchemes
         _qualifiersOcollectErrors = rule2255 _expressionIcollectErrors
         _qualifiersOcollectWarnings = rule2256 _expressionIcollectWarnings
         _qualifiersOcounter = rule2257 _expressionIcounter
         _qualifiersOcurClassPred = rule2258 _lhsIcurClassPred
         _qualifiersOcurPred = rule2259 _lhsIcurPred
         _qualifiersOcurrentChunk = rule2260 _lhsIcurrentChunk
         _qualifiersOdictionaryEnvironment = rule2261 _expressionIdictionaryEnvironment
         _qualifiersOimportEnvironment = rule2262 _lhsIimportEnvironment
         _qualifiersOinstanceName = rule2263 _lhsIinstanceName
         _qualifiersOinstanceTypes = rule2264 _lhsIinstanceTypes
         _qualifiersOmatchIO = rule2265 _expressionImatchIO
         _qualifiersOmoduleName = rule2266 _lhsImoduleName
         _qualifiersOorderedTypeSynonyms = rule2267 _lhsIorderedTypeSynonyms
         _qualifiersOparentTree = rule2268 _parentTree
         _qualifiersOpatternMatchWarnings = rule2269 _expressionIpatternMatchWarnings
         _qualifiersOrequiredPredicates = rule2270 _lhsIrequiredPredicates
         _qualifiersOsubstitution = rule2271 _lhsIsubstitution
         _qualifiersOtypeConstructors = rule2272 _lhsItypeConstructors
         _qualifiersOtypeschemeMap = rule2273 _lhsItypeschemeMap
         _qualifiersOuniqueChunk = rule2274 _expressionIuniqueChunk
         _qualifiersOuniqueSecondRound = rule2275 _expressionIuniqueSecondRound
         _qualifiersOvariableMapping = rule2276 _lhsIvariableMapping
         !__result_ = T_Expression_vOut40 _lhsOassumptions _lhsObeta _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraints _lhsOcounter _lhsOdictionaryEnvironment _lhsOinfoTree _lhsOmatchIO _lhsOmatches _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOuniqueSecondRound
         in __result_ )
     in C_Expression_s41 v40
   {-# INLINE rule2178 #-}
   rule2178 = \ _assumptions _constraints ((_lhsItryPatterns) :: [(Expression     , [String])]) _localInfo ->
            let infoTuple = metaVarInfo _constraints _assumptions _localInfo
            in matchOnlyVariable infoTuple _lhsItryPatterns
   {-# INLINE rule2179 #-}
   rule2179 = \  (_ :: ()) ->
                                                     []
   {-# INLINE rule2180 #-}
   rule2180 = \ ((_qualifiersIunboundNames) :: Names) ->
                                                   _qualifiersIunboundNames
   {-# INLINE rule2181 #-}
   rule2181 = \ ((_qualifiersInamesInScope) :: Names) ->
                                                   _qualifiersInamesInScope
   {-# INLINE rule2182 #-}
   rule2182 = \ ((_lhsInamesInScope) :: Names) ->
                                                   _lhsInamesInScope
   {-# INLINE rule2183 #-}
   rule2183 = \ ((_expressionIunboundNames) :: Names) ->
                                                   _expressionIunboundNames
   {-# INLINE rule2184 #-}
   rule2184 = \ ((_lhsIparentTree) :: InfoTree) _localInfo ((_qualifiersIinfoTrees) :: InfoTrees) ->
                            node _lhsIparentTree _localInfo _qualifiersIinfoTrees
   {-# INLINE rule2185 #-}
   rule2185 = \ _parentTree ->
                            _parentTree
   {-# INLINE rule2186 #-}
   rule2186 = \ _beta ((_lhsImonos) :: Monos) _self ->
                            LocalInfo { self = UHA_Expr _self
                                      , assignedType = Just _beta
                                      , monos = _lhsImonos
                                      }
   {-# INLINE rule2187 #-}
   rule2187 = \ _parentTree ->
     resultConstraint "list comprehension" _parentTree
        [ FolkloreConstraint ]
   {-# INLINE rule2188 #-}
   rule2188 = \ ((_lhsIbetaUnique) :: Int) ->
                                   _lhsIbetaUnique + 1
   {-# INLINE rule2189 #-}
   rule2189 = \ ((_qualifiersImonos) :: Monos) ->
                                   _qualifiersImonos
   {-# INLINE rule2190 #-}
   rule2190 = \ ((_expressionIassumptions) :: Assumptions) ->
                                   _expressionIassumptions
   {-# INLINE rule2191 #-}
   rule2191 = \ ((_expressionIconstraints) :: ConstraintSet) ->
                                   _expressionIconstraints
   {-# INLINE rule2192 #-}
   rule2192 = \ ((_lhsImonos) :: Monos) ->
                                   _lhsImonos
   {-# INLINE rule2193 #-}
   rule2193 = \ ((_qualifiersIassumptions) :: Assumptions) ->
                                   _qualifiersIassumptions
   {-# INLINE rule2194 #-}
   rule2194 = \ _newcon ((_qualifiersIconstraints) :: ConstraintSet) ->
                                   _newcon .>. Node [ _qualifiersIconstraints ]
   {-# INLINE rule2195 #-}
   rule2195 = \ ((_lhsIbetaUnique) :: Int) ->
                                   TVar _lhsIbetaUnique
   {-# INLINE rule2196 #-}
   rule2196 = \ _beta _cinfo ((_expressionIbeta) :: Tp) ->
                                   [ (listType _expressionIbeta .==. _beta) _cinfo ]
   {-# INLINE rule2197 #-}
   rule2197 = \ ((_expressionIcollectInstances) :: [(Name, Instance)]) ((_qualifiersIcollectInstances) :: [(Name, Instance)]) ->
     _expressionIcollectInstances  ++  _qualifiersIcollectInstances
   {-# INLINE rule2198 #-}
   rule2198 = \ ((_expressionIself) :: Expression) ((_qualifiersIself) :: Qualifiers) ((_rangeIself) :: Range) ->
     Expression_Comprehension _rangeIself _expressionIself _qualifiersIself
   {-# INLINE rule2199 #-}
   rule2199 = \ _self ->
     _self
   {-# INLINE rule2200 #-}
   rule2200 = \ _assumptions ->
     _assumptions
   {-# INLINE rule2201 #-}
   rule2201 = \ _beta ->
     _beta
   {-# INLINE rule2202 #-}
   rule2202 = \ ((_qualifiersIbetaUnique) :: Int) ->
     _qualifiersIbetaUnique
   {-# INLINE rule2203 #-}
   rule2203 = \ ((_qualifiersIcollectErrors) :: TypeErrors) ->
     _qualifiersIcollectErrors
   {-# INLINE rule2204 #-}
   rule2204 = \ ((_qualifiersIcollectWarnings) :: Warnings) ->
     _qualifiersIcollectWarnings
   {-# INLINE rule2205 #-}
   rule2205 = \ _constraints ->
     _constraints
   {-# INLINE rule2206 #-}
   rule2206 = \ ((_qualifiersIcounter) :: Int) ->
     _qualifiersIcounter
   {-# INLINE rule2207 #-}
   rule2207 = \ ((_qualifiersIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _qualifiersIdictionaryEnvironment
   {-# INLINE rule2208 #-}
   rule2208 = \ ((_qualifiersImatchIO) :: IO ()) ->
     _qualifiersImatchIO
   {-# INLINE rule2209 #-}
   rule2209 = \ ((_qualifiersIpatternMatchWarnings) :: [Warning]) ->
     _qualifiersIpatternMatchWarnings
   {-# INLINE rule2210 #-}
   rule2210 = \ ((_qualifiersIuniqueChunk) :: Int) ->
     _qualifiersIuniqueChunk
   {-# INLINE rule2211 #-}
   rule2211 = \ ((_qualifiersIuniqueSecondRound) :: Int) ->
     _qualifiersIuniqueSecondRound
   {-# INLINE rule2212 #-}
   rule2212 = \ ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ->
     _lhsIallPatterns
   {-# INLINE rule2213 #-}
   rule2213 = \ ((_lhsIallTypeSchemes) :: M.Map NameWithRange TpScheme) ->
     _lhsIallTypeSchemes
   {-# INLINE rule2214 #-}
   rule2214 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule2215 #-}
   rule2215 = \ ((_lhsIavailablePredicates) :: [PredicateWithSource]) ->
     _lhsIavailablePredicates
   {-# INLINE rule2216 #-}
   rule2216 = \ ((_lhsIclassEnvironment) :: ClassEnvironment) ->
     _lhsIclassEnvironment
   {-# INLINE rule2217 #-}
   rule2217 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule2218 #-}
   rule2218 = \ ((_lhsIclassMemberTypeSchemes) :: Maybe [(Name, TpScheme)]) ->
     _lhsIclassMemberTypeSchemes
   {-# INLINE rule2219 #-}
   rule2219 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule2220 #-}
   rule2220 = \ ((_lhsIclassPredicate) :: Maybe (Name, Names)) ->
     _lhsIclassPredicate
   {-# INLINE rule2221 #-}
   rule2221 = \ ((_lhsIclassTypeSchemes) :: M.Map Name TpScheme) ->
     _lhsIclassTypeSchemes
   {-# INLINE rule2222 #-}
   rule2222 = \ ((_lhsIcollectErrors) :: TypeErrors) ->
     _lhsIcollectErrors
   {-# INLINE rule2223 #-}
   rule2223 = \ ((_lhsIcollectWarnings) :: Warnings) ->
     _lhsIcollectWarnings
   {-# INLINE rule2224 #-}
   rule2224 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule2225 #-}
   rule2225 = \ ((_lhsIcurClassPred) :: Maybe Predicate) ->
     _lhsIcurClassPred
   {-# INLINE rule2226 #-}
   rule2226 = \ ((_lhsIcurPred) :: Maybe Predicate) ->
     _lhsIcurPred
   {-# INLINE rule2227 #-}
   rule2227 = \ ((_lhsIcurrentChunk) :: Int) ->
     _lhsIcurrentChunk
   {-# INLINE rule2228 #-}
   rule2228 = \ ((_lhsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _lhsIdictionaryEnvironment
   {-# INLINE rule2229 #-}
   rule2229 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule2230 #-}
   rule2230 = \ ((_lhsIinstanceName) :: Maybe Name) ->
     _lhsIinstanceName
   {-# INLINE rule2231 #-}
   rule2231 = \ ((_lhsIinstanceTypes) :: [(Name, TpScheme)]) ->
     _lhsIinstanceTypes
   {-# INLINE rule2232 #-}
   rule2232 = \ ((_lhsImatchIO) :: IO ()) ->
     _lhsImatchIO
   {-# INLINE rule2233 #-}
   rule2233 = \ ((_lhsImoduleName) :: Maybe Name) ->
     _lhsImoduleName
   {-# INLINE rule2234 #-}
   rule2234 = \ ((_lhsIorderedTypeSynonyms) :: OrderedTypeSynonyms) ->
     _lhsIorderedTypeSynonyms
   {-# INLINE rule2235 #-}
   rule2235 = \ _parentTree ->
     _parentTree
   {-# INLINE rule2236 #-}
   rule2236 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule2237 #-}
   rule2237 = \ ((_lhsIrequiredPredicates) :: Predicates) ->
     _lhsIrequiredPredicates
   {-# INLINE rule2238 #-}
   rule2238 = \ ((_lhsIsubstitution) :: FixpointSubstitution) ->
     _lhsIsubstitution
   {-# INLINE rule2239 #-}
   rule2239 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
   {-# INLINE rule2240 #-}
   rule2240 = \ ((_lhsItypeschemeMap) :: M.Map Int (Scheme Predicates)) ->
     _lhsItypeschemeMap
   {-# INLINE rule2241 #-}
   rule2241 = \ ((_lhsIuniqueChunk) :: Int) ->
     _lhsIuniqueChunk
   {-# INLINE rule2242 #-}
   rule2242 = \ ((_lhsIuniqueSecondRound) :: Int) ->
     _lhsIuniqueSecondRound
   {-# INLINE rule2243 #-}
   rule2243 = \ ((_lhsIvariableMapping) :: Maybe [(Name, Tp)]) ->
     _lhsIvariableMapping
   {-# INLINE rule2244 #-}
   rule2244 = \ ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ->
     _lhsIallPatterns
   {-# INLINE rule2245 #-}
   rule2245 = \ ((_lhsIallTypeSchemes) :: M.Map NameWithRange TpScheme) ->
     _lhsIallTypeSchemes
   {-# INLINE rule2246 #-}
   rule2246 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule2247 #-}
   rule2247 = \ ((_lhsIavailablePredicates) :: [PredicateWithSource]) ->
     _lhsIavailablePredicates
   {-# INLINE rule2248 #-}
   rule2248 = \ ((_expressionIbetaUnique) :: Int) ->
     _expressionIbetaUnique
   {-# INLINE rule2249 #-}
   rule2249 = \ ((_lhsIclassEnvironment) :: ClassEnvironment) ->
     _lhsIclassEnvironment
   {-# INLINE rule2250 #-}
   rule2250 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule2251 #-}
   rule2251 = \ ((_lhsIclassMemberTypeSchemes) :: Maybe [(Name, TpScheme)]) ->
     _lhsIclassMemberTypeSchemes
   {-# INLINE rule2252 #-}
   rule2252 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule2253 #-}
   rule2253 = \ ((_lhsIclassPredicate) :: Maybe (Name, Names)) ->
     _lhsIclassPredicate
   {-# INLINE rule2254 #-}
   rule2254 = \ ((_lhsIclassTypeSchemes) :: M.Map Name TpScheme) ->
     _lhsIclassTypeSchemes
   {-# INLINE rule2255 #-}
   rule2255 = \ ((_expressionIcollectErrors) :: TypeErrors) ->
     _expressionIcollectErrors
   {-# INLINE rule2256 #-}
   rule2256 = \ ((_expressionIcollectWarnings) :: Warnings) ->
     _expressionIcollectWarnings
   {-# INLINE rule2257 #-}
   rule2257 = \ ((_expressionIcounter) :: Int) ->
     _expressionIcounter
   {-# INLINE rule2258 #-}
   rule2258 = \ ((_lhsIcurClassPred) :: Maybe Predicate) ->
     _lhsIcurClassPred
   {-# INLINE rule2259 #-}
   rule2259 = \ ((_lhsIcurPred) :: Maybe Predicate) ->
     _lhsIcurPred
   {-# INLINE rule2260 #-}
   rule2260 = \ ((_lhsIcurrentChunk) :: Int) ->
     _lhsIcurrentChunk
   {-# INLINE rule2261 #-}
   rule2261 = \ ((_expressionIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _expressionIdictionaryEnvironment
   {-# INLINE rule2262 #-}
   rule2262 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule2263 #-}
   rule2263 = \ ((_lhsIinstanceName) :: Maybe Name) ->
     _lhsIinstanceName
   {-# INLINE rule2264 #-}
   rule2264 = \ ((_lhsIinstanceTypes) :: [(Name, TpScheme)]) ->
     _lhsIinstanceTypes
   {-# INLINE rule2265 #-}
   rule2265 = \ ((_expressionImatchIO) :: IO ()) ->
     _expressionImatchIO
   {-# INLINE rule2266 #-}
   rule2266 = \ ((_lhsImoduleName) :: Maybe Name) ->
     _lhsImoduleName
   {-# INLINE rule2267 #-}
   rule2267 = \ ((_lhsIorderedTypeSynonyms) :: OrderedTypeSynonyms) ->
     _lhsIorderedTypeSynonyms
   {-# INLINE rule2268 #-}
   rule2268 = \ _parentTree ->
     _parentTree
   {-# INLINE rule2269 #-}
   rule2269 = \ ((_expressionIpatternMatchWarnings) :: [Warning]) ->
     _expressionIpatternMatchWarnings
   {-# INLINE rule2270 #-}
   rule2270 = \ ((_lhsIrequiredPredicates) :: Predicates) ->
     _lhsIrequiredPredicates
   {-# INLINE rule2271 #-}
   rule2271 = \ ((_lhsIsubstitution) :: FixpointSubstitution) ->
     _lhsIsubstitution
   {-# INLINE rule2272 #-}
   rule2272 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
   {-# INLINE rule2273 #-}
   rule2273 = \ ((_lhsItypeschemeMap) :: M.Map Int (Scheme Predicates)) ->
     _lhsItypeschemeMap
   {-# INLINE rule2274 #-}
   rule2274 = \ ((_expressionIuniqueChunk) :: Int) ->
     _expressionIuniqueChunk
   {-# INLINE rule2275 #-}
   rule2275 = \ ((_expressionIuniqueSecondRound) :: Int) ->
     _expressionIuniqueSecondRound
   {-# INLINE rule2276 #-}
   rule2276 = \ ((_lhsIvariableMapping) :: Maybe [(Name, Tp)]) ->
     _lhsIvariableMapping
{-# NOINLINE sem_Expression_Typed #-}
sem_Expression_Typed :: T_Range  -> T_Expression  -> T_Type  -> T_Expression 
sem_Expression_Typed arg_range_ arg_expression_ arg_type_ = T_Expression (return st41) where
   {-# NOINLINE st41 #-}
   !st41 = let
      v40 :: T_Expression_v40 
      v40 = \ !(T_Expression_vIn40 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItryPatterns _lhsItypeConstructors _lhsItypeschemeMap _lhsIuniqueChunk _lhsIuniqueSecondRound _lhsIvariableMapping) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _expressionX41 = Control.Monad.Identity.runIdentity (attach_T_Expression (arg_expression_))
         _typeX164 = Control.Monad.Identity.runIdentity (attach_T_Type (arg_type_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_Expression_vOut40 _expressionIassumptions _expressionIbeta _expressionIbetaUnique _expressionIcollectErrors _expressionIcollectInstances _expressionIcollectWarnings _expressionIconstraints _expressionIcounter _expressionIdictionaryEnvironment _expressionIinfoTree _expressionImatchIO _expressionImatches _expressionIpatternMatchWarnings _expressionIself _expressionIunboundNames _expressionIuniqueChunk _expressionIuniqueSecondRound) = inv_Expression_s41 _expressionX41 (T_Expression_vIn40 _expressionOallPatterns _expressionOallTypeSchemes _expressionOambiguousConflicts _expressionOavailablePredicates _expressionObetaUnique _expressionOclassEnvironment _expressionOclassMemberEnv _expressionOclassMemberTypeSchemes _expressionOclassNamesEnv _expressionOclassPredicate _expressionOclassTypeSchemes _expressionOcollectErrors _expressionOcollectWarnings _expressionOcounter _expressionOcurClassPred _expressionOcurPred _expressionOcurrentChunk _expressionOdictionaryEnvironment _expressionOimportEnvironment _expressionOinstanceName _expressionOinstanceTypes _expressionOmatchIO _expressionOmoduleName _expressionOmonos _expressionOnamesInScope _expressionOorderedTypeSynonyms _expressionOparentTree _expressionOpatternMatchWarnings _expressionOrequiredPredicates _expressionOsubstitution _expressionOtryPatterns _expressionOtypeConstructors _expressionOtypeschemeMap _expressionOuniqueChunk _expressionOuniqueSecondRound _expressionOvariableMapping)
         (T_Type_vOut163 _typeIself) = inv_Type_s164 _typeX164 (T_Type_vIn163 _typeOclassMemberEnv _typeOclassNamesEnv)
         _lhsOmatches :: [Maybe MetaVariableTable]
         _lhsOmatches = rule2277 _assumptions _constraints _lhsItryPatterns _localInfo
         _expressionOtryPatterns = rule2278  ()
         _parentTree = rule2279 _expressionIinfoTree _lhsIparentTree _localInfo
         _lhsOinfoTree :: InfoTree
         _lhsOinfoTree = rule2280 _parentTree
         _localInfo = rule2281 _beta _lhsImonos _self
         _cinfoExpr = rule2282 _parentTree _typeIself
         _cinfoResult = rule2283 _parentTree
         _expressionObetaUnique = rule2284 _lhsIbetaUnique
         _assumptions = rule2285 _expressionIassumptions
         _constraints = rule2286 _conExpr _conResult _expressionIconstraints
         _beta = rule2287 _lhsIbetaUnique
         _qualType = rule2288 _lhsIimportEnvironment _typeIself
         _typeScheme = rule2289 _qualType
         _conResult = rule2290 _beta _cinfoResult _typeScheme
         _conExpr = rule2291 _cinfoExpr _expressionIbeta _lhsImonos _typeScheme
         _lhsOcollectInstances :: [(Name, Instance)]
         _lhsOcollectInstances = rule2292 _expressionIcollectInstances
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule2293 _expressionIunboundNames
         _self = rule2294 _expressionIself _rangeIself _typeIself
         _lhsOself :: Expression
         _lhsOself = rule2295 _self
         _lhsOassumptions :: Assumptions
         _lhsOassumptions = rule2296 _assumptions
         _lhsObeta :: Tp
         _lhsObeta = rule2297 _beta
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule2298 _expressionIbetaUnique
         _lhsOcollectErrors :: TypeErrors
         _lhsOcollectErrors = rule2299 _expressionIcollectErrors
         _lhsOcollectWarnings :: Warnings
         _lhsOcollectWarnings = rule2300 _expressionIcollectWarnings
         _lhsOconstraints :: ConstraintSet
         _lhsOconstraints = rule2301 _constraints
         _lhsOcounter :: Int
         _lhsOcounter = rule2302 _expressionIcounter
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule2303 _expressionIdictionaryEnvironment
         _lhsOmatchIO :: IO ()
         _lhsOmatchIO = rule2304 _expressionImatchIO
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule2305 _expressionIpatternMatchWarnings
         _lhsOuniqueChunk :: Int
         _lhsOuniqueChunk = rule2306 _expressionIuniqueChunk
         _lhsOuniqueSecondRound :: Int
         _lhsOuniqueSecondRound = rule2307 _expressionIuniqueSecondRound
         _expressionOallPatterns = rule2308 _lhsIallPatterns
         _expressionOallTypeSchemes = rule2309 _lhsIallTypeSchemes
         _expressionOambiguousConflicts = rule2310 _lhsIambiguousConflicts
         _expressionOavailablePredicates = rule2311 _lhsIavailablePredicates
         _expressionOclassEnvironment = rule2312 _lhsIclassEnvironment
         _expressionOclassMemberEnv = rule2313 _lhsIclassMemberEnv
         _expressionOclassMemberTypeSchemes = rule2314 _lhsIclassMemberTypeSchemes
         _expressionOclassNamesEnv = rule2315 _lhsIclassNamesEnv
         _expressionOclassPredicate = rule2316 _lhsIclassPredicate
         _expressionOclassTypeSchemes = rule2317 _lhsIclassTypeSchemes
         _expressionOcollectErrors = rule2318 _lhsIcollectErrors
         _expressionOcollectWarnings = rule2319 _lhsIcollectWarnings
         _expressionOcounter = rule2320 _lhsIcounter
         _expressionOcurClassPred = rule2321 _lhsIcurClassPred
         _expressionOcurPred = rule2322 _lhsIcurPred
         _expressionOcurrentChunk = rule2323 _lhsIcurrentChunk
         _expressionOdictionaryEnvironment = rule2324 _lhsIdictionaryEnvironment
         _expressionOimportEnvironment = rule2325 _lhsIimportEnvironment
         _expressionOinstanceName = rule2326 _lhsIinstanceName
         _expressionOinstanceTypes = rule2327 _lhsIinstanceTypes
         _expressionOmatchIO = rule2328 _lhsImatchIO
         _expressionOmoduleName = rule2329 _lhsImoduleName
         _expressionOmonos = rule2330 _lhsImonos
         _expressionOnamesInScope = rule2331 _lhsInamesInScope
         _expressionOorderedTypeSynonyms = rule2332 _lhsIorderedTypeSynonyms
         _expressionOparentTree = rule2333 _parentTree
         _expressionOpatternMatchWarnings = rule2334 _lhsIpatternMatchWarnings
         _expressionOrequiredPredicates = rule2335 _lhsIrequiredPredicates
         _expressionOsubstitution = rule2336 _lhsIsubstitution
         _expressionOtypeConstructors = rule2337 _lhsItypeConstructors
         _expressionOtypeschemeMap = rule2338 _lhsItypeschemeMap
         _expressionOuniqueChunk = rule2339 _lhsIuniqueChunk
         _expressionOuniqueSecondRound = rule2340 _lhsIuniqueSecondRound
         _expressionOvariableMapping = rule2341 _lhsIvariableMapping
         _typeOclassMemberEnv = rule2342 _lhsIclassMemberEnv
         _typeOclassNamesEnv = rule2343 _lhsIclassNamesEnv
         !__result_ = T_Expression_vOut40 _lhsOassumptions _lhsObeta _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraints _lhsOcounter _lhsOdictionaryEnvironment _lhsOinfoTree _lhsOmatchIO _lhsOmatches _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOuniqueSecondRound
         in __result_ )
     in C_Expression_s41 v40
   {-# INLINE rule2277 #-}
   rule2277 = \ _assumptions _constraints ((_lhsItryPatterns) :: [(Expression     , [String])]) _localInfo ->
            let infoTuple = metaVarInfo _constraints _assumptions _localInfo
            in matchOnlyVariable infoTuple _lhsItryPatterns
   {-# INLINE rule2278 #-}
   rule2278 = \  (_ :: ()) ->
                                                     []
   {-# INLINE rule2279 #-}
   rule2279 = \ ((_expressionIinfoTree) :: InfoTree) ((_lhsIparentTree) :: InfoTree) _localInfo ->
                            node _lhsIparentTree _localInfo [_expressionIinfoTree]
   {-# INLINE rule2280 #-}
   rule2280 = \ _parentTree ->
                            _parentTree
   {-# INLINE rule2281 #-}
   rule2281 = \ _beta ((_lhsImonos) :: Monos) _self ->
                            LocalInfo { self = UHA_Expr _self
                                      , assignedType = Just _beta
                                      , monos = _lhsImonos
                                      }
   {-# INLINE rule2282 #-}
   rule2282 = \ _parentTree ((_typeIself) :: Type) ->
     childConstraint 0 "type annotation" _parentTree
        [ TypeSignatureLocation (getTypeRange _typeIself) ]
   {-# INLINE rule2283 #-}
   rule2283 = \ _parentTree ->
     resultConstraint "type annotation" _parentTree
        [ FolkloreConstraint ]
   {-# INLINE rule2284 #-}
   rule2284 = \ ((_lhsIbetaUnique) :: Int) ->
                                   _lhsIbetaUnique + 1
   {-# INLINE rule2285 #-}
   rule2285 = \ ((_expressionIassumptions) :: Assumptions) ->
                                   _expressionIassumptions
   {-# INLINE rule2286 #-}
   rule2286 = \ _conExpr _conResult ((_expressionIconstraints) :: ConstraintSet) ->
                                   _conResult .>.
                                   Node [ _conExpr .<. _expressionIconstraints ]
   {-# INLINE rule2287 #-}
   rule2287 = \ ((_lhsIbetaUnique) :: Int) ->
                                   TVar _lhsIbetaUnique
   {-# INLINE rule2288 #-}
   rule2288 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ((_typeIself) :: Type) ->
                                   convertTypeToQualified _lhsIimportEnvironment _typeIself
   {-# INLINE rule2289 #-}
   rule2289 = \ _qualType ->
                                   makeTpSchemeFromType _qualType
   {-# INLINE rule2290 #-}
   rule2290 = \ _beta _cinfoResult _typeScheme ->
                                   [ (_beta            .::. _typeScheme) _cinfoResult          ]
   {-# INLINE rule2291 #-}
   rule2291 = \ _cinfoExpr ((_expressionIbeta) :: Tp) ((_lhsImonos) :: Monos) _typeScheme ->
                                   [ (_expressionIbeta !::! _typeScheme) _lhsImonos _cinfoExpr ]
   {-# INLINE rule2292 #-}
   rule2292 = \ ((_expressionIcollectInstances) :: [(Name, Instance)]) ->
     _expressionIcollectInstances
   {-# INLINE rule2293 #-}
   rule2293 = \ ((_expressionIunboundNames) :: Names) ->
     _expressionIunboundNames
   {-# INLINE rule2294 #-}
   rule2294 = \ ((_expressionIself) :: Expression) ((_rangeIself) :: Range) ((_typeIself) :: Type) ->
     Expression_Typed _rangeIself _expressionIself _typeIself
   {-# INLINE rule2295 #-}
   rule2295 = \ _self ->
     _self
   {-# INLINE rule2296 #-}
   rule2296 = \ _assumptions ->
     _assumptions
   {-# INLINE rule2297 #-}
   rule2297 = \ _beta ->
     _beta
   {-# INLINE rule2298 #-}
   rule2298 = \ ((_expressionIbetaUnique) :: Int) ->
     _expressionIbetaUnique
   {-# INLINE rule2299 #-}
   rule2299 = \ ((_expressionIcollectErrors) :: TypeErrors) ->
     _expressionIcollectErrors
   {-# INLINE rule2300 #-}
   rule2300 = \ ((_expressionIcollectWarnings) :: Warnings) ->
     _expressionIcollectWarnings
   {-# INLINE rule2301 #-}
   rule2301 = \ _constraints ->
     _constraints
   {-# INLINE rule2302 #-}
   rule2302 = \ ((_expressionIcounter) :: Int) ->
     _expressionIcounter
   {-# INLINE rule2303 #-}
   rule2303 = \ ((_expressionIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _expressionIdictionaryEnvironment
   {-# INLINE rule2304 #-}
   rule2304 = \ ((_expressionImatchIO) :: IO ()) ->
     _expressionImatchIO
   {-# INLINE rule2305 #-}
   rule2305 = \ ((_expressionIpatternMatchWarnings) :: [Warning]) ->
     _expressionIpatternMatchWarnings
   {-# INLINE rule2306 #-}
   rule2306 = \ ((_expressionIuniqueChunk) :: Int) ->
     _expressionIuniqueChunk
   {-# INLINE rule2307 #-}
   rule2307 = \ ((_expressionIuniqueSecondRound) :: Int) ->
     _expressionIuniqueSecondRound
   {-# INLINE rule2308 #-}
   rule2308 = \ ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ->
     _lhsIallPatterns
   {-# INLINE rule2309 #-}
   rule2309 = \ ((_lhsIallTypeSchemes) :: M.Map NameWithRange TpScheme) ->
     _lhsIallTypeSchemes
   {-# INLINE rule2310 #-}
   rule2310 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule2311 #-}
   rule2311 = \ ((_lhsIavailablePredicates) :: [PredicateWithSource]) ->
     _lhsIavailablePredicates
   {-# INLINE rule2312 #-}
   rule2312 = \ ((_lhsIclassEnvironment) :: ClassEnvironment) ->
     _lhsIclassEnvironment
   {-# INLINE rule2313 #-}
   rule2313 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule2314 #-}
   rule2314 = \ ((_lhsIclassMemberTypeSchemes) :: Maybe [(Name, TpScheme)]) ->
     _lhsIclassMemberTypeSchemes
   {-# INLINE rule2315 #-}
   rule2315 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule2316 #-}
   rule2316 = \ ((_lhsIclassPredicate) :: Maybe (Name, Names)) ->
     _lhsIclassPredicate
   {-# INLINE rule2317 #-}
   rule2317 = \ ((_lhsIclassTypeSchemes) :: M.Map Name TpScheme) ->
     _lhsIclassTypeSchemes
   {-# INLINE rule2318 #-}
   rule2318 = \ ((_lhsIcollectErrors) :: TypeErrors) ->
     _lhsIcollectErrors
   {-# INLINE rule2319 #-}
   rule2319 = \ ((_lhsIcollectWarnings) :: Warnings) ->
     _lhsIcollectWarnings
   {-# INLINE rule2320 #-}
   rule2320 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule2321 #-}
   rule2321 = \ ((_lhsIcurClassPred) :: Maybe Predicate) ->
     _lhsIcurClassPred
   {-# INLINE rule2322 #-}
   rule2322 = \ ((_lhsIcurPred) :: Maybe Predicate) ->
     _lhsIcurPred
   {-# INLINE rule2323 #-}
   rule2323 = \ ((_lhsIcurrentChunk) :: Int) ->
     _lhsIcurrentChunk
   {-# INLINE rule2324 #-}
   rule2324 = \ ((_lhsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _lhsIdictionaryEnvironment
   {-# INLINE rule2325 #-}
   rule2325 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule2326 #-}
   rule2326 = \ ((_lhsIinstanceName) :: Maybe Name) ->
     _lhsIinstanceName
   {-# INLINE rule2327 #-}
   rule2327 = \ ((_lhsIinstanceTypes) :: [(Name, TpScheme)]) ->
     _lhsIinstanceTypes
   {-# INLINE rule2328 #-}
   rule2328 = \ ((_lhsImatchIO) :: IO ()) ->
     _lhsImatchIO
   {-# INLINE rule2329 #-}
   rule2329 = \ ((_lhsImoduleName) :: Maybe Name) ->
     _lhsImoduleName
   {-# INLINE rule2330 #-}
   rule2330 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule2331 #-}
   rule2331 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule2332 #-}
   rule2332 = \ ((_lhsIorderedTypeSynonyms) :: OrderedTypeSynonyms) ->
     _lhsIorderedTypeSynonyms
   {-# INLINE rule2333 #-}
   rule2333 = \ _parentTree ->
     _parentTree
   {-# INLINE rule2334 #-}
   rule2334 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule2335 #-}
   rule2335 = \ ((_lhsIrequiredPredicates) :: Predicates) ->
     _lhsIrequiredPredicates
   {-# INLINE rule2336 #-}
   rule2336 = \ ((_lhsIsubstitution) :: FixpointSubstitution) ->
     _lhsIsubstitution
   {-# INLINE rule2337 #-}
   rule2337 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
   {-# INLINE rule2338 #-}
   rule2338 = \ ((_lhsItypeschemeMap) :: M.Map Int (Scheme Predicates)) ->
     _lhsItypeschemeMap
   {-# INLINE rule2339 #-}
   rule2339 = \ ((_lhsIuniqueChunk) :: Int) ->
     _lhsIuniqueChunk
   {-# INLINE rule2340 #-}
   rule2340 = \ ((_lhsIuniqueSecondRound) :: Int) ->
     _lhsIuniqueSecondRound
   {-# INLINE rule2341 #-}
   rule2341 = \ ((_lhsIvariableMapping) :: Maybe [(Name, Tp)]) ->
     _lhsIvariableMapping
   {-# INLINE rule2342 #-}
   rule2342 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule2343 #-}
   rule2343 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
{-# NOINLINE sem_Expression_RecordConstruction #-}
sem_Expression_RecordConstruction :: T_Range  -> T_Name  -> T_RecordExpressionBindings  -> T_Expression 
sem_Expression_RecordConstruction arg_range_ arg_name_ arg_recordExpressionBindings_ = T_Expression (return st41) where
   {-# NOINLINE st41 #-}
   !st41 = let
      v40 :: T_Expression_v40 
      v40 = \ !(T_Expression_vIn40 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItryPatterns _lhsItypeConstructors _lhsItypeschemeMap _lhsIuniqueChunk _lhsIuniqueSecondRound _lhsIvariableMapping) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _nameX113 = Control.Monad.Identity.runIdentity (attach_T_Name (arg_name_))
         _recordExpressionBindingsX140 = Control.Monad.Identity.runIdentity (attach_T_RecordExpressionBindings (arg_recordExpressionBindings_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_Name_vOut112 _nameIself) = inv_Name_s113 _nameX113 (T_Name_vIn112 )
         (T_RecordExpressionBindings_vOut139 _recordExpressionBindingsIcollectErrors _recordExpressionBindingsIcollectInstances _recordExpressionBindingsIcollectWarnings _recordExpressionBindingsIcounter _recordExpressionBindingsIdictionaryEnvironment _recordExpressionBindingsIpatternMatchWarnings _recordExpressionBindingsIself _recordExpressionBindingsIunboundNames _recordExpressionBindingsIuniqueChunk) = inv_RecordExpressionBindings_s140 _recordExpressionBindingsX140 (T_RecordExpressionBindings_vIn139 _recordExpressionBindingsOallTypeSchemes _recordExpressionBindingsOambiguousConflicts _recordExpressionBindingsOavailablePredicates _recordExpressionBindingsOclassEnvironment _recordExpressionBindingsOclassMemberEnv _recordExpressionBindingsOclassMemberTypeSchemes _recordExpressionBindingsOclassNamesEnv _recordExpressionBindingsOclassPredicate _recordExpressionBindingsOclassTypeSchemes _recordExpressionBindingsOcollectErrors _recordExpressionBindingsOcollectWarnings _recordExpressionBindingsOcounter _recordExpressionBindingsOcurClassPred _recordExpressionBindingsOcurPred _recordExpressionBindingsOcurrentChunk _recordExpressionBindingsOdictionaryEnvironment _recordExpressionBindingsOimportEnvironment _recordExpressionBindingsOinstanceName _recordExpressionBindingsOinstanceTypes _recordExpressionBindingsOmoduleName _recordExpressionBindingsOnamesInScope _recordExpressionBindingsOorderedTypeSynonyms _recordExpressionBindingsOpatternMatchWarnings _recordExpressionBindingsOrequiredPredicates _recordExpressionBindingsOsubstitution _recordExpressionBindingsOtypeschemeMap _recordExpressionBindingsOuniqueChunk _recordExpressionBindingsOvariableMapping)
         _matches = rule2344  ()
         (_assumptions,_constraints,_beta) = rule2345  ()
         _infoTree = rule2346  ()
         _lhsOcollectInstances :: [(Name, Instance)]
         _lhsOcollectInstances = rule2347 _recordExpressionBindingsIcollectInstances
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule2348 _recordExpressionBindingsIunboundNames
         _self = rule2349 _nameIself _rangeIself _recordExpressionBindingsIself
         _lhsOself :: Expression
         _lhsOself = rule2350 _self
         _lhsOassumptions :: Assumptions
         _lhsOassumptions = rule2351 _assumptions
         _lhsObeta :: Tp
         _lhsObeta = rule2352 _beta
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule2353 _lhsIbetaUnique
         _lhsOcollectErrors :: TypeErrors
         _lhsOcollectErrors = rule2354 _recordExpressionBindingsIcollectErrors
         _lhsOcollectWarnings :: Warnings
         _lhsOcollectWarnings = rule2355 _recordExpressionBindingsIcollectWarnings
         _lhsOconstraints :: ConstraintSet
         _lhsOconstraints = rule2356 _constraints
         _lhsOcounter :: Int
         _lhsOcounter = rule2357 _recordExpressionBindingsIcounter
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule2358 _recordExpressionBindingsIdictionaryEnvironment
         _lhsOinfoTree :: InfoTree
         _lhsOinfoTree = rule2359 _infoTree
         _lhsOmatchIO :: IO ()
         _lhsOmatchIO = rule2360 _lhsImatchIO
         _lhsOmatches :: [Maybe MetaVariableTable]
         _lhsOmatches = rule2361 _matches
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule2362 _recordExpressionBindingsIpatternMatchWarnings
         _lhsOuniqueChunk :: Int
         _lhsOuniqueChunk = rule2363 _recordExpressionBindingsIuniqueChunk
         _lhsOuniqueSecondRound :: Int
         _lhsOuniqueSecondRound = rule2364 _lhsIuniqueSecondRound
         _recordExpressionBindingsOallTypeSchemes = rule2365 _lhsIallTypeSchemes
         _recordExpressionBindingsOambiguousConflicts = rule2366 _lhsIambiguousConflicts
         _recordExpressionBindingsOavailablePredicates = rule2367 _lhsIavailablePredicates
         _recordExpressionBindingsOclassEnvironment = rule2368 _lhsIclassEnvironment
         _recordExpressionBindingsOclassMemberEnv = rule2369 _lhsIclassMemberEnv
         _recordExpressionBindingsOclassMemberTypeSchemes = rule2370 _lhsIclassMemberTypeSchemes
         _recordExpressionBindingsOclassNamesEnv = rule2371 _lhsIclassNamesEnv
         _recordExpressionBindingsOclassPredicate = rule2372 _lhsIclassPredicate
         _recordExpressionBindingsOclassTypeSchemes = rule2373 _lhsIclassTypeSchemes
         _recordExpressionBindingsOcollectErrors = rule2374 _lhsIcollectErrors
         _recordExpressionBindingsOcollectWarnings = rule2375 _lhsIcollectWarnings
         _recordExpressionBindingsOcounter = rule2376 _lhsIcounter
         _recordExpressionBindingsOcurClassPred = rule2377 _lhsIcurClassPred
         _recordExpressionBindingsOcurPred = rule2378 _lhsIcurPred
         _recordExpressionBindingsOcurrentChunk = rule2379 _lhsIcurrentChunk
         _recordExpressionBindingsOdictionaryEnvironment = rule2380 _lhsIdictionaryEnvironment
         _recordExpressionBindingsOimportEnvironment = rule2381 _lhsIimportEnvironment
         _recordExpressionBindingsOinstanceName = rule2382 _lhsIinstanceName
         _recordExpressionBindingsOinstanceTypes = rule2383 _lhsIinstanceTypes
         _recordExpressionBindingsOmoduleName = rule2384 _lhsImoduleName
         _recordExpressionBindingsOnamesInScope = rule2385 _lhsInamesInScope
         _recordExpressionBindingsOorderedTypeSynonyms = rule2386 _lhsIorderedTypeSynonyms
         _recordExpressionBindingsOpatternMatchWarnings = rule2387 _lhsIpatternMatchWarnings
         _recordExpressionBindingsOrequiredPredicates = rule2388 _lhsIrequiredPredicates
         _recordExpressionBindingsOsubstitution = rule2389 _lhsIsubstitution
         _recordExpressionBindingsOtypeschemeMap = rule2390 _lhsItypeschemeMap
         _recordExpressionBindingsOuniqueChunk = rule2391 _lhsIuniqueChunk
         _recordExpressionBindingsOvariableMapping = rule2392 _lhsIvariableMapping
         !__result_ = T_Expression_vOut40 _lhsOassumptions _lhsObeta _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraints _lhsOcounter _lhsOdictionaryEnvironment _lhsOinfoTree _lhsOmatchIO _lhsOmatches _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOuniqueSecondRound
         in __result_ )
     in C_Expression_s41 v40
   {-# INLINE rule2344 #-}
   rule2344 = \  (_ :: ()) ->
                         internalError "TS_PatternMatching.ag" "n/a" "RecordConstruction is not supported"
   {-# INLINE rule2345 #-}
   rule2345 = \  (_ :: ()) ->
                                                                 internalError "PartialSyntax.ag" "n/a" "Expression.RecordConstruction"
   {-# INLINE rule2346 #-}
   rule2346 = \  (_ :: ()) ->
                                                                            globalInfoError
   {-# INLINE rule2347 #-}
   rule2347 = \ ((_recordExpressionBindingsIcollectInstances) :: [(Name, Instance)]) ->
     _recordExpressionBindingsIcollectInstances
   {-# INLINE rule2348 #-}
   rule2348 = \ ((_recordExpressionBindingsIunboundNames) :: Names) ->
     _recordExpressionBindingsIunboundNames
   {-# INLINE rule2349 #-}
   rule2349 = \ ((_nameIself) :: Name) ((_rangeIself) :: Range) ((_recordExpressionBindingsIself) :: RecordExpressionBindings) ->
     Expression_RecordConstruction _rangeIself _nameIself _recordExpressionBindingsIself
   {-# INLINE rule2350 #-}
   rule2350 = \ _self ->
     _self
   {-# INLINE rule2351 #-}
   rule2351 = \ _assumptions ->
     _assumptions
   {-# INLINE rule2352 #-}
   rule2352 = \ _beta ->
     _beta
   {-# INLINE rule2353 #-}
   rule2353 = \ ((_lhsIbetaUnique) :: Int) ->
     _lhsIbetaUnique
   {-# INLINE rule2354 #-}
   rule2354 = \ ((_recordExpressionBindingsIcollectErrors) :: TypeErrors) ->
     _recordExpressionBindingsIcollectErrors
   {-# INLINE rule2355 #-}
   rule2355 = \ ((_recordExpressionBindingsIcollectWarnings) :: Warnings) ->
     _recordExpressionBindingsIcollectWarnings
   {-# INLINE rule2356 #-}
   rule2356 = \ _constraints ->
     _constraints
   {-# INLINE rule2357 #-}
   rule2357 = \ ((_recordExpressionBindingsIcounter) :: Int) ->
     _recordExpressionBindingsIcounter
   {-# INLINE rule2358 #-}
   rule2358 = \ ((_recordExpressionBindingsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _recordExpressionBindingsIdictionaryEnvironment
   {-# INLINE rule2359 #-}
   rule2359 = \ _infoTree ->
     _infoTree
   {-# INLINE rule2360 #-}
   rule2360 = \ ((_lhsImatchIO) :: IO ()) ->
     _lhsImatchIO
   {-# INLINE rule2361 #-}
   rule2361 = \ _matches ->
     _matches
   {-# INLINE rule2362 #-}
   rule2362 = \ ((_recordExpressionBindingsIpatternMatchWarnings) :: [Warning]) ->
     _recordExpressionBindingsIpatternMatchWarnings
   {-# INLINE rule2363 #-}
   rule2363 = \ ((_recordExpressionBindingsIuniqueChunk) :: Int) ->
     _recordExpressionBindingsIuniqueChunk
   {-# INLINE rule2364 #-}
   rule2364 = \ ((_lhsIuniqueSecondRound) :: Int) ->
     _lhsIuniqueSecondRound
   {-# INLINE rule2365 #-}
   rule2365 = \ ((_lhsIallTypeSchemes) :: M.Map NameWithRange TpScheme) ->
     _lhsIallTypeSchemes
   {-# INLINE rule2366 #-}
   rule2366 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule2367 #-}
   rule2367 = \ ((_lhsIavailablePredicates) :: [PredicateWithSource]) ->
     _lhsIavailablePredicates
   {-# INLINE rule2368 #-}
   rule2368 = \ ((_lhsIclassEnvironment) :: ClassEnvironment) ->
     _lhsIclassEnvironment
   {-# INLINE rule2369 #-}
   rule2369 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule2370 #-}
   rule2370 = \ ((_lhsIclassMemberTypeSchemes) :: Maybe [(Name, TpScheme)]) ->
     _lhsIclassMemberTypeSchemes
   {-# INLINE rule2371 #-}
   rule2371 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule2372 #-}
   rule2372 = \ ((_lhsIclassPredicate) :: Maybe (Name, Names)) ->
     _lhsIclassPredicate
   {-# INLINE rule2373 #-}
   rule2373 = \ ((_lhsIclassTypeSchemes) :: M.Map Name TpScheme) ->
     _lhsIclassTypeSchemes
   {-# INLINE rule2374 #-}
   rule2374 = \ ((_lhsIcollectErrors) :: TypeErrors) ->
     _lhsIcollectErrors
   {-# INLINE rule2375 #-}
   rule2375 = \ ((_lhsIcollectWarnings) :: Warnings) ->
     _lhsIcollectWarnings
   {-# INLINE rule2376 #-}
   rule2376 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule2377 #-}
   rule2377 = \ ((_lhsIcurClassPred) :: Maybe Predicate) ->
     _lhsIcurClassPred
   {-# INLINE rule2378 #-}
   rule2378 = \ ((_lhsIcurPred) :: Maybe Predicate) ->
     _lhsIcurPred
   {-# INLINE rule2379 #-}
   rule2379 = \ ((_lhsIcurrentChunk) :: Int) ->
     _lhsIcurrentChunk
   {-# INLINE rule2380 #-}
   rule2380 = \ ((_lhsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _lhsIdictionaryEnvironment
   {-# INLINE rule2381 #-}
   rule2381 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule2382 #-}
   rule2382 = \ ((_lhsIinstanceName) :: Maybe Name) ->
     _lhsIinstanceName
   {-# INLINE rule2383 #-}
   rule2383 = \ ((_lhsIinstanceTypes) :: [(Name, TpScheme)]) ->
     _lhsIinstanceTypes
   {-# INLINE rule2384 #-}
   rule2384 = \ ((_lhsImoduleName) :: Maybe Name) ->
     _lhsImoduleName
   {-# INLINE rule2385 #-}
   rule2385 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule2386 #-}
   rule2386 = \ ((_lhsIorderedTypeSynonyms) :: OrderedTypeSynonyms) ->
     _lhsIorderedTypeSynonyms
   {-# INLINE rule2387 #-}
   rule2387 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule2388 #-}
   rule2388 = \ ((_lhsIrequiredPredicates) :: Predicates) ->
     _lhsIrequiredPredicates
   {-# INLINE rule2389 #-}
   rule2389 = \ ((_lhsIsubstitution) :: FixpointSubstitution) ->
     _lhsIsubstitution
   {-# INLINE rule2390 #-}
   rule2390 = \ ((_lhsItypeschemeMap) :: M.Map Int (Scheme Predicates)) ->
     _lhsItypeschemeMap
   {-# INLINE rule2391 #-}
   rule2391 = \ ((_lhsIuniqueChunk) :: Int) ->
     _lhsIuniqueChunk
   {-# INLINE rule2392 #-}
   rule2392 = \ ((_lhsIvariableMapping) :: Maybe [(Name, Tp)]) ->
     _lhsIvariableMapping
{-# NOINLINE sem_Expression_RecordUpdate #-}
sem_Expression_RecordUpdate :: T_Range  -> T_Expression  -> T_RecordExpressionBindings  -> T_Expression 
sem_Expression_RecordUpdate arg_range_ arg_expression_ arg_recordExpressionBindings_ = T_Expression (return st41) where
   {-# NOINLINE st41 #-}
   !st41 = let
      v40 :: T_Expression_v40 
      v40 = \ !(T_Expression_vIn40 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItryPatterns _lhsItypeConstructors _lhsItypeschemeMap _lhsIuniqueChunk _lhsIuniqueSecondRound _lhsIvariableMapping) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _expressionX41 = Control.Monad.Identity.runIdentity (attach_T_Expression (arg_expression_))
         _recordExpressionBindingsX140 = Control.Monad.Identity.runIdentity (attach_T_RecordExpressionBindings (arg_recordExpressionBindings_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_Expression_vOut40 _expressionIassumptions _expressionIbeta _expressionIbetaUnique _expressionIcollectErrors _expressionIcollectInstances _expressionIcollectWarnings _expressionIconstraints _expressionIcounter _expressionIdictionaryEnvironment _expressionIinfoTree _expressionImatchIO _expressionImatches _expressionIpatternMatchWarnings _expressionIself _expressionIunboundNames _expressionIuniqueChunk _expressionIuniqueSecondRound) = inv_Expression_s41 _expressionX41 (T_Expression_vIn40 _expressionOallPatterns _expressionOallTypeSchemes _expressionOambiguousConflicts _expressionOavailablePredicates _expressionObetaUnique _expressionOclassEnvironment _expressionOclassMemberEnv _expressionOclassMemberTypeSchemes _expressionOclassNamesEnv _expressionOclassPredicate _expressionOclassTypeSchemes _expressionOcollectErrors _expressionOcollectWarnings _expressionOcounter _expressionOcurClassPred _expressionOcurPred _expressionOcurrentChunk _expressionOdictionaryEnvironment _expressionOimportEnvironment _expressionOinstanceName _expressionOinstanceTypes _expressionOmatchIO _expressionOmoduleName _expressionOmonos _expressionOnamesInScope _expressionOorderedTypeSynonyms _expressionOparentTree _expressionOpatternMatchWarnings _expressionOrequiredPredicates _expressionOsubstitution _expressionOtryPatterns _expressionOtypeConstructors _expressionOtypeschemeMap _expressionOuniqueChunk _expressionOuniqueSecondRound _expressionOvariableMapping)
         (T_RecordExpressionBindings_vOut139 _recordExpressionBindingsIcollectErrors _recordExpressionBindingsIcollectInstances _recordExpressionBindingsIcollectWarnings _recordExpressionBindingsIcounter _recordExpressionBindingsIdictionaryEnvironment _recordExpressionBindingsIpatternMatchWarnings _recordExpressionBindingsIself _recordExpressionBindingsIunboundNames _recordExpressionBindingsIuniqueChunk) = inv_RecordExpressionBindings_s140 _recordExpressionBindingsX140 (T_RecordExpressionBindings_vIn139 _recordExpressionBindingsOallTypeSchemes _recordExpressionBindingsOambiguousConflicts _recordExpressionBindingsOavailablePredicates _recordExpressionBindingsOclassEnvironment _recordExpressionBindingsOclassMemberEnv _recordExpressionBindingsOclassMemberTypeSchemes _recordExpressionBindingsOclassNamesEnv _recordExpressionBindingsOclassPredicate _recordExpressionBindingsOclassTypeSchemes _recordExpressionBindingsOcollectErrors _recordExpressionBindingsOcollectWarnings _recordExpressionBindingsOcounter _recordExpressionBindingsOcurClassPred _recordExpressionBindingsOcurPred _recordExpressionBindingsOcurrentChunk _recordExpressionBindingsOdictionaryEnvironment _recordExpressionBindingsOimportEnvironment _recordExpressionBindingsOinstanceName _recordExpressionBindingsOinstanceTypes _recordExpressionBindingsOmoduleName _recordExpressionBindingsOnamesInScope _recordExpressionBindingsOorderedTypeSynonyms _recordExpressionBindingsOpatternMatchWarnings _recordExpressionBindingsOrequiredPredicates _recordExpressionBindingsOsubstitution _recordExpressionBindingsOtypeschemeMap _recordExpressionBindingsOuniqueChunk _recordExpressionBindingsOvariableMapping)
         _lhsOcollectInstances :: [(Name, Instance)]
         _lhsOcollectInstances = rule2393 _expressionIcollectInstances _recordExpressionBindingsIcollectInstances
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule2394 _expressionIunboundNames _recordExpressionBindingsIunboundNames
         _self = rule2395 _expressionIself _rangeIself _recordExpressionBindingsIself
         _lhsOself :: Expression
         _lhsOself = rule2396 _self
         _lhsOassumptions :: Assumptions
         _lhsOassumptions = rule2397 _expressionIassumptions
         _lhsObeta :: Tp
         _lhsObeta = rule2398 _expressionIbeta
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule2399 _expressionIbetaUnique
         _lhsOcollectErrors :: TypeErrors
         _lhsOcollectErrors = rule2400 _recordExpressionBindingsIcollectErrors
         _lhsOcollectWarnings :: Warnings
         _lhsOcollectWarnings = rule2401 _recordExpressionBindingsIcollectWarnings
         _lhsOconstraints :: ConstraintSet
         _lhsOconstraints = rule2402 _expressionIconstraints
         _lhsOcounter :: Int
         _lhsOcounter = rule2403 _recordExpressionBindingsIcounter
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule2404 _recordExpressionBindingsIdictionaryEnvironment
         _lhsOinfoTree :: InfoTree
         _lhsOinfoTree = rule2405 _expressionIinfoTree
         _lhsOmatchIO :: IO ()
         _lhsOmatchIO = rule2406 _expressionImatchIO
         _lhsOmatches :: [Maybe MetaVariableTable]
         _lhsOmatches = rule2407 _expressionImatches
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule2408 _recordExpressionBindingsIpatternMatchWarnings
         _lhsOuniqueChunk :: Int
         _lhsOuniqueChunk = rule2409 _recordExpressionBindingsIuniqueChunk
         _lhsOuniqueSecondRound :: Int
         _lhsOuniqueSecondRound = rule2410 _expressionIuniqueSecondRound
         _expressionOallPatterns = rule2411 _lhsIallPatterns
         _expressionOallTypeSchemes = rule2412 _lhsIallTypeSchemes
         _expressionOambiguousConflicts = rule2413 _lhsIambiguousConflicts
         _expressionOavailablePredicates = rule2414 _lhsIavailablePredicates
         _expressionObetaUnique = rule2415 _lhsIbetaUnique
         _expressionOclassEnvironment = rule2416 _lhsIclassEnvironment
         _expressionOclassMemberEnv = rule2417 _lhsIclassMemberEnv
         _expressionOclassMemberTypeSchemes = rule2418 _lhsIclassMemberTypeSchemes
         _expressionOclassNamesEnv = rule2419 _lhsIclassNamesEnv
         _expressionOclassPredicate = rule2420 _lhsIclassPredicate
         _expressionOclassTypeSchemes = rule2421 _lhsIclassTypeSchemes
         _expressionOcollectErrors = rule2422 _lhsIcollectErrors
         _expressionOcollectWarnings = rule2423 _lhsIcollectWarnings
         _expressionOcounter = rule2424 _lhsIcounter
         _expressionOcurClassPred = rule2425 _lhsIcurClassPred
         _expressionOcurPred = rule2426 _lhsIcurPred
         _expressionOcurrentChunk = rule2427 _lhsIcurrentChunk
         _expressionOdictionaryEnvironment = rule2428 _lhsIdictionaryEnvironment
         _expressionOimportEnvironment = rule2429 _lhsIimportEnvironment
         _expressionOinstanceName = rule2430 _lhsIinstanceName
         _expressionOinstanceTypes = rule2431 _lhsIinstanceTypes
         _expressionOmatchIO = rule2432 _lhsImatchIO
         _expressionOmoduleName = rule2433 _lhsImoduleName
         _expressionOmonos = rule2434 _lhsImonos
         _expressionOnamesInScope = rule2435 _lhsInamesInScope
         _expressionOorderedTypeSynonyms = rule2436 _lhsIorderedTypeSynonyms
         _expressionOparentTree = rule2437 _lhsIparentTree
         _expressionOpatternMatchWarnings = rule2438 _lhsIpatternMatchWarnings
         _expressionOrequiredPredicates = rule2439 _lhsIrequiredPredicates
         _expressionOsubstitution = rule2440 _lhsIsubstitution
         _expressionOtryPatterns = rule2441 _lhsItryPatterns
         _expressionOtypeConstructors = rule2442 _lhsItypeConstructors
         _expressionOtypeschemeMap = rule2443 _lhsItypeschemeMap
         _expressionOuniqueChunk = rule2444 _lhsIuniqueChunk
         _expressionOuniqueSecondRound = rule2445 _lhsIuniqueSecondRound
         _expressionOvariableMapping = rule2446 _lhsIvariableMapping
         _recordExpressionBindingsOallTypeSchemes = rule2447 _lhsIallTypeSchemes
         _recordExpressionBindingsOambiguousConflicts = rule2448 _lhsIambiguousConflicts
         _recordExpressionBindingsOavailablePredicates = rule2449 _lhsIavailablePredicates
         _recordExpressionBindingsOclassEnvironment = rule2450 _lhsIclassEnvironment
         _recordExpressionBindingsOclassMemberEnv = rule2451 _lhsIclassMemberEnv
         _recordExpressionBindingsOclassMemberTypeSchemes = rule2452 _lhsIclassMemberTypeSchemes
         _recordExpressionBindingsOclassNamesEnv = rule2453 _lhsIclassNamesEnv
         _recordExpressionBindingsOclassPredicate = rule2454 _lhsIclassPredicate
         _recordExpressionBindingsOclassTypeSchemes = rule2455 _lhsIclassTypeSchemes
         _recordExpressionBindingsOcollectErrors = rule2456 _expressionIcollectErrors
         _recordExpressionBindingsOcollectWarnings = rule2457 _expressionIcollectWarnings
         _recordExpressionBindingsOcounter = rule2458 _expressionIcounter
         _recordExpressionBindingsOcurClassPred = rule2459 _lhsIcurClassPred
         _recordExpressionBindingsOcurPred = rule2460 _lhsIcurPred
         _recordExpressionBindingsOcurrentChunk = rule2461 _lhsIcurrentChunk
         _recordExpressionBindingsOdictionaryEnvironment = rule2462 _expressionIdictionaryEnvironment
         _recordExpressionBindingsOimportEnvironment = rule2463 _lhsIimportEnvironment
         _recordExpressionBindingsOinstanceName = rule2464 _lhsIinstanceName
         _recordExpressionBindingsOinstanceTypes = rule2465 _lhsIinstanceTypes
         _recordExpressionBindingsOmoduleName = rule2466 _lhsImoduleName
         _recordExpressionBindingsOnamesInScope = rule2467 _lhsInamesInScope
         _recordExpressionBindingsOorderedTypeSynonyms = rule2468 _lhsIorderedTypeSynonyms
         _recordExpressionBindingsOpatternMatchWarnings = rule2469 _expressionIpatternMatchWarnings
         _recordExpressionBindingsOrequiredPredicates = rule2470 _lhsIrequiredPredicates
         _recordExpressionBindingsOsubstitution = rule2471 _lhsIsubstitution
         _recordExpressionBindingsOtypeschemeMap = rule2472 _lhsItypeschemeMap
         _recordExpressionBindingsOuniqueChunk = rule2473 _expressionIuniqueChunk
         _recordExpressionBindingsOvariableMapping = rule2474 _lhsIvariableMapping
         !__result_ = T_Expression_vOut40 _lhsOassumptions _lhsObeta _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraints _lhsOcounter _lhsOdictionaryEnvironment _lhsOinfoTree _lhsOmatchIO _lhsOmatches _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOuniqueSecondRound
         in __result_ )
     in C_Expression_s41 v40
   {-# INLINE rule2393 #-}
   rule2393 = \ ((_expressionIcollectInstances) :: [(Name, Instance)]) ((_recordExpressionBindingsIcollectInstances) :: [(Name, Instance)]) ->
     _expressionIcollectInstances  ++  _recordExpressionBindingsIcollectInstances
   {-# INLINE rule2394 #-}
   rule2394 = \ ((_expressionIunboundNames) :: Names) ((_recordExpressionBindingsIunboundNames) :: Names) ->
     ((++) _expressionIunboundNames _recordExpressionBindingsIunboundNames)
   {-# INLINE rule2395 #-}
   rule2395 = \ ((_expressionIself) :: Expression) ((_rangeIself) :: Range) ((_recordExpressionBindingsIself) :: RecordExpressionBindings) ->
     Expression_RecordUpdate _rangeIself _expressionIself _recordExpressionBindingsIself
   {-# INLINE rule2396 #-}
   rule2396 = \ _self ->
     _self
   {-# INLINE rule2397 #-}
   rule2397 = \ ((_expressionIassumptions) :: Assumptions) ->
     _expressionIassumptions
   {-# INLINE rule2398 #-}
   rule2398 = \ ((_expressionIbeta) :: Tp) ->
     _expressionIbeta
   {-# INLINE rule2399 #-}
   rule2399 = \ ((_expressionIbetaUnique) :: Int) ->
     _expressionIbetaUnique
   {-# INLINE rule2400 #-}
   rule2400 = \ ((_recordExpressionBindingsIcollectErrors) :: TypeErrors) ->
     _recordExpressionBindingsIcollectErrors
   {-# INLINE rule2401 #-}
   rule2401 = \ ((_recordExpressionBindingsIcollectWarnings) :: Warnings) ->
     _recordExpressionBindingsIcollectWarnings
   {-# INLINE rule2402 #-}
   rule2402 = \ ((_expressionIconstraints) :: ConstraintSet) ->
     _expressionIconstraints
   {-# INLINE rule2403 #-}
   rule2403 = \ ((_recordExpressionBindingsIcounter) :: Int) ->
     _recordExpressionBindingsIcounter
   {-# INLINE rule2404 #-}
   rule2404 = \ ((_recordExpressionBindingsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _recordExpressionBindingsIdictionaryEnvironment
   {-# INLINE rule2405 #-}
   rule2405 = \ ((_expressionIinfoTree) :: InfoTree) ->
     _expressionIinfoTree
   {-# INLINE rule2406 #-}
   rule2406 = \ ((_expressionImatchIO) :: IO ()) ->
     _expressionImatchIO
   {-# INLINE rule2407 #-}
   rule2407 = \ ((_expressionImatches) :: [Maybe MetaVariableTable]) ->
     _expressionImatches
   {-# INLINE rule2408 #-}
   rule2408 = \ ((_recordExpressionBindingsIpatternMatchWarnings) :: [Warning]) ->
     _recordExpressionBindingsIpatternMatchWarnings
   {-# INLINE rule2409 #-}
   rule2409 = \ ((_recordExpressionBindingsIuniqueChunk) :: Int) ->
     _recordExpressionBindingsIuniqueChunk
   {-# INLINE rule2410 #-}
   rule2410 = \ ((_expressionIuniqueSecondRound) :: Int) ->
     _expressionIuniqueSecondRound
   {-# INLINE rule2411 #-}
   rule2411 = \ ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ->
     _lhsIallPatterns
   {-# INLINE rule2412 #-}
   rule2412 = \ ((_lhsIallTypeSchemes) :: M.Map NameWithRange TpScheme) ->
     _lhsIallTypeSchemes
   {-# INLINE rule2413 #-}
   rule2413 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule2414 #-}
   rule2414 = \ ((_lhsIavailablePredicates) :: [PredicateWithSource]) ->
     _lhsIavailablePredicates
   {-# INLINE rule2415 #-}
   rule2415 = \ ((_lhsIbetaUnique) :: Int) ->
     _lhsIbetaUnique
   {-# INLINE rule2416 #-}
   rule2416 = \ ((_lhsIclassEnvironment) :: ClassEnvironment) ->
     _lhsIclassEnvironment
   {-# INLINE rule2417 #-}
   rule2417 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule2418 #-}
   rule2418 = \ ((_lhsIclassMemberTypeSchemes) :: Maybe [(Name, TpScheme)]) ->
     _lhsIclassMemberTypeSchemes
   {-# INLINE rule2419 #-}
   rule2419 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule2420 #-}
   rule2420 = \ ((_lhsIclassPredicate) :: Maybe (Name, Names)) ->
     _lhsIclassPredicate
   {-# INLINE rule2421 #-}
   rule2421 = \ ((_lhsIclassTypeSchemes) :: M.Map Name TpScheme) ->
     _lhsIclassTypeSchemes
   {-# INLINE rule2422 #-}
   rule2422 = \ ((_lhsIcollectErrors) :: TypeErrors) ->
     _lhsIcollectErrors
   {-# INLINE rule2423 #-}
   rule2423 = \ ((_lhsIcollectWarnings) :: Warnings) ->
     _lhsIcollectWarnings
   {-# INLINE rule2424 #-}
   rule2424 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule2425 #-}
   rule2425 = \ ((_lhsIcurClassPred) :: Maybe Predicate) ->
     _lhsIcurClassPred
   {-# INLINE rule2426 #-}
   rule2426 = \ ((_lhsIcurPred) :: Maybe Predicate) ->
     _lhsIcurPred
   {-# INLINE rule2427 #-}
   rule2427 = \ ((_lhsIcurrentChunk) :: Int) ->
     _lhsIcurrentChunk
   {-# INLINE rule2428 #-}
   rule2428 = \ ((_lhsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _lhsIdictionaryEnvironment
   {-# INLINE rule2429 #-}
   rule2429 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule2430 #-}
   rule2430 = \ ((_lhsIinstanceName) :: Maybe Name) ->
     _lhsIinstanceName
   {-# INLINE rule2431 #-}
   rule2431 = \ ((_lhsIinstanceTypes) :: [(Name, TpScheme)]) ->
     _lhsIinstanceTypes
   {-# INLINE rule2432 #-}
   rule2432 = \ ((_lhsImatchIO) :: IO ()) ->
     _lhsImatchIO
   {-# INLINE rule2433 #-}
   rule2433 = \ ((_lhsImoduleName) :: Maybe Name) ->
     _lhsImoduleName
   {-# INLINE rule2434 #-}
   rule2434 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule2435 #-}
   rule2435 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule2436 #-}
   rule2436 = \ ((_lhsIorderedTypeSynonyms) :: OrderedTypeSynonyms) ->
     _lhsIorderedTypeSynonyms
   {-# INLINE rule2437 #-}
   rule2437 = \ ((_lhsIparentTree) :: InfoTree) ->
     _lhsIparentTree
   {-# INLINE rule2438 #-}
   rule2438 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule2439 #-}
   rule2439 = \ ((_lhsIrequiredPredicates) :: Predicates) ->
     _lhsIrequiredPredicates
   {-# INLINE rule2440 #-}
   rule2440 = \ ((_lhsIsubstitution) :: FixpointSubstitution) ->
     _lhsIsubstitution
   {-# INLINE rule2441 #-}
   rule2441 = \ ((_lhsItryPatterns) :: [(Expression     , [String])]) ->
     _lhsItryPatterns
   {-# INLINE rule2442 #-}
   rule2442 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
   {-# INLINE rule2443 #-}
   rule2443 = \ ((_lhsItypeschemeMap) :: M.Map Int (Scheme Predicates)) ->
     _lhsItypeschemeMap
   {-# INLINE rule2444 #-}
   rule2444 = \ ((_lhsIuniqueChunk) :: Int) ->
     _lhsIuniqueChunk
   {-# INLINE rule2445 #-}
   rule2445 = \ ((_lhsIuniqueSecondRound) :: Int) ->
     _lhsIuniqueSecondRound
   {-# INLINE rule2446 #-}
   rule2446 = \ ((_lhsIvariableMapping) :: Maybe [(Name, Tp)]) ->
     _lhsIvariableMapping
   {-# INLINE rule2447 #-}
   rule2447 = \ ((_lhsIallTypeSchemes) :: M.Map NameWithRange TpScheme) ->
     _lhsIallTypeSchemes
   {-# INLINE rule2448 #-}
   rule2448 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule2449 #-}
   rule2449 = \ ((_lhsIavailablePredicates) :: [PredicateWithSource]) ->
     _lhsIavailablePredicates
   {-# INLINE rule2450 #-}
   rule2450 = \ ((_lhsIclassEnvironment) :: ClassEnvironment) ->
     _lhsIclassEnvironment
   {-# INLINE rule2451 #-}
   rule2451 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule2452 #-}
   rule2452 = \ ((_lhsIclassMemberTypeSchemes) :: Maybe [(Name, TpScheme)]) ->
     _lhsIclassMemberTypeSchemes
   {-# INLINE rule2453 #-}
   rule2453 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule2454 #-}
   rule2454 = \ ((_lhsIclassPredicate) :: Maybe (Name, Names)) ->
     _lhsIclassPredicate
   {-# INLINE rule2455 #-}
   rule2455 = \ ((_lhsIclassTypeSchemes) :: M.Map Name TpScheme) ->
     _lhsIclassTypeSchemes
   {-# INLINE rule2456 #-}
   rule2456 = \ ((_expressionIcollectErrors) :: TypeErrors) ->
     _expressionIcollectErrors
   {-# INLINE rule2457 #-}
   rule2457 = \ ((_expressionIcollectWarnings) :: Warnings) ->
     _expressionIcollectWarnings
   {-# INLINE rule2458 #-}
   rule2458 = \ ((_expressionIcounter) :: Int) ->
     _expressionIcounter
   {-# INLINE rule2459 #-}
   rule2459 = \ ((_lhsIcurClassPred) :: Maybe Predicate) ->
     _lhsIcurClassPred
   {-# INLINE rule2460 #-}
   rule2460 = \ ((_lhsIcurPred) :: Maybe Predicate) ->
     _lhsIcurPred
   {-# INLINE rule2461 #-}
   rule2461 = \ ((_lhsIcurrentChunk) :: Int) ->
     _lhsIcurrentChunk
   {-# INLINE rule2462 #-}
   rule2462 = \ ((_expressionIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _expressionIdictionaryEnvironment
   {-# INLINE rule2463 #-}
   rule2463 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule2464 #-}
   rule2464 = \ ((_lhsIinstanceName) :: Maybe Name) ->
     _lhsIinstanceName
   {-# INLINE rule2465 #-}
   rule2465 = \ ((_lhsIinstanceTypes) :: [(Name, TpScheme)]) ->
     _lhsIinstanceTypes
   {-# INLINE rule2466 #-}
   rule2466 = \ ((_lhsImoduleName) :: Maybe Name) ->
     _lhsImoduleName
   {-# INLINE rule2467 #-}
   rule2467 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule2468 #-}
   rule2468 = \ ((_lhsIorderedTypeSynonyms) :: OrderedTypeSynonyms) ->
     _lhsIorderedTypeSynonyms
   {-# INLINE rule2469 #-}
   rule2469 = \ ((_expressionIpatternMatchWarnings) :: [Warning]) ->
     _expressionIpatternMatchWarnings
   {-# INLINE rule2470 #-}
   rule2470 = \ ((_lhsIrequiredPredicates) :: Predicates) ->
     _lhsIrequiredPredicates
   {-# INLINE rule2471 #-}
   rule2471 = \ ((_lhsIsubstitution) :: FixpointSubstitution) ->
     _lhsIsubstitution
   {-# INLINE rule2472 #-}
   rule2472 = \ ((_lhsItypeschemeMap) :: M.Map Int (Scheme Predicates)) ->
     _lhsItypeschemeMap
   {-# INLINE rule2473 #-}
   rule2473 = \ ((_expressionIuniqueChunk) :: Int) ->
     _expressionIuniqueChunk
   {-# INLINE rule2474 #-}
   rule2474 = \ ((_lhsIvariableMapping) :: Maybe [(Name, Tp)]) ->
     _lhsIvariableMapping
{-# NOINLINE sem_Expression_Enum #-}
sem_Expression_Enum :: T_Range  -> T_Expression  -> T_MaybeExpression  -> T_MaybeExpression  -> T_Expression 
sem_Expression_Enum arg_range_ arg_from_ arg_then_ arg_to_ = T_Expression (return st41) where
   {-# NOINLINE st41 #-}
   !st41 = let
      v40 :: T_Expression_v40 
      v40 = \ !(T_Expression_vIn40 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItryPatterns _lhsItypeConstructors _lhsItypeschemeMap _lhsIuniqueChunk _lhsIuniqueSecondRound _lhsIvariableMapping) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _fromX41 = Control.Monad.Identity.runIdentity (attach_T_Expression (arg_from_))
         _thenX95 = Control.Monad.Identity.runIdentity (attach_T_MaybeExpression (arg_then_))
         _toX95 = Control.Monad.Identity.runIdentity (attach_T_MaybeExpression (arg_to_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_Expression_vOut40 _fromIassumptions _fromIbeta _fromIbetaUnique _fromIcollectErrors _fromIcollectInstances _fromIcollectWarnings _fromIconstraints _fromIcounter _fromIdictionaryEnvironment _fromIinfoTree _fromImatchIO _fromImatches _fromIpatternMatchWarnings _fromIself _fromIunboundNames _fromIuniqueChunk _fromIuniqueSecondRound) = inv_Expression_s41 _fromX41 (T_Expression_vIn40 _fromOallPatterns _fromOallTypeSchemes _fromOambiguousConflicts _fromOavailablePredicates _fromObetaUnique _fromOclassEnvironment _fromOclassMemberEnv _fromOclassMemberTypeSchemes _fromOclassNamesEnv _fromOclassPredicate _fromOclassTypeSchemes _fromOcollectErrors _fromOcollectWarnings _fromOcounter _fromOcurClassPred _fromOcurPred _fromOcurrentChunk _fromOdictionaryEnvironment _fromOimportEnvironment _fromOinstanceName _fromOinstanceTypes _fromOmatchIO _fromOmoduleName _fromOmonos _fromOnamesInScope _fromOorderedTypeSynonyms _fromOparentTree _fromOpatternMatchWarnings _fromOrequiredPredicates _fromOsubstitution _fromOtryPatterns _fromOtypeConstructors _fromOtypeschemeMap _fromOuniqueChunk _fromOuniqueSecondRound _fromOvariableMapping)
         (T_MaybeExpression_vOut94 _thenIassumptions _thenIbeta _thenIbetaUnique _thenIcollectErrors _thenIcollectInstances _thenIcollectWarnings _thenIconstraints _thenIcounter _thenIdictionaryEnvironment _thenIinfoTrees _thenImatchIO _thenImatches _thenIpatternMatchWarnings _thenIsection _thenIself _thenIunboundNames _thenIuniqueChunk _thenIuniqueSecondRound) = inv_MaybeExpression_s95 _thenX95 (T_MaybeExpression_vIn94 _thenOallPatterns _thenOallTypeSchemes _thenOambiguousConflicts _thenOavailablePredicates _thenObetaUnique _thenOclassEnvironment _thenOclassMemberEnv _thenOclassMemberTypeSchemes _thenOclassNamesEnv _thenOclassPredicate _thenOclassTypeSchemes _thenOcollectErrors _thenOcollectWarnings _thenOcounter _thenOcurClassPred _thenOcurPred _thenOcurrentChunk _thenOdictionaryEnvironment _thenOimportEnvironment _thenOinstanceName _thenOinstanceTypes _thenOmatchIO _thenOmoduleName _thenOmonos _thenOnamesInScope _thenOorderedTypeSynonyms _thenOparentTree _thenOpatternMatchWarnings _thenOrequiredPredicates _thenOsubstitution _thenOtryPatterns _thenOtypeConstructors _thenOtypeschemeMap _thenOuniqueChunk _thenOuniqueSecondRound _thenOvariableMapping)
         (T_MaybeExpression_vOut94 _toIassumptions _toIbeta _toIbetaUnique _toIcollectErrors _toIcollectInstances _toIcollectWarnings _toIconstraints _toIcounter _toIdictionaryEnvironment _toIinfoTrees _toImatchIO _toImatches _toIpatternMatchWarnings _toIsection _toIself _toIunboundNames _toIuniqueChunk _toIuniqueSecondRound) = inv_MaybeExpression_s95 _toX95 (T_MaybeExpression_vIn94 _toOallPatterns _toOallTypeSchemes _toOambiguousConflicts _toOavailablePredicates _toObetaUnique _toOclassEnvironment _toOclassMemberEnv _toOclassMemberTypeSchemes _toOclassNamesEnv _toOclassPredicate _toOclassTypeSchemes _toOcollectErrors _toOcollectWarnings _toOcounter _toOcurClassPred _toOcurPred _toOcurrentChunk _toOdictionaryEnvironment _toOimportEnvironment _toOinstanceName _toOinstanceTypes _toOmatchIO _toOmoduleName _toOmonos _toOnamesInScope _toOorderedTypeSynonyms _toOparentTree _toOpatternMatchWarnings _toOrequiredPredicates _toOsubstitution _toOtryPatterns _toOtypeConstructors _toOtypeschemeMap _toOuniqueChunk _toOuniqueSecondRound _toOvariableMapping)
         _lhsOmatches :: [Maybe MetaVariableTable]
         _lhsOconstraints :: ConstraintSet
         _lhsOassumptions :: Assumptions
         _lhsOuniqueSecondRound :: Int
         ((_fromOtryPatterns,_thenOtryPatterns,_toOtryPatterns),_lhsOmatches,_lhsOconstraints,_lhsOassumptions,_lhsOuniqueSecondRound,_ioMatch) = rule2475 _assumptions _constraints _fromImatches _lhsIallPatterns _lhsItryPatterns _localInfo _thenImatches _toImatches _toIuniqueSecondRound
         _lhsOmatchIO :: IO ()
         _lhsOmatchIO = rule2476 _ioMatch _toImatchIO
         _parentTree = rule2477 _fromIinfoTree _lhsIparentTree _localInfo _thenIinfoTrees _toIinfoTrees
         _lhsOinfoTree :: InfoTree
         _lhsOinfoTree = rule2478 _parentTree
         _localInfo = rule2479 _beta _lhsImonos _self
         _cinfoFrom = rule2480 _parentTree
         _cinfoThen = rule2481 _parentTree
         _toChildNr = rule2482 _thenIinfoTrees
         _cinfoTo = rule2483 _parentTree _toChildNr
         _cinfoResult = rule2484 _parentTree
         _cinfoPred = rule2485 _elementType _parentTree
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule2486 _newDEnv
         _localName = rule2487 _rangeIself _thenIsection _toIsection
         _requiredDictionaries = rule2488 _elementType _lhsIsubstitution _overloaded
         _newDEnv = rule2489 _lhsIavailablePredicates _lhsIclassEnvironment _lhsIcurPred _lhsIinstanceName _lhsIsubstitution _localName _requiredDictionaries _toIdictionaryEnvironment
         _fromObetaUnique = rule2490 _lhsIbetaUnique _overloaded
         _assumptions = rule2491 _fromIassumptions _thenIassumptions _toIassumptions
         _constraints = rule2492 _conFrom _conList _conPredicate _conThen _conTo _fromIconstraints _thenIconstraints _toIconstraints
         _beta = rule2493 _lhsIbetaUnique
         _overloaded = rule2494 _lhsIimportEnvironment
         _elementType = rule2495 _lhsIbetaUnique _overloaded
         _conPredicate = rule2496 _cinfoPred _elementType _overloaded
         _conList = rule2497 _beta _cinfoResult _elementType
         _conFrom = rule2498 _cinfoFrom _elementType _fromIbeta
         _conThen = rule2499 _cinfoThen _elementType _thenIbeta
         _conTo = rule2500 _cinfoTo _elementType _toIbeta
         _lhsOcollectInstances :: [(Name, Instance)]
         _lhsOcollectInstances = rule2501 _fromIcollectInstances _thenIcollectInstances _toIcollectInstances
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule2502 _fromIunboundNames _thenIunboundNames _toIunboundNames
         _self = rule2503 _fromIself _rangeIself _thenIself _toIself
         _lhsOself :: Expression
         _lhsOself = rule2504 _self
         _lhsObeta :: Tp
         _lhsObeta = rule2505 _beta
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule2506 _toIbetaUnique
         _lhsOcollectErrors :: TypeErrors
         _lhsOcollectErrors = rule2507 _toIcollectErrors
         _lhsOcollectWarnings :: Warnings
         _lhsOcollectWarnings = rule2508 _toIcollectWarnings
         _lhsOcounter :: Int
         _lhsOcounter = rule2509 _toIcounter
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule2510 _toIpatternMatchWarnings
         _lhsOuniqueChunk :: Int
         _lhsOuniqueChunk = rule2511 _toIuniqueChunk
         _fromOallPatterns = rule2512 _lhsIallPatterns
         _fromOallTypeSchemes = rule2513 _lhsIallTypeSchemes
         _fromOambiguousConflicts = rule2514 _lhsIambiguousConflicts
         _fromOavailablePredicates = rule2515 _lhsIavailablePredicates
         _fromOclassEnvironment = rule2516 _lhsIclassEnvironment
         _fromOclassMemberEnv = rule2517 _lhsIclassMemberEnv
         _fromOclassMemberTypeSchemes = rule2518 _lhsIclassMemberTypeSchemes
         _fromOclassNamesEnv = rule2519 _lhsIclassNamesEnv
         _fromOclassPredicate = rule2520 _lhsIclassPredicate
         _fromOclassTypeSchemes = rule2521 _lhsIclassTypeSchemes
         _fromOcollectErrors = rule2522 _lhsIcollectErrors
         _fromOcollectWarnings = rule2523 _lhsIcollectWarnings
         _fromOcounter = rule2524 _lhsIcounter
         _fromOcurClassPred = rule2525 _lhsIcurClassPred
         _fromOcurPred = rule2526 _lhsIcurPred
         _fromOcurrentChunk = rule2527 _lhsIcurrentChunk
         _fromOdictionaryEnvironment = rule2528 _lhsIdictionaryEnvironment
         _fromOimportEnvironment = rule2529 _lhsIimportEnvironment
         _fromOinstanceName = rule2530 _lhsIinstanceName
         _fromOinstanceTypes = rule2531 _lhsIinstanceTypes
         _fromOmatchIO = rule2532 _lhsImatchIO
         _fromOmoduleName = rule2533 _lhsImoduleName
         _fromOmonos = rule2534 _lhsImonos
         _fromOnamesInScope = rule2535 _lhsInamesInScope
         _fromOorderedTypeSynonyms = rule2536 _lhsIorderedTypeSynonyms
         _fromOparentTree = rule2537 _parentTree
         _fromOpatternMatchWarnings = rule2538 _lhsIpatternMatchWarnings
         _fromOrequiredPredicates = rule2539 _lhsIrequiredPredicates
         _fromOsubstitution = rule2540 _lhsIsubstitution
         _fromOtypeConstructors = rule2541 _lhsItypeConstructors
         _fromOtypeschemeMap = rule2542 _lhsItypeschemeMap
         _fromOuniqueChunk = rule2543 _lhsIuniqueChunk
         _fromOuniqueSecondRound = rule2544 _lhsIuniqueSecondRound
         _fromOvariableMapping = rule2545 _lhsIvariableMapping
         _thenOallPatterns = rule2546 _lhsIallPatterns
         _thenOallTypeSchemes = rule2547 _lhsIallTypeSchemes
         _thenOambiguousConflicts = rule2548 _lhsIambiguousConflicts
         _thenOavailablePredicates = rule2549 _lhsIavailablePredicates
         _thenObetaUnique = rule2550 _fromIbetaUnique
         _thenOclassEnvironment = rule2551 _lhsIclassEnvironment
         _thenOclassMemberEnv = rule2552 _lhsIclassMemberEnv
         _thenOclassMemberTypeSchemes = rule2553 _lhsIclassMemberTypeSchemes
         _thenOclassNamesEnv = rule2554 _lhsIclassNamesEnv
         _thenOclassPredicate = rule2555 _lhsIclassPredicate
         _thenOclassTypeSchemes = rule2556 _lhsIclassTypeSchemes
         _thenOcollectErrors = rule2557 _fromIcollectErrors
         _thenOcollectWarnings = rule2558 _fromIcollectWarnings
         _thenOcounter = rule2559 _fromIcounter
         _thenOcurClassPred = rule2560 _lhsIcurClassPred
         _thenOcurPred = rule2561 _lhsIcurPred
         _thenOcurrentChunk = rule2562 _lhsIcurrentChunk
         _thenOdictionaryEnvironment = rule2563 _fromIdictionaryEnvironment
         _thenOimportEnvironment = rule2564 _lhsIimportEnvironment
         _thenOinstanceName = rule2565 _lhsIinstanceName
         _thenOinstanceTypes = rule2566 _lhsIinstanceTypes
         _thenOmatchIO = rule2567 _fromImatchIO
         _thenOmoduleName = rule2568 _lhsImoduleName
         _thenOmonos = rule2569 _lhsImonos
         _thenOnamesInScope = rule2570 _lhsInamesInScope
         _thenOorderedTypeSynonyms = rule2571 _lhsIorderedTypeSynonyms
         _thenOparentTree = rule2572 _parentTree
         _thenOpatternMatchWarnings = rule2573 _fromIpatternMatchWarnings
         _thenOrequiredPredicates = rule2574 _lhsIrequiredPredicates
         _thenOsubstitution = rule2575 _lhsIsubstitution
         _thenOtypeConstructors = rule2576 _lhsItypeConstructors
         _thenOtypeschemeMap = rule2577 _lhsItypeschemeMap
         _thenOuniqueChunk = rule2578 _fromIuniqueChunk
         _thenOuniqueSecondRound = rule2579 _fromIuniqueSecondRound
         _thenOvariableMapping = rule2580 _lhsIvariableMapping
         _toOallPatterns = rule2581 _lhsIallPatterns
         _toOallTypeSchemes = rule2582 _lhsIallTypeSchemes
         _toOambiguousConflicts = rule2583 _lhsIambiguousConflicts
         _toOavailablePredicates = rule2584 _lhsIavailablePredicates
         _toObetaUnique = rule2585 _thenIbetaUnique
         _toOclassEnvironment = rule2586 _lhsIclassEnvironment
         _toOclassMemberEnv = rule2587 _lhsIclassMemberEnv
         _toOclassMemberTypeSchemes = rule2588 _lhsIclassMemberTypeSchemes
         _toOclassNamesEnv = rule2589 _lhsIclassNamesEnv
         _toOclassPredicate = rule2590 _lhsIclassPredicate
         _toOclassTypeSchemes = rule2591 _lhsIclassTypeSchemes
         _toOcollectErrors = rule2592 _thenIcollectErrors
         _toOcollectWarnings = rule2593 _thenIcollectWarnings
         _toOcounter = rule2594 _thenIcounter
         _toOcurClassPred = rule2595 _lhsIcurClassPred
         _toOcurPred = rule2596 _lhsIcurPred
         _toOcurrentChunk = rule2597 _lhsIcurrentChunk
         _toOdictionaryEnvironment = rule2598 _thenIdictionaryEnvironment
         _toOimportEnvironment = rule2599 _lhsIimportEnvironment
         _toOinstanceName = rule2600 _lhsIinstanceName
         _toOinstanceTypes = rule2601 _lhsIinstanceTypes
         _toOmatchIO = rule2602 _thenImatchIO
         _toOmoduleName = rule2603 _lhsImoduleName
         _toOmonos = rule2604 _lhsImonos
         _toOnamesInScope = rule2605 _lhsInamesInScope
         _toOorderedTypeSynonyms = rule2606 _lhsIorderedTypeSynonyms
         _toOparentTree = rule2607 _parentTree
         _toOpatternMatchWarnings = rule2608 _thenIpatternMatchWarnings
         _toOrequiredPredicates = rule2609 _lhsIrequiredPredicates
         _toOsubstitution = rule2610 _lhsIsubstitution
         _toOtypeConstructors = rule2611 _lhsItypeConstructors
         _toOtypeschemeMap = rule2612 _lhsItypeschemeMap
         _toOuniqueChunk = rule2613 _thenIuniqueChunk
         _toOuniqueSecondRound = rule2614 _thenIuniqueSecondRound
         _toOvariableMapping = rule2615 _lhsIvariableMapping
         !__result_ = T_Expression_vOut40 _lhsOassumptions _lhsObeta _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraints _lhsOcounter _lhsOdictionaryEnvironment _lhsOinfoTree _lhsOmatchIO _lhsOmatches _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOuniqueSecondRound
         in __result_ )
     in C_Expression_s41 v40
   {-# INLINE rule2475 #-}
   rule2475 = \ _assumptions _constraints ((_fromImatches) :: [Maybe MetaVariableTable]) ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ((_lhsItryPatterns) :: [(Expression     , [String])]) _localInfo ((_thenImatches) :: [Maybe MetaVariableTable]) ((_toImatches) :: [Maybe MetaVariableTable]) ((_toIuniqueSecondRound) :: Int) ->
             let infoTuple = metaVarInfo _constraints _assumptions _localInfo
             in match3 infoTuple _toIuniqueSecondRound
                       match_Expression_Enum
                       _lhsItryPatterns _lhsIallPatterns
                       [_fromImatches, _thenImatches, _toImatches]
   {-# INLINE rule2476 #-}
   rule2476 = \ _ioMatch ((_toImatchIO) :: IO ()) ->
                                       _toImatchIO              >> _ioMatch
   {-# INLINE rule2477 #-}
   rule2477 = \ ((_fromIinfoTree) :: InfoTree) ((_lhsIparentTree) :: InfoTree) _localInfo ((_thenIinfoTrees) :: InfoTrees) ((_toIinfoTrees) :: InfoTrees) ->
                            node _lhsIparentTree _localInfo (_fromIinfoTree : _thenIinfoTrees ++ _toIinfoTrees)
   {-# INLINE rule2478 #-}
   rule2478 = \ _parentTree ->
                            _parentTree
   {-# INLINE rule2479 #-}
   rule2479 = \ _beta ((_lhsImonos) :: Monos) _self ->
                            LocalInfo { self = UHA_Expr _self
                                      , assignedType = Just _beta
                                      , monos = _lhsImonos
                                      }
   {-# INLINE rule2480 #-}
   rule2480 = \ _parentTree ->
     childConstraint 0 "enumeration" _parentTree
        []
   {-# INLINE rule2481 #-}
   rule2481 = \ _parentTree ->
     childConstraint 1 "enumeration" _parentTree
        []
   {-# INLINE rule2482 #-}
   rule2482 = \ ((_thenIinfoTrees) :: InfoTrees) ->
                                          1 + length _thenIinfoTrees
   {-# INLINE rule2483 #-}
   rule2483 = \ _parentTree _toChildNr ->
     childConstraint _toChildNr "enumeration" _parentTree
        []
   {-# INLINE rule2484 #-}
   rule2484 = \ _parentTree ->
     resultConstraint "enumeration" _parentTree
        [ FolkloreConstraint ]
   {-# INLINE rule2485 #-}
   rule2485 = \ _elementType _parentTree ->
     resultConstraint "enumeration" _parentTree
        [ ReductionErrorInfo (Predicate "Enum" _elementType) ]
   {-# INLINE rule2486 #-}
   rule2486 = \ _newDEnv ->
                                             _newDEnv
   {-# INLINE rule2487 #-}
   rule2487 = \ ((_rangeIself) :: Range) ((_thenIsection) :: Bool) ((_toIsection) :: Bool) ->
                                             flip setNameRange _rangeIself $
                                             case (_thenIsection, _toIsection) of
                                                (False, False) -> enumFromThenToName
                                                (False, True ) -> enumFromThenName
                                                (True , False) -> enumFromToName
                                                (True , True ) -> enumFromName
   {-# INLINE rule2488 #-}
   rule2488 = \ _elementType ((_lhsIsubstitution) :: FixpointSubstitution) _overloaded ->
                                             if _overloaded then _lhsIsubstitution |-> [PredicateFunction $ Predicate "Prelude.Enum" _elementType] else []
   {-# INLINE rule2489 #-}
   rule2489 = \ ((_lhsIavailablePredicates) :: [PredicateWithSource]) ((_lhsIclassEnvironment) :: ClassEnvironment) ((_lhsIcurPred) :: Maybe Predicate) ((_lhsIinstanceName) :: Maybe Name) ((_lhsIsubstitution) :: FixpointSubstitution) _localName _requiredDictionaries ((_toIdictionaryEnvironment) :: DictionaryEnvironment) ->
                                             resolveOverloading (_lhsIclassEnvironment)  _localName
                                                                (_lhsIsubstitution |-> _lhsIavailablePredicates)
                                                                (_lhsIsubstitution |-> _requiredDictionaries)
                                                                (fmap getNameName _lhsIinstanceName)
                                                                _lhsIcurPred
                                                                _toIdictionaryEnvironment
   {-# INLINE rule2490 #-}
   rule2490 = \ ((_lhsIbetaUnique) :: Int) _overloaded ->
                               _lhsIbetaUnique + (if _overloaded then 2 else 1)
   {-# INLINE rule2491 #-}
   rule2491 = \ ((_fromIassumptions) :: Assumptions) ((_thenIassumptions) :: Assumptions) ((_toIassumptions) :: Assumptions) ->
                               _fromIassumptions `combine` _thenIassumptions `combine` _toIassumptions
   {-# INLINE rule2492 #-}
   rule2492 = \ _conFrom _conList _conPredicate _conThen _conTo ((_fromIconstraints) :: ConstraintSet) ((_thenIconstraints) :: ConstraintSet) ((_toIconstraints) :: ConstraintSet) ->
                               (_conList ++ _conPredicate) .>.
                               Node [ _conFrom .<. _fromIconstraints
                                    , _conThen .<. _thenIconstraints
                                    , _conTo   .<. _toIconstraints
                                    ]
   {-# INLINE rule2493 #-}
   rule2493 = \ ((_lhsIbetaUnique) :: Int) ->
                               TVar _lhsIbetaUnique
   {-# INLINE rule2494 #-}
   rule2494 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
                               case M.lookup enumFromName (typeEnvironment _lhsIimportEnvironment) of
                                  Just scheme -> isOverloaded scheme
                                  Nothing     -> False
   {-# INLINE rule2495 #-}
   rule2495 = \ ((_lhsIbetaUnique) :: Int) _overloaded ->
                               if _overloaded then TVar (_lhsIbetaUnique + 1) else intQualType
   {-# INLINE rule2496 #-}
   rule2496 = \ _cinfoPred _elementType _overloaded ->
                               if _overloaded then [predicate (Predicate "Prelude.Enum" _elementType) _cinfoPred] else []
   {-# INLINE rule2497 #-}
   rule2497 = \ _beta _cinfoResult _elementType ->
                               [ (listType _elementType .==. _beta) _cinfoResult ]
   {-# INLINE rule2498 #-}
   rule2498 = \ _cinfoFrom _elementType ((_fromIbeta) :: Tp) ->
                               [ (_fromIbeta .==. _elementType) _cinfoFrom ]
   {-# INLINE rule2499 #-}
   rule2499 = \ _cinfoThen _elementType ((_thenIbeta) :: Tp) ->
                               [ (_thenIbeta .==. _elementType) _cinfoThen ]
   {-# INLINE rule2500 #-}
   rule2500 = \ _cinfoTo _elementType ((_toIbeta) :: Tp) ->
                               [ (_toIbeta   .==. _elementType) _cinfoTo   ]
   {-# INLINE rule2501 #-}
   rule2501 = \ ((_fromIcollectInstances) :: [(Name, Instance)]) ((_thenIcollectInstances) :: [(Name, Instance)]) ((_toIcollectInstances) :: [(Name, Instance)]) ->
     _fromIcollectInstances  ++  _thenIcollectInstances  ++  _toIcollectInstances
   {-# INLINE rule2502 #-}
   rule2502 = \ ((_fromIunboundNames) :: Names) ((_thenIunboundNames) :: Names) ((_toIunboundNames) :: Names) ->
     ((++) _fromIunboundNames ((++) _thenIunboundNames _toIunboundNames))
   {-# INLINE rule2503 #-}
   rule2503 = \ ((_fromIself) :: Expression) ((_rangeIself) :: Range) ((_thenIself) :: MaybeExpression) ((_toIself) :: MaybeExpression) ->
     Expression_Enum _rangeIself _fromIself _thenIself _toIself
   {-# INLINE rule2504 #-}
   rule2504 = \ _self ->
     _self
   {-# INLINE rule2505 #-}
   rule2505 = \ _beta ->
     _beta
   {-# INLINE rule2506 #-}
   rule2506 = \ ((_toIbetaUnique) :: Int) ->
     _toIbetaUnique
   {-# INLINE rule2507 #-}
   rule2507 = \ ((_toIcollectErrors) :: TypeErrors) ->
     _toIcollectErrors
   {-# INLINE rule2508 #-}
   rule2508 = \ ((_toIcollectWarnings) :: Warnings) ->
     _toIcollectWarnings
   {-# INLINE rule2509 #-}
   rule2509 = \ ((_toIcounter) :: Int) ->
     _toIcounter
   {-# INLINE rule2510 #-}
   rule2510 = \ ((_toIpatternMatchWarnings) :: [Warning]) ->
     _toIpatternMatchWarnings
   {-# INLINE rule2511 #-}
   rule2511 = \ ((_toIuniqueChunk) :: Int) ->
     _toIuniqueChunk
   {-# INLINE rule2512 #-}
   rule2512 = \ ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ->
     _lhsIallPatterns
   {-# INLINE rule2513 #-}
   rule2513 = \ ((_lhsIallTypeSchemes) :: M.Map NameWithRange TpScheme) ->
     _lhsIallTypeSchemes
   {-# INLINE rule2514 #-}
   rule2514 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule2515 #-}
   rule2515 = \ ((_lhsIavailablePredicates) :: [PredicateWithSource]) ->
     _lhsIavailablePredicates
   {-# INLINE rule2516 #-}
   rule2516 = \ ((_lhsIclassEnvironment) :: ClassEnvironment) ->
     _lhsIclassEnvironment
   {-# INLINE rule2517 #-}
   rule2517 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule2518 #-}
   rule2518 = \ ((_lhsIclassMemberTypeSchemes) :: Maybe [(Name, TpScheme)]) ->
     _lhsIclassMemberTypeSchemes
   {-# INLINE rule2519 #-}
   rule2519 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule2520 #-}
   rule2520 = \ ((_lhsIclassPredicate) :: Maybe (Name, Names)) ->
     _lhsIclassPredicate
   {-# INLINE rule2521 #-}
   rule2521 = \ ((_lhsIclassTypeSchemes) :: M.Map Name TpScheme) ->
     _lhsIclassTypeSchemes
   {-# INLINE rule2522 #-}
   rule2522 = \ ((_lhsIcollectErrors) :: TypeErrors) ->
     _lhsIcollectErrors
   {-# INLINE rule2523 #-}
   rule2523 = \ ((_lhsIcollectWarnings) :: Warnings) ->
     _lhsIcollectWarnings
   {-# INLINE rule2524 #-}
   rule2524 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule2525 #-}
   rule2525 = \ ((_lhsIcurClassPred) :: Maybe Predicate) ->
     _lhsIcurClassPred
   {-# INLINE rule2526 #-}
   rule2526 = \ ((_lhsIcurPred) :: Maybe Predicate) ->
     _lhsIcurPred
   {-# INLINE rule2527 #-}
   rule2527 = \ ((_lhsIcurrentChunk) :: Int) ->
     _lhsIcurrentChunk
   {-# INLINE rule2528 #-}
   rule2528 = \ ((_lhsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _lhsIdictionaryEnvironment
   {-# INLINE rule2529 #-}
   rule2529 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule2530 #-}
   rule2530 = \ ((_lhsIinstanceName) :: Maybe Name) ->
     _lhsIinstanceName
   {-# INLINE rule2531 #-}
   rule2531 = \ ((_lhsIinstanceTypes) :: [(Name, TpScheme)]) ->
     _lhsIinstanceTypes
   {-# INLINE rule2532 #-}
   rule2532 = \ ((_lhsImatchIO) :: IO ()) ->
     _lhsImatchIO
   {-# INLINE rule2533 #-}
   rule2533 = \ ((_lhsImoduleName) :: Maybe Name) ->
     _lhsImoduleName
   {-# INLINE rule2534 #-}
   rule2534 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule2535 #-}
   rule2535 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule2536 #-}
   rule2536 = \ ((_lhsIorderedTypeSynonyms) :: OrderedTypeSynonyms) ->
     _lhsIorderedTypeSynonyms
   {-# INLINE rule2537 #-}
   rule2537 = \ _parentTree ->
     _parentTree
   {-# INLINE rule2538 #-}
   rule2538 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule2539 #-}
   rule2539 = \ ((_lhsIrequiredPredicates) :: Predicates) ->
     _lhsIrequiredPredicates
   {-# INLINE rule2540 #-}
   rule2540 = \ ((_lhsIsubstitution) :: FixpointSubstitution) ->
     _lhsIsubstitution
   {-# INLINE rule2541 #-}
   rule2541 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
   {-# INLINE rule2542 #-}
   rule2542 = \ ((_lhsItypeschemeMap) :: M.Map Int (Scheme Predicates)) ->
     _lhsItypeschemeMap
   {-# INLINE rule2543 #-}
   rule2543 = \ ((_lhsIuniqueChunk) :: Int) ->
     _lhsIuniqueChunk
   {-# INLINE rule2544 #-}
   rule2544 = \ ((_lhsIuniqueSecondRound) :: Int) ->
     _lhsIuniqueSecondRound
   {-# INLINE rule2545 #-}
   rule2545 = \ ((_lhsIvariableMapping) :: Maybe [(Name, Tp)]) ->
     _lhsIvariableMapping
   {-# INLINE rule2546 #-}
   rule2546 = \ ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ->
     _lhsIallPatterns
   {-# INLINE rule2547 #-}
   rule2547 = \ ((_lhsIallTypeSchemes) :: M.Map NameWithRange TpScheme) ->
     _lhsIallTypeSchemes
   {-# INLINE rule2548 #-}
   rule2548 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule2549 #-}
   rule2549 = \ ((_lhsIavailablePredicates) :: [PredicateWithSource]) ->
     _lhsIavailablePredicates
   {-# INLINE rule2550 #-}
   rule2550 = \ ((_fromIbetaUnique) :: Int) ->
     _fromIbetaUnique
   {-# INLINE rule2551 #-}
   rule2551 = \ ((_lhsIclassEnvironment) :: ClassEnvironment) ->
     _lhsIclassEnvironment
   {-# INLINE rule2552 #-}
   rule2552 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule2553 #-}
   rule2553 = \ ((_lhsIclassMemberTypeSchemes) :: Maybe [(Name, TpScheme)]) ->
     _lhsIclassMemberTypeSchemes
   {-# INLINE rule2554 #-}
   rule2554 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule2555 #-}
   rule2555 = \ ((_lhsIclassPredicate) :: Maybe (Name, Names)) ->
     _lhsIclassPredicate
   {-# INLINE rule2556 #-}
   rule2556 = \ ((_lhsIclassTypeSchemes) :: M.Map Name TpScheme) ->
     _lhsIclassTypeSchemes
   {-# INLINE rule2557 #-}
   rule2557 = \ ((_fromIcollectErrors) :: TypeErrors) ->
     _fromIcollectErrors
   {-# INLINE rule2558 #-}
   rule2558 = \ ((_fromIcollectWarnings) :: Warnings) ->
     _fromIcollectWarnings
   {-# INLINE rule2559 #-}
   rule2559 = \ ((_fromIcounter) :: Int) ->
     _fromIcounter
   {-# INLINE rule2560 #-}
   rule2560 = \ ((_lhsIcurClassPred) :: Maybe Predicate) ->
     _lhsIcurClassPred
   {-# INLINE rule2561 #-}
   rule2561 = \ ((_lhsIcurPred) :: Maybe Predicate) ->
     _lhsIcurPred
   {-# INLINE rule2562 #-}
   rule2562 = \ ((_lhsIcurrentChunk) :: Int) ->
     _lhsIcurrentChunk
   {-# INLINE rule2563 #-}
   rule2563 = \ ((_fromIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _fromIdictionaryEnvironment
   {-# INLINE rule2564 #-}
   rule2564 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule2565 #-}
   rule2565 = \ ((_lhsIinstanceName) :: Maybe Name) ->
     _lhsIinstanceName
   {-# INLINE rule2566 #-}
   rule2566 = \ ((_lhsIinstanceTypes) :: [(Name, TpScheme)]) ->
     _lhsIinstanceTypes
   {-# INLINE rule2567 #-}
   rule2567 = \ ((_fromImatchIO) :: IO ()) ->
     _fromImatchIO
   {-# INLINE rule2568 #-}
   rule2568 = \ ((_lhsImoduleName) :: Maybe Name) ->
     _lhsImoduleName
   {-# INLINE rule2569 #-}
   rule2569 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule2570 #-}
   rule2570 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule2571 #-}
   rule2571 = \ ((_lhsIorderedTypeSynonyms) :: OrderedTypeSynonyms) ->
     _lhsIorderedTypeSynonyms
   {-# INLINE rule2572 #-}
   rule2572 = \ _parentTree ->
     _parentTree
   {-# INLINE rule2573 #-}
   rule2573 = \ ((_fromIpatternMatchWarnings) :: [Warning]) ->
     _fromIpatternMatchWarnings
   {-# INLINE rule2574 #-}
   rule2574 = \ ((_lhsIrequiredPredicates) :: Predicates) ->
     _lhsIrequiredPredicates
   {-# INLINE rule2575 #-}
   rule2575 = \ ((_lhsIsubstitution) :: FixpointSubstitution) ->
     _lhsIsubstitution
   {-# INLINE rule2576 #-}
   rule2576 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
   {-# INLINE rule2577 #-}
   rule2577 = \ ((_lhsItypeschemeMap) :: M.Map Int (Scheme Predicates)) ->
     _lhsItypeschemeMap
   {-# INLINE rule2578 #-}
   rule2578 = \ ((_fromIuniqueChunk) :: Int) ->
     _fromIuniqueChunk
   {-# INLINE rule2579 #-}
   rule2579 = \ ((_fromIuniqueSecondRound) :: Int) ->
     _fromIuniqueSecondRound
   {-# INLINE rule2580 #-}
   rule2580 = \ ((_lhsIvariableMapping) :: Maybe [(Name, Tp)]) ->
     _lhsIvariableMapping
   {-# INLINE rule2581 #-}
   rule2581 = \ ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ->
     _lhsIallPatterns
   {-# INLINE rule2582 #-}
   rule2582 = \ ((_lhsIallTypeSchemes) :: M.Map NameWithRange TpScheme) ->
     _lhsIallTypeSchemes
   {-# INLINE rule2583 #-}
   rule2583 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule2584 #-}
   rule2584 = \ ((_lhsIavailablePredicates) :: [PredicateWithSource]) ->
     _lhsIavailablePredicates
   {-# INLINE rule2585 #-}
   rule2585 = \ ((_thenIbetaUnique) :: Int) ->
     _thenIbetaUnique
   {-# INLINE rule2586 #-}
   rule2586 = \ ((_lhsIclassEnvironment) :: ClassEnvironment) ->
     _lhsIclassEnvironment
   {-# INLINE rule2587 #-}
   rule2587 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule2588 #-}
   rule2588 = \ ((_lhsIclassMemberTypeSchemes) :: Maybe [(Name, TpScheme)]) ->
     _lhsIclassMemberTypeSchemes
   {-# INLINE rule2589 #-}
   rule2589 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule2590 #-}
   rule2590 = \ ((_lhsIclassPredicate) :: Maybe (Name, Names)) ->
     _lhsIclassPredicate
   {-# INLINE rule2591 #-}
   rule2591 = \ ((_lhsIclassTypeSchemes) :: M.Map Name TpScheme) ->
     _lhsIclassTypeSchemes
   {-# INLINE rule2592 #-}
   rule2592 = \ ((_thenIcollectErrors) :: TypeErrors) ->
     _thenIcollectErrors
   {-# INLINE rule2593 #-}
   rule2593 = \ ((_thenIcollectWarnings) :: Warnings) ->
     _thenIcollectWarnings
   {-# INLINE rule2594 #-}
   rule2594 = \ ((_thenIcounter) :: Int) ->
     _thenIcounter
   {-# INLINE rule2595 #-}
   rule2595 = \ ((_lhsIcurClassPred) :: Maybe Predicate) ->
     _lhsIcurClassPred
   {-# INLINE rule2596 #-}
   rule2596 = \ ((_lhsIcurPred) :: Maybe Predicate) ->
     _lhsIcurPred
   {-# INLINE rule2597 #-}
   rule2597 = \ ((_lhsIcurrentChunk) :: Int) ->
     _lhsIcurrentChunk
   {-# INLINE rule2598 #-}
   rule2598 = \ ((_thenIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _thenIdictionaryEnvironment
   {-# INLINE rule2599 #-}
   rule2599 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule2600 #-}
   rule2600 = \ ((_lhsIinstanceName) :: Maybe Name) ->
     _lhsIinstanceName
   {-# INLINE rule2601 #-}
   rule2601 = \ ((_lhsIinstanceTypes) :: [(Name, TpScheme)]) ->
     _lhsIinstanceTypes
   {-# INLINE rule2602 #-}
   rule2602 = \ ((_thenImatchIO) :: IO ()) ->
     _thenImatchIO
   {-# INLINE rule2603 #-}
   rule2603 = \ ((_lhsImoduleName) :: Maybe Name) ->
     _lhsImoduleName
   {-# INLINE rule2604 #-}
   rule2604 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule2605 #-}
   rule2605 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule2606 #-}
   rule2606 = \ ((_lhsIorderedTypeSynonyms) :: OrderedTypeSynonyms) ->
     _lhsIorderedTypeSynonyms
   {-# INLINE rule2607 #-}
   rule2607 = \ _parentTree ->
     _parentTree
   {-# INLINE rule2608 #-}
   rule2608 = \ ((_thenIpatternMatchWarnings) :: [Warning]) ->
     _thenIpatternMatchWarnings
   {-# INLINE rule2609 #-}
   rule2609 = \ ((_lhsIrequiredPredicates) :: Predicates) ->
     _lhsIrequiredPredicates
   {-# INLINE rule2610 #-}
   rule2610 = \ ((_lhsIsubstitution) :: FixpointSubstitution) ->
     _lhsIsubstitution
   {-# INLINE rule2611 #-}
   rule2611 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
   {-# INLINE rule2612 #-}
   rule2612 = \ ((_lhsItypeschemeMap) :: M.Map Int (Scheme Predicates)) ->
     _lhsItypeschemeMap
   {-# INLINE rule2613 #-}
   rule2613 = \ ((_thenIuniqueChunk) :: Int) ->
     _thenIuniqueChunk
   {-# INLINE rule2614 #-}
   rule2614 = \ ((_thenIuniqueSecondRound) :: Int) ->
     _thenIuniqueSecondRound
   {-# INLINE rule2615 #-}
   rule2615 = \ ((_lhsIvariableMapping) :: Maybe [(Name, Tp)]) ->
     _lhsIvariableMapping
{-# NOINLINE sem_Expression_Negate #-}
sem_Expression_Negate :: T_Range  -> T_Expression  -> T_Expression 
sem_Expression_Negate arg_range_ arg_expression_ = T_Expression (return st41) where
   {-# NOINLINE st41 #-}
   !st41 = let
      v40 :: T_Expression_v40 
      v40 = \ !(T_Expression_vIn40 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItryPatterns _lhsItypeConstructors _lhsItypeschemeMap _lhsIuniqueChunk _lhsIuniqueSecondRound _lhsIvariableMapping) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _expressionX41 = Control.Monad.Identity.runIdentity (attach_T_Expression (arg_expression_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_Expression_vOut40 _expressionIassumptions _expressionIbeta _expressionIbetaUnique _expressionIcollectErrors _expressionIcollectInstances _expressionIcollectWarnings _expressionIconstraints _expressionIcounter _expressionIdictionaryEnvironment _expressionIinfoTree _expressionImatchIO _expressionImatches _expressionIpatternMatchWarnings _expressionIself _expressionIunboundNames _expressionIuniqueChunk _expressionIuniqueSecondRound) = inv_Expression_s41 _expressionX41 (T_Expression_vIn40 _expressionOallPatterns _expressionOallTypeSchemes _expressionOambiguousConflicts _expressionOavailablePredicates _expressionObetaUnique _expressionOclassEnvironment _expressionOclassMemberEnv _expressionOclassMemberTypeSchemes _expressionOclassNamesEnv _expressionOclassPredicate _expressionOclassTypeSchemes _expressionOcollectErrors _expressionOcollectWarnings _expressionOcounter _expressionOcurClassPred _expressionOcurPred _expressionOcurrentChunk _expressionOdictionaryEnvironment _expressionOimportEnvironment _expressionOinstanceName _expressionOinstanceTypes _expressionOmatchIO _expressionOmoduleName _expressionOmonos _expressionOnamesInScope _expressionOorderedTypeSynonyms _expressionOparentTree _expressionOpatternMatchWarnings _expressionOrequiredPredicates _expressionOsubstitution _expressionOtryPatterns _expressionOtypeConstructors _expressionOtypeschemeMap _expressionOuniqueChunk _expressionOuniqueSecondRound _expressionOvariableMapping)
         _lhsOmatches :: [Maybe MetaVariableTable]
         _lhsOconstraints :: ConstraintSet
         _lhsOassumptions :: Assumptions
         _lhsOuniqueSecondRound :: Int
         (_expressionOtryPatterns,_lhsOmatches,_lhsOconstraints,_lhsOassumptions,_lhsOuniqueSecondRound,_ioMatch) = rule2616 _constraints _expressionIassumptions _expressionImatches _expressionIuniqueSecondRound _lhsIallPatterns _lhsItryPatterns _localInfo
         _lhsOmatchIO :: IO ()
         _lhsOmatchIO = rule2617 _expressionImatchIO _ioMatch
         _parentTree = rule2618 _expressionIinfoTree _lhsIparentTree _localInfo
         _lhsOinfoTree :: InfoTree
         _lhsOinfoTree = rule2619 _parentTree
         _localInfo = rule2620 _beta _lhsImonos _self
         _cinfo = rule2621 _localInfo _parentTree _rangeIself
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule2622 _newDEnv
         _localName = rule2623 _rangeIself
         _negateTypeScheme = rule2624 _lhsIimportEnvironment _localName
         _requiredDictionaries = rule2625 _lhsIimportEnvironment _lhsIsubstitution _negateTypeScheme _usedAsType
         _usedAsType = rule2626 _beta _expressionIbeta _lhsIsubstitution
         _newDEnv = rule2627 _expressionIdictionaryEnvironment _lhsIavailablePredicates _lhsIclassEnvironment _lhsIcurPred _lhsIinstanceName _lhsIsubstitution _localName _requiredDictionaries
         _expressionObetaUnique = rule2628 _lhsIbetaUnique
         _constraints = rule2629 _expressionIconstraints _newcon
         _beta = rule2630 _lhsIbetaUnique
         _newcon = rule2631 _beta _cinfo _expressionIbeta _lhsIimportEnvironment
         _lhsOcollectInstances :: [(Name, Instance)]
         _lhsOcollectInstances = rule2632 _expressionIcollectInstances
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule2633 _expressionIunboundNames
         _self = rule2634 _expressionIself _rangeIself
         _lhsOself :: Expression
         _lhsOself = rule2635 _self
         _lhsObeta :: Tp
         _lhsObeta = rule2636 _beta
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule2637 _expressionIbetaUnique
         _lhsOcollectErrors :: TypeErrors
         _lhsOcollectErrors = rule2638 _expressionIcollectErrors
         _lhsOcollectWarnings :: Warnings
         _lhsOcollectWarnings = rule2639 _expressionIcollectWarnings
         _lhsOcounter :: Int
         _lhsOcounter = rule2640 _expressionIcounter
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule2641 _expressionIpatternMatchWarnings
         _lhsOuniqueChunk :: Int
         _lhsOuniqueChunk = rule2642 _expressionIuniqueChunk
         _expressionOallPatterns = rule2643 _lhsIallPatterns
         _expressionOallTypeSchemes = rule2644 _lhsIallTypeSchemes
         _expressionOambiguousConflicts = rule2645 _lhsIambiguousConflicts
         _expressionOavailablePredicates = rule2646 _lhsIavailablePredicates
         _expressionOclassEnvironment = rule2647 _lhsIclassEnvironment
         _expressionOclassMemberEnv = rule2648 _lhsIclassMemberEnv
         _expressionOclassMemberTypeSchemes = rule2649 _lhsIclassMemberTypeSchemes
         _expressionOclassNamesEnv = rule2650 _lhsIclassNamesEnv
         _expressionOclassPredicate = rule2651 _lhsIclassPredicate
         _expressionOclassTypeSchemes = rule2652 _lhsIclassTypeSchemes
         _expressionOcollectErrors = rule2653 _lhsIcollectErrors
         _expressionOcollectWarnings = rule2654 _lhsIcollectWarnings
         _expressionOcounter = rule2655 _lhsIcounter
         _expressionOcurClassPred = rule2656 _lhsIcurClassPred
         _expressionOcurPred = rule2657 _lhsIcurPred
         _expressionOcurrentChunk = rule2658 _lhsIcurrentChunk
         _expressionOdictionaryEnvironment = rule2659 _lhsIdictionaryEnvironment
         _expressionOimportEnvironment = rule2660 _lhsIimportEnvironment
         _expressionOinstanceName = rule2661 _lhsIinstanceName
         _expressionOinstanceTypes = rule2662 _lhsIinstanceTypes
         _expressionOmatchIO = rule2663 _lhsImatchIO
         _expressionOmoduleName = rule2664 _lhsImoduleName
         _expressionOmonos = rule2665 _lhsImonos
         _expressionOnamesInScope = rule2666 _lhsInamesInScope
         _expressionOorderedTypeSynonyms = rule2667 _lhsIorderedTypeSynonyms
         _expressionOparentTree = rule2668 _parentTree
         _expressionOpatternMatchWarnings = rule2669 _lhsIpatternMatchWarnings
         _expressionOrequiredPredicates = rule2670 _lhsIrequiredPredicates
         _expressionOsubstitution = rule2671 _lhsIsubstitution
         _expressionOtypeConstructors = rule2672 _lhsItypeConstructors
         _expressionOtypeschemeMap = rule2673 _lhsItypeschemeMap
         _expressionOuniqueChunk = rule2674 _lhsIuniqueChunk
         _expressionOuniqueSecondRound = rule2675 _lhsIuniqueSecondRound
         _expressionOvariableMapping = rule2676 _lhsIvariableMapping
         !__result_ = T_Expression_vOut40 _lhsOassumptions _lhsObeta _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraints _lhsOcounter _lhsOdictionaryEnvironment _lhsOinfoTree _lhsOmatchIO _lhsOmatches _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOuniqueSecondRound
         in __result_ )
     in C_Expression_s41 v40
   {-# INLINE rule2616 #-}
   rule2616 = \ _constraints ((_expressionIassumptions) :: Assumptions) ((_expressionImatches) :: [Maybe MetaVariableTable]) ((_expressionIuniqueSecondRound) :: Int) ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ((_lhsItryPatterns) :: [(Expression     , [String])]) _localInfo ->
            let infoTuple = metaVarInfo _constraints _expressionIassumptions _localInfo
            in match1 infoTuple _expressionIuniqueSecondRound
                      match_Expression_Negate
                      _lhsItryPatterns _lhsIallPatterns
                      [_expressionImatches]
   {-# INLINE rule2617 #-}
   rule2617 = \ ((_expressionImatchIO) :: IO ()) _ioMatch ->
                                       _expressionImatchIO      >> _ioMatch
   {-# INLINE rule2618 #-}
   rule2618 = \ ((_expressionIinfoTree) :: InfoTree) ((_lhsIparentTree) :: InfoTree) _localInfo ->
                            node _lhsIparentTree _localInfo [_expressionIinfoTree]
   {-# INLINE rule2619 #-}
   rule2619 = \ _parentTree ->
                            _parentTree
   {-# INLINE rule2620 #-}
   rule2620 = \ _beta ((_lhsImonos) :: Monos) _self ->
                            LocalInfo { self = UHA_Expr _self
                                      , assignedType = Just _beta
                                      , monos = _lhsImonos
                                      }
   {-# INLINE rule2621 #-}
   rule2621 = \ _localInfo _parentTree ((_rangeIself) :: Range) ->
     specialConstraint "negation" _parentTree
        (self _localInfo, Just $ nameToUHA_Expr (Name_Operator _rangeIself [] [] "-"))
        []
   {-# INLINE rule2622 #-}
   rule2622 = \ _newDEnv ->
                                             _newDEnv
   {-# INLINE rule2623 #-}
   rule2623 = \ ((_rangeIself) :: Range) ->
                                             setNameRange intUnaryMinusName _rangeIself
   {-# INLINE rule2624 #-}
   rule2624 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) _localName ->
                                             case M.lookup _localName (typeEnvironment _lhsIimportEnvironment) of
                                                Just scheme -> scheme
                                                Nothing     -> generalizeAll ([Predicate "Prelude.Num" (TVar 0)] .=>. TVar 0 .->. TVar 0)
   {-# INLINE rule2625 #-}
   rule2625 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ((_lhsIsubstitution) :: FixpointSubstitution) _negateTypeScheme _usedAsType ->
                                             map PredicateFunction $ getRequiredDictionaries
                                                (getOrderedTypeSynonyms _lhsIimportEnvironment)
                                                (_lhsIsubstitution |-> _usedAsType)
                                                (_lhsIsubstitution |-> _negateTypeScheme)
   {-# INLINE rule2626 #-}
   rule2626 = \ _beta ((_expressionIbeta) :: Tp) ((_lhsIsubstitution) :: FixpointSubstitution) ->
                                             _lhsIsubstitution |-> (_expressionIbeta .->. _beta)
   {-# INLINE rule2627 #-}
   rule2627 = \ ((_expressionIdictionaryEnvironment) :: DictionaryEnvironment) ((_lhsIavailablePredicates) :: [PredicateWithSource]) ((_lhsIclassEnvironment) :: ClassEnvironment) ((_lhsIcurPred) :: Maybe Predicate) ((_lhsIinstanceName) :: Maybe Name) ((_lhsIsubstitution) :: FixpointSubstitution) _localName _requiredDictionaries ->
                                             resolveOverloading (_lhsIclassEnvironment)  _localName
                                                                (_lhsIsubstitution |-> _lhsIavailablePredicates)
                                                                (_lhsIsubstitution |-> _requiredDictionaries)
                                                                (fmap getNameName _lhsIinstanceName)
                                                                _lhsIcurPred
                                                                _expressionIdictionaryEnvironment
   {-# INLINE rule2628 #-}
   rule2628 = \ ((_lhsIbetaUnique) :: Int) ->
                                    _lhsIbetaUnique + 1
   {-# INLINE rule2629 #-}
   rule2629 = \ ((_expressionIconstraints) :: ConstraintSet) _newcon ->
                                    _newcon .>. Node [ _expressionIconstraints ]
   {-# INLINE rule2630 #-}
   rule2630 = \ ((_lhsIbetaUnique) :: Int) ->
                                    TVar _lhsIbetaUnique
   {-# INLINE rule2631 #-}
   rule2631 = \ _beta _cinfo ((_expressionIbeta) :: Tp) ((_lhsIimportEnvironment) :: ImportEnvironment) ->
                                    let standard = makeScheme [] [Predicate "Num" (TVar 0)] (TVar 0 .->. TVar 0)
                                        tpscheme = M.findWithDefault standard (nameFromString "negate") (typeEnvironment _lhsIimportEnvironment)
                                    in [ (_expressionIbeta .->. _beta .::. tpscheme) _cinfo]
   {-# INLINE rule2632 #-}
   rule2632 = \ ((_expressionIcollectInstances) :: [(Name, Instance)]) ->
     _expressionIcollectInstances
   {-# INLINE rule2633 #-}
   rule2633 = \ ((_expressionIunboundNames) :: Names) ->
     _expressionIunboundNames
   {-# INLINE rule2634 #-}
   rule2634 = \ ((_expressionIself) :: Expression) ((_rangeIself) :: Range) ->
     Expression_Negate _rangeIself _expressionIself
   {-# INLINE rule2635 #-}
   rule2635 = \ _self ->
     _self
   {-# INLINE rule2636 #-}
   rule2636 = \ _beta ->
     _beta
   {-# INLINE rule2637 #-}
   rule2637 = \ ((_expressionIbetaUnique) :: Int) ->
     _expressionIbetaUnique
   {-# INLINE rule2638 #-}
   rule2638 = \ ((_expressionIcollectErrors) :: TypeErrors) ->
     _expressionIcollectErrors
   {-# INLINE rule2639 #-}
   rule2639 = \ ((_expressionIcollectWarnings) :: Warnings) ->
     _expressionIcollectWarnings
   {-# INLINE rule2640 #-}
   rule2640 = \ ((_expressionIcounter) :: Int) ->
     _expressionIcounter
   {-# INLINE rule2641 #-}
   rule2641 = \ ((_expressionIpatternMatchWarnings) :: [Warning]) ->
     _expressionIpatternMatchWarnings
   {-# INLINE rule2642 #-}
   rule2642 = \ ((_expressionIuniqueChunk) :: Int) ->
     _expressionIuniqueChunk
   {-# INLINE rule2643 #-}
   rule2643 = \ ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ->
     _lhsIallPatterns
   {-# INLINE rule2644 #-}
   rule2644 = \ ((_lhsIallTypeSchemes) :: M.Map NameWithRange TpScheme) ->
     _lhsIallTypeSchemes
   {-# INLINE rule2645 #-}
   rule2645 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule2646 #-}
   rule2646 = \ ((_lhsIavailablePredicates) :: [PredicateWithSource]) ->
     _lhsIavailablePredicates
   {-# INLINE rule2647 #-}
   rule2647 = \ ((_lhsIclassEnvironment) :: ClassEnvironment) ->
     _lhsIclassEnvironment
   {-# INLINE rule2648 #-}
   rule2648 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule2649 #-}
   rule2649 = \ ((_lhsIclassMemberTypeSchemes) :: Maybe [(Name, TpScheme)]) ->
     _lhsIclassMemberTypeSchemes
   {-# INLINE rule2650 #-}
   rule2650 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule2651 #-}
   rule2651 = \ ((_lhsIclassPredicate) :: Maybe (Name, Names)) ->
     _lhsIclassPredicate
   {-# INLINE rule2652 #-}
   rule2652 = \ ((_lhsIclassTypeSchemes) :: M.Map Name TpScheme) ->
     _lhsIclassTypeSchemes
   {-# INLINE rule2653 #-}
   rule2653 = \ ((_lhsIcollectErrors) :: TypeErrors) ->
     _lhsIcollectErrors
   {-# INLINE rule2654 #-}
   rule2654 = \ ((_lhsIcollectWarnings) :: Warnings) ->
     _lhsIcollectWarnings
   {-# INLINE rule2655 #-}
   rule2655 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule2656 #-}
   rule2656 = \ ((_lhsIcurClassPred) :: Maybe Predicate) ->
     _lhsIcurClassPred
   {-# INLINE rule2657 #-}
   rule2657 = \ ((_lhsIcurPred) :: Maybe Predicate) ->
     _lhsIcurPred
   {-# INLINE rule2658 #-}
   rule2658 = \ ((_lhsIcurrentChunk) :: Int) ->
     _lhsIcurrentChunk
   {-# INLINE rule2659 #-}
   rule2659 = \ ((_lhsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _lhsIdictionaryEnvironment
   {-# INLINE rule2660 #-}
   rule2660 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule2661 #-}
   rule2661 = \ ((_lhsIinstanceName) :: Maybe Name) ->
     _lhsIinstanceName
   {-# INLINE rule2662 #-}
   rule2662 = \ ((_lhsIinstanceTypes) :: [(Name, TpScheme)]) ->
     _lhsIinstanceTypes
   {-# INLINE rule2663 #-}
   rule2663 = \ ((_lhsImatchIO) :: IO ()) ->
     _lhsImatchIO
   {-# INLINE rule2664 #-}
   rule2664 = \ ((_lhsImoduleName) :: Maybe Name) ->
     _lhsImoduleName
   {-# INLINE rule2665 #-}
   rule2665 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule2666 #-}
   rule2666 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule2667 #-}
   rule2667 = \ ((_lhsIorderedTypeSynonyms) :: OrderedTypeSynonyms) ->
     _lhsIorderedTypeSynonyms
   {-# INLINE rule2668 #-}
   rule2668 = \ _parentTree ->
     _parentTree
   {-# INLINE rule2669 #-}
   rule2669 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule2670 #-}
   rule2670 = \ ((_lhsIrequiredPredicates) :: Predicates) ->
     _lhsIrequiredPredicates
   {-# INLINE rule2671 #-}
   rule2671 = \ ((_lhsIsubstitution) :: FixpointSubstitution) ->
     _lhsIsubstitution
   {-# INLINE rule2672 #-}
   rule2672 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
   {-# INLINE rule2673 #-}
   rule2673 = \ ((_lhsItypeschemeMap) :: M.Map Int (Scheme Predicates)) ->
     _lhsItypeschemeMap
   {-# INLINE rule2674 #-}
   rule2674 = \ ((_lhsIuniqueChunk) :: Int) ->
     _lhsIuniqueChunk
   {-# INLINE rule2675 #-}
   rule2675 = \ ((_lhsIuniqueSecondRound) :: Int) ->
     _lhsIuniqueSecondRound
   {-# INLINE rule2676 #-}
   rule2676 = \ ((_lhsIvariableMapping) :: Maybe [(Name, Tp)]) ->
     _lhsIvariableMapping
{-# NOINLINE sem_Expression_NegateFloat #-}
sem_Expression_NegateFloat :: T_Range  -> T_Expression  -> T_Expression 
sem_Expression_NegateFloat arg_range_ arg_expression_ = T_Expression (return st41) where
   {-# NOINLINE st41 #-}
   !st41 = let
      v40 :: T_Expression_v40 
      v40 = \ !(T_Expression_vIn40 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItryPatterns _lhsItypeConstructors _lhsItypeschemeMap _lhsIuniqueChunk _lhsIuniqueSecondRound _lhsIvariableMapping) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _expressionX41 = Control.Monad.Identity.runIdentity (attach_T_Expression (arg_expression_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_Expression_vOut40 _expressionIassumptions _expressionIbeta _expressionIbetaUnique _expressionIcollectErrors _expressionIcollectInstances _expressionIcollectWarnings _expressionIconstraints _expressionIcounter _expressionIdictionaryEnvironment _expressionIinfoTree _expressionImatchIO _expressionImatches _expressionIpatternMatchWarnings _expressionIself _expressionIunboundNames _expressionIuniqueChunk _expressionIuniqueSecondRound) = inv_Expression_s41 _expressionX41 (T_Expression_vIn40 _expressionOallPatterns _expressionOallTypeSchemes _expressionOambiguousConflicts _expressionOavailablePredicates _expressionObetaUnique _expressionOclassEnvironment _expressionOclassMemberEnv _expressionOclassMemberTypeSchemes _expressionOclassNamesEnv _expressionOclassPredicate _expressionOclassTypeSchemes _expressionOcollectErrors _expressionOcollectWarnings _expressionOcounter _expressionOcurClassPred _expressionOcurPred _expressionOcurrentChunk _expressionOdictionaryEnvironment _expressionOimportEnvironment _expressionOinstanceName _expressionOinstanceTypes _expressionOmatchIO _expressionOmoduleName _expressionOmonos _expressionOnamesInScope _expressionOorderedTypeSynonyms _expressionOparentTree _expressionOpatternMatchWarnings _expressionOrequiredPredicates _expressionOsubstitution _expressionOtryPatterns _expressionOtypeConstructors _expressionOtypeschemeMap _expressionOuniqueChunk _expressionOuniqueSecondRound _expressionOvariableMapping)
         _lhsOmatches :: [Maybe MetaVariableTable]
         _lhsOconstraints :: ConstraintSet
         _lhsOassumptions :: Assumptions
         _lhsOuniqueSecondRound :: Int
         (_expressionOtryPatterns,_lhsOmatches,_lhsOconstraints,_lhsOassumptions,_lhsOuniqueSecondRound,_ioMatch) = rule2677 _constraints _expressionIassumptions _expressionImatches _expressionIuniqueSecondRound _lhsIallPatterns _lhsItryPatterns _localInfo
         _lhsOmatchIO :: IO ()
         _lhsOmatchIO = rule2678 _expressionImatchIO _ioMatch
         _parentTree = rule2679 _expressionIinfoTree _lhsIparentTree _localInfo
         _lhsOinfoTree :: InfoTree
         _lhsOinfoTree = rule2680 _parentTree
         _localInfo = rule2681 _beta _lhsImonos _self
         _cinfo = rule2682 _localInfo _parentTree _rangeIself
         _expressionObetaUnique = rule2683 _lhsIbetaUnique
         _constraints = rule2684 _expressionIconstraints _newcon
         _beta = rule2685 _lhsIbetaUnique
         _newcon = rule2686 _beta _cinfo _expressionIbeta
         _lhsOcollectInstances :: [(Name, Instance)]
         _lhsOcollectInstances = rule2687 _expressionIcollectInstances
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule2688 _expressionIunboundNames
         _self = rule2689 _expressionIself _rangeIself
         _lhsOself :: Expression
         _lhsOself = rule2690 _self
         _lhsObeta :: Tp
         _lhsObeta = rule2691 _beta
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule2692 _expressionIbetaUnique
         _lhsOcollectErrors :: TypeErrors
         _lhsOcollectErrors = rule2693 _expressionIcollectErrors
         _lhsOcollectWarnings :: Warnings
         _lhsOcollectWarnings = rule2694 _expressionIcollectWarnings
         _lhsOcounter :: Int
         _lhsOcounter = rule2695 _expressionIcounter
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule2696 _expressionIdictionaryEnvironment
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule2697 _expressionIpatternMatchWarnings
         _lhsOuniqueChunk :: Int
         _lhsOuniqueChunk = rule2698 _expressionIuniqueChunk
         _expressionOallPatterns = rule2699 _lhsIallPatterns
         _expressionOallTypeSchemes = rule2700 _lhsIallTypeSchemes
         _expressionOambiguousConflicts = rule2701 _lhsIambiguousConflicts
         _expressionOavailablePredicates = rule2702 _lhsIavailablePredicates
         _expressionOclassEnvironment = rule2703 _lhsIclassEnvironment
         _expressionOclassMemberEnv = rule2704 _lhsIclassMemberEnv
         _expressionOclassMemberTypeSchemes = rule2705 _lhsIclassMemberTypeSchemes
         _expressionOclassNamesEnv = rule2706 _lhsIclassNamesEnv
         _expressionOclassPredicate = rule2707 _lhsIclassPredicate
         _expressionOclassTypeSchemes = rule2708 _lhsIclassTypeSchemes
         _expressionOcollectErrors = rule2709 _lhsIcollectErrors
         _expressionOcollectWarnings = rule2710 _lhsIcollectWarnings
         _expressionOcounter = rule2711 _lhsIcounter
         _expressionOcurClassPred = rule2712 _lhsIcurClassPred
         _expressionOcurPred = rule2713 _lhsIcurPred
         _expressionOcurrentChunk = rule2714 _lhsIcurrentChunk
         _expressionOdictionaryEnvironment = rule2715 _lhsIdictionaryEnvironment
         _expressionOimportEnvironment = rule2716 _lhsIimportEnvironment
         _expressionOinstanceName = rule2717 _lhsIinstanceName
         _expressionOinstanceTypes = rule2718 _lhsIinstanceTypes
         _expressionOmatchIO = rule2719 _lhsImatchIO
         _expressionOmoduleName = rule2720 _lhsImoduleName
         _expressionOmonos = rule2721 _lhsImonos
         _expressionOnamesInScope = rule2722 _lhsInamesInScope
         _expressionOorderedTypeSynonyms = rule2723 _lhsIorderedTypeSynonyms
         _expressionOparentTree = rule2724 _parentTree
         _expressionOpatternMatchWarnings = rule2725 _lhsIpatternMatchWarnings
         _expressionOrequiredPredicates = rule2726 _lhsIrequiredPredicates
         _expressionOsubstitution = rule2727 _lhsIsubstitution
         _expressionOtypeConstructors = rule2728 _lhsItypeConstructors
         _expressionOtypeschemeMap = rule2729 _lhsItypeschemeMap
         _expressionOuniqueChunk = rule2730 _lhsIuniqueChunk
         _expressionOuniqueSecondRound = rule2731 _lhsIuniqueSecondRound
         _expressionOvariableMapping = rule2732 _lhsIvariableMapping
         !__result_ = T_Expression_vOut40 _lhsOassumptions _lhsObeta _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraints _lhsOcounter _lhsOdictionaryEnvironment _lhsOinfoTree _lhsOmatchIO _lhsOmatches _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOuniqueSecondRound
         in __result_ )
     in C_Expression_s41 v40
   {-# INLINE rule2677 #-}
   rule2677 = \ _constraints ((_expressionIassumptions) :: Assumptions) ((_expressionImatches) :: [Maybe MetaVariableTable]) ((_expressionIuniqueSecondRound) :: Int) ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ((_lhsItryPatterns) :: [(Expression     , [String])]) _localInfo ->
            let infoTuple = metaVarInfo _constraints _expressionIassumptions _localInfo
            in match1 infoTuple _expressionIuniqueSecondRound
                      match_Expression_NegateFloat
                      _lhsItryPatterns _lhsIallPatterns
                      [_expressionImatches]
   {-# INLINE rule2678 #-}
   rule2678 = \ ((_expressionImatchIO) :: IO ()) _ioMatch ->
                                       _expressionImatchIO      >> _ioMatch
   {-# INLINE rule2679 #-}
   rule2679 = \ ((_expressionIinfoTree) :: InfoTree) ((_lhsIparentTree) :: InfoTree) _localInfo ->
                            node _lhsIparentTree _localInfo [_expressionIinfoTree]
   {-# INLINE rule2680 #-}
   rule2680 = \ _parentTree ->
                            _parentTree
   {-# INLINE rule2681 #-}
   rule2681 = \ _beta ((_lhsImonos) :: Monos) _self ->
                            LocalInfo { self = UHA_Expr _self
                                      , assignedType = Just _beta
                                      , monos = _lhsImonos
                                      }
   {-# INLINE rule2682 #-}
   rule2682 = \ _localInfo _parentTree ((_rangeIself) :: Range) ->
     specialConstraint "negation" _parentTree
        (self _localInfo, Just $ nameToUHA_Expr (Name_Operator _rangeIself [] [] "-."))
        []
   {-# INLINE rule2683 #-}
   rule2683 = \ ((_lhsIbetaUnique) :: Int) ->
                                    _lhsIbetaUnique + 1
   {-# INLINE rule2684 #-}
   rule2684 = \ ((_expressionIconstraints) :: ConstraintSet) _newcon ->
                                    _newcon .>. Node [ _expressionIconstraints ]
   {-# INLINE rule2685 #-}
   rule2685 = \ ((_lhsIbetaUnique) :: Int) ->
                                    TVar _lhsIbetaUnique
   {-# INLINE rule2686 #-}
   rule2686 = \ _beta _cinfo ((_expressionIbeta) :: Tp) ->
                                    [ (floatQualType .->. floatQualType .==. _expressionIbeta .->. _beta) _cinfo]
   {-# INLINE rule2687 #-}
   rule2687 = \ ((_expressionIcollectInstances) :: [(Name, Instance)]) ->
     _expressionIcollectInstances
   {-# INLINE rule2688 #-}
   rule2688 = \ ((_expressionIunboundNames) :: Names) ->
     _expressionIunboundNames
   {-# INLINE rule2689 #-}
   rule2689 = \ ((_expressionIself) :: Expression) ((_rangeIself) :: Range) ->
     Expression_NegateFloat _rangeIself _expressionIself
   {-# INLINE rule2690 #-}
   rule2690 = \ _self ->
     _self
   {-# INLINE rule2691 #-}
   rule2691 = \ _beta ->
     _beta
   {-# INLINE rule2692 #-}
   rule2692 = \ ((_expressionIbetaUnique) :: Int) ->
     _expressionIbetaUnique
   {-# INLINE rule2693 #-}
   rule2693 = \ ((_expressionIcollectErrors) :: TypeErrors) ->
     _expressionIcollectErrors
   {-# INLINE rule2694 #-}
   rule2694 = \ ((_expressionIcollectWarnings) :: Warnings) ->
     _expressionIcollectWarnings
   {-# INLINE rule2695 #-}
   rule2695 = \ ((_expressionIcounter) :: Int) ->
     _expressionIcounter
   {-# INLINE rule2696 #-}
   rule2696 = \ ((_expressionIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _expressionIdictionaryEnvironment
   {-# INLINE rule2697 #-}
   rule2697 = \ ((_expressionIpatternMatchWarnings) :: [Warning]) ->
     _expressionIpatternMatchWarnings
   {-# INLINE rule2698 #-}
   rule2698 = \ ((_expressionIuniqueChunk) :: Int) ->
     _expressionIuniqueChunk
   {-# INLINE rule2699 #-}
   rule2699 = \ ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ->
     _lhsIallPatterns
   {-# INLINE rule2700 #-}
   rule2700 = \ ((_lhsIallTypeSchemes) :: M.Map NameWithRange TpScheme) ->
     _lhsIallTypeSchemes
   {-# INLINE rule2701 #-}
   rule2701 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule2702 #-}
   rule2702 = \ ((_lhsIavailablePredicates) :: [PredicateWithSource]) ->
     _lhsIavailablePredicates
   {-# INLINE rule2703 #-}
   rule2703 = \ ((_lhsIclassEnvironment) :: ClassEnvironment) ->
     _lhsIclassEnvironment
   {-# INLINE rule2704 #-}
   rule2704 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule2705 #-}
   rule2705 = \ ((_lhsIclassMemberTypeSchemes) :: Maybe [(Name, TpScheme)]) ->
     _lhsIclassMemberTypeSchemes
   {-# INLINE rule2706 #-}
   rule2706 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule2707 #-}
   rule2707 = \ ((_lhsIclassPredicate) :: Maybe (Name, Names)) ->
     _lhsIclassPredicate
   {-# INLINE rule2708 #-}
   rule2708 = \ ((_lhsIclassTypeSchemes) :: M.Map Name TpScheme) ->
     _lhsIclassTypeSchemes
   {-# INLINE rule2709 #-}
   rule2709 = \ ((_lhsIcollectErrors) :: TypeErrors) ->
     _lhsIcollectErrors
   {-# INLINE rule2710 #-}
   rule2710 = \ ((_lhsIcollectWarnings) :: Warnings) ->
     _lhsIcollectWarnings
   {-# INLINE rule2711 #-}
   rule2711 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule2712 #-}
   rule2712 = \ ((_lhsIcurClassPred) :: Maybe Predicate) ->
     _lhsIcurClassPred
   {-# INLINE rule2713 #-}
   rule2713 = \ ((_lhsIcurPred) :: Maybe Predicate) ->
     _lhsIcurPred
   {-# INLINE rule2714 #-}
   rule2714 = \ ((_lhsIcurrentChunk) :: Int) ->
     _lhsIcurrentChunk
   {-# INLINE rule2715 #-}
   rule2715 = \ ((_lhsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _lhsIdictionaryEnvironment
   {-# INLINE rule2716 #-}
   rule2716 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule2717 #-}
   rule2717 = \ ((_lhsIinstanceName) :: Maybe Name) ->
     _lhsIinstanceName
   {-# INLINE rule2718 #-}
   rule2718 = \ ((_lhsIinstanceTypes) :: [(Name, TpScheme)]) ->
     _lhsIinstanceTypes
   {-# INLINE rule2719 #-}
   rule2719 = \ ((_lhsImatchIO) :: IO ()) ->
     _lhsImatchIO
   {-# INLINE rule2720 #-}
   rule2720 = \ ((_lhsImoduleName) :: Maybe Name) ->
     _lhsImoduleName
   {-# INLINE rule2721 #-}
   rule2721 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule2722 #-}
   rule2722 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule2723 #-}
   rule2723 = \ ((_lhsIorderedTypeSynonyms) :: OrderedTypeSynonyms) ->
     _lhsIorderedTypeSynonyms
   {-# INLINE rule2724 #-}
   rule2724 = \ _parentTree ->
     _parentTree
   {-# INLINE rule2725 #-}
   rule2725 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule2726 #-}
   rule2726 = \ ((_lhsIrequiredPredicates) :: Predicates) ->
     _lhsIrequiredPredicates
   {-# INLINE rule2727 #-}
   rule2727 = \ ((_lhsIsubstitution) :: FixpointSubstitution) ->
     _lhsIsubstitution
   {-# INLINE rule2728 #-}
   rule2728 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
   {-# INLINE rule2729 #-}
   rule2729 = \ ((_lhsItypeschemeMap) :: M.Map Int (Scheme Predicates)) ->
     _lhsItypeschemeMap
   {-# INLINE rule2730 #-}
   rule2730 = \ ((_lhsIuniqueChunk) :: Int) ->
     _lhsIuniqueChunk
   {-# INLINE rule2731 #-}
   rule2731 = \ ((_lhsIuniqueSecondRound) :: Int) ->
     _lhsIuniqueSecondRound
   {-# INLINE rule2732 #-}
   rule2732 = \ ((_lhsIvariableMapping) :: Maybe [(Name, Tp)]) ->
     _lhsIvariableMapping

-- Expressions -------------------------------------------------
-- wrapper
data Inh_Expressions  = Inh_Expressions { allPatterns_Inh_Expressions :: !([((Expression, [String]), Core_TypingStrategy)]), allTypeSchemes_Inh_Expressions :: !(M.Map NameWithRange TpScheme), ambiguousConflicts_Inh_Expressions :: !([[Name]]), availablePredicates_Inh_Expressions :: !([PredicateWithSource]), betaUnique_Inh_Expressions :: !(Int), classEnvironment_Inh_Expressions :: !(ClassEnvironment), classMemberEnv_Inh_Expressions :: !(ClassMemberEnvironment), classMemberTypeSchemes_Inh_Expressions :: !(Maybe [(Name, TpScheme)]), classNamesEnv_Inh_Expressions :: !(ClassNameEnvironment), classPredicate_Inh_Expressions :: !(Maybe (Name, Names)), classTypeSchemes_Inh_Expressions :: !(M.Map Name TpScheme), collectErrors_Inh_Expressions :: !(TypeErrors), collectWarnings_Inh_Expressions :: !(Warnings), counter_Inh_Expressions :: !(Int), curClassPred_Inh_Expressions :: !(Maybe Predicate), curPred_Inh_Expressions :: !(Maybe Predicate), currentChunk_Inh_Expressions :: !(Int), dictionaryEnvironment_Inh_Expressions :: !(DictionaryEnvironment), importEnvironment_Inh_Expressions :: !(ImportEnvironment), instanceName_Inh_Expressions :: !(Maybe Name), instanceTypes_Inh_Expressions :: !([(Name, TpScheme)]), matchIO_Inh_Expressions :: !(IO ()), moduleName_Inh_Expressions :: !(Maybe Name), monos_Inh_Expressions :: !(Monos), namesInScope_Inh_Expressions :: !(Names), orderedTypeSynonyms_Inh_Expressions :: !(OrderedTypeSynonyms), parentTree_Inh_Expressions :: !(InfoTree), patternMatchWarnings_Inh_Expressions :: !([Warning]), requiredPredicates_Inh_Expressions :: !(Predicates), substitution_Inh_Expressions :: !(FixpointSubstitution), tryPatterns_Inh_Expressions :: !([(Expressions    , [String])]), typeConstructors_Inh_Expressions :: !(TypeConstructorEnvironment), typeschemeMap_Inh_Expressions :: !(M.Map Int (Scheme Predicates)), uniqueChunk_Inh_Expressions :: !(Int), uniqueSecondRound_Inh_Expressions :: !(Int), variableMapping_Inh_Expressions :: !(Maybe [(Name, Tp)]) }
data Syn_Expressions  = Syn_Expressions { assumptions_Syn_Expressions :: !(Assumptions), betaUnique_Syn_Expressions :: !(Int), betas_Syn_Expressions :: !(Tps), collectErrors_Syn_Expressions :: !(TypeErrors), collectInstances_Syn_Expressions :: !([(Name, Instance)]), collectWarnings_Syn_Expressions :: !(Warnings), constraintslist_Syn_Expressions :: !(ConstraintSets), counter_Syn_Expressions :: !(Int), dictionaryEnvironment_Syn_Expressions :: !(DictionaryEnvironment), infoTrees_Syn_Expressions :: !(InfoTrees), matchIO_Syn_Expressions :: !(IO ()), matches_Syn_Expressions :: !([Maybe MetaVariableTable]), patternMatchWarnings_Syn_Expressions :: !([Warning]), self_Syn_Expressions :: !(Expressions), unboundNames_Syn_Expressions :: !(Names), uniqueChunk_Syn_Expressions :: !(Int), uniqueSecondRound_Syn_Expressions :: !(Int) }
{-# INLINABLE wrap_Expressions #-}
wrap_Expressions :: T_Expressions  -> Inh_Expressions  -> (Syn_Expressions )
wrap_Expressions !(T_Expressions act) !(Inh_Expressions _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItryPatterns _lhsItypeConstructors _lhsItypeschemeMap _lhsIuniqueChunk _lhsIuniqueSecondRound _lhsIvariableMapping) =
   Control.Monad.Identity.runIdentity (
     do !sem <- act
        let arg43 = T_Expressions_vIn43 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItryPatterns _lhsItypeConstructors _lhsItypeschemeMap _lhsIuniqueChunk _lhsIuniqueSecondRound _lhsIvariableMapping
        !(T_Expressions_vOut43 _lhsOassumptions _lhsObetaUnique _lhsObetas _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraintslist _lhsOcounter _lhsOdictionaryEnvironment _lhsOinfoTrees _lhsOmatchIO _lhsOmatches _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOuniqueSecondRound) <- return (inv_Expressions_s44 sem arg43)
        return (Syn_Expressions _lhsOassumptions _lhsObetaUnique _lhsObetas _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraintslist _lhsOcounter _lhsOdictionaryEnvironment _lhsOinfoTrees _lhsOmatchIO _lhsOmatches _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOuniqueSecondRound)
   )

-- cata
{-# NOINLINE sem_Expressions #-}
sem_Expressions :: Expressions  -> T_Expressions 
sem_Expressions list = Prelude.foldr sem_Expressions_Cons sem_Expressions_Nil (Prelude.map sem_Expression list)

-- semantic domain
newtype T_Expressions  = T_Expressions {
                                       attach_T_Expressions :: Identity (T_Expressions_s44 )
                                       }
newtype T_Expressions_s44  = C_Expressions_s44 {
                                               inv_Expressions_s44 :: (T_Expressions_v43 )
                                               }
data T_Expressions_s45  = C_Expressions_s45
type T_Expressions_v43  = (T_Expressions_vIn43 ) -> (T_Expressions_vOut43 )
data T_Expressions_vIn43  = T_Expressions_vIn43 ([((Expression, [String]), Core_TypingStrategy)]) (M.Map NameWithRange TpScheme) ([[Name]]) ([PredicateWithSource]) (Int) (ClassEnvironment) (ClassMemberEnvironment) (Maybe [(Name, TpScheme)]) (ClassNameEnvironment) (Maybe (Name, Names)) (M.Map Name TpScheme) (TypeErrors) (Warnings) (Int) (Maybe Predicate) (Maybe Predicate) (Int) (DictionaryEnvironment) (ImportEnvironment) (Maybe Name) ([(Name, TpScheme)]) (IO ()) (Maybe Name) (Monos) (Names) (OrderedTypeSynonyms) (InfoTree) ([Warning]) (Predicates) (FixpointSubstitution) ([(Expressions    , [String])]) (TypeConstructorEnvironment) (M.Map Int (Scheme Predicates)) (Int) (Int) (Maybe [(Name, Tp)])
data T_Expressions_vOut43  = T_Expressions_vOut43 (Assumptions) (Int) (Tps) (TypeErrors) ([(Name, Instance)]) (Warnings) (ConstraintSets) (Int) (DictionaryEnvironment) (InfoTrees) (IO ()) ([Maybe MetaVariableTable]) ([Warning]) (Expressions) (Names) (Int) (Int)
{-# NOINLINE sem_Expressions_Cons #-}
sem_Expressions_Cons :: T_Expression  -> T_Expressions  -> T_Expressions 
sem_Expressions_Cons arg_hd_ arg_tl_ = T_Expressions (return st44) where
   {-# NOINLINE st44 #-}
   !st44 = let
      v43 :: T_Expressions_v43 
      v43 = \ !(T_Expressions_vIn43 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItryPatterns _lhsItypeConstructors _lhsItypeschemeMap _lhsIuniqueChunk _lhsIuniqueSecondRound _lhsIvariableMapping) -> ( let
         _hdX41 = Control.Monad.Identity.runIdentity (attach_T_Expression (arg_hd_))
         _tlX44 = Control.Monad.Identity.runIdentity (attach_T_Expressions (arg_tl_))
         (T_Expression_vOut40 _hdIassumptions _hdIbeta _hdIbetaUnique _hdIcollectErrors _hdIcollectInstances _hdIcollectWarnings _hdIconstraints _hdIcounter _hdIdictionaryEnvironment _hdIinfoTree _hdImatchIO _hdImatches _hdIpatternMatchWarnings _hdIself _hdIunboundNames _hdIuniqueChunk _hdIuniqueSecondRound) = inv_Expression_s41 _hdX41 (T_Expression_vIn40 _hdOallPatterns _hdOallTypeSchemes _hdOambiguousConflicts _hdOavailablePredicates _hdObetaUnique _hdOclassEnvironment _hdOclassMemberEnv _hdOclassMemberTypeSchemes _hdOclassNamesEnv _hdOclassPredicate _hdOclassTypeSchemes _hdOcollectErrors _hdOcollectWarnings _hdOcounter _hdOcurClassPred _hdOcurPred _hdOcurrentChunk _hdOdictionaryEnvironment _hdOimportEnvironment _hdOinstanceName _hdOinstanceTypes _hdOmatchIO _hdOmoduleName _hdOmonos _hdOnamesInScope _hdOorderedTypeSynonyms _hdOparentTree _hdOpatternMatchWarnings _hdOrequiredPredicates _hdOsubstitution _hdOtryPatterns _hdOtypeConstructors _hdOtypeschemeMap _hdOuniqueChunk _hdOuniqueSecondRound _hdOvariableMapping)
         (T_Expressions_vOut43 _tlIassumptions _tlIbetaUnique _tlIbetas _tlIcollectErrors _tlIcollectInstances _tlIcollectWarnings _tlIconstraintslist _tlIcounter _tlIdictionaryEnvironment _tlIinfoTrees _tlImatchIO _tlImatches _tlIpatternMatchWarnings _tlIself _tlIunboundNames _tlIuniqueChunk _tlIuniqueSecondRound) = inv_Expressions_s44 _tlX44 (T_Expressions_vIn43 _tlOallPatterns _tlOallTypeSchemes _tlOambiguousConflicts _tlOavailablePredicates _tlObetaUnique _tlOclassEnvironment _tlOclassMemberEnv _tlOclassMemberTypeSchemes _tlOclassNamesEnv _tlOclassPredicate _tlOclassTypeSchemes _tlOcollectErrors _tlOcollectWarnings _tlOcounter _tlOcurClassPred _tlOcurPred _tlOcurrentChunk _tlOdictionaryEnvironment _tlOimportEnvironment _tlOinstanceName _tlOinstanceTypes _tlOmatchIO _tlOmoduleName _tlOmonos _tlOnamesInScope _tlOorderedTypeSynonyms _tlOparentTree _tlOpatternMatchWarnings _tlOrequiredPredicates _tlOsubstitution _tlOtryPatterns _tlOtypeConstructors _tlOtypeschemeMap _tlOuniqueChunk _tlOuniqueSecondRound _tlOvariableMapping)
         _lhsOmatches :: [Maybe MetaVariableTable]
         ((_hdOtryPatterns,_tlOtryPatterns),_lhsOmatches,_,_,_,_) = rule2733 _hdImatches _lhsItryPatterns _tlImatches
         _lhsOinfoTrees :: InfoTrees
         _lhsOinfoTrees = rule2734 _hdIinfoTree _tlIinfoTrees
         _lhsObetas :: Tps
         _lhsObetas = rule2735 _hdIbeta _tlIbetas
         _lhsOassumptions :: Assumptions
         _lhsOassumptions = rule2736 _hdIassumptions _tlIassumptions
         _lhsOconstraintslist :: ConstraintSets
         _lhsOconstraintslist = rule2737 _hdIconstraints _tlIconstraintslist
         _lhsOcollectInstances :: [(Name, Instance)]
         _lhsOcollectInstances = rule2738 _hdIcollectInstances _tlIcollectInstances
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule2739 _hdIunboundNames _tlIunboundNames
         _self = rule2740 _hdIself _tlIself
         _lhsOself :: Expressions
         _lhsOself = rule2741 _self
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule2742 _tlIbetaUnique
         _lhsOcollectErrors :: TypeErrors
         _lhsOcollectErrors = rule2743 _tlIcollectErrors
         _lhsOcollectWarnings :: Warnings
         _lhsOcollectWarnings = rule2744 _tlIcollectWarnings
         _lhsOcounter :: Int
         _lhsOcounter = rule2745 _tlIcounter
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule2746 _tlIdictionaryEnvironment
         _lhsOmatchIO :: IO ()
         _lhsOmatchIO = rule2747 _tlImatchIO
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule2748 _tlIpatternMatchWarnings
         _lhsOuniqueChunk :: Int
         _lhsOuniqueChunk = rule2749 _tlIuniqueChunk
         _lhsOuniqueSecondRound :: Int
         _lhsOuniqueSecondRound = rule2750 _tlIuniqueSecondRound
         _hdOallPatterns = rule2751 _lhsIallPatterns
         _hdOallTypeSchemes = rule2752 _lhsIallTypeSchemes
         _hdOambiguousConflicts = rule2753 _lhsIambiguousConflicts
         _hdOavailablePredicates = rule2754 _lhsIavailablePredicates
         _hdObetaUnique = rule2755 _lhsIbetaUnique
         _hdOclassEnvironment = rule2756 _lhsIclassEnvironment
         _hdOclassMemberEnv = rule2757 _lhsIclassMemberEnv
         _hdOclassMemberTypeSchemes = rule2758 _lhsIclassMemberTypeSchemes
         _hdOclassNamesEnv = rule2759 _lhsIclassNamesEnv
         _hdOclassPredicate = rule2760 _lhsIclassPredicate
         _hdOclassTypeSchemes = rule2761 _lhsIclassTypeSchemes
         _hdOcollectErrors = rule2762 _lhsIcollectErrors
         _hdOcollectWarnings = rule2763 _lhsIcollectWarnings
         _hdOcounter = rule2764 _lhsIcounter
         _hdOcurClassPred = rule2765 _lhsIcurClassPred
         _hdOcurPred = rule2766 _lhsIcurPred
         _hdOcurrentChunk = rule2767 _lhsIcurrentChunk
         _hdOdictionaryEnvironment = rule2768 _lhsIdictionaryEnvironment
         _hdOimportEnvironment = rule2769 _lhsIimportEnvironment
         _hdOinstanceName = rule2770 _lhsIinstanceName
         _hdOinstanceTypes = rule2771 _lhsIinstanceTypes
         _hdOmatchIO = rule2772 _lhsImatchIO
         _hdOmoduleName = rule2773 _lhsImoduleName
         _hdOmonos = rule2774 _lhsImonos
         _hdOnamesInScope = rule2775 _lhsInamesInScope
         _hdOorderedTypeSynonyms = rule2776 _lhsIorderedTypeSynonyms
         _hdOparentTree = rule2777 _lhsIparentTree
         _hdOpatternMatchWarnings = rule2778 _lhsIpatternMatchWarnings
         _hdOrequiredPredicates = rule2779 _lhsIrequiredPredicates
         _hdOsubstitution = rule2780 _lhsIsubstitution
         _hdOtypeConstructors = rule2781 _lhsItypeConstructors
         _hdOtypeschemeMap = rule2782 _lhsItypeschemeMap
         _hdOuniqueChunk = rule2783 _lhsIuniqueChunk
         _hdOuniqueSecondRound = rule2784 _lhsIuniqueSecondRound
         _hdOvariableMapping = rule2785 _lhsIvariableMapping
         _tlOallPatterns = rule2786 _lhsIallPatterns
         _tlOallTypeSchemes = rule2787 _lhsIallTypeSchemes
         _tlOambiguousConflicts = rule2788 _lhsIambiguousConflicts
         _tlOavailablePredicates = rule2789 _lhsIavailablePredicates
         _tlObetaUnique = rule2790 _hdIbetaUnique
         _tlOclassEnvironment = rule2791 _lhsIclassEnvironment
         _tlOclassMemberEnv = rule2792 _lhsIclassMemberEnv
         _tlOclassMemberTypeSchemes = rule2793 _lhsIclassMemberTypeSchemes
         _tlOclassNamesEnv = rule2794 _lhsIclassNamesEnv
         _tlOclassPredicate = rule2795 _lhsIclassPredicate
         _tlOclassTypeSchemes = rule2796 _lhsIclassTypeSchemes
         _tlOcollectErrors = rule2797 _hdIcollectErrors
         _tlOcollectWarnings = rule2798 _hdIcollectWarnings
         _tlOcounter = rule2799 _hdIcounter
         _tlOcurClassPred = rule2800 _lhsIcurClassPred
         _tlOcurPred = rule2801 _lhsIcurPred
         _tlOcurrentChunk = rule2802 _lhsIcurrentChunk
         _tlOdictionaryEnvironment = rule2803 _hdIdictionaryEnvironment
         _tlOimportEnvironment = rule2804 _lhsIimportEnvironment
         _tlOinstanceName = rule2805 _lhsIinstanceName
         _tlOinstanceTypes = rule2806 _lhsIinstanceTypes
         _tlOmatchIO = rule2807 _hdImatchIO
         _tlOmoduleName = rule2808 _lhsImoduleName
         _tlOmonos = rule2809 _lhsImonos
         _tlOnamesInScope = rule2810 _lhsInamesInScope
         _tlOorderedTypeSynonyms = rule2811 _lhsIorderedTypeSynonyms
         _tlOparentTree = rule2812 _lhsIparentTree
         _tlOpatternMatchWarnings = rule2813 _hdIpatternMatchWarnings
         _tlOrequiredPredicates = rule2814 _lhsIrequiredPredicates
         _tlOsubstitution = rule2815 _lhsIsubstitution
         _tlOtypeConstructors = rule2816 _lhsItypeConstructors
         _tlOtypeschemeMap = rule2817 _lhsItypeschemeMap
         _tlOuniqueChunk = rule2818 _hdIuniqueChunk
         _tlOuniqueSecondRound = rule2819 _hdIuniqueSecondRound
         _tlOvariableMapping = rule2820 _lhsIvariableMapping
         !__result_ = T_Expressions_vOut43 _lhsOassumptions _lhsObetaUnique _lhsObetas _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraintslist _lhsOcounter _lhsOdictionaryEnvironment _lhsOinfoTrees _lhsOmatchIO _lhsOmatches _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOuniqueSecondRound
         in __result_ )
     in C_Expressions_s44 v43
   {-# INLINE rule2733 #-}
   rule2733 = \ ((_hdImatches) :: [Maybe MetaVariableTable]) ((_lhsItryPatterns) :: [(Expressions    , [String])]) ((_tlImatches) :: [Maybe MetaVariableTable]) ->
            match2' match_Expressions_Cons _lhsItryPatterns [] [_hdImatches, _tlImatches]
   {-# INLINE rule2734 #-}
   rule2734 = \ ((_hdIinfoTree) :: InfoTree) ((_tlIinfoTrees) :: InfoTrees) ->
                               _hdIinfoTree : _tlIinfoTrees
   {-# INLINE rule2735 #-}
   rule2735 = \ ((_hdIbeta) :: Tp) ((_tlIbetas) :: Tps) ->
                                _hdIbeta : _tlIbetas
   {-# INLINE rule2736 #-}
   rule2736 = \ ((_hdIassumptions) :: Assumptions) ((_tlIassumptions) :: Assumptions) ->
                                _hdIassumptions `combine` _tlIassumptions
   {-# INLINE rule2737 #-}
   rule2737 = \ ((_hdIconstraints) :: ConstraintSet) ((_tlIconstraintslist) :: ConstraintSets) ->
                                _hdIconstraints : _tlIconstraintslist
   {-# INLINE rule2738 #-}
   rule2738 = \ ((_hdIcollectInstances) :: [(Name, Instance)]) ((_tlIcollectInstances) :: [(Name, Instance)]) ->
     _hdIcollectInstances  ++  _tlIcollectInstances
   {-# INLINE rule2739 #-}
   rule2739 = \ ((_hdIunboundNames) :: Names) ((_tlIunboundNames) :: Names) ->
     ((++) _hdIunboundNames _tlIunboundNames)
   {-# INLINE rule2740 #-}
   rule2740 = \ ((_hdIself) :: Expression) ((_tlIself) :: Expressions) ->
     (:) _hdIself _tlIself
   {-# INLINE rule2741 #-}
   rule2741 = \ _self ->
     _self
   {-# INLINE rule2742 #-}
   rule2742 = \ ((_tlIbetaUnique) :: Int) ->
     _tlIbetaUnique
   {-# INLINE rule2743 #-}
   rule2743 = \ ((_tlIcollectErrors) :: TypeErrors) ->
     _tlIcollectErrors
   {-# INLINE rule2744 #-}
   rule2744 = \ ((_tlIcollectWarnings) :: Warnings) ->
     _tlIcollectWarnings
   {-# INLINE rule2745 #-}
   rule2745 = \ ((_tlIcounter) :: Int) ->
     _tlIcounter
   {-# INLINE rule2746 #-}
   rule2746 = \ ((_tlIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _tlIdictionaryEnvironment
   {-# INLINE rule2747 #-}
   rule2747 = \ ((_tlImatchIO) :: IO ()) ->
     _tlImatchIO
   {-# INLINE rule2748 #-}
   rule2748 = \ ((_tlIpatternMatchWarnings) :: [Warning]) ->
     _tlIpatternMatchWarnings
   {-# INLINE rule2749 #-}
   rule2749 = \ ((_tlIuniqueChunk) :: Int) ->
     _tlIuniqueChunk
   {-# INLINE rule2750 #-}
   rule2750 = \ ((_tlIuniqueSecondRound) :: Int) ->
     _tlIuniqueSecondRound
   {-# INLINE rule2751 #-}
   rule2751 = \ ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ->
     _lhsIallPatterns
   {-# INLINE rule2752 #-}
   rule2752 = \ ((_lhsIallTypeSchemes) :: M.Map NameWithRange TpScheme) ->
     _lhsIallTypeSchemes
   {-# INLINE rule2753 #-}
   rule2753 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule2754 #-}
   rule2754 = \ ((_lhsIavailablePredicates) :: [PredicateWithSource]) ->
     _lhsIavailablePredicates
   {-# INLINE rule2755 #-}
   rule2755 = \ ((_lhsIbetaUnique) :: Int) ->
     _lhsIbetaUnique
   {-# INLINE rule2756 #-}
   rule2756 = \ ((_lhsIclassEnvironment) :: ClassEnvironment) ->
     _lhsIclassEnvironment
   {-# INLINE rule2757 #-}
   rule2757 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule2758 #-}
   rule2758 = \ ((_lhsIclassMemberTypeSchemes) :: Maybe [(Name, TpScheme)]) ->
     _lhsIclassMemberTypeSchemes
   {-# INLINE rule2759 #-}
   rule2759 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule2760 #-}
   rule2760 = \ ((_lhsIclassPredicate) :: Maybe (Name, Names)) ->
     _lhsIclassPredicate
   {-# INLINE rule2761 #-}
   rule2761 = \ ((_lhsIclassTypeSchemes) :: M.Map Name TpScheme) ->
     _lhsIclassTypeSchemes
   {-# INLINE rule2762 #-}
   rule2762 = \ ((_lhsIcollectErrors) :: TypeErrors) ->
     _lhsIcollectErrors
   {-# INLINE rule2763 #-}
   rule2763 = \ ((_lhsIcollectWarnings) :: Warnings) ->
     _lhsIcollectWarnings
   {-# INLINE rule2764 #-}
   rule2764 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule2765 #-}
   rule2765 = \ ((_lhsIcurClassPred) :: Maybe Predicate) ->
     _lhsIcurClassPred
   {-# INLINE rule2766 #-}
   rule2766 = \ ((_lhsIcurPred) :: Maybe Predicate) ->
     _lhsIcurPred
   {-# INLINE rule2767 #-}
   rule2767 = \ ((_lhsIcurrentChunk) :: Int) ->
     _lhsIcurrentChunk
   {-# INLINE rule2768 #-}
   rule2768 = \ ((_lhsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _lhsIdictionaryEnvironment
   {-# INLINE rule2769 #-}
   rule2769 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule2770 #-}
   rule2770 = \ ((_lhsIinstanceName) :: Maybe Name) ->
     _lhsIinstanceName
   {-# INLINE rule2771 #-}
   rule2771 = \ ((_lhsIinstanceTypes) :: [(Name, TpScheme)]) ->
     _lhsIinstanceTypes
   {-# INLINE rule2772 #-}
   rule2772 = \ ((_lhsImatchIO) :: IO ()) ->
     _lhsImatchIO
   {-# INLINE rule2773 #-}
   rule2773 = \ ((_lhsImoduleName) :: Maybe Name) ->
     _lhsImoduleName
   {-# INLINE rule2774 #-}
   rule2774 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule2775 #-}
   rule2775 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule2776 #-}
   rule2776 = \ ((_lhsIorderedTypeSynonyms) :: OrderedTypeSynonyms) ->
     _lhsIorderedTypeSynonyms
   {-# INLINE rule2777 #-}
   rule2777 = \ ((_lhsIparentTree) :: InfoTree) ->
     _lhsIparentTree
   {-# INLINE rule2778 #-}
   rule2778 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule2779 #-}
   rule2779 = \ ((_lhsIrequiredPredicates) :: Predicates) ->
     _lhsIrequiredPredicates
   {-# INLINE rule2780 #-}
   rule2780 = \ ((_lhsIsubstitution) :: FixpointSubstitution) ->
     _lhsIsubstitution
   {-# INLINE rule2781 #-}
   rule2781 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
   {-# INLINE rule2782 #-}
   rule2782 = \ ((_lhsItypeschemeMap) :: M.Map Int (Scheme Predicates)) ->
     _lhsItypeschemeMap
   {-# INLINE rule2783 #-}
   rule2783 = \ ((_lhsIuniqueChunk) :: Int) ->
     _lhsIuniqueChunk
   {-# INLINE rule2784 #-}
   rule2784 = \ ((_lhsIuniqueSecondRound) :: Int) ->
     _lhsIuniqueSecondRound
   {-# INLINE rule2785 #-}
   rule2785 = \ ((_lhsIvariableMapping) :: Maybe [(Name, Tp)]) ->
     _lhsIvariableMapping
   {-# INLINE rule2786 #-}
   rule2786 = \ ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ->
     _lhsIallPatterns
   {-# INLINE rule2787 #-}
   rule2787 = \ ((_lhsIallTypeSchemes) :: M.Map NameWithRange TpScheme) ->
     _lhsIallTypeSchemes
   {-# INLINE rule2788 #-}
   rule2788 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule2789 #-}
   rule2789 = \ ((_lhsIavailablePredicates) :: [PredicateWithSource]) ->
     _lhsIavailablePredicates
   {-# INLINE rule2790 #-}
   rule2790 = \ ((_hdIbetaUnique) :: Int) ->
     _hdIbetaUnique
   {-# INLINE rule2791 #-}
   rule2791 = \ ((_lhsIclassEnvironment) :: ClassEnvironment) ->
     _lhsIclassEnvironment
   {-# INLINE rule2792 #-}
   rule2792 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule2793 #-}
   rule2793 = \ ((_lhsIclassMemberTypeSchemes) :: Maybe [(Name, TpScheme)]) ->
     _lhsIclassMemberTypeSchemes
   {-# INLINE rule2794 #-}
   rule2794 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule2795 #-}
   rule2795 = \ ((_lhsIclassPredicate) :: Maybe (Name, Names)) ->
     _lhsIclassPredicate
   {-# INLINE rule2796 #-}
   rule2796 = \ ((_lhsIclassTypeSchemes) :: M.Map Name TpScheme) ->
     _lhsIclassTypeSchemes
   {-# INLINE rule2797 #-}
   rule2797 = \ ((_hdIcollectErrors) :: TypeErrors) ->
     _hdIcollectErrors
   {-# INLINE rule2798 #-}
   rule2798 = \ ((_hdIcollectWarnings) :: Warnings) ->
     _hdIcollectWarnings
   {-# INLINE rule2799 #-}
   rule2799 = \ ((_hdIcounter) :: Int) ->
     _hdIcounter
   {-# INLINE rule2800 #-}
   rule2800 = \ ((_lhsIcurClassPred) :: Maybe Predicate) ->
     _lhsIcurClassPred
   {-# INLINE rule2801 #-}
   rule2801 = \ ((_lhsIcurPred) :: Maybe Predicate) ->
     _lhsIcurPred
   {-# INLINE rule2802 #-}
   rule2802 = \ ((_lhsIcurrentChunk) :: Int) ->
     _lhsIcurrentChunk
   {-# INLINE rule2803 #-}
   rule2803 = \ ((_hdIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _hdIdictionaryEnvironment
   {-# INLINE rule2804 #-}
   rule2804 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule2805 #-}
   rule2805 = \ ((_lhsIinstanceName) :: Maybe Name) ->
     _lhsIinstanceName
   {-# INLINE rule2806 #-}
   rule2806 = \ ((_lhsIinstanceTypes) :: [(Name, TpScheme)]) ->
     _lhsIinstanceTypes
   {-# INLINE rule2807 #-}
   rule2807 = \ ((_hdImatchIO) :: IO ()) ->
     _hdImatchIO
   {-# INLINE rule2808 #-}
   rule2808 = \ ((_lhsImoduleName) :: Maybe Name) ->
     _lhsImoduleName
   {-# INLINE rule2809 #-}
   rule2809 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule2810 #-}
   rule2810 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule2811 #-}
   rule2811 = \ ((_lhsIorderedTypeSynonyms) :: OrderedTypeSynonyms) ->
     _lhsIorderedTypeSynonyms
   {-# INLINE rule2812 #-}
   rule2812 = \ ((_lhsIparentTree) :: InfoTree) ->
     _lhsIparentTree
   {-# INLINE rule2813 #-}
   rule2813 = \ ((_hdIpatternMatchWarnings) :: [Warning]) ->
     _hdIpatternMatchWarnings
   {-# INLINE rule2814 #-}
   rule2814 = \ ((_lhsIrequiredPredicates) :: Predicates) ->
     _lhsIrequiredPredicates
   {-# INLINE rule2815 #-}
   rule2815 = \ ((_lhsIsubstitution) :: FixpointSubstitution) ->
     _lhsIsubstitution
   {-# INLINE rule2816 #-}
   rule2816 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
   {-# INLINE rule2817 #-}
   rule2817 = \ ((_lhsItypeschemeMap) :: M.Map Int (Scheme Predicates)) ->
     _lhsItypeschemeMap
   {-# INLINE rule2818 #-}
   rule2818 = \ ((_hdIuniqueChunk) :: Int) ->
     _hdIuniqueChunk
   {-# INLINE rule2819 #-}
   rule2819 = \ ((_hdIuniqueSecondRound) :: Int) ->
     _hdIuniqueSecondRound
   {-# INLINE rule2820 #-}
   rule2820 = \ ((_lhsIvariableMapping) :: Maybe [(Name, Tp)]) ->
     _lhsIvariableMapping
{-# NOINLINE sem_Expressions_Nil #-}
sem_Expressions_Nil ::  T_Expressions 
sem_Expressions_Nil  = T_Expressions (return st44) where
   {-# NOINLINE st44 #-}
   !st44 = let
      v43 :: T_Expressions_v43 
      v43 = \ !(T_Expressions_vIn43 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItryPatterns _lhsItypeConstructors _lhsItypeschemeMap _lhsIuniqueChunk _lhsIuniqueSecondRound _lhsIvariableMapping) -> ( let
         _lhsOmatches :: [Maybe MetaVariableTable]
         ((),_lhsOmatches,_,_,_,_) = rule2821 _lhsItryPatterns
         _lhsOinfoTrees :: InfoTrees
         _lhsOinfoTrees = rule2822  ()
         _lhsObetas :: Tps
         _lhsObetas = rule2823  ()
         _lhsOassumptions :: Assumptions
         _lhsOassumptions = rule2824  ()
         _lhsOconstraintslist :: ConstraintSets
         _lhsOconstraintslist = rule2825  ()
         _lhsOcollectInstances :: [(Name, Instance)]
         _lhsOcollectInstances = rule2826  ()
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule2827  ()
         _self = rule2828  ()
         _lhsOself :: Expressions
         _lhsOself = rule2829 _self
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule2830 _lhsIbetaUnique
         _lhsOcollectErrors :: TypeErrors
         _lhsOcollectErrors = rule2831 _lhsIcollectErrors
         _lhsOcollectWarnings :: Warnings
         _lhsOcollectWarnings = rule2832 _lhsIcollectWarnings
         _lhsOcounter :: Int
         _lhsOcounter = rule2833 _lhsIcounter
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule2834 _lhsIdictionaryEnvironment
         _lhsOmatchIO :: IO ()
         _lhsOmatchIO = rule2835 _lhsImatchIO
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule2836 _lhsIpatternMatchWarnings
         _lhsOuniqueChunk :: Int
         _lhsOuniqueChunk = rule2837 _lhsIuniqueChunk
         _lhsOuniqueSecondRound :: Int
         _lhsOuniqueSecondRound = rule2838 _lhsIuniqueSecondRound
         !__result_ = T_Expressions_vOut43 _lhsOassumptions _lhsObetaUnique _lhsObetas _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraintslist _lhsOcounter _lhsOdictionaryEnvironment _lhsOinfoTrees _lhsOmatchIO _lhsOmatches _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOuniqueSecondRound
         in __result_ )
     in C_Expressions_s44 v43
   {-# INLINE rule2821 #-}
   rule2821 = \ ((_lhsItryPatterns) :: [(Expressions    , [String])]) ->
            match0' match_Expressions_Nil _lhsItryPatterns [] []
   {-# INLINE rule2822 #-}
   rule2822 = \  (_ :: ()) ->
                               []
   {-# INLINE rule2823 #-}
   rule2823 = \  (_ :: ()) ->
                                []
   {-# INLINE rule2824 #-}
   rule2824 = \  (_ :: ()) ->
                                noAssumptions
   {-# INLINE rule2825 #-}
   rule2825 = \  (_ :: ()) ->
                                []
   {-# INLINE rule2826 #-}
   rule2826 = \  (_ :: ()) ->
     []
   {-# INLINE rule2827 #-}
   rule2827 = \  (_ :: ()) ->
     []
   {-# INLINE rule2828 #-}
   rule2828 = \  (_ :: ()) ->
     []
   {-# INLINE rule2829 #-}
   rule2829 = \ _self ->
     _self
   {-# INLINE rule2830 #-}
   rule2830 = \ ((_lhsIbetaUnique) :: Int) ->
     _lhsIbetaUnique
   {-# INLINE rule2831 #-}
   rule2831 = \ ((_lhsIcollectErrors) :: TypeErrors) ->
     _lhsIcollectErrors
   {-# INLINE rule2832 #-}
   rule2832 = \ ((_lhsIcollectWarnings) :: Warnings) ->
     _lhsIcollectWarnings
   {-# INLINE rule2833 #-}
   rule2833 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule2834 #-}
   rule2834 = \ ((_lhsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _lhsIdictionaryEnvironment
   {-# INLINE rule2835 #-}
   rule2835 = \ ((_lhsImatchIO) :: IO ()) ->
     _lhsImatchIO
   {-# INLINE rule2836 #-}
   rule2836 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule2837 #-}
   rule2837 = \ ((_lhsIuniqueChunk) :: Int) ->
     _lhsIuniqueChunk
   {-# INLINE rule2838 #-}
   rule2838 = \ ((_lhsIuniqueSecondRound) :: Int) ->
     _lhsIuniqueSecondRound

-- FieldDeclaration --------------------------------------------
-- wrapper
data Inh_FieldDeclaration  = Inh_FieldDeclaration { ambiguousConflicts_Inh_FieldDeclaration :: !([[Name]]), classMemberEnv_Inh_FieldDeclaration :: !(ClassMemberEnvironment), classNamesEnv_Inh_FieldDeclaration :: !(ClassNameEnvironment), counter_Inh_FieldDeclaration :: !(Int), namesInScope_Inh_FieldDeclaration :: !(Names) }
data Syn_FieldDeclaration  = Syn_FieldDeclaration { counter_Syn_FieldDeclaration :: !(Int), self_Syn_FieldDeclaration :: !(FieldDeclaration), unboundNames_Syn_FieldDeclaration :: !(Names) }
{-# INLINABLE wrap_FieldDeclaration #-}
wrap_FieldDeclaration :: T_FieldDeclaration  -> Inh_FieldDeclaration  -> (Syn_FieldDeclaration )
wrap_FieldDeclaration !(T_FieldDeclaration act) !(Inh_FieldDeclaration _lhsIambiguousConflicts _lhsIclassMemberEnv _lhsIclassNamesEnv _lhsIcounter _lhsInamesInScope) =
   Control.Monad.Identity.runIdentity (
     do !sem <- act
        let arg46 = T_FieldDeclaration_vIn46 _lhsIambiguousConflicts _lhsIclassMemberEnv _lhsIclassNamesEnv _lhsIcounter _lhsInamesInScope
        !(T_FieldDeclaration_vOut46 _lhsOcounter _lhsOself _lhsOunboundNames) <- return (inv_FieldDeclaration_s47 sem arg46)
        return (Syn_FieldDeclaration _lhsOcounter _lhsOself _lhsOunboundNames)
   )

-- cata
{-# INLINE sem_FieldDeclaration #-}
sem_FieldDeclaration :: FieldDeclaration  -> T_FieldDeclaration 
sem_FieldDeclaration ( FieldDeclaration_FieldDeclaration range_ names_ type_ ) = sem_FieldDeclaration_FieldDeclaration ( sem_Range range_ ) ( sem_Names names_ ) ( sem_AnnotatedType type_ )

-- semantic domain
newtype T_FieldDeclaration  = T_FieldDeclaration {
                                                 attach_T_FieldDeclaration :: Identity (T_FieldDeclaration_s47 )
                                                 }
newtype T_FieldDeclaration_s47  = C_FieldDeclaration_s47 {
                                                         inv_FieldDeclaration_s47 :: (T_FieldDeclaration_v46 )
                                                         }
data T_FieldDeclaration_s48  = C_FieldDeclaration_s48
type T_FieldDeclaration_v46  = (T_FieldDeclaration_vIn46 ) -> (T_FieldDeclaration_vOut46 )
data T_FieldDeclaration_vIn46  = T_FieldDeclaration_vIn46 ([[Name]]) (ClassMemberEnvironment) (ClassNameEnvironment) (Int) (Names)
data T_FieldDeclaration_vOut46  = T_FieldDeclaration_vOut46 (Int) (FieldDeclaration) (Names)
{-# NOINLINE sem_FieldDeclaration_FieldDeclaration #-}
sem_FieldDeclaration_FieldDeclaration :: T_Range  -> T_Names  -> T_AnnotatedType  -> T_FieldDeclaration 
sem_FieldDeclaration_FieldDeclaration arg_range_ arg_names_ arg_type_ = T_FieldDeclaration (return st47) where
   {-# NOINLINE st47 #-}
   !st47 = let
      v46 :: T_FieldDeclaration_v46 
      v46 = \ !(T_FieldDeclaration_vIn46 _lhsIambiguousConflicts _lhsIclassMemberEnv _lhsIclassNamesEnv _lhsIcounter _lhsInamesInScope) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _namesX116 = Control.Monad.Identity.runIdentity (attach_T_Names (arg_names_))
         _typeX8 = Control.Monad.Identity.runIdentity (attach_T_AnnotatedType (arg_type_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_Names_vOut115 _namesIself) = inv_Names_s116 _namesX116 (T_Names_vIn115 )
         (T_AnnotatedType_vOut7 _typeIcounter _typeIself _typeIunboundNames) = inv_AnnotatedType_s8 _typeX8 (T_AnnotatedType_vIn7 _typeOambiguousConflicts _typeOclassMemberEnv _typeOclassNamesEnv _typeOcounter _typeOnamesInScope)
         (_kindErrors,_tyconEnv,_constructorenv,_importEnvironment,_valueConstructors,_allValueConstructors,_typeConstructors,_typeConstructorsWithDefined,_allTypeConstructors,_warnings,_ambiguousValueConstructors,_ambiguousTypeConstructors) = rule2839  ()
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule2840 _typeIunboundNames
         _self = rule2841 _namesIself _rangeIself _typeIself
         _lhsOself :: FieldDeclaration
         _lhsOself = rule2842 _self
         _lhsOcounter :: Int
         _lhsOcounter = rule2843 _typeIcounter
         _typeOambiguousConflicts = rule2844 _lhsIambiguousConflicts
         _typeOclassMemberEnv = rule2845 _lhsIclassMemberEnv
         _typeOclassNamesEnv = rule2846 _lhsIclassNamesEnv
         _typeOcounter = rule2847 _lhsIcounter
         _typeOnamesInScope = rule2848 _lhsInamesInScope
         !__result_ = T_FieldDeclaration_vOut46 _lhsOcounter _lhsOself _lhsOunboundNames
         in __result_ )
     in C_FieldDeclaration_s47 v46
   {-# INLINE rule2839 #-}
   rule2839 = \  (_ :: ()) ->
                                                                                                  internalError "PartialSyntax.ag" "n/a" "FieldDeclaration.FieldDeclaration"
   {-# INLINE rule2840 #-}
   rule2840 = \ ((_typeIunboundNames) :: Names) ->
     _typeIunboundNames
   {-# INLINE rule2841 #-}
   rule2841 = \ ((_namesIself) :: Names) ((_rangeIself) :: Range) ((_typeIself) :: AnnotatedType) ->
     FieldDeclaration_FieldDeclaration _rangeIself _namesIself _typeIself
   {-# INLINE rule2842 #-}
   rule2842 = \ _self ->
     _self
   {-# INLINE rule2843 #-}
   rule2843 = \ ((_typeIcounter) :: Int) ->
     _typeIcounter
   {-# INLINE rule2844 #-}
   rule2844 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule2845 #-}
   rule2845 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule2846 #-}
   rule2846 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule2847 #-}
   rule2847 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule2848 #-}
   rule2848 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope

-- FieldDeclarations -------------------------------------------
-- wrapper
data Inh_FieldDeclarations  = Inh_FieldDeclarations { ambiguousConflicts_Inh_FieldDeclarations :: !([[Name]]), classMemberEnv_Inh_FieldDeclarations :: !(ClassMemberEnvironment), classNamesEnv_Inh_FieldDeclarations :: !(ClassNameEnvironment), counter_Inh_FieldDeclarations :: !(Int), namesInScope_Inh_FieldDeclarations :: !(Names) }
data Syn_FieldDeclarations  = Syn_FieldDeclarations { counter_Syn_FieldDeclarations :: !(Int), self_Syn_FieldDeclarations :: !(FieldDeclarations), unboundNames_Syn_FieldDeclarations :: !(Names) }
{-# INLINABLE wrap_FieldDeclarations #-}
wrap_FieldDeclarations :: T_FieldDeclarations  -> Inh_FieldDeclarations  -> (Syn_FieldDeclarations )
wrap_FieldDeclarations !(T_FieldDeclarations act) !(Inh_FieldDeclarations _lhsIambiguousConflicts _lhsIclassMemberEnv _lhsIclassNamesEnv _lhsIcounter _lhsInamesInScope) =
   Control.Monad.Identity.runIdentity (
     do !sem <- act
        let arg49 = T_FieldDeclarations_vIn49 _lhsIambiguousConflicts _lhsIclassMemberEnv _lhsIclassNamesEnv _lhsIcounter _lhsInamesInScope
        !(T_FieldDeclarations_vOut49 _lhsOcounter _lhsOself _lhsOunboundNames) <- return (inv_FieldDeclarations_s50 sem arg49)
        return (Syn_FieldDeclarations _lhsOcounter _lhsOself _lhsOunboundNames)
   )

-- cata
{-# NOINLINE sem_FieldDeclarations #-}
sem_FieldDeclarations :: FieldDeclarations  -> T_FieldDeclarations 
sem_FieldDeclarations list = Prelude.foldr sem_FieldDeclarations_Cons sem_FieldDeclarations_Nil (Prelude.map sem_FieldDeclaration list)

-- semantic domain
newtype T_FieldDeclarations  = T_FieldDeclarations {
                                                   attach_T_FieldDeclarations :: Identity (T_FieldDeclarations_s50 )
                                                   }
newtype T_FieldDeclarations_s50  = C_FieldDeclarations_s50 {
                                                           inv_FieldDeclarations_s50 :: (T_FieldDeclarations_v49 )
                                                           }
data T_FieldDeclarations_s51  = C_FieldDeclarations_s51
type T_FieldDeclarations_v49  = (T_FieldDeclarations_vIn49 ) -> (T_FieldDeclarations_vOut49 )
data T_FieldDeclarations_vIn49  = T_FieldDeclarations_vIn49 ([[Name]]) (ClassMemberEnvironment) (ClassNameEnvironment) (Int) (Names)
data T_FieldDeclarations_vOut49  = T_FieldDeclarations_vOut49 (Int) (FieldDeclarations) (Names)
{-# NOINLINE sem_FieldDeclarations_Cons #-}
sem_FieldDeclarations_Cons :: T_FieldDeclaration  -> T_FieldDeclarations  -> T_FieldDeclarations 
sem_FieldDeclarations_Cons arg_hd_ arg_tl_ = T_FieldDeclarations (return st50) where
   {-# NOINLINE st50 #-}
   !st50 = let
      v49 :: T_FieldDeclarations_v49 
      v49 = \ !(T_FieldDeclarations_vIn49 _lhsIambiguousConflicts _lhsIclassMemberEnv _lhsIclassNamesEnv _lhsIcounter _lhsInamesInScope) -> ( let
         _hdX47 = Control.Monad.Identity.runIdentity (attach_T_FieldDeclaration (arg_hd_))
         _tlX50 = Control.Monad.Identity.runIdentity (attach_T_FieldDeclarations (arg_tl_))
         (T_FieldDeclaration_vOut46 _hdIcounter _hdIself _hdIunboundNames) = inv_FieldDeclaration_s47 _hdX47 (T_FieldDeclaration_vIn46 _hdOambiguousConflicts _hdOclassMemberEnv _hdOclassNamesEnv _hdOcounter _hdOnamesInScope)
         (T_FieldDeclarations_vOut49 _tlIcounter _tlIself _tlIunboundNames) = inv_FieldDeclarations_s50 _tlX50 (T_FieldDeclarations_vIn49 _tlOambiguousConflicts _tlOclassMemberEnv _tlOclassNamesEnv _tlOcounter _tlOnamesInScope)
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule2849 _hdIunboundNames _tlIunboundNames
         _self = rule2850 _hdIself _tlIself
         _lhsOself :: FieldDeclarations
         _lhsOself = rule2851 _self
         _lhsOcounter :: Int
         _lhsOcounter = rule2852 _tlIcounter
         _hdOambiguousConflicts = rule2853 _lhsIambiguousConflicts
         _hdOclassMemberEnv = rule2854 _lhsIclassMemberEnv
         _hdOclassNamesEnv = rule2855 _lhsIclassNamesEnv
         _hdOcounter = rule2856 _lhsIcounter
         _hdOnamesInScope = rule2857 _lhsInamesInScope
         _tlOambiguousConflicts = rule2858 _lhsIambiguousConflicts
         _tlOclassMemberEnv = rule2859 _lhsIclassMemberEnv
         _tlOclassNamesEnv = rule2860 _lhsIclassNamesEnv
         _tlOcounter = rule2861 _hdIcounter
         _tlOnamesInScope = rule2862 _lhsInamesInScope
         !__result_ = T_FieldDeclarations_vOut49 _lhsOcounter _lhsOself _lhsOunboundNames
         in __result_ )
     in C_FieldDeclarations_s50 v49
   {-# INLINE rule2849 #-}
   rule2849 = \ ((_hdIunboundNames) :: Names) ((_tlIunboundNames) :: Names) ->
     ((++) _hdIunboundNames _tlIunboundNames)
   {-# INLINE rule2850 #-}
   rule2850 = \ ((_hdIself) :: FieldDeclaration) ((_tlIself) :: FieldDeclarations) ->
     (:) _hdIself _tlIself
   {-# INLINE rule2851 #-}
   rule2851 = \ _self ->
     _self
   {-# INLINE rule2852 #-}
   rule2852 = \ ((_tlIcounter) :: Int) ->
     _tlIcounter
   {-# INLINE rule2853 #-}
   rule2853 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule2854 #-}
   rule2854 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule2855 #-}
   rule2855 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule2856 #-}
   rule2856 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule2857 #-}
   rule2857 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule2858 #-}
   rule2858 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule2859 #-}
   rule2859 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule2860 #-}
   rule2860 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule2861 #-}
   rule2861 = \ ((_hdIcounter) :: Int) ->
     _hdIcounter
   {-# INLINE rule2862 #-}
   rule2862 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
{-# NOINLINE sem_FieldDeclarations_Nil #-}
sem_FieldDeclarations_Nil ::  T_FieldDeclarations 
sem_FieldDeclarations_Nil  = T_FieldDeclarations (return st50) where
   {-# NOINLINE st50 #-}
   !st50 = let
      v49 :: T_FieldDeclarations_v49 
      v49 = \ !(T_FieldDeclarations_vIn49 _lhsIambiguousConflicts _lhsIclassMemberEnv _lhsIclassNamesEnv _lhsIcounter _lhsInamesInScope) -> ( let
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule2863  ()
         _self = rule2864  ()
         _lhsOself :: FieldDeclarations
         _lhsOself = rule2865 _self
         _lhsOcounter :: Int
         _lhsOcounter = rule2866 _lhsIcounter
         !__result_ = T_FieldDeclarations_vOut49 _lhsOcounter _lhsOself _lhsOunboundNames
         in __result_ )
     in C_FieldDeclarations_s50 v49
   {-# INLINE rule2863 #-}
   rule2863 = \  (_ :: ()) ->
     []
   {-# INLINE rule2864 #-}
   rule2864 = \  (_ :: ()) ->
     []
   {-# INLINE rule2865 #-}
   rule2865 = \ _self ->
     _self
   {-# INLINE rule2866 #-}
   rule2866 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter

-- Fixity ------------------------------------------------------
-- wrapper
data Inh_Fixity  = Inh_Fixity {  }
data Syn_Fixity  = Syn_Fixity { self_Syn_Fixity :: !(Fixity) }
{-# INLINABLE wrap_Fixity #-}
wrap_Fixity :: T_Fixity  -> Inh_Fixity  -> (Syn_Fixity )
wrap_Fixity !(T_Fixity act) !(Inh_Fixity ) =
   Control.Monad.Identity.runIdentity (
     do !sem <- act
        let arg52 = T_Fixity_vIn52 
        !(T_Fixity_vOut52 _lhsOself) <- return (inv_Fixity_s53 sem arg52)
        return (Syn_Fixity _lhsOself)
   )

-- cata
{-# NOINLINE sem_Fixity #-}
sem_Fixity :: Fixity  -> T_Fixity 
sem_Fixity ( Fixity_Infixl range_ ) = sem_Fixity_Infixl ( sem_Range range_ )
sem_Fixity ( Fixity_Infixr range_ ) = sem_Fixity_Infixr ( sem_Range range_ )
sem_Fixity ( Fixity_Infix range_ ) = sem_Fixity_Infix ( sem_Range range_ )

-- semantic domain
newtype T_Fixity  = T_Fixity {
                             attach_T_Fixity :: Identity (T_Fixity_s53 )
                             }
newtype T_Fixity_s53  = C_Fixity_s53 {
                                     inv_Fixity_s53 :: (T_Fixity_v52 )
                                     }
data T_Fixity_s54  = C_Fixity_s54
type T_Fixity_v52  = (T_Fixity_vIn52 ) -> (T_Fixity_vOut52 )
data T_Fixity_vIn52  = T_Fixity_vIn52 
data T_Fixity_vOut52  = T_Fixity_vOut52 (Fixity)
{-# NOINLINE sem_Fixity_Infixl #-}
sem_Fixity_Infixl :: T_Range  -> T_Fixity 
sem_Fixity_Infixl arg_range_ = T_Fixity (return st53) where
   {-# NOINLINE st53 #-}
   !st53 = let
      v52 :: T_Fixity_v52 
      v52 = \ !(T_Fixity_vIn52 ) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         _self = rule2867 _rangeIself
         _lhsOself :: Fixity
         _lhsOself = rule2868 _self
         !__result_ = T_Fixity_vOut52 _lhsOself
         in __result_ )
     in C_Fixity_s53 v52
   {-# INLINE rule2867 #-}
   rule2867 = \ ((_rangeIself) :: Range) ->
     Fixity_Infixl _rangeIself
   {-# INLINE rule2868 #-}
   rule2868 = \ _self ->
     _self
{-# NOINLINE sem_Fixity_Infixr #-}
sem_Fixity_Infixr :: T_Range  -> T_Fixity 
sem_Fixity_Infixr arg_range_ = T_Fixity (return st53) where
   {-# NOINLINE st53 #-}
   !st53 = let
      v52 :: T_Fixity_v52 
      v52 = \ !(T_Fixity_vIn52 ) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         _self = rule2869 _rangeIself
         _lhsOself :: Fixity
         _lhsOself = rule2870 _self
         !__result_ = T_Fixity_vOut52 _lhsOself
         in __result_ )
     in C_Fixity_s53 v52
   {-# INLINE rule2869 #-}
   rule2869 = \ ((_rangeIself) :: Range) ->
     Fixity_Infixr _rangeIself
   {-# INLINE rule2870 #-}
   rule2870 = \ _self ->
     _self
{-# NOINLINE sem_Fixity_Infix #-}
sem_Fixity_Infix :: T_Range  -> T_Fixity 
sem_Fixity_Infix arg_range_ = T_Fixity (return st53) where
   {-# NOINLINE st53 #-}
   !st53 = let
      v52 :: T_Fixity_v52 
      v52 = \ !(T_Fixity_vIn52 ) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         _self = rule2871 _rangeIself
         _lhsOself :: Fixity
         _lhsOself = rule2872 _self
         !__result_ = T_Fixity_vOut52 _lhsOself
         in __result_ )
     in C_Fixity_s53 v52
   {-# INLINE rule2871 #-}
   rule2871 = \ ((_rangeIself) :: Range) ->
     Fixity_Infix _rangeIself
   {-# INLINE rule2872 #-}
   rule2872 = \ _self ->
     _self

-- FunctionBinding ---------------------------------------------
-- wrapper
data Inh_FunctionBinding  = Inh_FunctionBinding { allPatterns_Inh_FunctionBinding :: !([((Expression, [String]), Core_TypingStrategy)]), allTypeSchemes_Inh_FunctionBinding :: !(M.Map NameWithRange TpScheme), ambiguousConflicts_Inh_FunctionBinding :: !([[Name]]), availablePredicates_Inh_FunctionBinding :: !([PredicateWithSource]), betaRight_Inh_FunctionBinding :: !(Tp), betaUnique_Inh_FunctionBinding :: !(Int), betasLeft_Inh_FunctionBinding :: !(Tps), classEnvironment_Inh_FunctionBinding :: !(ClassEnvironment), classMemberEnv_Inh_FunctionBinding :: !(ClassMemberEnvironment), classMemberTypeSchemes_Inh_FunctionBinding :: !(Maybe [(Name, TpScheme)]), classNamesEnv_Inh_FunctionBinding :: !(ClassNameEnvironment), classPredicate_Inh_FunctionBinding :: !(Maybe (Name, Names)), classTypeSchemes_Inh_FunctionBinding :: !(M.Map Name TpScheme), collectErrors_Inh_FunctionBinding :: !(TypeErrors), collectWarnings_Inh_FunctionBinding :: !(Warnings), counter_Inh_FunctionBinding :: !(Int), curClassPred_Inh_FunctionBinding :: !(Maybe Predicate), curPred_Inh_FunctionBinding :: !(Maybe Predicate), currentChunk_Inh_FunctionBinding :: !(Int), dictionaryEnvironment_Inh_FunctionBinding :: !(DictionaryEnvironment), importEnvironment_Inh_FunctionBinding :: !(ImportEnvironment), instanceName_Inh_FunctionBinding :: !(Maybe Name), instanceTypes_Inh_FunctionBinding :: !([(Name, TpScheme)]), matchIO_Inh_FunctionBinding :: !(IO ()), moduleName_Inh_FunctionBinding :: !(Maybe Name), monos_Inh_FunctionBinding :: !(Monos), namesInScope_Inh_FunctionBinding :: !(Names), orderedTypeSynonyms_Inh_FunctionBinding :: !(OrderedTypeSynonyms), parentTree_Inh_FunctionBinding :: !(InfoTree), patternMatchWarnings_Inh_FunctionBinding :: !([Warning]), requiredPredicates_Inh_FunctionBinding :: !(Predicates), substitution_Inh_FunctionBinding :: !(FixpointSubstitution), typeConstructors_Inh_FunctionBinding :: !(TypeConstructorEnvironment), typeschemeMap_Inh_FunctionBinding :: !(M.Map Int (Scheme Predicates)), uniqueChunk_Inh_FunctionBinding :: !(Int), variableMapping_Inh_FunctionBinding :: !(Maybe [(Name, Tp)]) }
data Syn_FunctionBinding  = Syn_FunctionBinding { argcount_Syn_FunctionBinding :: !(Int), assumptions_Syn_FunctionBinding :: !(Assumptions), betaUnique_Syn_FunctionBinding :: !(Int), collectErrors_Syn_FunctionBinding :: !(TypeErrors), collectInstances_Syn_FunctionBinding :: !([(Name, Instance)]), collectWarnings_Syn_FunctionBinding :: !(Warnings), constraints_Syn_FunctionBinding :: !(ConstraintSet), counter_Syn_FunctionBinding :: !(Int), dictionaryEnvironment_Syn_FunctionBinding :: !(DictionaryEnvironment), elements_Syn_FunctionBinding :: !( ([PatternElement], Bool) ), infoTree_Syn_FunctionBinding :: !(InfoTree), matchIO_Syn_FunctionBinding :: !(IO ()), name_Syn_FunctionBinding :: !(Name), numberOfPatterns_Syn_FunctionBinding :: !(Int), patternMatchWarnings_Syn_FunctionBinding :: !([Warning]), self_Syn_FunctionBinding :: !(FunctionBinding), unboundNames_Syn_FunctionBinding :: !(Names), uniqueChunk_Syn_FunctionBinding :: !(Int), unrwar_Syn_FunctionBinding :: !(Warning) }
{-# INLINABLE wrap_FunctionBinding #-}
wrap_FunctionBinding :: T_FunctionBinding  -> Inh_FunctionBinding  -> (Syn_FunctionBinding )
wrap_FunctionBinding !(T_FunctionBinding act) !(Inh_FunctionBinding _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaRight _lhsIbetaUnique _lhsIbetasLeft _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeConstructors _lhsItypeschemeMap _lhsIuniqueChunk _lhsIvariableMapping) =
   Control.Monad.Identity.runIdentity (
     do !sem <- act
        let arg55 = T_FunctionBinding_vIn55 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaRight _lhsIbetaUnique _lhsIbetasLeft _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeConstructors _lhsItypeschemeMap _lhsIuniqueChunk _lhsIvariableMapping
        !(T_FunctionBinding_vOut55 _lhsOargcount _lhsOassumptions _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraints _lhsOcounter _lhsOdictionaryEnvironment _lhsOelements _lhsOinfoTree _lhsOmatchIO _lhsOname _lhsOnumberOfPatterns _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOunrwar) <- return (inv_FunctionBinding_s56 sem arg55)
        return (Syn_FunctionBinding _lhsOargcount _lhsOassumptions _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraints _lhsOcounter _lhsOdictionaryEnvironment _lhsOelements _lhsOinfoTree _lhsOmatchIO _lhsOname _lhsOnumberOfPatterns _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOunrwar)
   )

-- cata
{-# NOINLINE sem_FunctionBinding #-}
sem_FunctionBinding :: FunctionBinding  -> T_FunctionBinding 
sem_FunctionBinding ( FunctionBinding_Hole range_ !id_ ) = sem_FunctionBinding_Hole ( sem_Range range_ ) id_
sem_FunctionBinding ( FunctionBinding_Feedback range_ !feedback_ functionBinding_ ) = sem_FunctionBinding_Feedback ( sem_Range range_ ) feedback_ ( sem_FunctionBinding functionBinding_ )
sem_FunctionBinding ( FunctionBinding_FunctionBinding range_ lefthandside_ righthandside_ ) = sem_FunctionBinding_FunctionBinding ( sem_Range range_ ) ( sem_LeftHandSide lefthandside_ ) ( sem_RightHandSide righthandside_ )

-- semantic domain
newtype T_FunctionBinding  = T_FunctionBinding {
                                               attach_T_FunctionBinding :: Identity (T_FunctionBinding_s56 )
                                               }
newtype T_FunctionBinding_s56  = C_FunctionBinding_s56 {
                                                       inv_FunctionBinding_s56 :: (T_FunctionBinding_v55 )
                                                       }
data T_FunctionBinding_s57  = C_FunctionBinding_s57
type T_FunctionBinding_v55  = (T_FunctionBinding_vIn55 ) -> (T_FunctionBinding_vOut55 )
data T_FunctionBinding_vIn55  = T_FunctionBinding_vIn55 ([((Expression, [String]), Core_TypingStrategy)]) (M.Map NameWithRange TpScheme) ([[Name]]) ([PredicateWithSource]) (Tp) (Int) (Tps) (ClassEnvironment) (ClassMemberEnvironment) (Maybe [(Name, TpScheme)]) (ClassNameEnvironment) (Maybe (Name, Names)) (M.Map Name TpScheme) (TypeErrors) (Warnings) (Int) (Maybe Predicate) (Maybe Predicate) (Int) (DictionaryEnvironment) (ImportEnvironment) (Maybe Name) ([(Name, TpScheme)]) (IO ()) (Maybe Name) (Monos) (Names) (OrderedTypeSynonyms) (InfoTree) ([Warning]) (Predicates) (FixpointSubstitution) (TypeConstructorEnvironment) (M.Map Int (Scheme Predicates)) (Int) (Maybe [(Name, Tp)])
data T_FunctionBinding_vOut55  = T_FunctionBinding_vOut55 (Int) (Assumptions) (Int) (TypeErrors) ([(Name, Instance)]) (Warnings) (ConstraintSet) (Int) (DictionaryEnvironment) ( ([PatternElement], Bool) ) (InfoTree) (IO ()) (Name) (Int) ([Warning]) (FunctionBinding) (Names) (Int) (Warning)
{-# NOINLINE sem_FunctionBinding_Hole #-}
sem_FunctionBinding_Hole :: T_Range  -> (String) -> T_FunctionBinding 
sem_FunctionBinding_Hole arg_range_ !arg_id_ = T_FunctionBinding (return st56) where
   {-# NOINLINE st56 #-}
   !st56 = let
      v55 :: T_FunctionBinding_v55 
      v55 = \ !(T_FunctionBinding_vIn55 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaRight _lhsIbetaUnique _lhsIbetasLeft _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeConstructors _lhsItypeschemeMap _lhsIuniqueChunk _lhsIvariableMapping) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         _lhsOargcount :: Int
         _lhsOargcount = rule2873  ()
         _lhsOelements ::  ([PatternElement], Bool) 
         _lhsOelements = rule2874  ()
         _lhsOunrwar :: Warning
         _lhsOunrwar = rule2875  ()
         _parentTree = rule2876 _lhsIparentTree _localInfo
         _lhsOinfoTree :: InfoTree
         _lhsOinfoTree = rule2877 _parentTree
         _localInfo = rule2878 _lhsImonos _self
         _assumptions = rule2879  ()
         _constraints = rule2880  ()
         _numberOfPatterns = rule2881  ()
         _name = rule2882  ()
         _lhsOcollectInstances :: [(Name, Instance)]
         _lhsOcollectInstances = rule2883  ()
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule2884  ()
         _self = rule2885 _rangeIself arg_id_
         _lhsOself :: FunctionBinding
         _lhsOself = rule2886 _self
         _lhsOassumptions :: Assumptions
         _lhsOassumptions = rule2887 _assumptions
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule2888 _lhsIbetaUnique
         _lhsOcollectErrors :: TypeErrors
         _lhsOcollectErrors = rule2889 _lhsIcollectErrors
         _lhsOcollectWarnings :: Warnings
         _lhsOcollectWarnings = rule2890 _lhsIcollectWarnings
         _lhsOconstraints :: ConstraintSet
         _lhsOconstraints = rule2891 _constraints
         _lhsOcounter :: Int
         _lhsOcounter = rule2892 _lhsIcounter
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule2893 _lhsIdictionaryEnvironment
         _lhsOmatchIO :: IO ()
         _lhsOmatchIO = rule2894 _lhsImatchIO
         _lhsOname :: Name
         _lhsOname = rule2895 _name
         _lhsOnumberOfPatterns :: Int
         _lhsOnumberOfPatterns = rule2896 _numberOfPatterns
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule2897 _lhsIpatternMatchWarnings
         _lhsOuniqueChunk :: Int
         _lhsOuniqueChunk = rule2898 _lhsIuniqueChunk
         !__result_ = T_FunctionBinding_vOut55 _lhsOargcount _lhsOassumptions _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraints _lhsOcounter _lhsOdictionaryEnvironment _lhsOelements _lhsOinfoTree _lhsOmatchIO _lhsOname _lhsOnumberOfPatterns _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOunrwar
         in __result_ )
     in C_FunctionBinding_s56 v55
   {-# INLINE rule2873 #-}
   rule2873 = \  (_ :: ()) ->
                                         0
   {-# INLINE rule2874 #-}
   rule2874 = \  (_ :: ()) ->
                                         ([], False)
   {-# INLINE rule2875 #-}
   rule2875 = \  (_ :: ()) ->
                                         pmError "FunctionBinding_Hole.unrwar" "hole unrwar"
   {-# INLINE rule2876 #-}
   rule2876 = \ ((_lhsIparentTree) :: InfoTree) _localInfo ->
                                          node _lhsIparentTree _localInfo []
   {-# INLINE rule2877 #-}
   rule2877 = \ _parentTree ->
                                          _parentTree
   {-# INLINE rule2878 #-}
   rule2878 = \ ((_lhsImonos) :: Monos) _self ->
                            LocalInfo { self = UHA_FB _self
                                      , assignedType = Nothing
                                      , monos = _lhsImonos
                                      }
   {-# INLINE rule2879 #-}
   rule2879 = \  (_ :: ()) ->
                                 noAssumptions
   {-# INLINE rule2880 #-}
   rule2880 = \  (_ :: ()) ->
                                 emptyTree
   {-# INLINE rule2881 #-}
   rule2881 = \  (_ :: ()) ->
                                 0
   {-# INLINE rule2882 #-}
   rule2882 = \  (_ :: ()) ->
                                 internalError "TypeInferencing.ag" "n/a" "FunctionBindings(2)"
   {-# INLINE rule2883 #-}
   rule2883 = \  (_ :: ()) ->
     []
   {-# INLINE rule2884 #-}
   rule2884 = \  (_ :: ()) ->
     []
   {-# INLINE rule2885 #-}
   rule2885 = \ ((_rangeIself) :: Range) id_ ->
     FunctionBinding_Hole _rangeIself id_
   {-# INLINE rule2886 #-}
   rule2886 = \ _self ->
     _self
   {-# INLINE rule2887 #-}
   rule2887 = \ _assumptions ->
     _assumptions
   {-# INLINE rule2888 #-}
   rule2888 = \ ((_lhsIbetaUnique) :: Int) ->
     _lhsIbetaUnique
   {-# INLINE rule2889 #-}
   rule2889 = \ ((_lhsIcollectErrors) :: TypeErrors) ->
     _lhsIcollectErrors
   {-# INLINE rule2890 #-}
   rule2890 = \ ((_lhsIcollectWarnings) :: Warnings) ->
     _lhsIcollectWarnings
   {-# INLINE rule2891 #-}
   rule2891 = \ _constraints ->
     _constraints
   {-# INLINE rule2892 #-}
   rule2892 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule2893 #-}
   rule2893 = \ ((_lhsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _lhsIdictionaryEnvironment
   {-# INLINE rule2894 #-}
   rule2894 = \ ((_lhsImatchIO) :: IO ()) ->
     _lhsImatchIO
   {-# INLINE rule2895 #-}
   rule2895 = \ _name ->
     _name
   {-# INLINE rule2896 #-}
   rule2896 = \ _numberOfPatterns ->
     _numberOfPatterns
   {-# INLINE rule2897 #-}
   rule2897 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule2898 #-}
   rule2898 = \ ((_lhsIuniqueChunk) :: Int) ->
     _lhsIuniqueChunk
{-# NOINLINE sem_FunctionBinding_Feedback #-}
sem_FunctionBinding_Feedback :: T_Range  -> (String) -> T_FunctionBinding  -> T_FunctionBinding 
sem_FunctionBinding_Feedback arg_range_ !arg_feedback_ arg_functionBinding_ = T_FunctionBinding (return st56) where
   {-# NOINLINE st56 #-}
   !st56 = let
      v55 :: T_FunctionBinding_v55 
      v55 = \ !(T_FunctionBinding_vIn55 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaRight _lhsIbetaUnique _lhsIbetasLeft _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeConstructors _lhsItypeschemeMap _lhsIuniqueChunk _lhsIvariableMapping) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _functionBindingX56 = Control.Monad.Identity.runIdentity (attach_T_FunctionBinding (arg_functionBinding_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_FunctionBinding_vOut55 _functionBindingIargcount _functionBindingIassumptions _functionBindingIbetaUnique _functionBindingIcollectErrors _functionBindingIcollectInstances _functionBindingIcollectWarnings _functionBindingIconstraints _functionBindingIcounter _functionBindingIdictionaryEnvironment _functionBindingIelements _functionBindingIinfoTree _functionBindingImatchIO _functionBindingIname _functionBindingInumberOfPatterns _functionBindingIpatternMatchWarnings _functionBindingIself _functionBindingIunboundNames _functionBindingIuniqueChunk _functionBindingIunrwar) = inv_FunctionBinding_s56 _functionBindingX56 (T_FunctionBinding_vIn55 _functionBindingOallPatterns _functionBindingOallTypeSchemes _functionBindingOambiguousConflicts _functionBindingOavailablePredicates _functionBindingObetaRight _functionBindingObetaUnique _functionBindingObetasLeft _functionBindingOclassEnvironment _functionBindingOclassMemberEnv _functionBindingOclassMemberTypeSchemes _functionBindingOclassNamesEnv _functionBindingOclassPredicate _functionBindingOclassTypeSchemes _functionBindingOcollectErrors _functionBindingOcollectWarnings _functionBindingOcounter _functionBindingOcurClassPred _functionBindingOcurPred _functionBindingOcurrentChunk _functionBindingOdictionaryEnvironment _functionBindingOimportEnvironment _functionBindingOinstanceName _functionBindingOinstanceTypes _functionBindingOmatchIO _functionBindingOmoduleName _functionBindingOmonos _functionBindingOnamesInScope _functionBindingOorderedTypeSynonyms _functionBindingOparentTree _functionBindingOpatternMatchWarnings _functionBindingOrequiredPredicates _functionBindingOsubstitution _functionBindingOtypeConstructors _functionBindingOtypeschemeMap _functionBindingOuniqueChunk _functionBindingOvariableMapping)
         _lhsOcollectInstances :: [(Name, Instance)]
         _lhsOcollectInstances = rule2899 _functionBindingIcollectInstances
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule2900 _functionBindingIunboundNames
         _self = rule2901 _functionBindingIself _rangeIself arg_feedback_
         _lhsOself :: FunctionBinding
         _lhsOself = rule2902 _self
         _lhsOargcount :: Int
         _lhsOargcount = rule2903 _functionBindingIargcount
         _lhsOassumptions :: Assumptions
         _lhsOassumptions = rule2904 _functionBindingIassumptions
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule2905 _functionBindingIbetaUnique
         _lhsOcollectErrors :: TypeErrors
         _lhsOcollectErrors = rule2906 _functionBindingIcollectErrors
         _lhsOcollectWarnings :: Warnings
         _lhsOcollectWarnings = rule2907 _functionBindingIcollectWarnings
         _lhsOconstraints :: ConstraintSet
         _lhsOconstraints = rule2908 _functionBindingIconstraints
         _lhsOcounter :: Int
         _lhsOcounter = rule2909 _functionBindingIcounter
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule2910 _functionBindingIdictionaryEnvironment
         _lhsOelements ::  ([PatternElement], Bool) 
         _lhsOelements = rule2911 _functionBindingIelements
         _lhsOinfoTree :: InfoTree
         _lhsOinfoTree = rule2912 _functionBindingIinfoTree
         _lhsOmatchIO :: IO ()
         _lhsOmatchIO = rule2913 _functionBindingImatchIO
         _lhsOname :: Name
         _lhsOname = rule2914 _functionBindingIname
         _lhsOnumberOfPatterns :: Int
         _lhsOnumberOfPatterns = rule2915 _functionBindingInumberOfPatterns
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule2916 _functionBindingIpatternMatchWarnings
         _lhsOuniqueChunk :: Int
         _lhsOuniqueChunk = rule2917 _functionBindingIuniqueChunk
         _lhsOunrwar :: Warning
         _lhsOunrwar = rule2918 _functionBindingIunrwar
         _functionBindingOallPatterns = rule2919 _lhsIallPatterns
         _functionBindingOallTypeSchemes = rule2920 _lhsIallTypeSchemes
         _functionBindingOambiguousConflicts = rule2921 _lhsIambiguousConflicts
         _functionBindingOavailablePredicates = rule2922 _lhsIavailablePredicates
         _functionBindingObetaRight = rule2923 _lhsIbetaRight
         _functionBindingObetaUnique = rule2924 _lhsIbetaUnique
         _functionBindingObetasLeft = rule2925 _lhsIbetasLeft
         _functionBindingOclassEnvironment = rule2926 _lhsIclassEnvironment
         _functionBindingOclassMemberEnv = rule2927 _lhsIclassMemberEnv
         _functionBindingOclassMemberTypeSchemes = rule2928 _lhsIclassMemberTypeSchemes
         _functionBindingOclassNamesEnv = rule2929 _lhsIclassNamesEnv
         _functionBindingOclassPredicate = rule2930 _lhsIclassPredicate
         _functionBindingOclassTypeSchemes = rule2931 _lhsIclassTypeSchemes
         _functionBindingOcollectErrors = rule2932 _lhsIcollectErrors
         _functionBindingOcollectWarnings = rule2933 _lhsIcollectWarnings
         _functionBindingOcounter = rule2934 _lhsIcounter
         _functionBindingOcurClassPred = rule2935 _lhsIcurClassPred
         _functionBindingOcurPred = rule2936 _lhsIcurPred
         _functionBindingOcurrentChunk = rule2937 _lhsIcurrentChunk
         _functionBindingOdictionaryEnvironment = rule2938 _lhsIdictionaryEnvironment
         _functionBindingOimportEnvironment = rule2939 _lhsIimportEnvironment
         _functionBindingOinstanceName = rule2940 _lhsIinstanceName
         _functionBindingOinstanceTypes = rule2941 _lhsIinstanceTypes
         _functionBindingOmatchIO = rule2942 _lhsImatchIO
         _functionBindingOmoduleName = rule2943 _lhsImoduleName
         _functionBindingOmonos = rule2944 _lhsImonos
         _functionBindingOnamesInScope = rule2945 _lhsInamesInScope
         _functionBindingOorderedTypeSynonyms = rule2946 _lhsIorderedTypeSynonyms
         _functionBindingOparentTree = rule2947 _lhsIparentTree
         _functionBindingOpatternMatchWarnings = rule2948 _lhsIpatternMatchWarnings
         _functionBindingOrequiredPredicates = rule2949 _lhsIrequiredPredicates
         _functionBindingOsubstitution = rule2950 _lhsIsubstitution
         _functionBindingOtypeConstructors = rule2951 _lhsItypeConstructors
         _functionBindingOtypeschemeMap = rule2952 _lhsItypeschemeMap
         _functionBindingOuniqueChunk = rule2953 _lhsIuniqueChunk
         _functionBindingOvariableMapping = rule2954 _lhsIvariableMapping
         !__result_ = T_FunctionBinding_vOut55 _lhsOargcount _lhsOassumptions _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraints _lhsOcounter _lhsOdictionaryEnvironment _lhsOelements _lhsOinfoTree _lhsOmatchIO _lhsOname _lhsOnumberOfPatterns _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOunrwar
         in __result_ )
     in C_FunctionBinding_s56 v55
   {-# INLINE rule2899 #-}
   rule2899 = \ ((_functionBindingIcollectInstances) :: [(Name, Instance)]) ->
     _functionBindingIcollectInstances
   {-# INLINE rule2900 #-}
   rule2900 = \ ((_functionBindingIunboundNames) :: Names) ->
     _functionBindingIunboundNames
   {-# INLINE rule2901 #-}
   rule2901 = \ ((_functionBindingIself) :: FunctionBinding) ((_rangeIself) :: Range) feedback_ ->
     FunctionBinding_Feedback _rangeIself feedback_ _functionBindingIself
   {-# INLINE rule2902 #-}
   rule2902 = \ _self ->
     _self
   {-# INLINE rule2903 #-}
   rule2903 = \ ((_functionBindingIargcount) :: Int) ->
     _functionBindingIargcount
   {-# INLINE rule2904 #-}
   rule2904 = \ ((_functionBindingIassumptions) :: Assumptions) ->
     _functionBindingIassumptions
   {-# INLINE rule2905 #-}
   rule2905 = \ ((_functionBindingIbetaUnique) :: Int) ->
     _functionBindingIbetaUnique
   {-# INLINE rule2906 #-}
   rule2906 = \ ((_functionBindingIcollectErrors) :: TypeErrors) ->
     _functionBindingIcollectErrors
   {-# INLINE rule2907 #-}
   rule2907 = \ ((_functionBindingIcollectWarnings) :: Warnings) ->
     _functionBindingIcollectWarnings
   {-# INLINE rule2908 #-}
   rule2908 = \ ((_functionBindingIconstraints) :: ConstraintSet) ->
     _functionBindingIconstraints
   {-# INLINE rule2909 #-}
   rule2909 = \ ((_functionBindingIcounter) :: Int) ->
     _functionBindingIcounter
   {-# INLINE rule2910 #-}
   rule2910 = \ ((_functionBindingIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _functionBindingIdictionaryEnvironment
   {-# INLINE rule2911 #-}
   rule2911 = \ ((_functionBindingIelements) ::  ([PatternElement], Bool) ) ->
     _functionBindingIelements
   {-# INLINE rule2912 #-}
   rule2912 = \ ((_functionBindingIinfoTree) :: InfoTree) ->
     _functionBindingIinfoTree
   {-# INLINE rule2913 #-}
   rule2913 = \ ((_functionBindingImatchIO) :: IO ()) ->
     _functionBindingImatchIO
   {-# INLINE rule2914 #-}
   rule2914 = \ ((_functionBindingIname) :: Name) ->
     _functionBindingIname
   {-# INLINE rule2915 #-}
   rule2915 = \ ((_functionBindingInumberOfPatterns) :: Int) ->
     _functionBindingInumberOfPatterns
   {-# INLINE rule2916 #-}
   rule2916 = \ ((_functionBindingIpatternMatchWarnings) :: [Warning]) ->
     _functionBindingIpatternMatchWarnings
   {-# INLINE rule2917 #-}
   rule2917 = \ ((_functionBindingIuniqueChunk) :: Int) ->
     _functionBindingIuniqueChunk
   {-# INLINE rule2918 #-}
   rule2918 = \ ((_functionBindingIunrwar) :: Warning) ->
     _functionBindingIunrwar
   {-# INLINE rule2919 #-}
   rule2919 = \ ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ->
     _lhsIallPatterns
   {-# INLINE rule2920 #-}
   rule2920 = \ ((_lhsIallTypeSchemes) :: M.Map NameWithRange TpScheme) ->
     _lhsIallTypeSchemes
   {-# INLINE rule2921 #-}
   rule2921 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule2922 #-}
   rule2922 = \ ((_lhsIavailablePredicates) :: [PredicateWithSource]) ->
     _lhsIavailablePredicates
   {-# INLINE rule2923 #-}
   rule2923 = \ ((_lhsIbetaRight) :: Tp) ->
     _lhsIbetaRight
   {-# INLINE rule2924 #-}
   rule2924 = \ ((_lhsIbetaUnique) :: Int) ->
     _lhsIbetaUnique
   {-# INLINE rule2925 #-}
   rule2925 = \ ((_lhsIbetasLeft) :: Tps) ->
     _lhsIbetasLeft
   {-# INLINE rule2926 #-}
   rule2926 = \ ((_lhsIclassEnvironment) :: ClassEnvironment) ->
     _lhsIclassEnvironment
   {-# INLINE rule2927 #-}
   rule2927 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule2928 #-}
   rule2928 = \ ((_lhsIclassMemberTypeSchemes) :: Maybe [(Name, TpScheme)]) ->
     _lhsIclassMemberTypeSchemes
   {-# INLINE rule2929 #-}
   rule2929 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule2930 #-}
   rule2930 = \ ((_lhsIclassPredicate) :: Maybe (Name, Names)) ->
     _lhsIclassPredicate
   {-# INLINE rule2931 #-}
   rule2931 = \ ((_lhsIclassTypeSchemes) :: M.Map Name TpScheme) ->
     _lhsIclassTypeSchemes
   {-# INLINE rule2932 #-}
   rule2932 = \ ((_lhsIcollectErrors) :: TypeErrors) ->
     _lhsIcollectErrors
   {-# INLINE rule2933 #-}
   rule2933 = \ ((_lhsIcollectWarnings) :: Warnings) ->
     _lhsIcollectWarnings
   {-# INLINE rule2934 #-}
   rule2934 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule2935 #-}
   rule2935 = \ ((_lhsIcurClassPred) :: Maybe Predicate) ->
     _lhsIcurClassPred
   {-# INLINE rule2936 #-}
   rule2936 = \ ((_lhsIcurPred) :: Maybe Predicate) ->
     _lhsIcurPred
   {-# INLINE rule2937 #-}
   rule2937 = \ ((_lhsIcurrentChunk) :: Int) ->
     _lhsIcurrentChunk
   {-# INLINE rule2938 #-}
   rule2938 = \ ((_lhsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _lhsIdictionaryEnvironment
   {-# INLINE rule2939 #-}
   rule2939 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule2940 #-}
   rule2940 = \ ((_lhsIinstanceName) :: Maybe Name) ->
     _lhsIinstanceName
   {-# INLINE rule2941 #-}
   rule2941 = \ ((_lhsIinstanceTypes) :: [(Name, TpScheme)]) ->
     _lhsIinstanceTypes
   {-# INLINE rule2942 #-}
   rule2942 = \ ((_lhsImatchIO) :: IO ()) ->
     _lhsImatchIO
   {-# INLINE rule2943 #-}
   rule2943 = \ ((_lhsImoduleName) :: Maybe Name) ->
     _lhsImoduleName
   {-# INLINE rule2944 #-}
   rule2944 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule2945 #-}
   rule2945 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule2946 #-}
   rule2946 = \ ((_lhsIorderedTypeSynonyms) :: OrderedTypeSynonyms) ->
     _lhsIorderedTypeSynonyms
   {-# INLINE rule2947 #-}
   rule2947 = \ ((_lhsIparentTree) :: InfoTree) ->
     _lhsIparentTree
   {-# INLINE rule2948 #-}
   rule2948 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule2949 #-}
   rule2949 = \ ((_lhsIrequiredPredicates) :: Predicates) ->
     _lhsIrequiredPredicates
   {-# INLINE rule2950 #-}
   rule2950 = \ ((_lhsIsubstitution) :: FixpointSubstitution) ->
     _lhsIsubstitution
   {-# INLINE rule2951 #-}
   rule2951 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
   {-# INLINE rule2952 #-}
   rule2952 = \ ((_lhsItypeschemeMap) :: M.Map Int (Scheme Predicates)) ->
     _lhsItypeschemeMap
   {-# INLINE rule2953 #-}
   rule2953 = \ ((_lhsIuniqueChunk) :: Int) ->
     _lhsIuniqueChunk
   {-# INLINE rule2954 #-}
   rule2954 = \ ((_lhsIvariableMapping) :: Maybe [(Name, Tp)]) ->
     _lhsIvariableMapping
{-# NOINLINE sem_FunctionBinding_FunctionBinding #-}
sem_FunctionBinding_FunctionBinding :: T_Range  -> T_LeftHandSide  -> T_RightHandSide  -> T_FunctionBinding 
sem_FunctionBinding_FunctionBinding arg_range_ arg_lefthandside_ arg_righthandside_ = T_FunctionBinding (return st56) where
   {-# NOINLINE st56 #-}
   !st56 = let
      v55 :: T_FunctionBinding_v55 
      v55 = \ !(T_FunctionBinding_vIn55 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaRight _lhsIbetaUnique _lhsIbetasLeft _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeConstructors _lhsItypeschemeMap _lhsIuniqueChunk _lhsIvariableMapping) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _lefthandsideX83 = Control.Monad.Identity.runIdentity (attach_T_LeftHandSide (arg_lefthandside_))
         _righthandsideX149 = Control.Monad.Identity.runIdentity (attach_T_RightHandSide (arg_righthandside_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_LeftHandSide_vOut82 _lefthandsideIargcount _lefthandsideIbetaUnique _lefthandsideIbetas _lefthandsideIconstraints _lefthandsideIcounter _lefthandsideIelements _lefthandsideIenvironment _lefthandsideIinfoTrees _lefthandsideIname _lefthandsideInumberOfPatterns _lefthandsideIpatVarNames _lefthandsideIpatternMatchWarnings _lefthandsideIself _lefthandsideIunboundNames) = inv_LeftHandSide_s83 _lefthandsideX83 (T_LeftHandSide_vIn82 _lefthandsideOambiguousConflicts _lefthandsideObetaUnique _lefthandsideOcounter _lefthandsideOimportEnvironment _lefthandsideOmonos _lefthandsideOnamesInScope _lefthandsideOparentTree _lefthandsideOpatternMatchWarnings _lefthandsideOtypeConstructors)
         (T_RightHandSide_vOut148 _righthandsideIassumptions _righthandsideIbetaUnique _righthandsideIcollectErrors _righthandsideIcollectInstances _righthandsideIcollectWarnings _righthandsideIconstraints _righthandsideIcounter _righthandsideIdictionaryEnvironment _righthandsideIfallthrough _righthandsideIinfoTree _righthandsideImatchIO _righthandsideIpatternMatchWarnings _righthandsideIself _righthandsideIunboundNames _righthandsideIuniqueChunk) = inv_RightHandSide_s149 _righthandsideX149 (T_RightHandSide_vIn148 _righthandsideOallPatterns _righthandsideOallTypeSchemes _righthandsideOambiguousConflicts _righthandsideOavailablePredicates _righthandsideObetaRight _righthandsideObetaUnique _righthandsideOclassEnvironment _righthandsideOclassMemberEnv _righthandsideOclassMemberTypeSchemes _righthandsideOclassNamesEnv _righthandsideOclassPredicate _righthandsideOclassTypeSchemes _righthandsideOcollectErrors _righthandsideOcollectWarnings _righthandsideOcounter _righthandsideOcurClassPred _righthandsideOcurPred _righthandsideOcurrentChunk _righthandsideOdictionaryEnvironment _righthandsideOimportEnvironment _righthandsideOinstanceName _righthandsideOinstanceTypes _righthandsideOmatchIO _righthandsideOmoduleName _righthandsideOmonos _righthandsideOnamesInScope _righthandsideOorderedTypeSynonyms _righthandsideOparentTree _righthandsideOpatternMatchWarnings _righthandsideOrequiredPredicates _righthandsideOsubstitution _righthandsideOtypeConstructors _righthandsideOtypeschemeMap _righthandsideOuniqueChunk _righthandsideOvariableMapping)
         _lhsOunrwar :: Warning
         _lhsOunrwar = rule2955 _lefthandsideIself
         _lhsOelements ::  ([PatternElement], Bool) 
         _lhsOelements = rule2956 _lefthandsideIelements _righthandsideIfallthrough
         (_namesInScope,_unboundNames,_scopeInfo) = rule2957 _lefthandsideIpatVarNames _lhsInamesInScope _righthandsideIunboundNames
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule2958 _unboundNames
         _parentTree = rule2959 _lefthandsideIinfoTrees _lhsIparentTree _localInfo _righthandsideIinfoTree
         _lhsOinfoTree :: InfoTree
         _lhsOinfoTree = rule2960 _parentTree
         _localInfo = rule2961 _lhsImonos _self
         _cinfoLeft = rule2962 _lhsIbetasLeft _lhsIparentTree _parentTree
         _cinfoBind = rule2963 _lefthandsideIenvironment _parentTree
         _righthandsideOmonos = rule2964 _csetBinds _lefthandsideIenvironment _lhsImonos
         _constraints = rule2965 _conLeft _csetBinds _lefthandsideIconstraints _righthandsideIconstraints
         _conLeft = rule2966 _cinfoLeft _lefthandsideIbetas _lhsIbetasLeft
         _lhsOassumptions :: Assumptions
         (_csetBinds,_lhsOassumptions) = rule2967 _cinfoBind _lefthandsideIenvironment _righthandsideIassumptions
         _lhsOcollectInstances :: [(Name, Instance)]
         _lhsOcollectInstances = rule2968 _righthandsideIcollectInstances
         _self = rule2969 _lefthandsideIself _rangeIself _righthandsideIself
         _lhsOself :: FunctionBinding
         _lhsOself = rule2970 _self
         _lhsOargcount :: Int
         _lhsOargcount = rule2971 _lefthandsideIargcount
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule2972 _righthandsideIbetaUnique
         _lhsOcollectErrors :: TypeErrors
         _lhsOcollectErrors = rule2973 _righthandsideIcollectErrors
         _lhsOcollectWarnings :: Warnings
         _lhsOcollectWarnings = rule2974 _righthandsideIcollectWarnings
         _lhsOconstraints :: ConstraintSet
         _lhsOconstraints = rule2975 _constraints
         _lhsOcounter :: Int
         _lhsOcounter = rule2976 _righthandsideIcounter
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule2977 _righthandsideIdictionaryEnvironment
         _lhsOmatchIO :: IO ()
         _lhsOmatchIO = rule2978 _righthandsideImatchIO
         _lhsOname :: Name
         _lhsOname = rule2979 _lefthandsideIname
         _lhsOnumberOfPatterns :: Int
         _lhsOnumberOfPatterns = rule2980 _lefthandsideInumberOfPatterns
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule2981 _righthandsideIpatternMatchWarnings
         _lhsOuniqueChunk :: Int
         _lhsOuniqueChunk = rule2982 _righthandsideIuniqueChunk
         _lefthandsideOambiguousConflicts = rule2983 _lhsIambiguousConflicts
         _lefthandsideObetaUnique = rule2984 _lhsIbetaUnique
         _lefthandsideOcounter = rule2985 _lhsIcounter
         _lefthandsideOimportEnvironment = rule2986 _lhsIimportEnvironment
         _lefthandsideOmonos = rule2987 _lhsImonos
         _lefthandsideOnamesInScope = rule2988 _namesInScope
         _lefthandsideOparentTree = rule2989 _parentTree
         _lefthandsideOpatternMatchWarnings = rule2990 _lhsIpatternMatchWarnings
         _lefthandsideOtypeConstructors = rule2991 _lhsItypeConstructors
         _righthandsideOallPatterns = rule2992 _lhsIallPatterns
         _righthandsideOallTypeSchemes = rule2993 _lhsIallTypeSchemes
         _righthandsideOambiguousConflicts = rule2994 _lhsIambiguousConflicts
         _righthandsideOavailablePredicates = rule2995 _lhsIavailablePredicates
         _righthandsideObetaRight = rule2996 _lhsIbetaRight
         _righthandsideObetaUnique = rule2997 _lefthandsideIbetaUnique
         _righthandsideOclassEnvironment = rule2998 _lhsIclassEnvironment
         _righthandsideOclassMemberEnv = rule2999 _lhsIclassMemberEnv
         _righthandsideOclassMemberTypeSchemes = rule3000 _lhsIclassMemberTypeSchemes
         _righthandsideOclassNamesEnv = rule3001 _lhsIclassNamesEnv
         _righthandsideOclassPredicate = rule3002 _lhsIclassPredicate
         _righthandsideOclassTypeSchemes = rule3003 _lhsIclassTypeSchemes
         _righthandsideOcollectErrors = rule3004 _lhsIcollectErrors
         _righthandsideOcollectWarnings = rule3005 _lhsIcollectWarnings
         _righthandsideOcounter = rule3006 _lefthandsideIcounter
         _righthandsideOcurClassPred = rule3007 _lhsIcurClassPred
         _righthandsideOcurPred = rule3008 _lhsIcurPred
         _righthandsideOcurrentChunk = rule3009 _lhsIcurrentChunk
         _righthandsideOdictionaryEnvironment = rule3010 _lhsIdictionaryEnvironment
         _righthandsideOimportEnvironment = rule3011 _lhsIimportEnvironment
         _righthandsideOinstanceName = rule3012 _lhsIinstanceName
         _righthandsideOinstanceTypes = rule3013 _lhsIinstanceTypes
         _righthandsideOmatchIO = rule3014 _lhsImatchIO
         _righthandsideOmoduleName = rule3015 _lhsImoduleName
         _righthandsideOnamesInScope = rule3016 _namesInScope
         _righthandsideOorderedTypeSynonyms = rule3017 _lhsIorderedTypeSynonyms
         _righthandsideOparentTree = rule3018 _parentTree
         _righthandsideOpatternMatchWarnings = rule3019 _lefthandsideIpatternMatchWarnings
         _righthandsideOrequiredPredicates = rule3020 _lhsIrequiredPredicates
         _righthandsideOsubstitution = rule3021 _lhsIsubstitution
         _righthandsideOtypeConstructors = rule3022 _lhsItypeConstructors
         _righthandsideOtypeschemeMap = rule3023 _lhsItypeschemeMap
         _righthandsideOuniqueChunk = rule3024 _lhsIuniqueChunk
         _righthandsideOvariableMapping = rule3025 _lhsIvariableMapping
         !__result_ = T_FunctionBinding_vOut55 _lhsOargcount _lhsOassumptions _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraints _lhsOcounter _lhsOdictionaryEnvironment _lhsOelements _lhsOinfoTree _lhsOmatchIO _lhsOname _lhsOnumberOfPatterns _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOunrwar
         in __result_ )
     in C_FunctionBinding_s56 v55
   {-# INLINE rule2955 #-}
   rule2955 = \ ((_lefthandsideIself) :: LeftHandSide) ->
                                         UnreachablePatternLHS _lefthandsideIself
   {-# INLINE rule2956 #-}
   rule2956 = \ ((_lefthandsideIelements) ::   [PatternElement]        ) ((_righthandsideIfallthrough) :: Bool) ->
                                         (_lefthandsideIelements, _righthandsideIfallthrough)
   {-# INLINE rule2957 #-}
   rule2957 = \ ((_lefthandsideIpatVarNames) :: Names) ((_lhsInamesInScope) :: Names) ((_righthandsideIunboundNames) :: Names) ->
                                                                        changeOfScope _lefthandsideIpatVarNames _righthandsideIunboundNames _lhsInamesInScope
   {-# INLINE rule2958 #-}
   rule2958 = \ _unboundNames ->
                                             _unboundNames
   {-# INLINE rule2959 #-}
   rule2959 = \ ((_lefthandsideIinfoTrees) :: InfoTrees) ((_lhsIparentTree) :: InfoTree) _localInfo ((_righthandsideIinfoTree) :: InfoTree) ->
                                          node _lhsIparentTree _localInfo (_lefthandsideIinfoTrees ++ [_righthandsideIinfoTree])
   {-# INLINE rule2960 #-}
   rule2960 = \ _parentTree ->
                                          _parentTree
   {-# INLINE rule2961 #-}
   rule2961 = \ ((_lhsImonos) :: Monos) _self ->
                            LocalInfo { self = UHA_FB _self
                                      , assignedType = Nothing
                                      , monos = _lhsImonos
                                      }
   {-# INLINE rule2962 #-}
   rule2962 = \ ((_lhsIbetasLeft) :: Tps) ((_lhsIparentTree) :: InfoTree) _parentTree ->
     \num  ->
     orphanConstraint num "pattern of function binding" _parentTree
        [ Unifier (head (ftv (_lhsIbetasLeft !! num))) (ordinal True (num+1)++" pattern of function bindings", attribute _lhsIparentTree, "pattern") ]
   {-# INLINE rule2963 #-}
   rule2963 = \ ((_lefthandsideIenvironment) :: PatternAssumptions) _parentTree ->
     \name -> variableConstraint "variable" (nameToUHA_Expr name)
        [ FolkloreConstraint
        , makeUnifier name "function binding" _lefthandsideIenvironment _parentTree
        ]
   {-# INLINE rule2964 #-}
   rule2964 = \ _csetBinds ((_lefthandsideIenvironment) :: PatternAssumptions) ((_lhsImonos) :: Monos) ->
                                      M.elems _lefthandsideIenvironment ++ getMonos _csetBinds ++ _lhsImonos
   {-# INLINE rule2965 #-}
   rule2965 = \ _conLeft _csetBinds ((_lefthandsideIconstraints) :: ConstraintSet) ((_righthandsideIconstraints) :: ConstraintSet) ->
                                      _csetBinds .>>.
                                      Node [ _conLeft  .<. _lefthandsideIconstraints
                                           , _righthandsideIconstraints
                                           ]
   {-# INLINE rule2966 #-}
   rule2966 = \ _cinfoLeft ((_lefthandsideIbetas) :: Tps) ((_lhsIbetasLeft) :: Tps) ->
                                      zipWith3 (\t1 t2 nr -> (t1 .==. t2) (_cinfoLeft nr)) _lefthandsideIbetas _lhsIbetasLeft [0..]
   {-# INLINE rule2967 #-}
   rule2967 = \ _cinfoBind ((_lefthandsideIenvironment) :: PatternAssumptions) ((_righthandsideIassumptions) :: Assumptions) ->
                                          (_lefthandsideIenvironment .===. _righthandsideIassumptions) _cinfoBind
   {-# INLINE rule2968 #-}
   rule2968 = \ ((_righthandsideIcollectInstances) :: [(Name, Instance)]) ->
     _righthandsideIcollectInstances
   {-# INLINE rule2969 #-}
   rule2969 = \ ((_lefthandsideIself) :: LeftHandSide) ((_rangeIself) :: Range) ((_righthandsideIself) :: RightHandSide) ->
     FunctionBinding_FunctionBinding _rangeIself _lefthandsideIself _righthandsideIself
   {-# INLINE rule2970 #-}
   rule2970 = \ _self ->
     _self
   {-# INLINE rule2971 #-}
   rule2971 = \ ((_lefthandsideIargcount) :: Int) ->
     _lefthandsideIargcount
   {-# INLINE rule2972 #-}
   rule2972 = \ ((_righthandsideIbetaUnique) :: Int) ->
     _righthandsideIbetaUnique
   {-# INLINE rule2973 #-}
   rule2973 = \ ((_righthandsideIcollectErrors) :: TypeErrors) ->
     _righthandsideIcollectErrors
   {-# INLINE rule2974 #-}
   rule2974 = \ ((_righthandsideIcollectWarnings) :: Warnings) ->
     _righthandsideIcollectWarnings
   {-# INLINE rule2975 #-}
   rule2975 = \ _constraints ->
     _constraints
   {-# INLINE rule2976 #-}
   rule2976 = \ ((_righthandsideIcounter) :: Int) ->
     _righthandsideIcounter
   {-# INLINE rule2977 #-}
   rule2977 = \ ((_righthandsideIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _righthandsideIdictionaryEnvironment
   {-# INLINE rule2978 #-}
   rule2978 = \ ((_righthandsideImatchIO) :: IO ()) ->
     _righthandsideImatchIO
   {-# INLINE rule2979 #-}
   rule2979 = \ ((_lefthandsideIname) :: Name) ->
     _lefthandsideIname
   {-# INLINE rule2980 #-}
   rule2980 = \ ((_lefthandsideInumberOfPatterns) :: Int) ->
     _lefthandsideInumberOfPatterns
   {-# INLINE rule2981 #-}
   rule2981 = \ ((_righthandsideIpatternMatchWarnings) :: [Warning]) ->
     _righthandsideIpatternMatchWarnings
   {-# INLINE rule2982 #-}
   rule2982 = \ ((_righthandsideIuniqueChunk) :: Int) ->
     _righthandsideIuniqueChunk
   {-# INLINE rule2983 #-}
   rule2983 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule2984 #-}
   rule2984 = \ ((_lhsIbetaUnique) :: Int) ->
     _lhsIbetaUnique
   {-# INLINE rule2985 #-}
   rule2985 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule2986 #-}
   rule2986 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule2987 #-}
   rule2987 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule2988 #-}
   rule2988 = \ _namesInScope ->
     _namesInScope
   {-# INLINE rule2989 #-}
   rule2989 = \ _parentTree ->
     _parentTree
   {-# INLINE rule2990 #-}
   rule2990 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule2991 #-}
   rule2991 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
   {-# INLINE rule2992 #-}
   rule2992 = \ ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ->
     _lhsIallPatterns
   {-# INLINE rule2993 #-}
   rule2993 = \ ((_lhsIallTypeSchemes) :: M.Map NameWithRange TpScheme) ->
     _lhsIallTypeSchemes
   {-# INLINE rule2994 #-}
   rule2994 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule2995 #-}
   rule2995 = \ ((_lhsIavailablePredicates) :: [PredicateWithSource]) ->
     _lhsIavailablePredicates
   {-# INLINE rule2996 #-}
   rule2996 = \ ((_lhsIbetaRight) :: Tp) ->
     _lhsIbetaRight
   {-# INLINE rule2997 #-}
   rule2997 = \ ((_lefthandsideIbetaUnique) :: Int) ->
     _lefthandsideIbetaUnique
   {-# INLINE rule2998 #-}
   rule2998 = \ ((_lhsIclassEnvironment) :: ClassEnvironment) ->
     _lhsIclassEnvironment
   {-# INLINE rule2999 #-}
   rule2999 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule3000 #-}
   rule3000 = \ ((_lhsIclassMemberTypeSchemes) :: Maybe [(Name, TpScheme)]) ->
     _lhsIclassMemberTypeSchemes
   {-# INLINE rule3001 #-}
   rule3001 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule3002 #-}
   rule3002 = \ ((_lhsIclassPredicate) :: Maybe (Name, Names)) ->
     _lhsIclassPredicate
   {-# INLINE rule3003 #-}
   rule3003 = \ ((_lhsIclassTypeSchemes) :: M.Map Name TpScheme) ->
     _lhsIclassTypeSchemes
   {-# INLINE rule3004 #-}
   rule3004 = \ ((_lhsIcollectErrors) :: TypeErrors) ->
     _lhsIcollectErrors
   {-# INLINE rule3005 #-}
   rule3005 = \ ((_lhsIcollectWarnings) :: Warnings) ->
     _lhsIcollectWarnings
   {-# INLINE rule3006 #-}
   rule3006 = \ ((_lefthandsideIcounter) :: Int) ->
     _lefthandsideIcounter
   {-# INLINE rule3007 #-}
   rule3007 = \ ((_lhsIcurClassPred) :: Maybe Predicate) ->
     _lhsIcurClassPred
   {-# INLINE rule3008 #-}
   rule3008 = \ ((_lhsIcurPred) :: Maybe Predicate) ->
     _lhsIcurPred
   {-# INLINE rule3009 #-}
   rule3009 = \ ((_lhsIcurrentChunk) :: Int) ->
     _lhsIcurrentChunk
   {-# INLINE rule3010 #-}
   rule3010 = \ ((_lhsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _lhsIdictionaryEnvironment
   {-# INLINE rule3011 #-}
   rule3011 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule3012 #-}
   rule3012 = \ ((_lhsIinstanceName) :: Maybe Name) ->
     _lhsIinstanceName
   {-# INLINE rule3013 #-}
   rule3013 = \ ((_lhsIinstanceTypes) :: [(Name, TpScheme)]) ->
     _lhsIinstanceTypes
   {-# INLINE rule3014 #-}
   rule3014 = \ ((_lhsImatchIO) :: IO ()) ->
     _lhsImatchIO
   {-# INLINE rule3015 #-}
   rule3015 = \ ((_lhsImoduleName) :: Maybe Name) ->
     _lhsImoduleName
   {-# INLINE rule3016 #-}
   rule3016 = \ _namesInScope ->
     _namesInScope
   {-# INLINE rule3017 #-}
   rule3017 = \ ((_lhsIorderedTypeSynonyms) :: OrderedTypeSynonyms) ->
     _lhsIorderedTypeSynonyms
   {-# INLINE rule3018 #-}
   rule3018 = \ _parentTree ->
     _parentTree
   {-# INLINE rule3019 #-}
   rule3019 = \ ((_lefthandsideIpatternMatchWarnings) :: [Warning]) ->
     _lefthandsideIpatternMatchWarnings
   {-# INLINE rule3020 #-}
   rule3020 = \ ((_lhsIrequiredPredicates) :: Predicates) ->
     _lhsIrequiredPredicates
   {-# INLINE rule3021 #-}
   rule3021 = \ ((_lhsIsubstitution) :: FixpointSubstitution) ->
     _lhsIsubstitution
   {-# INLINE rule3022 #-}
   rule3022 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
   {-# INLINE rule3023 #-}
   rule3023 = \ ((_lhsItypeschemeMap) :: M.Map Int (Scheme Predicates)) ->
     _lhsItypeschemeMap
   {-# INLINE rule3024 #-}
   rule3024 = \ ((_lhsIuniqueChunk) :: Int) ->
     _lhsIuniqueChunk
   {-# INLINE rule3025 #-}
   rule3025 = \ ((_lhsIvariableMapping) :: Maybe [(Name, Tp)]) ->
     _lhsIvariableMapping

-- FunctionBindings --------------------------------------------
-- wrapper
data Inh_FunctionBindings  = Inh_FunctionBindings { allPatterns_Inh_FunctionBindings :: !([((Expression, [String]), Core_TypingStrategy)]), allTypeSchemes_Inh_FunctionBindings :: !(M.Map NameWithRange TpScheme), ambiguousConflicts_Inh_FunctionBindings :: !([[Name]]), availablePredicates_Inh_FunctionBindings :: !([PredicateWithSource]), betaRight_Inh_FunctionBindings :: !(Tp), betaUnique_Inh_FunctionBindings :: !(Int), betasLeft_Inh_FunctionBindings :: !(Tps), classEnvironment_Inh_FunctionBindings :: !(ClassEnvironment), classMemberEnv_Inh_FunctionBindings :: !(ClassMemberEnvironment), classMemberTypeSchemes_Inh_FunctionBindings :: !(Maybe [(Name, TpScheme)]), classNamesEnv_Inh_FunctionBindings :: !(ClassNameEnvironment), classPredicate_Inh_FunctionBindings :: !(Maybe (Name, Names)), classTypeSchemes_Inh_FunctionBindings :: !(M.Map Name TpScheme), collectErrors_Inh_FunctionBindings :: !(TypeErrors), collectWarnings_Inh_FunctionBindings :: !(Warnings), counter_Inh_FunctionBindings :: !(Int), curClassPred_Inh_FunctionBindings :: !(Maybe Predicate), curPred_Inh_FunctionBindings :: !(Maybe Predicate), currentChunk_Inh_FunctionBindings :: !(Int), dictionaryEnvironment_Inh_FunctionBindings :: !(DictionaryEnvironment), importEnvironment_Inh_FunctionBindings :: !(ImportEnvironment), instanceName_Inh_FunctionBindings :: !(Maybe Name), instanceTypes_Inh_FunctionBindings :: !([(Name, TpScheme)]), matchIO_Inh_FunctionBindings :: !(IO ()), moduleName_Inh_FunctionBindings :: !(Maybe Name), monos_Inh_FunctionBindings :: !(Monos), namesInScope_Inh_FunctionBindings :: !(Names), orderedTypeSynonyms_Inh_FunctionBindings :: !(OrderedTypeSynonyms), parentTree_Inh_FunctionBindings :: !(InfoTree), patternMatchWarnings_Inh_FunctionBindings :: !([Warning]), requiredPredicates_Inh_FunctionBindings :: !(Predicates), substitution_Inh_FunctionBindings :: !(FixpointSubstitution), typeConstructors_Inh_FunctionBindings :: !(TypeConstructorEnvironment), typeschemeMap_Inh_FunctionBindings :: !(M.Map Int (Scheme Predicates)), uniqueChunk_Inh_FunctionBindings :: !(Int), variableMapping_Inh_FunctionBindings :: !(Maybe [(Name, Tp)]) }
data Syn_FunctionBindings  = Syn_FunctionBindings { argcount_Syn_FunctionBindings :: !(Int), assumptions_Syn_FunctionBindings :: !(Assumptions), betaUnique_Syn_FunctionBindings :: !(Int), collectErrors_Syn_FunctionBindings :: !(TypeErrors), collectInstances_Syn_FunctionBindings :: !([(Name, Instance)]), collectWarnings_Syn_FunctionBindings :: !(Warnings), constraintslist_Syn_FunctionBindings :: !(ConstraintSets), counter_Syn_FunctionBindings :: !(Int), dictionaryEnvironment_Syn_FunctionBindings :: !(DictionaryEnvironment), elementss_Syn_FunctionBindings :: !([([PatternElement], Bool)]), infoTrees_Syn_FunctionBindings :: !(InfoTrees), matchIO_Syn_FunctionBindings :: !(IO ()), name_Syn_FunctionBindings :: !(Name), numberOfPatterns_Syn_FunctionBindings :: !(Int), patternMatchWarnings_Syn_FunctionBindings :: !([Warning]), self_Syn_FunctionBindings :: !(FunctionBindings), unboundNames_Syn_FunctionBindings :: !(Names), uniqueChunk_Syn_FunctionBindings :: !(Int), unrwars_Syn_FunctionBindings :: !([Warning]) }
{-# INLINABLE wrap_FunctionBindings #-}
wrap_FunctionBindings :: T_FunctionBindings  -> Inh_FunctionBindings  -> (Syn_FunctionBindings )
wrap_FunctionBindings !(T_FunctionBindings act) !(Inh_FunctionBindings _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaRight _lhsIbetaUnique _lhsIbetasLeft _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeConstructors _lhsItypeschemeMap _lhsIuniqueChunk _lhsIvariableMapping) =
   Control.Monad.Identity.runIdentity (
     do !sem <- act
        let arg58 = T_FunctionBindings_vIn58 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaRight _lhsIbetaUnique _lhsIbetasLeft _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeConstructors _lhsItypeschemeMap _lhsIuniqueChunk _lhsIvariableMapping
        !(T_FunctionBindings_vOut58 _lhsOargcount _lhsOassumptions _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraintslist _lhsOcounter _lhsOdictionaryEnvironment _lhsOelementss _lhsOinfoTrees _lhsOmatchIO _lhsOname _lhsOnumberOfPatterns _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOunrwars) <- return (inv_FunctionBindings_s59 sem arg58)
        return (Syn_FunctionBindings _lhsOargcount _lhsOassumptions _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraintslist _lhsOcounter _lhsOdictionaryEnvironment _lhsOelementss _lhsOinfoTrees _lhsOmatchIO _lhsOname _lhsOnumberOfPatterns _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOunrwars)
   )

-- cata
{-# NOINLINE sem_FunctionBindings #-}
sem_FunctionBindings :: FunctionBindings  -> T_FunctionBindings 
sem_FunctionBindings list = Prelude.foldr sem_FunctionBindings_Cons sem_FunctionBindings_Nil (Prelude.map sem_FunctionBinding list)

-- semantic domain
newtype T_FunctionBindings  = T_FunctionBindings {
                                                 attach_T_FunctionBindings :: Identity (T_FunctionBindings_s59 )
                                                 }
newtype T_FunctionBindings_s59  = C_FunctionBindings_s59 {
                                                         inv_FunctionBindings_s59 :: (T_FunctionBindings_v58 )
                                                         }
data T_FunctionBindings_s60  = C_FunctionBindings_s60
type T_FunctionBindings_v58  = (T_FunctionBindings_vIn58 ) -> (T_FunctionBindings_vOut58 )
data T_FunctionBindings_vIn58  = T_FunctionBindings_vIn58 ([((Expression, [String]), Core_TypingStrategy)]) (M.Map NameWithRange TpScheme) ([[Name]]) ([PredicateWithSource]) (Tp) (Int) (Tps) (ClassEnvironment) (ClassMemberEnvironment) (Maybe [(Name, TpScheme)]) (ClassNameEnvironment) (Maybe (Name, Names)) (M.Map Name TpScheme) (TypeErrors) (Warnings) (Int) (Maybe Predicate) (Maybe Predicate) (Int) (DictionaryEnvironment) (ImportEnvironment) (Maybe Name) ([(Name, TpScheme)]) (IO ()) (Maybe Name) (Monos) (Names) (OrderedTypeSynonyms) (InfoTree) ([Warning]) (Predicates) (FixpointSubstitution) (TypeConstructorEnvironment) (M.Map Int (Scheme Predicates)) (Int) (Maybe [(Name, Tp)])
data T_FunctionBindings_vOut58  = T_FunctionBindings_vOut58 (Int) (Assumptions) (Int) (TypeErrors) ([(Name, Instance)]) (Warnings) (ConstraintSets) (Int) (DictionaryEnvironment) ([([PatternElement], Bool)]) (InfoTrees) (IO ()) (Name) (Int) ([Warning]) (FunctionBindings) (Names) (Int) ([Warning])
{-# NOINLINE sem_FunctionBindings_Cons #-}
sem_FunctionBindings_Cons :: T_FunctionBinding  -> T_FunctionBindings  -> T_FunctionBindings 
sem_FunctionBindings_Cons arg_hd_ arg_tl_ = T_FunctionBindings (return st59) where
   {-# NOINLINE st59 #-}
   !st59 = let
      v58 :: T_FunctionBindings_v58 
      v58 = \ !(T_FunctionBindings_vIn58 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaRight _lhsIbetaUnique _lhsIbetasLeft _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeConstructors _lhsItypeschemeMap _lhsIuniqueChunk _lhsIvariableMapping) -> ( let
         _hdX56 = Control.Monad.Identity.runIdentity (attach_T_FunctionBinding (arg_hd_))
         _tlX59 = Control.Monad.Identity.runIdentity (attach_T_FunctionBindings (arg_tl_))
         (T_FunctionBinding_vOut55 _hdIargcount _hdIassumptions _hdIbetaUnique _hdIcollectErrors _hdIcollectInstances _hdIcollectWarnings _hdIconstraints _hdIcounter _hdIdictionaryEnvironment _hdIelements _hdIinfoTree _hdImatchIO _hdIname _hdInumberOfPatterns _hdIpatternMatchWarnings _hdIself _hdIunboundNames _hdIuniqueChunk _hdIunrwar) = inv_FunctionBinding_s56 _hdX56 (T_FunctionBinding_vIn55 _hdOallPatterns _hdOallTypeSchemes _hdOambiguousConflicts _hdOavailablePredicates _hdObetaRight _hdObetaUnique _hdObetasLeft _hdOclassEnvironment _hdOclassMemberEnv _hdOclassMemberTypeSchemes _hdOclassNamesEnv _hdOclassPredicate _hdOclassTypeSchemes _hdOcollectErrors _hdOcollectWarnings _hdOcounter _hdOcurClassPred _hdOcurPred _hdOcurrentChunk _hdOdictionaryEnvironment _hdOimportEnvironment _hdOinstanceName _hdOinstanceTypes _hdOmatchIO _hdOmoduleName _hdOmonos _hdOnamesInScope _hdOorderedTypeSynonyms _hdOparentTree _hdOpatternMatchWarnings _hdOrequiredPredicates _hdOsubstitution _hdOtypeConstructors _hdOtypeschemeMap _hdOuniqueChunk _hdOvariableMapping)
         (T_FunctionBindings_vOut58 _tlIargcount _tlIassumptions _tlIbetaUnique _tlIcollectErrors _tlIcollectInstances _tlIcollectWarnings _tlIconstraintslist _tlIcounter _tlIdictionaryEnvironment _tlIelementss _tlIinfoTrees _tlImatchIO _tlIname _tlInumberOfPatterns _tlIpatternMatchWarnings _tlIself _tlIunboundNames _tlIuniqueChunk _tlIunrwars) = inv_FunctionBindings_s59 _tlX59 (T_FunctionBindings_vIn58 _tlOallPatterns _tlOallTypeSchemes _tlOambiguousConflicts _tlOavailablePredicates _tlObetaRight _tlObetaUnique _tlObetasLeft _tlOclassEnvironment _tlOclassMemberEnv _tlOclassMemberTypeSchemes _tlOclassNamesEnv _tlOclassPredicate _tlOclassTypeSchemes _tlOcollectErrors _tlOcollectWarnings _tlOcounter _tlOcurClassPred _tlOcurPred _tlOcurrentChunk _tlOdictionaryEnvironment _tlOimportEnvironment _tlOinstanceName _tlOinstanceTypes _tlOmatchIO _tlOmoduleName _tlOmonos _tlOnamesInScope _tlOorderedTypeSynonyms _tlOparentTree _tlOpatternMatchWarnings _tlOrequiredPredicates _tlOsubstitution _tlOtypeConstructors _tlOtypeschemeMap _tlOuniqueChunk _tlOvariableMapping)
         _lhsOelementss :: [([PatternElement], Bool)]
         _lhsOelementss = rule3026 _hdIelements _tlIelementss
         _lhsOunrwars :: [Warning]
         _lhsOunrwars = rule3027 _hdIunrwar _tlIunrwars
         _lhsOargcount :: Int
         _lhsOargcount = rule3028 _hdIargcount
         _lhsOinfoTrees :: InfoTrees
         _lhsOinfoTrees = rule3029 _hdIinfoTree _tlIinfoTrees
         _lhsOassumptions :: Assumptions
         _lhsOassumptions = rule3030 _hdIassumptions _tlIassumptions
         _lhsOnumberOfPatterns :: Int
         _lhsOnumberOfPatterns = rule3031 _hdInumberOfPatterns
         _lhsOname :: Name
         _lhsOname = rule3032 _hdIname
         _lhsOconstraintslist :: ConstraintSets
         _lhsOconstraintslist = rule3033 _hdIconstraints _tlIconstraintslist
         _lhsOcollectInstances :: [(Name, Instance)]
         _lhsOcollectInstances = rule3034 _hdIcollectInstances _tlIcollectInstances
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule3035 _hdIunboundNames _tlIunboundNames
         _self = rule3036 _hdIself _tlIself
         _lhsOself :: FunctionBindings
         _lhsOself = rule3037 _self
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule3038 _tlIbetaUnique
         _lhsOcollectErrors :: TypeErrors
         _lhsOcollectErrors = rule3039 _tlIcollectErrors
         _lhsOcollectWarnings :: Warnings
         _lhsOcollectWarnings = rule3040 _tlIcollectWarnings
         _lhsOcounter :: Int
         _lhsOcounter = rule3041 _tlIcounter
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule3042 _tlIdictionaryEnvironment
         _lhsOmatchIO :: IO ()
         _lhsOmatchIO = rule3043 _tlImatchIO
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule3044 _tlIpatternMatchWarnings
         _lhsOuniqueChunk :: Int
         _lhsOuniqueChunk = rule3045 _tlIuniqueChunk
         _hdOallPatterns = rule3046 _lhsIallPatterns
         _hdOallTypeSchemes = rule3047 _lhsIallTypeSchemes
         _hdOambiguousConflicts = rule3048 _lhsIambiguousConflicts
         _hdOavailablePredicates = rule3049 _lhsIavailablePredicates
         _hdObetaRight = rule3050 _lhsIbetaRight
         _hdObetaUnique = rule3051 _lhsIbetaUnique
         _hdObetasLeft = rule3052 _lhsIbetasLeft
         _hdOclassEnvironment = rule3053 _lhsIclassEnvironment
         _hdOclassMemberEnv = rule3054 _lhsIclassMemberEnv
         _hdOclassMemberTypeSchemes = rule3055 _lhsIclassMemberTypeSchemes
         _hdOclassNamesEnv = rule3056 _lhsIclassNamesEnv
         _hdOclassPredicate = rule3057 _lhsIclassPredicate
         _hdOclassTypeSchemes = rule3058 _lhsIclassTypeSchemes
         _hdOcollectErrors = rule3059 _lhsIcollectErrors
         _hdOcollectWarnings = rule3060 _lhsIcollectWarnings
         _hdOcounter = rule3061 _lhsIcounter
         _hdOcurClassPred = rule3062 _lhsIcurClassPred
         _hdOcurPred = rule3063 _lhsIcurPred
         _hdOcurrentChunk = rule3064 _lhsIcurrentChunk
         _hdOdictionaryEnvironment = rule3065 _lhsIdictionaryEnvironment
         _hdOimportEnvironment = rule3066 _lhsIimportEnvironment
         _hdOinstanceName = rule3067 _lhsIinstanceName
         _hdOinstanceTypes = rule3068 _lhsIinstanceTypes
         _hdOmatchIO = rule3069 _lhsImatchIO
         _hdOmoduleName = rule3070 _lhsImoduleName
         _hdOmonos = rule3071 _lhsImonos
         _hdOnamesInScope = rule3072 _lhsInamesInScope
         _hdOorderedTypeSynonyms = rule3073 _lhsIorderedTypeSynonyms
         _hdOparentTree = rule3074 _lhsIparentTree
         _hdOpatternMatchWarnings = rule3075 _lhsIpatternMatchWarnings
         _hdOrequiredPredicates = rule3076 _lhsIrequiredPredicates
         _hdOsubstitution = rule3077 _lhsIsubstitution
         _hdOtypeConstructors = rule3078 _lhsItypeConstructors
         _hdOtypeschemeMap = rule3079 _lhsItypeschemeMap
         _hdOuniqueChunk = rule3080 _lhsIuniqueChunk
         _hdOvariableMapping = rule3081 _lhsIvariableMapping
         _tlOallPatterns = rule3082 _lhsIallPatterns
         _tlOallTypeSchemes = rule3083 _lhsIallTypeSchemes
         _tlOambiguousConflicts = rule3084 _lhsIambiguousConflicts
         _tlOavailablePredicates = rule3085 _lhsIavailablePredicates
         _tlObetaRight = rule3086 _lhsIbetaRight
         _tlObetaUnique = rule3087 _hdIbetaUnique
         _tlObetasLeft = rule3088 _lhsIbetasLeft
         _tlOclassEnvironment = rule3089 _lhsIclassEnvironment
         _tlOclassMemberEnv = rule3090 _lhsIclassMemberEnv
         _tlOclassMemberTypeSchemes = rule3091 _lhsIclassMemberTypeSchemes
         _tlOclassNamesEnv = rule3092 _lhsIclassNamesEnv
         _tlOclassPredicate = rule3093 _lhsIclassPredicate
         _tlOclassTypeSchemes = rule3094 _lhsIclassTypeSchemes
         _tlOcollectErrors = rule3095 _hdIcollectErrors
         _tlOcollectWarnings = rule3096 _hdIcollectWarnings
         _tlOcounter = rule3097 _hdIcounter
         _tlOcurClassPred = rule3098 _lhsIcurClassPred
         _tlOcurPred = rule3099 _lhsIcurPred
         _tlOcurrentChunk = rule3100 _lhsIcurrentChunk
         _tlOdictionaryEnvironment = rule3101 _hdIdictionaryEnvironment
         _tlOimportEnvironment = rule3102 _lhsIimportEnvironment
         _tlOinstanceName = rule3103 _lhsIinstanceName
         _tlOinstanceTypes = rule3104 _lhsIinstanceTypes
         _tlOmatchIO = rule3105 _hdImatchIO
         _tlOmoduleName = rule3106 _lhsImoduleName
         _tlOmonos = rule3107 _lhsImonos
         _tlOnamesInScope = rule3108 _lhsInamesInScope
         _tlOorderedTypeSynonyms = rule3109 _lhsIorderedTypeSynonyms
         _tlOparentTree = rule3110 _lhsIparentTree
         _tlOpatternMatchWarnings = rule3111 _hdIpatternMatchWarnings
         _tlOrequiredPredicates = rule3112 _lhsIrequiredPredicates
         _tlOsubstitution = rule3113 _lhsIsubstitution
         _tlOtypeConstructors = rule3114 _lhsItypeConstructors
         _tlOtypeschemeMap = rule3115 _lhsItypeschemeMap
         _tlOuniqueChunk = rule3116 _hdIuniqueChunk
         _tlOvariableMapping = rule3117 _lhsIvariableMapping
         !__result_ = T_FunctionBindings_vOut58 _lhsOargcount _lhsOassumptions _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraintslist _lhsOcounter _lhsOdictionaryEnvironment _lhsOelementss _lhsOinfoTrees _lhsOmatchIO _lhsOname _lhsOnumberOfPatterns _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOunrwars
         in __result_ )
     in C_FunctionBindings_s59 v58
   {-# INLINE rule3026 #-}
   rule3026 = \ ((_hdIelements) ::  ([PatternElement], Bool) ) ((_tlIelementss) :: [([PatternElement], Bool)]) ->
                                         _hdIelements : _tlIelementss
   {-# INLINE rule3027 #-}
   rule3027 = \ ((_hdIunrwar) :: Warning) ((_tlIunrwars) :: [Warning]) ->
                                         _hdIunrwar   : _tlIunrwars
   {-# INLINE rule3028 #-}
   rule3028 = \ ((_hdIargcount) :: Int) ->
                                         _hdIargcount
   {-# INLINE rule3029 #-}
   rule3029 = \ ((_hdIinfoTree) :: InfoTree) ((_tlIinfoTrees) :: InfoTrees) ->
                               _hdIinfoTree : _tlIinfoTrees
   {-# INLINE rule3030 #-}
   rule3030 = \ ((_hdIassumptions) :: Assumptions) ((_tlIassumptions) :: Assumptions) ->
                                 _hdIassumptions `combine` _tlIassumptions
   {-# INLINE rule3031 #-}
   rule3031 = \ ((_hdInumberOfPatterns) :: Int) ->
                                 _hdInumberOfPatterns
   {-# INLINE rule3032 #-}
   rule3032 = \ ((_hdIname) :: Name) ->
                                 _hdIname
   {-# INLINE rule3033 #-}
   rule3033 = \ ((_hdIconstraints) :: ConstraintSet) ((_tlIconstraintslist) :: ConstraintSets) ->
                                 _hdIconstraints : _tlIconstraintslist
   {-# INLINE rule3034 #-}
   rule3034 = \ ((_hdIcollectInstances) :: [(Name, Instance)]) ((_tlIcollectInstances) :: [(Name, Instance)]) ->
     _hdIcollectInstances  ++  _tlIcollectInstances
   {-# INLINE rule3035 #-}
   rule3035 = \ ((_hdIunboundNames) :: Names) ((_tlIunboundNames) :: Names) ->
     ((++) _hdIunboundNames _tlIunboundNames)
   {-# INLINE rule3036 #-}
   rule3036 = \ ((_hdIself) :: FunctionBinding) ((_tlIself) :: FunctionBindings) ->
     (:) _hdIself _tlIself
   {-# INLINE rule3037 #-}
   rule3037 = \ _self ->
     _self
   {-# INLINE rule3038 #-}
   rule3038 = \ ((_tlIbetaUnique) :: Int) ->
     _tlIbetaUnique
   {-# INLINE rule3039 #-}
   rule3039 = \ ((_tlIcollectErrors) :: TypeErrors) ->
     _tlIcollectErrors
   {-# INLINE rule3040 #-}
   rule3040 = \ ((_tlIcollectWarnings) :: Warnings) ->
     _tlIcollectWarnings
   {-# INLINE rule3041 #-}
   rule3041 = \ ((_tlIcounter) :: Int) ->
     _tlIcounter
   {-# INLINE rule3042 #-}
   rule3042 = \ ((_tlIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _tlIdictionaryEnvironment
   {-# INLINE rule3043 #-}
   rule3043 = \ ((_tlImatchIO) :: IO ()) ->
     _tlImatchIO
   {-# INLINE rule3044 #-}
   rule3044 = \ ((_tlIpatternMatchWarnings) :: [Warning]) ->
     _tlIpatternMatchWarnings
   {-# INLINE rule3045 #-}
   rule3045 = \ ((_tlIuniqueChunk) :: Int) ->
     _tlIuniqueChunk
   {-# INLINE rule3046 #-}
   rule3046 = \ ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ->
     _lhsIallPatterns
   {-# INLINE rule3047 #-}
   rule3047 = \ ((_lhsIallTypeSchemes) :: M.Map NameWithRange TpScheme) ->
     _lhsIallTypeSchemes
   {-# INLINE rule3048 #-}
   rule3048 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule3049 #-}
   rule3049 = \ ((_lhsIavailablePredicates) :: [PredicateWithSource]) ->
     _lhsIavailablePredicates
   {-# INLINE rule3050 #-}
   rule3050 = \ ((_lhsIbetaRight) :: Tp) ->
     _lhsIbetaRight
   {-# INLINE rule3051 #-}
   rule3051 = \ ((_lhsIbetaUnique) :: Int) ->
     _lhsIbetaUnique
   {-# INLINE rule3052 #-}
   rule3052 = \ ((_lhsIbetasLeft) :: Tps) ->
     _lhsIbetasLeft
   {-# INLINE rule3053 #-}
   rule3053 = \ ((_lhsIclassEnvironment) :: ClassEnvironment) ->
     _lhsIclassEnvironment
   {-# INLINE rule3054 #-}
   rule3054 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule3055 #-}
   rule3055 = \ ((_lhsIclassMemberTypeSchemes) :: Maybe [(Name, TpScheme)]) ->
     _lhsIclassMemberTypeSchemes
   {-# INLINE rule3056 #-}
   rule3056 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule3057 #-}
   rule3057 = \ ((_lhsIclassPredicate) :: Maybe (Name, Names)) ->
     _lhsIclassPredicate
   {-# INLINE rule3058 #-}
   rule3058 = \ ((_lhsIclassTypeSchemes) :: M.Map Name TpScheme) ->
     _lhsIclassTypeSchemes
   {-# INLINE rule3059 #-}
   rule3059 = \ ((_lhsIcollectErrors) :: TypeErrors) ->
     _lhsIcollectErrors
   {-# INLINE rule3060 #-}
   rule3060 = \ ((_lhsIcollectWarnings) :: Warnings) ->
     _lhsIcollectWarnings
   {-# INLINE rule3061 #-}
   rule3061 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule3062 #-}
   rule3062 = \ ((_lhsIcurClassPred) :: Maybe Predicate) ->
     _lhsIcurClassPred
   {-# INLINE rule3063 #-}
   rule3063 = \ ((_lhsIcurPred) :: Maybe Predicate) ->
     _lhsIcurPred
   {-# INLINE rule3064 #-}
   rule3064 = \ ((_lhsIcurrentChunk) :: Int) ->
     _lhsIcurrentChunk
   {-# INLINE rule3065 #-}
   rule3065 = \ ((_lhsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _lhsIdictionaryEnvironment
   {-# INLINE rule3066 #-}
   rule3066 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule3067 #-}
   rule3067 = \ ((_lhsIinstanceName) :: Maybe Name) ->
     _lhsIinstanceName
   {-# INLINE rule3068 #-}
   rule3068 = \ ((_lhsIinstanceTypes) :: [(Name, TpScheme)]) ->
     _lhsIinstanceTypes
   {-# INLINE rule3069 #-}
   rule3069 = \ ((_lhsImatchIO) :: IO ()) ->
     _lhsImatchIO
   {-# INLINE rule3070 #-}
   rule3070 = \ ((_lhsImoduleName) :: Maybe Name) ->
     _lhsImoduleName
   {-# INLINE rule3071 #-}
   rule3071 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule3072 #-}
   rule3072 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule3073 #-}
   rule3073 = \ ((_lhsIorderedTypeSynonyms) :: OrderedTypeSynonyms) ->
     _lhsIorderedTypeSynonyms
   {-# INLINE rule3074 #-}
   rule3074 = \ ((_lhsIparentTree) :: InfoTree) ->
     _lhsIparentTree
   {-# INLINE rule3075 #-}
   rule3075 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule3076 #-}
   rule3076 = \ ((_lhsIrequiredPredicates) :: Predicates) ->
     _lhsIrequiredPredicates
   {-# INLINE rule3077 #-}
   rule3077 = \ ((_lhsIsubstitution) :: FixpointSubstitution) ->
     _lhsIsubstitution
   {-# INLINE rule3078 #-}
   rule3078 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
   {-# INLINE rule3079 #-}
   rule3079 = \ ((_lhsItypeschemeMap) :: M.Map Int (Scheme Predicates)) ->
     _lhsItypeschemeMap
   {-# INLINE rule3080 #-}
   rule3080 = \ ((_lhsIuniqueChunk) :: Int) ->
     _lhsIuniqueChunk
   {-# INLINE rule3081 #-}
   rule3081 = \ ((_lhsIvariableMapping) :: Maybe [(Name, Tp)]) ->
     _lhsIvariableMapping
   {-# INLINE rule3082 #-}
   rule3082 = \ ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ->
     _lhsIallPatterns
   {-# INLINE rule3083 #-}
   rule3083 = \ ((_lhsIallTypeSchemes) :: M.Map NameWithRange TpScheme) ->
     _lhsIallTypeSchemes
   {-# INLINE rule3084 #-}
   rule3084 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule3085 #-}
   rule3085 = \ ((_lhsIavailablePredicates) :: [PredicateWithSource]) ->
     _lhsIavailablePredicates
   {-# INLINE rule3086 #-}
   rule3086 = \ ((_lhsIbetaRight) :: Tp) ->
     _lhsIbetaRight
   {-# INLINE rule3087 #-}
   rule3087 = \ ((_hdIbetaUnique) :: Int) ->
     _hdIbetaUnique
   {-# INLINE rule3088 #-}
   rule3088 = \ ((_lhsIbetasLeft) :: Tps) ->
     _lhsIbetasLeft
   {-# INLINE rule3089 #-}
   rule3089 = \ ((_lhsIclassEnvironment) :: ClassEnvironment) ->
     _lhsIclassEnvironment
   {-# INLINE rule3090 #-}
   rule3090 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule3091 #-}
   rule3091 = \ ((_lhsIclassMemberTypeSchemes) :: Maybe [(Name, TpScheme)]) ->
     _lhsIclassMemberTypeSchemes
   {-# INLINE rule3092 #-}
   rule3092 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule3093 #-}
   rule3093 = \ ((_lhsIclassPredicate) :: Maybe (Name, Names)) ->
     _lhsIclassPredicate
   {-# INLINE rule3094 #-}
   rule3094 = \ ((_lhsIclassTypeSchemes) :: M.Map Name TpScheme) ->
     _lhsIclassTypeSchemes
   {-# INLINE rule3095 #-}
   rule3095 = \ ((_hdIcollectErrors) :: TypeErrors) ->
     _hdIcollectErrors
   {-# INLINE rule3096 #-}
   rule3096 = \ ((_hdIcollectWarnings) :: Warnings) ->
     _hdIcollectWarnings
   {-# INLINE rule3097 #-}
   rule3097 = \ ((_hdIcounter) :: Int) ->
     _hdIcounter
   {-# INLINE rule3098 #-}
   rule3098 = \ ((_lhsIcurClassPred) :: Maybe Predicate) ->
     _lhsIcurClassPred
   {-# INLINE rule3099 #-}
   rule3099 = \ ((_lhsIcurPred) :: Maybe Predicate) ->
     _lhsIcurPred
   {-# INLINE rule3100 #-}
   rule3100 = \ ((_lhsIcurrentChunk) :: Int) ->
     _lhsIcurrentChunk
   {-# INLINE rule3101 #-}
   rule3101 = \ ((_hdIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _hdIdictionaryEnvironment
   {-# INLINE rule3102 #-}
   rule3102 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule3103 #-}
   rule3103 = \ ((_lhsIinstanceName) :: Maybe Name) ->
     _lhsIinstanceName
   {-# INLINE rule3104 #-}
   rule3104 = \ ((_lhsIinstanceTypes) :: [(Name, TpScheme)]) ->
     _lhsIinstanceTypes
   {-# INLINE rule3105 #-}
   rule3105 = \ ((_hdImatchIO) :: IO ()) ->
     _hdImatchIO
   {-# INLINE rule3106 #-}
   rule3106 = \ ((_lhsImoduleName) :: Maybe Name) ->
     _lhsImoduleName
   {-# INLINE rule3107 #-}
   rule3107 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule3108 #-}
   rule3108 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule3109 #-}
   rule3109 = \ ((_lhsIorderedTypeSynonyms) :: OrderedTypeSynonyms) ->
     _lhsIorderedTypeSynonyms
   {-# INLINE rule3110 #-}
   rule3110 = \ ((_lhsIparentTree) :: InfoTree) ->
     _lhsIparentTree
   {-# INLINE rule3111 #-}
   rule3111 = \ ((_hdIpatternMatchWarnings) :: [Warning]) ->
     _hdIpatternMatchWarnings
   {-# INLINE rule3112 #-}
   rule3112 = \ ((_lhsIrequiredPredicates) :: Predicates) ->
     _lhsIrequiredPredicates
   {-# INLINE rule3113 #-}
   rule3113 = \ ((_lhsIsubstitution) :: FixpointSubstitution) ->
     _lhsIsubstitution
   {-# INLINE rule3114 #-}
   rule3114 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
   {-# INLINE rule3115 #-}
   rule3115 = \ ((_lhsItypeschemeMap) :: M.Map Int (Scheme Predicates)) ->
     _lhsItypeschemeMap
   {-# INLINE rule3116 #-}
   rule3116 = \ ((_hdIuniqueChunk) :: Int) ->
     _hdIuniqueChunk
   {-# INLINE rule3117 #-}
   rule3117 = \ ((_lhsIvariableMapping) :: Maybe [(Name, Tp)]) ->
     _lhsIvariableMapping
{-# NOINLINE sem_FunctionBindings_Nil #-}
sem_FunctionBindings_Nil ::  T_FunctionBindings 
sem_FunctionBindings_Nil  = T_FunctionBindings (return st59) where
   {-# NOINLINE st59 #-}
   !st59 = let
      v58 :: T_FunctionBindings_v58 
      v58 = \ !(T_FunctionBindings_vIn58 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaRight _lhsIbetaUnique _lhsIbetasLeft _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeConstructors _lhsItypeschemeMap _lhsIuniqueChunk _lhsIvariableMapping) -> ( let
         _lhsOelementss :: [([PatternElement], Bool)]
         _lhsOelementss = rule3118  ()
         _lhsOunrwars :: [Warning]
         _lhsOunrwars = rule3119  ()
         _lhsOargcount :: Int
         _lhsOargcount = rule3120  ()
         _lhsOinfoTrees :: InfoTrees
         _lhsOinfoTrees = rule3121  ()
         _lhsOassumptions :: Assumptions
         _lhsOassumptions = rule3122  ()
         _lhsOnumberOfPatterns :: Int
         _lhsOnumberOfPatterns = rule3123  ()
         _lhsOname :: Name
         _lhsOname = rule3124  ()
         _lhsOconstraintslist :: ConstraintSets
         _lhsOconstraintslist = rule3125  ()
         _lhsOcollectInstances :: [(Name, Instance)]
         _lhsOcollectInstances = rule3126  ()
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule3127  ()
         _self = rule3128  ()
         _lhsOself :: FunctionBindings
         _lhsOself = rule3129 _self
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule3130 _lhsIbetaUnique
         _lhsOcollectErrors :: TypeErrors
         _lhsOcollectErrors = rule3131 _lhsIcollectErrors
         _lhsOcollectWarnings :: Warnings
         _lhsOcollectWarnings = rule3132 _lhsIcollectWarnings
         _lhsOcounter :: Int
         _lhsOcounter = rule3133 _lhsIcounter
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule3134 _lhsIdictionaryEnvironment
         _lhsOmatchIO :: IO ()
         _lhsOmatchIO = rule3135 _lhsImatchIO
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule3136 _lhsIpatternMatchWarnings
         _lhsOuniqueChunk :: Int
         _lhsOuniqueChunk = rule3137 _lhsIuniqueChunk
         !__result_ = T_FunctionBindings_vOut58 _lhsOargcount _lhsOassumptions _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraintslist _lhsOcounter _lhsOdictionaryEnvironment _lhsOelementss _lhsOinfoTrees _lhsOmatchIO _lhsOname _lhsOnumberOfPatterns _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOunrwars
         in __result_ )
     in C_FunctionBindings_s59 v58
   {-# INLINE rule3118 #-}
   rule3118 = \  (_ :: ()) ->
                                         []
   {-# INLINE rule3119 #-}
   rule3119 = \  (_ :: ()) ->
                                         []
   {-# INLINE rule3120 #-}
   rule3120 = \  (_ :: ()) ->
                                         pmError "FunctionBindings_Nil.argcount" "?empty list of function bindings?"
   {-# INLINE rule3121 #-}
   rule3121 = \  (_ :: ()) ->
                               []
   {-# INLINE rule3122 #-}
   rule3122 = \  (_ :: ()) ->
                                 noAssumptions
   {-# INLINE rule3123 #-}
   rule3123 = \  (_ :: ()) ->
                                 internalError "TypeInferencing.ag" "n/a" "FunctionBindings(1)"
   {-# INLINE rule3124 #-}
   rule3124 = \  (_ :: ()) ->
                                 internalError "TypeInferencing.ag" "n/a" "FunctionBindings(2)"
   {-# INLINE rule3125 #-}
   rule3125 = \  (_ :: ()) ->
                                 []
   {-# INLINE rule3126 #-}
   rule3126 = \  (_ :: ()) ->
     []
   {-# INLINE rule3127 #-}
   rule3127 = \  (_ :: ()) ->
     []
   {-# INLINE rule3128 #-}
   rule3128 = \  (_ :: ()) ->
     []
   {-# INLINE rule3129 #-}
   rule3129 = \ _self ->
     _self
   {-# INLINE rule3130 #-}
   rule3130 = \ ((_lhsIbetaUnique) :: Int) ->
     _lhsIbetaUnique
   {-# INLINE rule3131 #-}
   rule3131 = \ ((_lhsIcollectErrors) :: TypeErrors) ->
     _lhsIcollectErrors
   {-# INLINE rule3132 #-}
   rule3132 = \ ((_lhsIcollectWarnings) :: Warnings) ->
     _lhsIcollectWarnings
   {-# INLINE rule3133 #-}
   rule3133 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule3134 #-}
   rule3134 = \ ((_lhsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _lhsIdictionaryEnvironment
   {-# INLINE rule3135 #-}
   rule3135 = \ ((_lhsImatchIO) :: IO ()) ->
     _lhsImatchIO
   {-# INLINE rule3136 #-}
   rule3136 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule3137 #-}
   rule3137 = \ ((_lhsIuniqueChunk) :: Int) ->
     _lhsIuniqueChunk

-- GuardedExpression -------------------------------------------
-- wrapper
data Inh_GuardedExpression  = Inh_GuardedExpression { allPatterns_Inh_GuardedExpression :: !([((Expression, [String]), Core_TypingStrategy)]), allTypeSchemes_Inh_GuardedExpression :: !(M.Map NameWithRange TpScheme), ambiguousConflicts_Inh_GuardedExpression :: !([[Name]]), availablePredicates_Inh_GuardedExpression :: !([PredicateWithSource]), betaRight_Inh_GuardedExpression :: !(Tp), betaUnique_Inh_GuardedExpression :: !(Int), classEnvironment_Inh_GuardedExpression :: !(ClassEnvironment), classMemberEnv_Inh_GuardedExpression :: !(ClassMemberEnvironment), classMemberTypeSchemes_Inh_GuardedExpression :: !(Maybe [(Name, TpScheme)]), classNamesEnv_Inh_GuardedExpression :: !(ClassNameEnvironment), classPredicate_Inh_GuardedExpression :: !(Maybe (Name, Names)), classTypeSchemes_Inh_GuardedExpression :: !(M.Map Name TpScheme), collectErrors_Inh_GuardedExpression :: !(TypeErrors), collectWarnings_Inh_GuardedExpression :: !(Warnings), counter_Inh_GuardedExpression :: !(Int), curClassPred_Inh_GuardedExpression :: !(Maybe Predicate), curPred_Inh_GuardedExpression :: !(Maybe Predicate), currentChunk_Inh_GuardedExpression :: !(Int), dictionaryEnvironment_Inh_GuardedExpression :: !(DictionaryEnvironment), importEnvironment_Inh_GuardedExpression :: !(ImportEnvironment), instanceName_Inh_GuardedExpression :: !(Maybe Name), instanceTypes_Inh_GuardedExpression :: !([(Name, TpScheme)]), matchIO_Inh_GuardedExpression :: !(IO ()), moduleName_Inh_GuardedExpression :: !(Maybe Name), monos_Inh_GuardedExpression :: !(Monos), namesInScope_Inh_GuardedExpression :: !(Names), numberOfGuards_Inh_GuardedExpression :: !(Int), orderedTypeSynonyms_Inh_GuardedExpression :: !(OrderedTypeSynonyms), parentTree_Inh_GuardedExpression :: !(InfoTree), patternMatchWarnings_Inh_GuardedExpression :: !([Warning]), requiredPredicates_Inh_GuardedExpression :: !(Predicates), substitution_Inh_GuardedExpression :: !(FixpointSubstitution), typeConstructors_Inh_GuardedExpression :: !(TypeConstructorEnvironment), typeschemeMap_Inh_GuardedExpression :: !(M.Map Int (Scheme Predicates)), uniqueChunk_Inh_GuardedExpression :: !(Int), uniqueSecondRound_Inh_GuardedExpression :: !(Int), variableMapping_Inh_GuardedExpression :: !(Maybe [(Name, Tp)]) }
data Syn_GuardedExpression  = Syn_GuardedExpression { assumptions_Syn_GuardedExpression :: !(Assumptions), betaUnique_Syn_GuardedExpression :: !(Int), collectErrors_Syn_GuardedExpression :: !(TypeErrors), collectInstances_Syn_GuardedExpression :: !([(Name, Instance)]), collectWarnings_Syn_GuardedExpression :: !(Warnings), constraints_Syn_GuardedExpression :: !(ConstraintSet), counter_Syn_GuardedExpression :: !(Int), dictionaryEnvironment_Syn_GuardedExpression :: !(DictionaryEnvironment), fallthrough_Syn_GuardedExpression :: !(Bool), infoTrees_Syn_GuardedExpression :: !(InfoTrees), matchIO_Syn_GuardedExpression :: !(IO ()), patternMatchWarnings_Syn_GuardedExpression :: !([Warning]), range_Syn_GuardedExpression :: !(Range), self_Syn_GuardedExpression :: !(GuardedExpression), unboundNames_Syn_GuardedExpression :: !(Names), uniqueChunk_Syn_GuardedExpression :: !(Int), uniqueSecondRound_Syn_GuardedExpression :: !(Int), unrwar_Syn_GuardedExpression :: !(Warning) }
{-# INLINABLE wrap_GuardedExpression #-}
wrap_GuardedExpression :: T_GuardedExpression  -> Inh_GuardedExpression  -> (Syn_GuardedExpression )
wrap_GuardedExpression !(T_GuardedExpression act) !(Inh_GuardedExpression _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaRight _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsInumberOfGuards _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeConstructors _lhsItypeschemeMap _lhsIuniqueChunk _lhsIuniqueSecondRound _lhsIvariableMapping) =
   Control.Monad.Identity.runIdentity (
     do !sem <- act
        let arg61 = T_GuardedExpression_vIn61 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaRight _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsInumberOfGuards _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeConstructors _lhsItypeschemeMap _lhsIuniqueChunk _lhsIuniqueSecondRound _lhsIvariableMapping
        !(T_GuardedExpression_vOut61 _lhsOassumptions _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraints _lhsOcounter _lhsOdictionaryEnvironment _lhsOfallthrough _lhsOinfoTrees _lhsOmatchIO _lhsOpatternMatchWarnings _lhsOrange _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOuniqueSecondRound _lhsOunrwar) <- return (inv_GuardedExpression_s62 sem arg61)
        return (Syn_GuardedExpression _lhsOassumptions _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraints _lhsOcounter _lhsOdictionaryEnvironment _lhsOfallthrough _lhsOinfoTrees _lhsOmatchIO _lhsOpatternMatchWarnings _lhsOrange _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOuniqueSecondRound _lhsOunrwar)
   )

-- cata
{-# NOINLINE sem_GuardedExpression #-}
sem_GuardedExpression :: GuardedExpression  -> T_GuardedExpression 
sem_GuardedExpression ( GuardedExpression_GuardedExpression range_ guard_ expression_ ) = sem_GuardedExpression_GuardedExpression ( sem_Range range_ ) ( sem_Expression guard_ ) ( sem_Expression expression_ )

-- semantic domain
newtype T_GuardedExpression  = T_GuardedExpression {
                                                   attach_T_GuardedExpression :: Identity (T_GuardedExpression_s62 )
                                                   }
newtype T_GuardedExpression_s62  = C_GuardedExpression_s62 {
                                                           inv_GuardedExpression_s62 :: (T_GuardedExpression_v61 )
                                                           }
data T_GuardedExpression_s63  = C_GuardedExpression_s63
type T_GuardedExpression_v61  = (T_GuardedExpression_vIn61 ) -> (T_GuardedExpression_vOut61 )
data T_GuardedExpression_vIn61  = T_GuardedExpression_vIn61 ([((Expression, [String]), Core_TypingStrategy)]) (M.Map NameWithRange TpScheme) ([[Name]]) ([PredicateWithSource]) (Tp) (Int) (ClassEnvironment) (ClassMemberEnvironment) (Maybe [(Name, TpScheme)]) (ClassNameEnvironment) (Maybe (Name, Names)) (M.Map Name TpScheme) (TypeErrors) (Warnings) (Int) (Maybe Predicate) (Maybe Predicate) (Int) (DictionaryEnvironment) (ImportEnvironment) (Maybe Name) ([(Name, TpScheme)]) (IO ()) (Maybe Name) (Monos) (Names) (Int) (OrderedTypeSynonyms) (InfoTree) ([Warning]) (Predicates) (FixpointSubstitution) (TypeConstructorEnvironment) (M.Map Int (Scheme Predicates)) (Int) (Int) (Maybe [(Name, Tp)])
data T_GuardedExpression_vOut61  = T_GuardedExpression_vOut61 (Assumptions) (Int) (TypeErrors) ([(Name, Instance)]) (Warnings) (ConstraintSet) (Int) (DictionaryEnvironment) (Bool) (InfoTrees) (IO ()) ([Warning]) (Range) (GuardedExpression) (Names) (Int) (Int) (Warning)
{-# NOINLINE sem_GuardedExpression_GuardedExpression #-}
sem_GuardedExpression_GuardedExpression :: T_Range  -> T_Expression  -> T_Expression  -> T_GuardedExpression 
sem_GuardedExpression_GuardedExpression arg_range_ arg_guard_ arg_expression_ = T_GuardedExpression (return st62) where
   {-# NOINLINE st62 #-}
   !st62 = let
      v61 :: T_GuardedExpression_v61 
      v61 = \ !(T_GuardedExpression_vIn61 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaRight _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsInumberOfGuards _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeConstructors _lhsItypeschemeMap _lhsIuniqueChunk _lhsIuniqueSecondRound _lhsIvariableMapping) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _guardX41 = Control.Monad.Identity.runIdentity (attach_T_Expression (arg_guard_))
         _expressionX41 = Control.Monad.Identity.runIdentity (attach_T_Expression (arg_expression_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_Expression_vOut40 _guardIassumptions _guardIbeta _guardIbetaUnique _guardIcollectErrors _guardIcollectInstances _guardIcollectWarnings _guardIconstraints _guardIcounter _guardIdictionaryEnvironment _guardIinfoTree _guardImatchIO _guardImatches _guardIpatternMatchWarnings _guardIself _guardIunboundNames _guardIuniqueChunk _guardIuniqueSecondRound) = inv_Expression_s41 _guardX41 (T_Expression_vIn40 _guardOallPatterns _guardOallTypeSchemes _guardOambiguousConflicts _guardOavailablePredicates _guardObetaUnique _guardOclassEnvironment _guardOclassMemberEnv _guardOclassMemberTypeSchemes _guardOclassNamesEnv _guardOclassPredicate _guardOclassTypeSchemes _guardOcollectErrors _guardOcollectWarnings _guardOcounter _guardOcurClassPred _guardOcurPred _guardOcurrentChunk _guardOdictionaryEnvironment _guardOimportEnvironment _guardOinstanceName _guardOinstanceTypes _guardOmatchIO _guardOmoduleName _guardOmonos _guardOnamesInScope _guardOorderedTypeSynonyms _guardOparentTree _guardOpatternMatchWarnings _guardOrequiredPredicates _guardOsubstitution _guardOtryPatterns _guardOtypeConstructors _guardOtypeschemeMap _guardOuniqueChunk _guardOuniqueSecondRound _guardOvariableMapping)
         (T_Expression_vOut40 _expressionIassumptions _expressionIbeta _expressionIbetaUnique _expressionIcollectErrors _expressionIcollectInstances _expressionIcollectWarnings _expressionIconstraints _expressionIcounter _expressionIdictionaryEnvironment _expressionIinfoTree _expressionImatchIO _expressionImatches _expressionIpatternMatchWarnings _expressionIself _expressionIunboundNames _expressionIuniqueChunk _expressionIuniqueSecondRound) = inv_Expression_s41 _expressionX41 (T_Expression_vIn40 _expressionOallPatterns _expressionOallTypeSchemes _expressionOambiguousConflicts _expressionOavailablePredicates _expressionObetaUnique _expressionOclassEnvironment _expressionOclassMemberEnv _expressionOclassMemberTypeSchemes _expressionOclassNamesEnv _expressionOclassPredicate _expressionOclassTypeSchemes _expressionOcollectErrors _expressionOcollectWarnings _expressionOcounter _expressionOcurClassPred _expressionOcurPred _expressionOcurrentChunk _expressionOdictionaryEnvironment _expressionOimportEnvironment _expressionOinstanceName _expressionOinstanceTypes _expressionOmatchIO _expressionOmoduleName _expressionOmonos _expressionOnamesInScope _expressionOorderedTypeSynonyms _expressionOparentTree _expressionOpatternMatchWarnings _expressionOrequiredPredicates _expressionOsubstitution _expressionOtryPatterns _expressionOtypeConstructors _expressionOtypeschemeMap _expressionOuniqueChunk _expressionOuniqueSecondRound _expressionOvariableMapping)
         _lhsOfallthrough :: Bool
         _lhsOfallthrough = rule3138 _guardIself
         _lhsOunrwar :: Warning
         _lhsOunrwar = rule3139 _guardIself _rangeIself
         _lhsOrange :: Range
         _lhsOrange = rule3140 _rangeIself
         _guardOtryPatterns = rule3141  ()
         _expressionOtryPatterns = rule3142  ()
         _lhsOinfoTrees :: InfoTrees
         _lhsOinfoTrees = rule3143 _expressionIinfoTree _guardIinfoTree
         _cinfoGuard = rule3144 _guardIinfoTree
         _cinfoExpr = rule3145 _expressionIinfoTree _lhsIbetaRight _lhsInumberOfGuards _lhsIparentTree
         _lhsOconstraints :: ConstraintSet
         _lhsOconstraints = rule3146 _expressionIconstraints _guardIconstraints _newconExpr _newconGuard
         _lhsOassumptions :: Assumptions
         _lhsOassumptions = rule3147 _expressionIassumptions _guardIassumptions
         _newconGuard = rule3148 _cinfoGuard _guardIbeta
         _newconExpr = rule3149 _cinfoExpr _expressionIbeta _lhsIbetaRight
         _lhsOcollectInstances :: [(Name, Instance)]
         _lhsOcollectInstances = rule3150 _expressionIcollectInstances _guardIcollectInstances
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule3151 _expressionIunboundNames _guardIunboundNames
         _self = rule3152 _expressionIself _guardIself _rangeIself
         _lhsOself :: GuardedExpression
         _lhsOself = rule3153 _self
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule3154 _expressionIbetaUnique
         _lhsOcollectErrors :: TypeErrors
         _lhsOcollectErrors = rule3155 _expressionIcollectErrors
         _lhsOcollectWarnings :: Warnings
         _lhsOcollectWarnings = rule3156 _expressionIcollectWarnings
         _lhsOcounter :: Int
         _lhsOcounter = rule3157 _expressionIcounter
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule3158 _expressionIdictionaryEnvironment
         _lhsOmatchIO :: IO ()
         _lhsOmatchIO = rule3159 _expressionImatchIO
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule3160 _expressionIpatternMatchWarnings
         _lhsOuniqueChunk :: Int
         _lhsOuniqueChunk = rule3161 _expressionIuniqueChunk
         _lhsOuniqueSecondRound :: Int
         _lhsOuniqueSecondRound = rule3162 _expressionIuniqueSecondRound
         _guardOallPatterns = rule3163 _lhsIallPatterns
         _guardOallTypeSchemes = rule3164 _lhsIallTypeSchemes
         _guardOambiguousConflicts = rule3165 _lhsIambiguousConflicts
         _guardOavailablePredicates = rule3166 _lhsIavailablePredicates
         _guardObetaUnique = rule3167 _lhsIbetaUnique
         _guardOclassEnvironment = rule3168 _lhsIclassEnvironment
         _guardOclassMemberEnv = rule3169 _lhsIclassMemberEnv
         _guardOclassMemberTypeSchemes = rule3170 _lhsIclassMemberTypeSchemes
         _guardOclassNamesEnv = rule3171 _lhsIclassNamesEnv
         _guardOclassPredicate = rule3172 _lhsIclassPredicate
         _guardOclassTypeSchemes = rule3173 _lhsIclassTypeSchemes
         _guardOcollectErrors = rule3174 _lhsIcollectErrors
         _guardOcollectWarnings = rule3175 _lhsIcollectWarnings
         _guardOcounter = rule3176 _lhsIcounter
         _guardOcurClassPred = rule3177 _lhsIcurClassPred
         _guardOcurPred = rule3178 _lhsIcurPred
         _guardOcurrentChunk = rule3179 _lhsIcurrentChunk
         _guardOdictionaryEnvironment = rule3180 _lhsIdictionaryEnvironment
         _guardOimportEnvironment = rule3181 _lhsIimportEnvironment
         _guardOinstanceName = rule3182 _lhsIinstanceName
         _guardOinstanceTypes = rule3183 _lhsIinstanceTypes
         _guardOmatchIO = rule3184 _lhsImatchIO
         _guardOmoduleName = rule3185 _lhsImoduleName
         _guardOmonos = rule3186 _lhsImonos
         _guardOnamesInScope = rule3187 _lhsInamesInScope
         _guardOorderedTypeSynonyms = rule3188 _lhsIorderedTypeSynonyms
         _guardOparentTree = rule3189 _lhsIparentTree
         _guardOpatternMatchWarnings = rule3190 _lhsIpatternMatchWarnings
         _guardOrequiredPredicates = rule3191 _lhsIrequiredPredicates
         _guardOsubstitution = rule3192 _lhsIsubstitution
         _guardOtypeConstructors = rule3193 _lhsItypeConstructors
         _guardOtypeschemeMap = rule3194 _lhsItypeschemeMap
         _guardOuniqueChunk = rule3195 _lhsIuniqueChunk
         _guardOuniqueSecondRound = rule3196 _lhsIuniqueSecondRound
         _guardOvariableMapping = rule3197 _lhsIvariableMapping
         _expressionOallPatterns = rule3198 _lhsIallPatterns
         _expressionOallTypeSchemes = rule3199 _lhsIallTypeSchemes
         _expressionOambiguousConflicts = rule3200 _lhsIambiguousConflicts
         _expressionOavailablePredicates = rule3201 _lhsIavailablePredicates
         _expressionObetaUnique = rule3202 _guardIbetaUnique
         _expressionOclassEnvironment = rule3203 _lhsIclassEnvironment
         _expressionOclassMemberEnv = rule3204 _lhsIclassMemberEnv
         _expressionOclassMemberTypeSchemes = rule3205 _lhsIclassMemberTypeSchemes
         _expressionOclassNamesEnv = rule3206 _lhsIclassNamesEnv
         _expressionOclassPredicate = rule3207 _lhsIclassPredicate
         _expressionOclassTypeSchemes = rule3208 _lhsIclassTypeSchemes
         _expressionOcollectErrors = rule3209 _guardIcollectErrors
         _expressionOcollectWarnings = rule3210 _guardIcollectWarnings
         _expressionOcounter = rule3211 _guardIcounter
         _expressionOcurClassPred = rule3212 _lhsIcurClassPred
         _expressionOcurPred = rule3213 _lhsIcurPred
         _expressionOcurrentChunk = rule3214 _lhsIcurrentChunk
         _expressionOdictionaryEnvironment = rule3215 _guardIdictionaryEnvironment
         _expressionOimportEnvironment = rule3216 _lhsIimportEnvironment
         _expressionOinstanceName = rule3217 _lhsIinstanceName
         _expressionOinstanceTypes = rule3218 _lhsIinstanceTypes
         _expressionOmatchIO = rule3219 _guardImatchIO
         _expressionOmoduleName = rule3220 _lhsImoduleName
         _expressionOmonos = rule3221 _lhsImonos
         _expressionOnamesInScope = rule3222 _lhsInamesInScope
         _expressionOorderedTypeSynonyms = rule3223 _lhsIorderedTypeSynonyms
         _expressionOparentTree = rule3224 _lhsIparentTree
         _expressionOpatternMatchWarnings = rule3225 _guardIpatternMatchWarnings
         _expressionOrequiredPredicates = rule3226 _lhsIrequiredPredicates
         _expressionOsubstitution = rule3227 _lhsIsubstitution
         _expressionOtypeConstructors = rule3228 _lhsItypeConstructors
         _expressionOtypeschemeMap = rule3229 _lhsItypeschemeMap
         _expressionOuniqueChunk = rule3230 _guardIuniqueChunk
         _expressionOuniqueSecondRound = rule3231 _guardIuniqueSecondRound
         _expressionOvariableMapping = rule3232 _lhsIvariableMapping
         !__result_ = T_GuardedExpression_vOut61 _lhsOassumptions _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraints _lhsOcounter _lhsOdictionaryEnvironment _lhsOfallthrough _lhsOinfoTrees _lhsOmatchIO _lhsOpatternMatchWarnings _lhsOrange _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOuniqueSecondRound _lhsOunrwar
         in __result_ )
     in C_GuardedExpression_s62 v61
   {-# INLINE rule3138 #-}
   rule3138 = \ ((_guardIself) :: Expression) ->
                                            case _guardIself
                                            of Expression_Variable    _ (Name_Identifier _ _ _ "otherwise") -> False
                                               Expression_Constructor _ (Name_Identifier _ _ _ "True"     ) -> False
                                               _                                                          -> True
   {-# INLINE rule3139 #-}
   rule3139 = \ ((_guardIself) :: Expression) ((_rangeIself) :: Range) ->
                                       UnreachableGuard _rangeIself _guardIself
   {-# INLINE rule3140 #-}
   rule3140 = \ ((_rangeIself) :: Range) ->
                                      _rangeIself
   {-# INLINE rule3141 #-}
   rule3141 = \  (_ :: ()) ->
                                                     []
   {-# INLINE rule3142 #-}
   rule3142 = \  (_ :: ()) ->
                                                     []
   {-# INLINE rule3143 #-}
   rule3143 = \ ((_expressionIinfoTree) :: InfoTree) ((_guardIinfoTree) :: InfoTree) ->
                                            [_guardIinfoTree, _expressionIinfoTree]
   {-# INLINE rule3144 #-}
   rule3144 = \ ((_guardIinfoTree) :: InfoTree) ->
     resultConstraint "guard" _guardIinfoTree
        []
   {-# INLINE rule3145 #-}
   rule3145 = \ ((_expressionIinfoTree) :: InfoTree) ((_lhsIbetaRight) :: Tp) ((_lhsInumberOfGuards) :: Int) ((_lhsIparentTree) :: InfoTree) ->
     resultConstraint "guarded expression" _expressionIinfoTree $
        [ HasTrustFactor 10.0 | _lhsInumberOfGuards < 2 ] ++
        [ Unifier (head (ftv _lhsIbetaRight)) ("right-hand sides", attribute (skip_UHA_FB_RHS _lhsIparentTree), "right-hand side") ]
   {-# INLINE rule3146 #-}
   rule3146 = \ ((_expressionIconstraints) :: ConstraintSet) ((_guardIconstraints) :: ConstraintSet) _newconExpr _newconGuard ->
                            Node [ _newconGuard .<. _guardIconstraints
                                 , _newconExpr  .<. _expressionIconstraints
                                 ]
   {-# INLINE rule3147 #-}
   rule3147 = \ ((_expressionIassumptions) :: Assumptions) ((_guardIassumptions) :: Assumptions) ->
                            _guardIassumptions `combine` _expressionIassumptions
   {-# INLINE rule3148 #-}
   rule3148 = \ _cinfoGuard ((_guardIbeta) :: Tp) ->
                            [ (_guardIbeta .==. boolQualType) _cinfoGuard ]
   {-# INLINE rule3149 #-}
   rule3149 = \ _cinfoExpr ((_expressionIbeta) :: Tp) ((_lhsIbetaRight) :: Tp) ->
                            [ (_expressionIbeta .==. _lhsIbetaRight) _cinfoExpr ]
   {-# INLINE rule3150 #-}
   rule3150 = \ ((_expressionIcollectInstances) :: [(Name, Instance)]) ((_guardIcollectInstances) :: [(Name, Instance)]) ->
     _guardIcollectInstances  ++  _expressionIcollectInstances
   {-# INLINE rule3151 #-}
   rule3151 = \ ((_expressionIunboundNames) :: Names) ((_guardIunboundNames) :: Names) ->
     ((++) _guardIunboundNames _expressionIunboundNames)
   {-# INLINE rule3152 #-}
   rule3152 = \ ((_expressionIself) :: Expression) ((_guardIself) :: Expression) ((_rangeIself) :: Range) ->
     GuardedExpression_GuardedExpression _rangeIself _guardIself _expressionIself
   {-# INLINE rule3153 #-}
   rule3153 = \ _self ->
     _self
   {-# INLINE rule3154 #-}
   rule3154 = \ ((_expressionIbetaUnique) :: Int) ->
     _expressionIbetaUnique
   {-# INLINE rule3155 #-}
   rule3155 = \ ((_expressionIcollectErrors) :: TypeErrors) ->
     _expressionIcollectErrors
   {-# INLINE rule3156 #-}
   rule3156 = \ ((_expressionIcollectWarnings) :: Warnings) ->
     _expressionIcollectWarnings
   {-# INLINE rule3157 #-}
   rule3157 = \ ((_expressionIcounter) :: Int) ->
     _expressionIcounter
   {-# INLINE rule3158 #-}
   rule3158 = \ ((_expressionIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _expressionIdictionaryEnvironment
   {-# INLINE rule3159 #-}
   rule3159 = \ ((_expressionImatchIO) :: IO ()) ->
     _expressionImatchIO
   {-# INLINE rule3160 #-}
   rule3160 = \ ((_expressionIpatternMatchWarnings) :: [Warning]) ->
     _expressionIpatternMatchWarnings
   {-# INLINE rule3161 #-}
   rule3161 = \ ((_expressionIuniqueChunk) :: Int) ->
     _expressionIuniqueChunk
   {-# INLINE rule3162 #-}
   rule3162 = \ ((_expressionIuniqueSecondRound) :: Int) ->
     _expressionIuniqueSecondRound
   {-# INLINE rule3163 #-}
   rule3163 = \ ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ->
     _lhsIallPatterns
   {-# INLINE rule3164 #-}
   rule3164 = \ ((_lhsIallTypeSchemes) :: M.Map NameWithRange TpScheme) ->
     _lhsIallTypeSchemes
   {-# INLINE rule3165 #-}
   rule3165 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule3166 #-}
   rule3166 = \ ((_lhsIavailablePredicates) :: [PredicateWithSource]) ->
     _lhsIavailablePredicates
   {-# INLINE rule3167 #-}
   rule3167 = \ ((_lhsIbetaUnique) :: Int) ->
     _lhsIbetaUnique
   {-# INLINE rule3168 #-}
   rule3168 = \ ((_lhsIclassEnvironment) :: ClassEnvironment) ->
     _lhsIclassEnvironment
   {-# INLINE rule3169 #-}
   rule3169 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule3170 #-}
   rule3170 = \ ((_lhsIclassMemberTypeSchemes) :: Maybe [(Name, TpScheme)]) ->
     _lhsIclassMemberTypeSchemes
   {-# INLINE rule3171 #-}
   rule3171 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule3172 #-}
   rule3172 = \ ((_lhsIclassPredicate) :: Maybe (Name, Names)) ->
     _lhsIclassPredicate
   {-# INLINE rule3173 #-}
   rule3173 = \ ((_lhsIclassTypeSchemes) :: M.Map Name TpScheme) ->
     _lhsIclassTypeSchemes
   {-# INLINE rule3174 #-}
   rule3174 = \ ((_lhsIcollectErrors) :: TypeErrors) ->
     _lhsIcollectErrors
   {-# INLINE rule3175 #-}
   rule3175 = \ ((_lhsIcollectWarnings) :: Warnings) ->
     _lhsIcollectWarnings
   {-# INLINE rule3176 #-}
   rule3176 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule3177 #-}
   rule3177 = \ ((_lhsIcurClassPred) :: Maybe Predicate) ->
     _lhsIcurClassPred
   {-# INLINE rule3178 #-}
   rule3178 = \ ((_lhsIcurPred) :: Maybe Predicate) ->
     _lhsIcurPred
   {-# INLINE rule3179 #-}
   rule3179 = \ ((_lhsIcurrentChunk) :: Int) ->
     _lhsIcurrentChunk
   {-# INLINE rule3180 #-}
   rule3180 = \ ((_lhsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _lhsIdictionaryEnvironment
   {-# INLINE rule3181 #-}
   rule3181 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule3182 #-}
   rule3182 = \ ((_lhsIinstanceName) :: Maybe Name) ->
     _lhsIinstanceName
   {-# INLINE rule3183 #-}
   rule3183 = \ ((_lhsIinstanceTypes) :: [(Name, TpScheme)]) ->
     _lhsIinstanceTypes
   {-# INLINE rule3184 #-}
   rule3184 = \ ((_lhsImatchIO) :: IO ()) ->
     _lhsImatchIO
   {-# INLINE rule3185 #-}
   rule3185 = \ ((_lhsImoduleName) :: Maybe Name) ->
     _lhsImoduleName
   {-# INLINE rule3186 #-}
   rule3186 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule3187 #-}
   rule3187 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule3188 #-}
   rule3188 = \ ((_lhsIorderedTypeSynonyms) :: OrderedTypeSynonyms) ->
     _lhsIorderedTypeSynonyms
   {-# INLINE rule3189 #-}
   rule3189 = \ ((_lhsIparentTree) :: InfoTree) ->
     _lhsIparentTree
   {-# INLINE rule3190 #-}
   rule3190 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule3191 #-}
   rule3191 = \ ((_lhsIrequiredPredicates) :: Predicates) ->
     _lhsIrequiredPredicates
   {-# INLINE rule3192 #-}
   rule3192 = \ ((_lhsIsubstitution) :: FixpointSubstitution) ->
     _lhsIsubstitution
   {-# INLINE rule3193 #-}
   rule3193 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
   {-# INLINE rule3194 #-}
   rule3194 = \ ((_lhsItypeschemeMap) :: M.Map Int (Scheme Predicates)) ->
     _lhsItypeschemeMap
   {-# INLINE rule3195 #-}
   rule3195 = \ ((_lhsIuniqueChunk) :: Int) ->
     _lhsIuniqueChunk
   {-# INLINE rule3196 #-}
   rule3196 = \ ((_lhsIuniqueSecondRound) :: Int) ->
     _lhsIuniqueSecondRound
   {-# INLINE rule3197 #-}
   rule3197 = \ ((_lhsIvariableMapping) :: Maybe [(Name, Tp)]) ->
     _lhsIvariableMapping
   {-# INLINE rule3198 #-}
   rule3198 = \ ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ->
     _lhsIallPatterns
   {-# INLINE rule3199 #-}
   rule3199 = \ ((_lhsIallTypeSchemes) :: M.Map NameWithRange TpScheme) ->
     _lhsIallTypeSchemes
   {-# INLINE rule3200 #-}
   rule3200 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule3201 #-}
   rule3201 = \ ((_lhsIavailablePredicates) :: [PredicateWithSource]) ->
     _lhsIavailablePredicates
   {-# INLINE rule3202 #-}
   rule3202 = \ ((_guardIbetaUnique) :: Int) ->
     _guardIbetaUnique
   {-# INLINE rule3203 #-}
   rule3203 = \ ((_lhsIclassEnvironment) :: ClassEnvironment) ->
     _lhsIclassEnvironment
   {-# INLINE rule3204 #-}
   rule3204 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule3205 #-}
   rule3205 = \ ((_lhsIclassMemberTypeSchemes) :: Maybe [(Name, TpScheme)]) ->
     _lhsIclassMemberTypeSchemes
   {-# INLINE rule3206 #-}
   rule3206 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule3207 #-}
   rule3207 = \ ((_lhsIclassPredicate) :: Maybe (Name, Names)) ->
     _lhsIclassPredicate
   {-# INLINE rule3208 #-}
   rule3208 = \ ((_lhsIclassTypeSchemes) :: M.Map Name TpScheme) ->
     _lhsIclassTypeSchemes
   {-# INLINE rule3209 #-}
   rule3209 = \ ((_guardIcollectErrors) :: TypeErrors) ->
     _guardIcollectErrors
   {-# INLINE rule3210 #-}
   rule3210 = \ ((_guardIcollectWarnings) :: Warnings) ->
     _guardIcollectWarnings
   {-# INLINE rule3211 #-}
   rule3211 = \ ((_guardIcounter) :: Int) ->
     _guardIcounter
   {-# INLINE rule3212 #-}
   rule3212 = \ ((_lhsIcurClassPred) :: Maybe Predicate) ->
     _lhsIcurClassPred
   {-# INLINE rule3213 #-}
   rule3213 = \ ((_lhsIcurPred) :: Maybe Predicate) ->
     _lhsIcurPred
   {-# INLINE rule3214 #-}
   rule3214 = \ ((_lhsIcurrentChunk) :: Int) ->
     _lhsIcurrentChunk
   {-# INLINE rule3215 #-}
   rule3215 = \ ((_guardIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _guardIdictionaryEnvironment
   {-# INLINE rule3216 #-}
   rule3216 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule3217 #-}
   rule3217 = \ ((_lhsIinstanceName) :: Maybe Name) ->
     _lhsIinstanceName
   {-# INLINE rule3218 #-}
   rule3218 = \ ((_lhsIinstanceTypes) :: [(Name, TpScheme)]) ->
     _lhsIinstanceTypes
   {-# INLINE rule3219 #-}
   rule3219 = \ ((_guardImatchIO) :: IO ()) ->
     _guardImatchIO
   {-# INLINE rule3220 #-}
   rule3220 = \ ((_lhsImoduleName) :: Maybe Name) ->
     _lhsImoduleName
   {-# INLINE rule3221 #-}
   rule3221 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule3222 #-}
   rule3222 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule3223 #-}
   rule3223 = \ ((_lhsIorderedTypeSynonyms) :: OrderedTypeSynonyms) ->
     _lhsIorderedTypeSynonyms
   {-# INLINE rule3224 #-}
   rule3224 = \ ((_lhsIparentTree) :: InfoTree) ->
     _lhsIparentTree
   {-# INLINE rule3225 #-}
   rule3225 = \ ((_guardIpatternMatchWarnings) :: [Warning]) ->
     _guardIpatternMatchWarnings
   {-# INLINE rule3226 #-}
   rule3226 = \ ((_lhsIrequiredPredicates) :: Predicates) ->
     _lhsIrequiredPredicates
   {-# INLINE rule3227 #-}
   rule3227 = \ ((_lhsIsubstitution) :: FixpointSubstitution) ->
     _lhsIsubstitution
   {-# INLINE rule3228 #-}
   rule3228 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
   {-# INLINE rule3229 #-}
   rule3229 = \ ((_lhsItypeschemeMap) :: M.Map Int (Scheme Predicates)) ->
     _lhsItypeschemeMap
   {-# INLINE rule3230 #-}
   rule3230 = \ ((_guardIuniqueChunk) :: Int) ->
     _guardIuniqueChunk
   {-# INLINE rule3231 #-}
   rule3231 = \ ((_guardIuniqueSecondRound) :: Int) ->
     _guardIuniqueSecondRound
   {-# INLINE rule3232 #-}
   rule3232 = \ ((_lhsIvariableMapping) :: Maybe [(Name, Tp)]) ->
     _lhsIvariableMapping

-- GuardedExpressions ------------------------------------------
-- wrapper
data Inh_GuardedExpressions  = Inh_GuardedExpressions { allPatterns_Inh_GuardedExpressions :: !([((Expression, [String]), Core_TypingStrategy)]), allTypeSchemes_Inh_GuardedExpressions :: !(M.Map NameWithRange TpScheme), ambiguousConflicts_Inh_GuardedExpressions :: !([[Name]]), availablePredicates_Inh_GuardedExpressions :: !([PredicateWithSource]), betaRight_Inh_GuardedExpressions :: !(Tp), betaUnique_Inh_GuardedExpressions :: !(Int), classEnvironment_Inh_GuardedExpressions :: !(ClassEnvironment), classMemberEnv_Inh_GuardedExpressions :: !(ClassMemberEnvironment), classMemberTypeSchemes_Inh_GuardedExpressions :: !(Maybe [(Name, TpScheme)]), classNamesEnv_Inh_GuardedExpressions :: !(ClassNameEnvironment), classPredicate_Inh_GuardedExpressions :: !(Maybe (Name, Names)), classTypeSchemes_Inh_GuardedExpressions :: !(M.Map Name TpScheme), collectErrors_Inh_GuardedExpressions :: !(TypeErrors), collectWarnings_Inh_GuardedExpressions :: !(Warnings), counter_Inh_GuardedExpressions :: !(Int), curClassPred_Inh_GuardedExpressions :: !(Maybe Predicate), curPred_Inh_GuardedExpressions :: !(Maybe Predicate), currentChunk_Inh_GuardedExpressions :: !(Int), dictionaryEnvironment_Inh_GuardedExpressions :: !(DictionaryEnvironment), importEnvironment_Inh_GuardedExpressions :: !(ImportEnvironment), instanceName_Inh_GuardedExpressions :: !(Maybe Name), instanceTypes_Inh_GuardedExpressions :: !([(Name, TpScheme)]), matchIO_Inh_GuardedExpressions :: !(IO ()), moduleName_Inh_GuardedExpressions :: !(Maybe Name), monos_Inh_GuardedExpressions :: !(Monos), namesInScope_Inh_GuardedExpressions :: !(Names), numberOfGuards_Inh_GuardedExpressions :: !(Int), open_Inh_GuardedExpressions :: !(Bool), orderedTypeSynonyms_Inh_GuardedExpressions :: !(OrderedTypeSynonyms), parentTree_Inh_GuardedExpressions :: !(InfoTree), patternMatchWarnings_Inh_GuardedExpressions :: !([Warning]), requiredPredicates_Inh_GuardedExpressions :: !(Predicates), substitution_Inh_GuardedExpressions :: !(FixpointSubstitution), typeConstructors_Inh_GuardedExpressions :: !(TypeConstructorEnvironment), typeschemeMap_Inh_GuardedExpressions :: !(M.Map Int (Scheme Predicates)), uniqueChunk_Inh_GuardedExpressions :: !(Int), uniqueSecondRound_Inh_GuardedExpressions :: !(Int), variableMapping_Inh_GuardedExpressions :: !(Maybe [(Name, Tp)]) }
data Syn_GuardedExpressions  = Syn_GuardedExpressions { assumptions_Syn_GuardedExpressions :: !(Assumptions), betaUnique_Syn_GuardedExpressions :: !(Int), collectErrors_Syn_GuardedExpressions :: !(TypeErrors), collectInstances_Syn_GuardedExpressions :: !([(Name, Instance)]), collectWarnings_Syn_GuardedExpressions :: !(Warnings), constraintslist_Syn_GuardedExpressions :: !(ConstraintSets), counter_Syn_GuardedExpressions :: !(Int), dictionaryEnvironment_Syn_GuardedExpressions :: !(DictionaryEnvironment), fallthrough_Syn_GuardedExpressions :: !(Bool), infoTrees_Syn_GuardedExpressions :: !(InfoTrees), matchIO_Syn_GuardedExpressions :: !(IO ()), patternMatchWarnings_Syn_GuardedExpressions :: !([Warning]), self_Syn_GuardedExpressions :: !(GuardedExpressions), unboundNames_Syn_GuardedExpressions :: !(Names), uniqueChunk_Syn_GuardedExpressions :: !(Int), uniqueSecondRound_Syn_GuardedExpressions :: !(Int) }
{-# INLINABLE wrap_GuardedExpressions #-}
wrap_GuardedExpressions :: T_GuardedExpressions  -> Inh_GuardedExpressions  -> (Syn_GuardedExpressions )
wrap_GuardedExpressions !(T_GuardedExpressions act) !(Inh_GuardedExpressions _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaRight _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsInumberOfGuards _lhsIopen _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeConstructors _lhsItypeschemeMap _lhsIuniqueChunk _lhsIuniqueSecondRound _lhsIvariableMapping) =
   Control.Monad.Identity.runIdentity (
     do !sem <- act
        let arg64 = T_GuardedExpressions_vIn64 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaRight _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsInumberOfGuards _lhsIopen _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeConstructors _lhsItypeschemeMap _lhsIuniqueChunk _lhsIuniqueSecondRound _lhsIvariableMapping
        !(T_GuardedExpressions_vOut64 _lhsOassumptions _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraintslist _lhsOcounter _lhsOdictionaryEnvironment _lhsOfallthrough _lhsOinfoTrees _lhsOmatchIO _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOuniqueSecondRound) <- return (inv_GuardedExpressions_s65 sem arg64)
        return (Syn_GuardedExpressions _lhsOassumptions _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraintslist _lhsOcounter _lhsOdictionaryEnvironment _lhsOfallthrough _lhsOinfoTrees _lhsOmatchIO _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOuniqueSecondRound)
   )

-- cata
{-# NOINLINE sem_GuardedExpressions #-}
sem_GuardedExpressions :: GuardedExpressions  -> T_GuardedExpressions 
sem_GuardedExpressions list = Prelude.foldr sem_GuardedExpressions_Cons sem_GuardedExpressions_Nil (Prelude.map sem_GuardedExpression list)

-- semantic domain
newtype T_GuardedExpressions  = T_GuardedExpressions {
                                                     attach_T_GuardedExpressions :: Identity (T_GuardedExpressions_s65 )
                                                     }
newtype T_GuardedExpressions_s65  = C_GuardedExpressions_s65 {
                                                             inv_GuardedExpressions_s65 :: (T_GuardedExpressions_v64 )
                                                             }
data T_GuardedExpressions_s66  = C_GuardedExpressions_s66
type T_GuardedExpressions_v64  = (T_GuardedExpressions_vIn64 ) -> (T_GuardedExpressions_vOut64 )
data T_GuardedExpressions_vIn64  = T_GuardedExpressions_vIn64 ([((Expression, [String]), Core_TypingStrategy)]) (M.Map NameWithRange TpScheme) ([[Name]]) ([PredicateWithSource]) (Tp) (Int) (ClassEnvironment) (ClassMemberEnvironment) (Maybe [(Name, TpScheme)]) (ClassNameEnvironment) (Maybe (Name, Names)) (M.Map Name TpScheme) (TypeErrors) (Warnings) (Int) (Maybe Predicate) (Maybe Predicate) (Int) (DictionaryEnvironment) (ImportEnvironment) (Maybe Name) ([(Name, TpScheme)]) (IO ()) (Maybe Name) (Monos) (Names) (Int) (Bool) (OrderedTypeSynonyms) (InfoTree) ([Warning]) (Predicates) (FixpointSubstitution) (TypeConstructorEnvironment) (M.Map Int (Scheme Predicates)) (Int) (Int) (Maybe [(Name, Tp)])
data T_GuardedExpressions_vOut64  = T_GuardedExpressions_vOut64 (Assumptions) (Int) (TypeErrors) ([(Name, Instance)]) (Warnings) (ConstraintSets) (Int) (DictionaryEnvironment) (Bool) (InfoTrees) (IO ()) ([Warning]) (GuardedExpressions) (Names) (Int) (Int)
{-# NOINLINE sem_GuardedExpressions_Cons #-}
sem_GuardedExpressions_Cons :: T_GuardedExpression  -> T_GuardedExpressions  -> T_GuardedExpressions 
sem_GuardedExpressions_Cons arg_hd_ arg_tl_ = T_GuardedExpressions (return st65) where
   {-# NOINLINE st65 #-}
   !st65 = let
      v64 :: T_GuardedExpressions_v64 
      v64 = \ !(T_GuardedExpressions_vIn64 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaRight _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsInumberOfGuards _lhsIopen _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeConstructors _lhsItypeschemeMap _lhsIuniqueChunk _lhsIuniqueSecondRound _lhsIvariableMapping) -> ( let
         _hdX62 = Control.Monad.Identity.runIdentity (attach_T_GuardedExpression (arg_hd_))
         _tlX65 = Control.Monad.Identity.runIdentity (attach_T_GuardedExpressions (arg_tl_))
         (T_GuardedExpression_vOut61 _hdIassumptions _hdIbetaUnique _hdIcollectErrors _hdIcollectInstances _hdIcollectWarnings _hdIconstraints _hdIcounter _hdIdictionaryEnvironment _hdIfallthrough _hdIinfoTrees _hdImatchIO _hdIpatternMatchWarnings _hdIrange _hdIself _hdIunboundNames _hdIuniqueChunk _hdIuniqueSecondRound _hdIunrwar) = inv_GuardedExpression_s62 _hdX62 (T_GuardedExpression_vIn61 _hdOallPatterns _hdOallTypeSchemes _hdOambiguousConflicts _hdOavailablePredicates _hdObetaRight _hdObetaUnique _hdOclassEnvironment _hdOclassMemberEnv _hdOclassMemberTypeSchemes _hdOclassNamesEnv _hdOclassPredicate _hdOclassTypeSchemes _hdOcollectErrors _hdOcollectWarnings _hdOcounter _hdOcurClassPred _hdOcurPred _hdOcurrentChunk _hdOdictionaryEnvironment _hdOimportEnvironment _hdOinstanceName _hdOinstanceTypes _hdOmatchIO _hdOmoduleName _hdOmonos _hdOnamesInScope _hdOnumberOfGuards _hdOorderedTypeSynonyms _hdOparentTree _hdOpatternMatchWarnings _hdOrequiredPredicates _hdOsubstitution _hdOtypeConstructors _hdOtypeschemeMap _hdOuniqueChunk _hdOuniqueSecondRound _hdOvariableMapping)
         (T_GuardedExpressions_vOut64 _tlIassumptions _tlIbetaUnique _tlIcollectErrors _tlIcollectInstances _tlIcollectWarnings _tlIconstraintslist _tlIcounter _tlIdictionaryEnvironment _tlIfallthrough _tlIinfoTrees _tlImatchIO _tlIpatternMatchWarnings _tlIself _tlIunboundNames _tlIuniqueChunk _tlIuniqueSecondRound) = inv_GuardedExpressions_s65 _tlX65 (T_GuardedExpressions_vIn64 _tlOallPatterns _tlOallTypeSchemes _tlOambiguousConflicts _tlOavailablePredicates _tlObetaRight _tlObetaUnique _tlOclassEnvironment _tlOclassMemberEnv _tlOclassMemberTypeSchemes _tlOclassNamesEnv _tlOclassPredicate _tlOclassTypeSchemes _tlOcollectErrors _tlOcollectWarnings _tlOcounter _tlOcurClassPred _tlOcurPred _tlOcurrentChunk _tlOdictionaryEnvironment _tlOimportEnvironment _tlOinstanceName _tlOinstanceTypes _tlOmatchIO _tlOmoduleName _tlOmonos _tlOnamesInScope _tlOnumberOfGuards _tlOopen _tlOorderedTypeSynonyms _tlOparentTree _tlOpatternMatchWarnings _tlOrequiredPredicates _tlOsubstitution _tlOtypeConstructors _tlOtypeschemeMap _tlOuniqueChunk _tlOuniqueSecondRound _tlOvariableMapping)
         _lhsOfallthrough :: Bool
         _lhsOfallthrough = rule3233 _hdIfallthrough _tlIfallthrough
         _tlOopen = rule3234 _hdIfallthrough _lhsIopen
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule3235 _hdIunrwar _lhsIopen _tlIpatternMatchWarnings
         _lhsOinfoTrees :: InfoTrees
         _lhsOinfoTrees = rule3236 _hdIinfoTrees _tlIinfoTrees
         _lhsOassumptions :: Assumptions
         _lhsOassumptions = rule3237 _hdIassumptions _tlIassumptions
         _lhsOconstraintslist :: ConstraintSets
         _lhsOconstraintslist = rule3238 _hdIconstraints _tlIconstraintslist
         _lhsOcollectInstances :: [(Name, Instance)]
         _lhsOcollectInstances = rule3239 _hdIcollectInstances _tlIcollectInstances
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule3240 _hdIunboundNames _tlIunboundNames
         _self = rule3241 _hdIself _tlIself
         _lhsOself :: GuardedExpressions
         _lhsOself = rule3242 _self
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule3243 _tlIbetaUnique
         _lhsOcollectErrors :: TypeErrors
         _lhsOcollectErrors = rule3244 _tlIcollectErrors
         _lhsOcollectWarnings :: Warnings
         _lhsOcollectWarnings = rule3245 _tlIcollectWarnings
         _lhsOcounter :: Int
         _lhsOcounter = rule3246 _tlIcounter
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule3247 _tlIdictionaryEnvironment
         _lhsOmatchIO :: IO ()
         _lhsOmatchIO = rule3248 _tlImatchIO
         _lhsOuniqueChunk :: Int
         _lhsOuniqueChunk = rule3249 _tlIuniqueChunk
         _lhsOuniqueSecondRound :: Int
         _lhsOuniqueSecondRound = rule3250 _tlIuniqueSecondRound
         _hdOallPatterns = rule3251 _lhsIallPatterns
         _hdOallTypeSchemes = rule3252 _lhsIallTypeSchemes
         _hdOambiguousConflicts = rule3253 _lhsIambiguousConflicts
         _hdOavailablePredicates = rule3254 _lhsIavailablePredicates
         _hdObetaRight = rule3255 _lhsIbetaRight
         _hdObetaUnique = rule3256 _lhsIbetaUnique
         _hdOclassEnvironment = rule3257 _lhsIclassEnvironment
         _hdOclassMemberEnv = rule3258 _lhsIclassMemberEnv
         _hdOclassMemberTypeSchemes = rule3259 _lhsIclassMemberTypeSchemes
         _hdOclassNamesEnv = rule3260 _lhsIclassNamesEnv
         _hdOclassPredicate = rule3261 _lhsIclassPredicate
         _hdOclassTypeSchemes = rule3262 _lhsIclassTypeSchemes
         _hdOcollectErrors = rule3263 _lhsIcollectErrors
         _hdOcollectWarnings = rule3264 _lhsIcollectWarnings
         _hdOcounter = rule3265 _lhsIcounter
         _hdOcurClassPred = rule3266 _lhsIcurClassPred
         _hdOcurPred = rule3267 _lhsIcurPred
         _hdOcurrentChunk = rule3268 _lhsIcurrentChunk
         _hdOdictionaryEnvironment = rule3269 _lhsIdictionaryEnvironment
         _hdOimportEnvironment = rule3270 _lhsIimportEnvironment
         _hdOinstanceName = rule3271 _lhsIinstanceName
         _hdOinstanceTypes = rule3272 _lhsIinstanceTypes
         _hdOmatchIO = rule3273 _lhsImatchIO
         _hdOmoduleName = rule3274 _lhsImoduleName
         _hdOmonos = rule3275 _lhsImonos
         _hdOnamesInScope = rule3276 _lhsInamesInScope
         _hdOnumberOfGuards = rule3277 _lhsInumberOfGuards
         _hdOorderedTypeSynonyms = rule3278 _lhsIorderedTypeSynonyms
         _hdOparentTree = rule3279 _lhsIparentTree
         _hdOpatternMatchWarnings = rule3280 _lhsIpatternMatchWarnings
         _hdOrequiredPredicates = rule3281 _lhsIrequiredPredicates
         _hdOsubstitution = rule3282 _lhsIsubstitution
         _hdOtypeConstructors = rule3283 _lhsItypeConstructors
         _hdOtypeschemeMap = rule3284 _lhsItypeschemeMap
         _hdOuniqueChunk = rule3285 _lhsIuniqueChunk
         _hdOuniqueSecondRound = rule3286 _lhsIuniqueSecondRound
         _hdOvariableMapping = rule3287 _lhsIvariableMapping
         _tlOallPatterns = rule3288 _lhsIallPatterns
         _tlOallTypeSchemes = rule3289 _lhsIallTypeSchemes
         _tlOambiguousConflicts = rule3290 _lhsIambiguousConflicts
         _tlOavailablePredicates = rule3291 _lhsIavailablePredicates
         _tlObetaRight = rule3292 _lhsIbetaRight
         _tlObetaUnique = rule3293 _hdIbetaUnique
         _tlOclassEnvironment = rule3294 _lhsIclassEnvironment
         _tlOclassMemberEnv = rule3295 _lhsIclassMemberEnv
         _tlOclassMemberTypeSchemes = rule3296 _lhsIclassMemberTypeSchemes
         _tlOclassNamesEnv = rule3297 _lhsIclassNamesEnv
         _tlOclassPredicate = rule3298 _lhsIclassPredicate
         _tlOclassTypeSchemes = rule3299 _lhsIclassTypeSchemes
         _tlOcollectErrors = rule3300 _hdIcollectErrors
         _tlOcollectWarnings = rule3301 _hdIcollectWarnings
         _tlOcounter = rule3302 _hdIcounter
         _tlOcurClassPred = rule3303 _lhsIcurClassPred
         _tlOcurPred = rule3304 _lhsIcurPred
         _tlOcurrentChunk = rule3305 _lhsIcurrentChunk
         _tlOdictionaryEnvironment = rule3306 _hdIdictionaryEnvironment
         _tlOimportEnvironment = rule3307 _lhsIimportEnvironment
         _tlOinstanceName = rule3308 _lhsIinstanceName
         _tlOinstanceTypes = rule3309 _lhsIinstanceTypes
         _tlOmatchIO = rule3310 _hdImatchIO
         _tlOmoduleName = rule3311 _lhsImoduleName
         _tlOmonos = rule3312 _lhsImonos
         _tlOnamesInScope = rule3313 _lhsInamesInScope
         _tlOnumberOfGuards = rule3314 _lhsInumberOfGuards
         _tlOorderedTypeSynonyms = rule3315 _lhsIorderedTypeSynonyms
         _tlOparentTree = rule3316 _lhsIparentTree
         _tlOpatternMatchWarnings = rule3317 _hdIpatternMatchWarnings
         _tlOrequiredPredicates = rule3318 _lhsIrequiredPredicates
         _tlOsubstitution = rule3319 _lhsIsubstitution
         _tlOtypeConstructors = rule3320 _lhsItypeConstructors
         _tlOtypeschemeMap = rule3321 _lhsItypeschemeMap
         _tlOuniqueChunk = rule3322 _hdIuniqueChunk
         _tlOuniqueSecondRound = rule3323 _hdIuniqueSecondRound
         _tlOvariableMapping = rule3324 _lhsIvariableMapping
         !__result_ = T_GuardedExpressions_vOut64 _lhsOassumptions _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraintslist _lhsOcounter _lhsOdictionaryEnvironment _lhsOfallthrough _lhsOinfoTrees _lhsOmatchIO _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOuniqueSecondRound
         in __result_ )
     in C_GuardedExpressions_s65 v64
   {-# INLINE rule3233 #-}
   rule3233 = \ ((_hdIfallthrough) :: Bool) ((_tlIfallthrough) :: Bool) ->
                                            _hdIfallthrough && _tlIfallthrough
   {-# INLINE rule3234 #-}
   rule3234 = \ ((_hdIfallthrough) :: Bool) ((_lhsIopen) :: Bool) ->
                                            _hdIfallthrough && _lhsIopen
   {-# INLINE rule3235 #-}
   rule3235 = \ ((_hdIunrwar) :: Warning) ((_lhsIopen) :: Bool) ((_tlIpatternMatchWarnings) :: [Warning]) ->
                                                     (if not _lhsIopen then [_hdIunrwar] else [])
                                                     ++ _tlIpatternMatchWarnings
   {-# INLINE rule3236 #-}
   rule3236 = \ ((_hdIinfoTrees) :: InfoTrees) ((_tlIinfoTrees) :: InfoTrees) ->
                                _hdIinfoTrees ++ _tlIinfoTrees
   {-# INLINE rule3237 #-}
   rule3237 = \ ((_hdIassumptions) :: Assumptions) ((_tlIassumptions) :: Assumptions) ->
                                _hdIassumptions `combine` _tlIassumptions
   {-# INLINE rule3238 #-}
   rule3238 = \ ((_hdIconstraints) :: ConstraintSet) ((_tlIconstraintslist) :: ConstraintSets) ->
                                _hdIconstraints : _tlIconstraintslist
   {-# INLINE rule3239 #-}
   rule3239 = \ ((_hdIcollectInstances) :: [(Name, Instance)]) ((_tlIcollectInstances) :: [(Name, Instance)]) ->
     _hdIcollectInstances  ++  _tlIcollectInstances
   {-# INLINE rule3240 #-}
   rule3240 = \ ((_hdIunboundNames) :: Names) ((_tlIunboundNames) :: Names) ->
     ((++) _hdIunboundNames _tlIunboundNames)
   {-# INLINE rule3241 #-}
   rule3241 = \ ((_hdIself) :: GuardedExpression) ((_tlIself) :: GuardedExpressions) ->
     (:) _hdIself _tlIself
   {-# INLINE rule3242 #-}
   rule3242 = \ _self ->
     _self
   {-# INLINE rule3243 #-}
   rule3243 = \ ((_tlIbetaUnique) :: Int) ->
     _tlIbetaUnique
   {-# INLINE rule3244 #-}
   rule3244 = \ ((_tlIcollectErrors) :: TypeErrors) ->
     _tlIcollectErrors
   {-# INLINE rule3245 #-}
   rule3245 = \ ((_tlIcollectWarnings) :: Warnings) ->
     _tlIcollectWarnings
   {-# INLINE rule3246 #-}
   rule3246 = \ ((_tlIcounter) :: Int) ->
     _tlIcounter
   {-# INLINE rule3247 #-}
   rule3247 = \ ((_tlIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _tlIdictionaryEnvironment
   {-# INLINE rule3248 #-}
   rule3248 = \ ((_tlImatchIO) :: IO ()) ->
     _tlImatchIO
   {-# INLINE rule3249 #-}
   rule3249 = \ ((_tlIuniqueChunk) :: Int) ->
     _tlIuniqueChunk
   {-# INLINE rule3250 #-}
   rule3250 = \ ((_tlIuniqueSecondRound) :: Int) ->
     _tlIuniqueSecondRound
   {-# INLINE rule3251 #-}
   rule3251 = \ ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ->
     _lhsIallPatterns
   {-# INLINE rule3252 #-}
   rule3252 = \ ((_lhsIallTypeSchemes) :: M.Map NameWithRange TpScheme) ->
     _lhsIallTypeSchemes
   {-# INLINE rule3253 #-}
   rule3253 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule3254 #-}
   rule3254 = \ ((_lhsIavailablePredicates) :: [PredicateWithSource]) ->
     _lhsIavailablePredicates
   {-# INLINE rule3255 #-}
   rule3255 = \ ((_lhsIbetaRight) :: Tp) ->
     _lhsIbetaRight
   {-# INLINE rule3256 #-}
   rule3256 = \ ((_lhsIbetaUnique) :: Int) ->
     _lhsIbetaUnique
   {-# INLINE rule3257 #-}
   rule3257 = \ ((_lhsIclassEnvironment) :: ClassEnvironment) ->
     _lhsIclassEnvironment
   {-# INLINE rule3258 #-}
   rule3258 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule3259 #-}
   rule3259 = \ ((_lhsIclassMemberTypeSchemes) :: Maybe [(Name, TpScheme)]) ->
     _lhsIclassMemberTypeSchemes
   {-# INLINE rule3260 #-}
   rule3260 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule3261 #-}
   rule3261 = \ ((_lhsIclassPredicate) :: Maybe (Name, Names)) ->
     _lhsIclassPredicate
   {-# INLINE rule3262 #-}
   rule3262 = \ ((_lhsIclassTypeSchemes) :: M.Map Name TpScheme) ->
     _lhsIclassTypeSchemes
   {-# INLINE rule3263 #-}
   rule3263 = \ ((_lhsIcollectErrors) :: TypeErrors) ->
     _lhsIcollectErrors
   {-# INLINE rule3264 #-}
   rule3264 = \ ((_lhsIcollectWarnings) :: Warnings) ->
     _lhsIcollectWarnings
   {-# INLINE rule3265 #-}
   rule3265 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule3266 #-}
   rule3266 = \ ((_lhsIcurClassPred) :: Maybe Predicate) ->
     _lhsIcurClassPred
   {-# INLINE rule3267 #-}
   rule3267 = \ ((_lhsIcurPred) :: Maybe Predicate) ->
     _lhsIcurPred
   {-# INLINE rule3268 #-}
   rule3268 = \ ((_lhsIcurrentChunk) :: Int) ->
     _lhsIcurrentChunk
   {-# INLINE rule3269 #-}
   rule3269 = \ ((_lhsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _lhsIdictionaryEnvironment
   {-# INLINE rule3270 #-}
   rule3270 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule3271 #-}
   rule3271 = \ ((_lhsIinstanceName) :: Maybe Name) ->
     _lhsIinstanceName
   {-# INLINE rule3272 #-}
   rule3272 = \ ((_lhsIinstanceTypes) :: [(Name, TpScheme)]) ->
     _lhsIinstanceTypes
   {-# INLINE rule3273 #-}
   rule3273 = \ ((_lhsImatchIO) :: IO ()) ->
     _lhsImatchIO
   {-# INLINE rule3274 #-}
   rule3274 = \ ((_lhsImoduleName) :: Maybe Name) ->
     _lhsImoduleName
   {-# INLINE rule3275 #-}
   rule3275 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule3276 #-}
   rule3276 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule3277 #-}
   rule3277 = \ ((_lhsInumberOfGuards) :: Int) ->
     _lhsInumberOfGuards
   {-# INLINE rule3278 #-}
   rule3278 = \ ((_lhsIorderedTypeSynonyms) :: OrderedTypeSynonyms) ->
     _lhsIorderedTypeSynonyms
   {-# INLINE rule3279 #-}
   rule3279 = \ ((_lhsIparentTree) :: InfoTree) ->
     _lhsIparentTree
   {-# INLINE rule3280 #-}
   rule3280 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule3281 #-}
   rule3281 = \ ((_lhsIrequiredPredicates) :: Predicates) ->
     _lhsIrequiredPredicates
   {-# INLINE rule3282 #-}
   rule3282 = \ ((_lhsIsubstitution) :: FixpointSubstitution) ->
     _lhsIsubstitution
   {-# INLINE rule3283 #-}
   rule3283 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
   {-# INLINE rule3284 #-}
   rule3284 = \ ((_lhsItypeschemeMap) :: M.Map Int (Scheme Predicates)) ->
     _lhsItypeschemeMap
   {-# INLINE rule3285 #-}
   rule3285 = \ ((_lhsIuniqueChunk) :: Int) ->
     _lhsIuniqueChunk
   {-# INLINE rule3286 #-}
   rule3286 = \ ((_lhsIuniqueSecondRound) :: Int) ->
     _lhsIuniqueSecondRound
   {-# INLINE rule3287 #-}
   rule3287 = \ ((_lhsIvariableMapping) :: Maybe [(Name, Tp)]) ->
     _lhsIvariableMapping
   {-# INLINE rule3288 #-}
   rule3288 = \ ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ->
     _lhsIallPatterns
   {-# INLINE rule3289 #-}
   rule3289 = \ ((_lhsIallTypeSchemes) :: M.Map NameWithRange TpScheme) ->
     _lhsIallTypeSchemes
   {-# INLINE rule3290 #-}
   rule3290 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule3291 #-}
   rule3291 = \ ((_lhsIavailablePredicates) :: [PredicateWithSource]) ->
     _lhsIavailablePredicates
   {-# INLINE rule3292 #-}
   rule3292 = \ ((_lhsIbetaRight) :: Tp) ->
     _lhsIbetaRight
   {-# INLINE rule3293 #-}
   rule3293 = \ ((_hdIbetaUnique) :: Int) ->
     _hdIbetaUnique
   {-# INLINE rule3294 #-}
   rule3294 = \ ((_lhsIclassEnvironment) :: ClassEnvironment) ->
     _lhsIclassEnvironment
   {-# INLINE rule3295 #-}
   rule3295 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule3296 #-}
   rule3296 = \ ((_lhsIclassMemberTypeSchemes) :: Maybe [(Name, TpScheme)]) ->
     _lhsIclassMemberTypeSchemes
   {-# INLINE rule3297 #-}
   rule3297 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule3298 #-}
   rule3298 = \ ((_lhsIclassPredicate) :: Maybe (Name, Names)) ->
     _lhsIclassPredicate
   {-# INLINE rule3299 #-}
   rule3299 = \ ((_lhsIclassTypeSchemes) :: M.Map Name TpScheme) ->
     _lhsIclassTypeSchemes
   {-# INLINE rule3300 #-}
   rule3300 = \ ((_hdIcollectErrors) :: TypeErrors) ->
     _hdIcollectErrors
   {-# INLINE rule3301 #-}
   rule3301 = \ ((_hdIcollectWarnings) :: Warnings) ->
     _hdIcollectWarnings
   {-# INLINE rule3302 #-}
   rule3302 = \ ((_hdIcounter) :: Int) ->
     _hdIcounter
   {-# INLINE rule3303 #-}
   rule3303 = \ ((_lhsIcurClassPred) :: Maybe Predicate) ->
     _lhsIcurClassPred
   {-# INLINE rule3304 #-}
   rule3304 = \ ((_lhsIcurPred) :: Maybe Predicate) ->
     _lhsIcurPred
   {-# INLINE rule3305 #-}
   rule3305 = \ ((_lhsIcurrentChunk) :: Int) ->
     _lhsIcurrentChunk
   {-# INLINE rule3306 #-}
   rule3306 = \ ((_hdIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _hdIdictionaryEnvironment
   {-# INLINE rule3307 #-}
   rule3307 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule3308 #-}
   rule3308 = \ ((_lhsIinstanceName) :: Maybe Name) ->
     _lhsIinstanceName
   {-# INLINE rule3309 #-}
   rule3309 = \ ((_lhsIinstanceTypes) :: [(Name, TpScheme)]) ->
     _lhsIinstanceTypes
   {-# INLINE rule3310 #-}
   rule3310 = \ ((_hdImatchIO) :: IO ()) ->
     _hdImatchIO
   {-# INLINE rule3311 #-}
   rule3311 = \ ((_lhsImoduleName) :: Maybe Name) ->
     _lhsImoduleName
   {-# INLINE rule3312 #-}
   rule3312 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule3313 #-}
   rule3313 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule3314 #-}
   rule3314 = \ ((_lhsInumberOfGuards) :: Int) ->
     _lhsInumberOfGuards
   {-# INLINE rule3315 #-}
   rule3315 = \ ((_lhsIorderedTypeSynonyms) :: OrderedTypeSynonyms) ->
     _lhsIorderedTypeSynonyms
   {-# INLINE rule3316 #-}
   rule3316 = \ ((_lhsIparentTree) :: InfoTree) ->
     _lhsIparentTree
   {-# INLINE rule3317 #-}
   rule3317 = \ ((_hdIpatternMatchWarnings) :: [Warning]) ->
     _hdIpatternMatchWarnings
   {-# INLINE rule3318 #-}
   rule3318 = \ ((_lhsIrequiredPredicates) :: Predicates) ->
     _lhsIrequiredPredicates
   {-# INLINE rule3319 #-}
   rule3319 = \ ((_lhsIsubstitution) :: FixpointSubstitution) ->
     _lhsIsubstitution
   {-# INLINE rule3320 #-}
   rule3320 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
   {-# INLINE rule3321 #-}
   rule3321 = \ ((_lhsItypeschemeMap) :: M.Map Int (Scheme Predicates)) ->
     _lhsItypeschemeMap
   {-# INLINE rule3322 #-}
   rule3322 = \ ((_hdIuniqueChunk) :: Int) ->
     _hdIuniqueChunk
   {-# INLINE rule3323 #-}
   rule3323 = \ ((_hdIuniqueSecondRound) :: Int) ->
     _hdIuniqueSecondRound
   {-# INLINE rule3324 #-}
   rule3324 = \ ((_lhsIvariableMapping) :: Maybe [(Name, Tp)]) ->
     _lhsIvariableMapping
{-# NOINLINE sem_GuardedExpressions_Nil #-}
sem_GuardedExpressions_Nil ::  T_GuardedExpressions 
sem_GuardedExpressions_Nil  = T_GuardedExpressions (return st65) where
   {-# NOINLINE st65 #-}
   !st65 = let
      v64 :: T_GuardedExpressions_v64 
      v64 = \ !(T_GuardedExpressions_vIn64 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaRight _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsInumberOfGuards _lhsIopen _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeConstructors _lhsItypeschemeMap _lhsIuniqueChunk _lhsIuniqueSecondRound _lhsIvariableMapping) -> ( let
         _lhsOfallthrough :: Bool
         _lhsOfallthrough = rule3325  ()
         _lhsOinfoTrees :: InfoTrees
         _lhsOinfoTrees = rule3326  ()
         _lhsOassumptions :: Assumptions
         _lhsOassumptions = rule3327  ()
         _lhsOconstraintslist :: ConstraintSets
         _lhsOconstraintslist = rule3328  ()
         _lhsOcollectInstances :: [(Name, Instance)]
         _lhsOcollectInstances = rule3329  ()
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule3330  ()
         _self = rule3331  ()
         _lhsOself :: GuardedExpressions
         _lhsOself = rule3332 _self
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule3333 _lhsIbetaUnique
         _lhsOcollectErrors :: TypeErrors
         _lhsOcollectErrors = rule3334 _lhsIcollectErrors
         _lhsOcollectWarnings :: Warnings
         _lhsOcollectWarnings = rule3335 _lhsIcollectWarnings
         _lhsOcounter :: Int
         _lhsOcounter = rule3336 _lhsIcounter
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule3337 _lhsIdictionaryEnvironment
         _lhsOmatchIO :: IO ()
         _lhsOmatchIO = rule3338 _lhsImatchIO
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule3339 _lhsIpatternMatchWarnings
         _lhsOuniqueChunk :: Int
         _lhsOuniqueChunk = rule3340 _lhsIuniqueChunk
         _lhsOuniqueSecondRound :: Int
         _lhsOuniqueSecondRound = rule3341 _lhsIuniqueSecondRound
         !__result_ = T_GuardedExpressions_vOut64 _lhsOassumptions _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraintslist _lhsOcounter _lhsOdictionaryEnvironment _lhsOfallthrough _lhsOinfoTrees _lhsOmatchIO _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOuniqueSecondRound
         in __result_ )
     in C_GuardedExpressions_s65 v64
   {-# INLINE rule3325 #-}
   rule3325 = \  (_ :: ()) ->
                                            True
   {-# INLINE rule3326 #-}
   rule3326 = \  (_ :: ()) ->
                                []
   {-# INLINE rule3327 #-}
   rule3327 = \  (_ :: ()) ->
                                noAssumptions
   {-# INLINE rule3328 #-}
   rule3328 = \  (_ :: ()) ->
                                []
   {-# INLINE rule3329 #-}
   rule3329 = \  (_ :: ()) ->
     []
   {-# INLINE rule3330 #-}
   rule3330 = \  (_ :: ()) ->
     []
   {-# INLINE rule3331 #-}
   rule3331 = \  (_ :: ()) ->
     []
   {-# INLINE rule3332 #-}
   rule3332 = \ _self ->
     _self
   {-# INLINE rule3333 #-}
   rule3333 = \ ((_lhsIbetaUnique) :: Int) ->
     _lhsIbetaUnique
   {-# INLINE rule3334 #-}
   rule3334 = \ ((_lhsIcollectErrors) :: TypeErrors) ->
     _lhsIcollectErrors
   {-# INLINE rule3335 #-}
   rule3335 = \ ((_lhsIcollectWarnings) :: Warnings) ->
     _lhsIcollectWarnings
   {-# INLINE rule3336 #-}
   rule3336 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule3337 #-}
   rule3337 = \ ((_lhsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _lhsIdictionaryEnvironment
   {-# INLINE rule3338 #-}
   rule3338 = \ ((_lhsImatchIO) :: IO ()) ->
     _lhsImatchIO
   {-# INLINE rule3339 #-}
   rule3339 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule3340 #-}
   rule3340 = \ ((_lhsIuniqueChunk) :: Int) ->
     _lhsIuniqueChunk
   {-# INLINE rule3341 #-}
   rule3341 = \ ((_lhsIuniqueSecondRound) :: Int) ->
     _lhsIuniqueSecondRound

-- Import ------------------------------------------------------
-- wrapper
data Inh_Import  = Inh_Import {  }
data Syn_Import  = Syn_Import { self_Syn_Import :: !(Import) }
{-# INLINABLE wrap_Import #-}
wrap_Import :: T_Import  -> Inh_Import  -> (Syn_Import )
wrap_Import !(T_Import act) !(Inh_Import ) =
   Control.Monad.Identity.runIdentity (
     do !sem <- act
        let arg67 = T_Import_vIn67 
        !(T_Import_vOut67 _lhsOself) <- return (inv_Import_s68 sem arg67)
        return (Syn_Import _lhsOself)
   )

-- cata
{-# NOINLINE sem_Import #-}
sem_Import :: Import  -> T_Import 
sem_Import ( Import_Variable range_ name_ ) = sem_Import_Variable ( sem_Range range_ ) ( sem_Name name_ )
sem_Import ( Import_TypeOrClass range_ name_ names_ ) = sem_Import_TypeOrClass ( sem_Range range_ ) ( sem_Name name_ ) ( sem_MaybeNames names_ )
sem_Import ( Import_TypeOrClassComplete range_ name_ ) = sem_Import_TypeOrClassComplete ( sem_Range range_ ) ( sem_Name name_ )

-- semantic domain
newtype T_Import  = T_Import {
                             attach_T_Import :: Identity (T_Import_s68 )
                             }
newtype T_Import_s68  = C_Import_s68 {
                                     inv_Import_s68 :: (T_Import_v67 )
                                     }
data T_Import_s69  = C_Import_s69
type T_Import_v67  = (T_Import_vIn67 ) -> (T_Import_vOut67 )
data T_Import_vIn67  = T_Import_vIn67 
data T_Import_vOut67  = T_Import_vOut67 (Import)
{-# NOINLINE sem_Import_Variable #-}
sem_Import_Variable :: T_Range  -> T_Name  -> T_Import 
sem_Import_Variable arg_range_ arg_name_ = T_Import (return st68) where
   {-# NOINLINE st68 #-}
   !st68 = let
      v67 :: T_Import_v67 
      v67 = \ !(T_Import_vIn67 ) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _nameX113 = Control.Monad.Identity.runIdentity (attach_T_Name (arg_name_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_Name_vOut112 _nameIself) = inv_Name_s113 _nameX113 (T_Name_vIn112 )
         _self = rule3342 _nameIself _rangeIself
         _lhsOself :: Import
         _lhsOself = rule3343 _self
         !__result_ = T_Import_vOut67 _lhsOself
         in __result_ )
     in C_Import_s68 v67
   {-# INLINE rule3342 #-}
   rule3342 = \ ((_nameIself) :: Name) ((_rangeIself) :: Range) ->
     Import_Variable _rangeIself _nameIself
   {-# INLINE rule3343 #-}
   rule3343 = \ _self ->
     _self
{-# NOINLINE sem_Import_TypeOrClass #-}
sem_Import_TypeOrClass :: T_Range  -> T_Name  -> T_MaybeNames  -> T_Import 
sem_Import_TypeOrClass arg_range_ arg_name_ arg_names_ = T_Import (return st68) where
   {-# NOINLINE st68 #-}
   !st68 = let
      v67 :: T_Import_v67 
      v67 = \ !(T_Import_vIn67 ) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _nameX113 = Control.Monad.Identity.runIdentity (attach_T_Name (arg_name_))
         _namesX107 = Control.Monad.Identity.runIdentity (attach_T_MaybeNames (arg_names_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_Name_vOut112 _nameIself) = inv_Name_s113 _nameX113 (T_Name_vIn112 )
         (T_MaybeNames_vOut106 _namesIself) = inv_MaybeNames_s107 _namesX107 (T_MaybeNames_vIn106 )
         _self = rule3344 _nameIself _namesIself _rangeIself
         _lhsOself :: Import
         _lhsOself = rule3345 _self
         !__result_ = T_Import_vOut67 _lhsOself
         in __result_ )
     in C_Import_s68 v67
   {-# INLINE rule3344 #-}
   rule3344 = \ ((_nameIself) :: Name) ((_namesIself) :: MaybeNames) ((_rangeIself) :: Range) ->
     Import_TypeOrClass _rangeIself _nameIself _namesIself
   {-# INLINE rule3345 #-}
   rule3345 = \ _self ->
     _self
{-# NOINLINE sem_Import_TypeOrClassComplete #-}
sem_Import_TypeOrClassComplete :: T_Range  -> T_Name  -> T_Import 
sem_Import_TypeOrClassComplete arg_range_ arg_name_ = T_Import (return st68) where
   {-# NOINLINE st68 #-}
   !st68 = let
      v67 :: T_Import_v67 
      v67 = \ !(T_Import_vIn67 ) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _nameX113 = Control.Monad.Identity.runIdentity (attach_T_Name (arg_name_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_Name_vOut112 _nameIself) = inv_Name_s113 _nameX113 (T_Name_vIn112 )
         _self = rule3346 _nameIself _rangeIself
         _lhsOself :: Import
         _lhsOself = rule3347 _self
         !__result_ = T_Import_vOut67 _lhsOself
         in __result_ )
     in C_Import_s68 v67
   {-# INLINE rule3346 #-}
   rule3346 = \ ((_nameIself) :: Name) ((_rangeIself) :: Range) ->
     Import_TypeOrClassComplete _rangeIself _nameIself
   {-# INLINE rule3347 #-}
   rule3347 = \ _self ->
     _self

-- ImportDeclaration -------------------------------------------
-- wrapper
data Inh_ImportDeclaration  = Inh_ImportDeclaration {  }
data Syn_ImportDeclaration  = Syn_ImportDeclaration { self_Syn_ImportDeclaration :: !(ImportDeclaration) }
{-# INLINABLE wrap_ImportDeclaration #-}
wrap_ImportDeclaration :: T_ImportDeclaration  -> Inh_ImportDeclaration  -> (Syn_ImportDeclaration )
wrap_ImportDeclaration !(T_ImportDeclaration act) !(Inh_ImportDeclaration ) =
   Control.Monad.Identity.runIdentity (
     do !sem <- act
        let arg70 = T_ImportDeclaration_vIn70 
        !(T_ImportDeclaration_vOut70 _lhsOself) <- return (inv_ImportDeclaration_s71 sem arg70)
        return (Syn_ImportDeclaration _lhsOself)
   )

-- cata
{-# NOINLINE sem_ImportDeclaration #-}
sem_ImportDeclaration :: ImportDeclaration  -> T_ImportDeclaration 
sem_ImportDeclaration ( ImportDeclaration_Import range_ !qualified_ name_ asname_ importspecification_ ) = sem_ImportDeclaration_Import ( sem_Range range_ ) qualified_ ( sem_Name name_ ) ( sem_MaybeName asname_ ) ( sem_MaybeImportSpecification importspecification_ )
sem_ImportDeclaration ( ImportDeclaration_Empty range_ ) = sem_ImportDeclaration_Empty ( sem_Range range_ )

-- semantic domain
newtype T_ImportDeclaration  = T_ImportDeclaration {
                                                   attach_T_ImportDeclaration :: Identity (T_ImportDeclaration_s71 )
                                                   }
newtype T_ImportDeclaration_s71  = C_ImportDeclaration_s71 {
                                                           inv_ImportDeclaration_s71 :: (T_ImportDeclaration_v70 )
                                                           }
data T_ImportDeclaration_s72  = C_ImportDeclaration_s72
type T_ImportDeclaration_v70  = (T_ImportDeclaration_vIn70 ) -> (T_ImportDeclaration_vOut70 )
data T_ImportDeclaration_vIn70  = T_ImportDeclaration_vIn70 
data T_ImportDeclaration_vOut70  = T_ImportDeclaration_vOut70 (ImportDeclaration)
{-# NOINLINE sem_ImportDeclaration_Import #-}
sem_ImportDeclaration_Import :: T_Range  -> (Bool) -> T_Name  -> T_MaybeName  -> T_MaybeImportSpecification  -> T_ImportDeclaration 
sem_ImportDeclaration_Import arg_range_ !arg_qualified_ arg_name_ arg_asname_ arg_importspecification_ = T_ImportDeclaration (return st71) where
   {-# NOINLINE st71 #-}
   !st71 = let
      v70 :: T_ImportDeclaration_v70 
      v70 = \ !(T_ImportDeclaration_vIn70 ) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _nameX113 = Control.Monad.Identity.runIdentity (attach_T_Name (arg_name_))
         _asnameX104 = Control.Monad.Identity.runIdentity (attach_T_MaybeName (arg_asname_))
         _importspecificationX98 = Control.Monad.Identity.runIdentity (attach_T_MaybeImportSpecification (arg_importspecification_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_Name_vOut112 _nameIself) = inv_Name_s113 _nameX113 (T_Name_vIn112 )
         (T_MaybeName_vOut103 _asnameIisNothing _asnameIname _asnameIself) = inv_MaybeName_s104 _asnameX104 (T_MaybeName_vIn103 )
         (T_MaybeImportSpecification_vOut97 _importspecificationIself) = inv_MaybeImportSpecification_s98 _importspecificationX98 (T_MaybeImportSpecification_vIn97 )
         _self = rule3348 _asnameIself _importspecificationIself _nameIself _rangeIself arg_qualified_
         _lhsOself :: ImportDeclaration
         _lhsOself = rule3349 _self
         !__result_ = T_ImportDeclaration_vOut70 _lhsOself
         in __result_ )
     in C_ImportDeclaration_s71 v70
   {-# INLINE rule3348 #-}
   rule3348 = \ ((_asnameIself) :: MaybeName) ((_importspecificationIself) :: MaybeImportSpecification) ((_nameIself) :: Name) ((_rangeIself) :: Range) qualified_ ->
     ImportDeclaration_Import _rangeIself qualified_ _nameIself _asnameIself _importspecificationIself
   {-# INLINE rule3349 #-}
   rule3349 = \ _self ->
     _self
{-# NOINLINE sem_ImportDeclaration_Empty #-}
sem_ImportDeclaration_Empty :: T_Range  -> T_ImportDeclaration 
sem_ImportDeclaration_Empty arg_range_ = T_ImportDeclaration (return st71) where
   {-# NOINLINE st71 #-}
   !st71 = let
      v70 :: T_ImportDeclaration_v70 
      v70 = \ !(T_ImportDeclaration_vIn70 ) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         _self = rule3350 _rangeIself
         _lhsOself :: ImportDeclaration
         _lhsOself = rule3351 _self
         !__result_ = T_ImportDeclaration_vOut70 _lhsOself
         in __result_ )
     in C_ImportDeclaration_s71 v70
   {-# INLINE rule3350 #-}
   rule3350 = \ ((_rangeIself) :: Range) ->
     ImportDeclaration_Empty _rangeIself
   {-# INLINE rule3351 #-}
   rule3351 = \ _self ->
     _self

-- ImportDeclarations ------------------------------------------
-- wrapper
data Inh_ImportDeclarations  = Inh_ImportDeclarations {  }
data Syn_ImportDeclarations  = Syn_ImportDeclarations { self_Syn_ImportDeclarations :: !(ImportDeclarations) }
{-# INLINABLE wrap_ImportDeclarations #-}
wrap_ImportDeclarations :: T_ImportDeclarations  -> Inh_ImportDeclarations  -> (Syn_ImportDeclarations )
wrap_ImportDeclarations !(T_ImportDeclarations act) !(Inh_ImportDeclarations ) =
   Control.Monad.Identity.runIdentity (
     do !sem <- act
        let arg73 = T_ImportDeclarations_vIn73 
        !(T_ImportDeclarations_vOut73 _lhsOself) <- return (inv_ImportDeclarations_s74 sem arg73)
        return (Syn_ImportDeclarations _lhsOself)
   )

-- cata
{-# NOINLINE sem_ImportDeclarations #-}
sem_ImportDeclarations :: ImportDeclarations  -> T_ImportDeclarations 
sem_ImportDeclarations list = Prelude.foldr sem_ImportDeclarations_Cons sem_ImportDeclarations_Nil (Prelude.map sem_ImportDeclaration list)

-- semantic domain
newtype T_ImportDeclarations  = T_ImportDeclarations {
                                                     attach_T_ImportDeclarations :: Identity (T_ImportDeclarations_s74 )
                                                     }
newtype T_ImportDeclarations_s74  = C_ImportDeclarations_s74 {
                                                             inv_ImportDeclarations_s74 :: (T_ImportDeclarations_v73 )
                                                             }
data T_ImportDeclarations_s75  = C_ImportDeclarations_s75
type T_ImportDeclarations_v73  = (T_ImportDeclarations_vIn73 ) -> (T_ImportDeclarations_vOut73 )
data T_ImportDeclarations_vIn73  = T_ImportDeclarations_vIn73 
data T_ImportDeclarations_vOut73  = T_ImportDeclarations_vOut73 (ImportDeclarations)
{-# NOINLINE sem_ImportDeclarations_Cons #-}
sem_ImportDeclarations_Cons :: T_ImportDeclaration  -> T_ImportDeclarations  -> T_ImportDeclarations 
sem_ImportDeclarations_Cons arg_hd_ arg_tl_ = T_ImportDeclarations (return st74) where
   {-# NOINLINE st74 #-}
   !st74 = let
      v73 :: T_ImportDeclarations_v73 
      v73 = \ !(T_ImportDeclarations_vIn73 ) -> ( let
         _hdX71 = Control.Monad.Identity.runIdentity (attach_T_ImportDeclaration (arg_hd_))
         _tlX74 = Control.Monad.Identity.runIdentity (attach_T_ImportDeclarations (arg_tl_))
         (T_ImportDeclaration_vOut70 _hdIself) = inv_ImportDeclaration_s71 _hdX71 (T_ImportDeclaration_vIn70 )
         (T_ImportDeclarations_vOut73 _tlIself) = inv_ImportDeclarations_s74 _tlX74 (T_ImportDeclarations_vIn73 )
         _self = rule3352 _hdIself _tlIself
         _lhsOself :: ImportDeclarations
         _lhsOself = rule3353 _self
         !__result_ = T_ImportDeclarations_vOut73 _lhsOself
         in __result_ )
     in C_ImportDeclarations_s74 v73
   {-# INLINE rule3352 #-}
   rule3352 = \ ((_hdIself) :: ImportDeclaration) ((_tlIself) :: ImportDeclarations) ->
     (:) _hdIself _tlIself
   {-# INLINE rule3353 #-}
   rule3353 = \ _self ->
     _self
{-# NOINLINE sem_ImportDeclarations_Nil #-}
sem_ImportDeclarations_Nil ::  T_ImportDeclarations 
sem_ImportDeclarations_Nil  = T_ImportDeclarations (return st74) where
   {-# NOINLINE st74 #-}
   !st74 = let
      v73 :: T_ImportDeclarations_v73 
      v73 = \ !(T_ImportDeclarations_vIn73 ) -> ( let
         _self = rule3354  ()
         _lhsOself :: ImportDeclarations
         _lhsOself = rule3355 _self
         !__result_ = T_ImportDeclarations_vOut73 _lhsOself
         in __result_ )
     in C_ImportDeclarations_s74 v73
   {-# INLINE rule3354 #-}
   rule3354 = \  (_ :: ()) ->
     []
   {-# INLINE rule3355 #-}
   rule3355 = \ _self ->
     _self

-- ImportSpecification -----------------------------------------
-- wrapper
data Inh_ImportSpecification  = Inh_ImportSpecification {  }
data Syn_ImportSpecification  = Syn_ImportSpecification { self_Syn_ImportSpecification :: !(ImportSpecification) }
{-# INLINABLE wrap_ImportSpecification #-}
wrap_ImportSpecification :: T_ImportSpecification  -> Inh_ImportSpecification  -> (Syn_ImportSpecification )
wrap_ImportSpecification !(T_ImportSpecification act) !(Inh_ImportSpecification ) =
   Control.Monad.Identity.runIdentity (
     do !sem <- act
        let arg76 = T_ImportSpecification_vIn76 
        !(T_ImportSpecification_vOut76 _lhsOself) <- return (inv_ImportSpecification_s77 sem arg76)
        return (Syn_ImportSpecification _lhsOself)
   )

-- cata
{-# INLINE sem_ImportSpecification #-}
sem_ImportSpecification :: ImportSpecification  -> T_ImportSpecification 
sem_ImportSpecification ( ImportSpecification_Import range_ !hiding_ imports_ ) = sem_ImportSpecification_Import ( sem_Range range_ ) hiding_ ( sem_Imports imports_ )

-- semantic domain
newtype T_ImportSpecification  = T_ImportSpecification {
                                                       attach_T_ImportSpecification :: Identity (T_ImportSpecification_s77 )
                                                       }
newtype T_ImportSpecification_s77  = C_ImportSpecification_s77 {
                                                               inv_ImportSpecification_s77 :: (T_ImportSpecification_v76 )
                                                               }
data T_ImportSpecification_s78  = C_ImportSpecification_s78
type T_ImportSpecification_v76  = (T_ImportSpecification_vIn76 ) -> (T_ImportSpecification_vOut76 )
data T_ImportSpecification_vIn76  = T_ImportSpecification_vIn76 
data T_ImportSpecification_vOut76  = T_ImportSpecification_vOut76 (ImportSpecification)
{-# NOINLINE sem_ImportSpecification_Import #-}
sem_ImportSpecification_Import :: T_Range  -> (Bool) -> T_Imports  -> T_ImportSpecification 
sem_ImportSpecification_Import arg_range_ !arg_hiding_ arg_imports_ = T_ImportSpecification (return st77) where
   {-# NOINLINE st77 #-}
   !st77 = let
      v76 :: T_ImportSpecification_v76 
      v76 = \ !(T_ImportSpecification_vIn76 ) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _importsX80 = Control.Monad.Identity.runIdentity (attach_T_Imports (arg_imports_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_Imports_vOut79 _importsIself) = inv_Imports_s80 _importsX80 (T_Imports_vIn79 )
         _self = rule3356 _importsIself _rangeIself arg_hiding_
         _lhsOself :: ImportSpecification
         _lhsOself = rule3357 _self
         !__result_ = T_ImportSpecification_vOut76 _lhsOself
         in __result_ )
     in C_ImportSpecification_s77 v76
   {-# INLINE rule3356 #-}
   rule3356 = \ ((_importsIself) :: Imports) ((_rangeIself) :: Range) hiding_ ->
     ImportSpecification_Import _rangeIself hiding_ _importsIself
   {-# INLINE rule3357 #-}
   rule3357 = \ _self ->
     _self

-- Imports -----------------------------------------------------
-- wrapper
data Inh_Imports  = Inh_Imports {  }
data Syn_Imports  = Syn_Imports { self_Syn_Imports :: !(Imports) }
{-# INLINABLE wrap_Imports #-}
wrap_Imports :: T_Imports  -> Inh_Imports  -> (Syn_Imports )
wrap_Imports !(T_Imports act) !(Inh_Imports ) =
   Control.Monad.Identity.runIdentity (
     do !sem <- act
        let arg79 = T_Imports_vIn79 
        !(T_Imports_vOut79 _lhsOself) <- return (inv_Imports_s80 sem arg79)
        return (Syn_Imports _lhsOself)
   )

-- cata
{-# NOINLINE sem_Imports #-}
sem_Imports :: Imports  -> T_Imports 
sem_Imports list = Prelude.foldr sem_Imports_Cons sem_Imports_Nil (Prelude.map sem_Import list)

-- semantic domain
newtype T_Imports  = T_Imports {
                               attach_T_Imports :: Identity (T_Imports_s80 )
                               }
newtype T_Imports_s80  = C_Imports_s80 {
                                       inv_Imports_s80 :: (T_Imports_v79 )
                                       }
data T_Imports_s81  = C_Imports_s81
type T_Imports_v79  = (T_Imports_vIn79 ) -> (T_Imports_vOut79 )
data T_Imports_vIn79  = T_Imports_vIn79 
data T_Imports_vOut79  = T_Imports_vOut79 (Imports)
{-# NOINLINE sem_Imports_Cons #-}
sem_Imports_Cons :: T_Import  -> T_Imports  -> T_Imports 
sem_Imports_Cons arg_hd_ arg_tl_ = T_Imports (return st80) where
   {-# NOINLINE st80 #-}
   !st80 = let
      v79 :: T_Imports_v79 
      v79 = \ !(T_Imports_vIn79 ) -> ( let
         _hdX68 = Control.Monad.Identity.runIdentity (attach_T_Import (arg_hd_))
         _tlX80 = Control.Monad.Identity.runIdentity (attach_T_Imports (arg_tl_))
         (T_Import_vOut67 _hdIself) = inv_Import_s68 _hdX68 (T_Import_vIn67 )
         (T_Imports_vOut79 _tlIself) = inv_Imports_s80 _tlX80 (T_Imports_vIn79 )
         _self = rule3358 _hdIself _tlIself
         _lhsOself :: Imports
         _lhsOself = rule3359 _self
         !__result_ = T_Imports_vOut79 _lhsOself
         in __result_ )
     in C_Imports_s80 v79
   {-# INLINE rule3358 #-}
   rule3358 = \ ((_hdIself) :: Import) ((_tlIself) :: Imports) ->
     (:) _hdIself _tlIself
   {-# INLINE rule3359 #-}
   rule3359 = \ _self ->
     _self
{-# NOINLINE sem_Imports_Nil #-}
sem_Imports_Nil ::  T_Imports 
sem_Imports_Nil  = T_Imports (return st80) where
   {-# NOINLINE st80 #-}
   !st80 = let
      v79 :: T_Imports_v79 
      v79 = \ !(T_Imports_vIn79 ) -> ( let
         _self = rule3360  ()
         _lhsOself :: Imports
         _lhsOself = rule3361 _self
         !__result_ = T_Imports_vOut79 _lhsOself
         in __result_ )
     in C_Imports_s80 v79
   {-# INLINE rule3360 #-}
   rule3360 = \  (_ :: ()) ->
     []
   {-# INLINE rule3361 #-}
   rule3361 = \ _self ->
     _self

-- LeftHandSide ------------------------------------------------
-- wrapper
data Inh_LeftHandSide  = Inh_LeftHandSide { ambiguousConflicts_Inh_LeftHandSide :: !([[Name]]), betaUnique_Inh_LeftHandSide :: !(Int), counter_Inh_LeftHandSide :: !(Int), importEnvironment_Inh_LeftHandSide :: !(ImportEnvironment), monos_Inh_LeftHandSide :: !(Monos), namesInScope_Inh_LeftHandSide :: !(Names), parentTree_Inh_LeftHandSide :: !(InfoTree), patternMatchWarnings_Inh_LeftHandSide :: !([Warning]), typeConstructors_Inh_LeftHandSide :: !(TypeConstructorEnvironment) }
data Syn_LeftHandSide  = Syn_LeftHandSide { argcount_Syn_LeftHandSide :: !(Int), betaUnique_Syn_LeftHandSide :: !(Int), betas_Syn_LeftHandSide :: !(Tps), constraints_Syn_LeftHandSide :: !(ConstraintSet), counter_Syn_LeftHandSide :: !(Int), elements_Syn_LeftHandSide :: !(  [PatternElement]        ), environment_Syn_LeftHandSide :: !(PatternAssumptions), infoTrees_Syn_LeftHandSide :: !(InfoTrees), name_Syn_LeftHandSide :: !(Name), numberOfPatterns_Syn_LeftHandSide :: !(Int), patVarNames_Syn_LeftHandSide :: !(Names), patternMatchWarnings_Syn_LeftHandSide :: !([Warning]), self_Syn_LeftHandSide :: !(LeftHandSide), unboundNames_Syn_LeftHandSide :: !(Names) }
{-# INLINABLE wrap_LeftHandSide #-}
wrap_LeftHandSide :: T_LeftHandSide  -> Inh_LeftHandSide  -> (Syn_LeftHandSide )
wrap_LeftHandSide !(T_LeftHandSide act) !(Inh_LeftHandSide _lhsIambiguousConflicts _lhsIbetaUnique _lhsIcounter _lhsIimportEnvironment _lhsImonos _lhsInamesInScope _lhsIparentTree _lhsIpatternMatchWarnings _lhsItypeConstructors) =
   Control.Monad.Identity.runIdentity (
     do !sem <- act
        let arg82 = T_LeftHandSide_vIn82 _lhsIambiguousConflicts _lhsIbetaUnique _lhsIcounter _lhsIimportEnvironment _lhsImonos _lhsInamesInScope _lhsIparentTree _lhsIpatternMatchWarnings _lhsItypeConstructors
        !(T_LeftHandSide_vOut82 _lhsOargcount _lhsObetaUnique _lhsObetas _lhsOconstraints _lhsOcounter _lhsOelements _lhsOenvironment _lhsOinfoTrees _lhsOname _lhsOnumberOfPatterns _lhsOpatVarNames _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames) <- return (inv_LeftHandSide_s83 sem arg82)
        return (Syn_LeftHandSide _lhsOargcount _lhsObetaUnique _lhsObetas _lhsOconstraints _lhsOcounter _lhsOelements _lhsOenvironment _lhsOinfoTrees _lhsOname _lhsOnumberOfPatterns _lhsOpatVarNames _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames)
   )

-- cata
{-# NOINLINE sem_LeftHandSide #-}
sem_LeftHandSide :: LeftHandSide  -> T_LeftHandSide 
sem_LeftHandSide ( LeftHandSide_Function range_ name_ patterns_ ) = sem_LeftHandSide_Function ( sem_Range range_ ) ( sem_Name name_ ) ( sem_Patterns patterns_ )
sem_LeftHandSide ( LeftHandSide_Infix range_ leftPattern_ operator_ rightPattern_ ) = sem_LeftHandSide_Infix ( sem_Range range_ ) ( sem_Pattern leftPattern_ ) ( sem_Name operator_ ) ( sem_Pattern rightPattern_ )
sem_LeftHandSide ( LeftHandSide_Parenthesized range_ lefthandside_ patterns_ ) = sem_LeftHandSide_Parenthesized ( sem_Range range_ ) ( sem_LeftHandSide lefthandside_ ) ( sem_Patterns patterns_ )

-- semantic domain
newtype T_LeftHandSide  = T_LeftHandSide {
                                         attach_T_LeftHandSide :: Identity (T_LeftHandSide_s83 )
                                         }
newtype T_LeftHandSide_s83  = C_LeftHandSide_s83 {
                                                 inv_LeftHandSide_s83 :: (T_LeftHandSide_v82 )
                                                 }
data T_LeftHandSide_s84  = C_LeftHandSide_s84
type T_LeftHandSide_v82  = (T_LeftHandSide_vIn82 ) -> (T_LeftHandSide_vOut82 )
data T_LeftHandSide_vIn82  = T_LeftHandSide_vIn82 ([[Name]]) (Int) (Int) (ImportEnvironment) (Monos) (Names) (InfoTree) ([Warning]) (TypeConstructorEnvironment)
data T_LeftHandSide_vOut82  = T_LeftHandSide_vOut82 (Int) (Int) (Tps) (ConstraintSet) (Int) (  [PatternElement]        ) (PatternAssumptions) (InfoTrees) (Name) (Int) (Names) ([Warning]) (LeftHandSide) (Names)
{-# NOINLINE sem_LeftHandSide_Function #-}
sem_LeftHandSide_Function :: T_Range  -> T_Name  -> T_Patterns  -> T_LeftHandSide 
sem_LeftHandSide_Function arg_range_ arg_name_ arg_patterns_ = T_LeftHandSide (return st83) where
   {-# NOINLINE st83 #-}
   !st83 = let
      v82 :: T_LeftHandSide_v82 
      v82 = \ !(T_LeftHandSide_vIn82 _lhsIambiguousConflicts _lhsIbetaUnique _lhsIcounter _lhsIimportEnvironment _lhsImonos _lhsInamesInScope _lhsIparentTree _lhsIpatternMatchWarnings _lhsItypeConstructors) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _nameX113 = Control.Monad.Identity.runIdentity (attach_T_Name (arg_name_))
         _patternsX122 = Control.Monad.Identity.runIdentity (attach_T_Patterns (arg_patterns_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_Name_vOut112 _nameIself) = inv_Name_s113 _nameX113 (T_Name_vIn112 )
         (T_Patterns_vOut121 _patternsIbetaUnique _patternsIbetas _patternsIconstraintslist _patternsIcounter _patternsIelementss _patternsIenvironment _patternsIinfoTrees _patternsInumberOfPatterns _patternsIpatVarNames _patternsIpatternMatchWarnings _patternsIself _patternsIunboundNames) = inv_Patterns_s122 _patternsX122 (T_Patterns_vIn121 _patternsOambiguousConflicts _patternsObetaUnique _patternsOcounter _patternsOimportEnvironment _patternsOmonos _patternsOnamesInScope _patternsOparentTree _patternsOpatternMatchWarnings _patternsOtypeConstructors)
         _lhsOelements ::   [PatternElement]        
         _lhsOelements = rule3362 _patternsIelementss
         _lhsOargcount :: Int
         _lhsOargcount = rule3363 _patternsIself
         _lhsOinfoTrees :: InfoTrees
         _lhsOinfoTrees = rule3364 _patternsIinfoTrees
         _lhsOname :: Name
         _lhsOname = rule3365 _nameIself
         _constraints = rule3366 _patternsIconstraintslist
         _lhsOpatVarNames :: Names
         _lhsOpatVarNames = rule3367 _patternsIpatVarNames
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule3368 _patternsIunboundNames
         _self = rule3369 _nameIself _patternsIself _rangeIself
         _lhsOself :: LeftHandSide
         _lhsOself = rule3370 _self
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule3371 _patternsIbetaUnique
         _lhsObetas :: Tps
         _lhsObetas = rule3372 _patternsIbetas
         _lhsOconstraints :: ConstraintSet
         _lhsOconstraints = rule3373 _constraints
         _lhsOcounter :: Int
         _lhsOcounter = rule3374 _patternsIcounter
         _lhsOenvironment :: PatternAssumptions
         _lhsOenvironment = rule3375 _patternsIenvironment
         _lhsOnumberOfPatterns :: Int
         _lhsOnumberOfPatterns = rule3376 _patternsInumberOfPatterns
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule3377 _patternsIpatternMatchWarnings
         _patternsOambiguousConflicts = rule3378 _lhsIambiguousConflicts
         _patternsObetaUnique = rule3379 _lhsIbetaUnique
         _patternsOcounter = rule3380 _lhsIcounter
         _patternsOimportEnvironment = rule3381 _lhsIimportEnvironment
         _patternsOmonos = rule3382 _lhsImonos
         _patternsOnamesInScope = rule3383 _lhsInamesInScope
         _patternsOparentTree = rule3384 _lhsIparentTree
         _patternsOpatternMatchWarnings = rule3385 _lhsIpatternMatchWarnings
         _patternsOtypeConstructors = rule3386 _lhsItypeConstructors
         !__result_ = T_LeftHandSide_vOut82 _lhsOargcount _lhsObetaUnique _lhsObetas _lhsOconstraints _lhsOcounter _lhsOelements _lhsOenvironment _lhsOinfoTrees _lhsOname _lhsOnumberOfPatterns _lhsOpatVarNames _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames
         in __result_ )
     in C_LeftHandSide_s83 v82
   {-# INLINE rule3362 #-}
   rule3362 = \ ((_patternsIelementss) :: [ [PatternElement]       ]) ->
                                         concat _patternsIelementss
   {-# INLINE rule3363 #-}
   rule3363 = \ ((_patternsIself) :: Patterns) ->
                                         length _patternsIself
   {-# INLINE rule3364 #-}
   rule3364 = \ ((_patternsIinfoTrees) :: InfoTrees) ->
                                       _patternsIinfoTrees
   {-# INLINE rule3365 #-}
   rule3365 = \ ((_nameIself) :: Name) ->
                                 _nameIself
   {-# INLINE rule3366 #-}
   rule3366 = \ ((_patternsIconstraintslist) :: ConstraintSets) ->
                                 Node _patternsIconstraintslist
   {-# INLINE rule3367 #-}
   rule3367 = \ ((_patternsIpatVarNames) :: Names) ->
     _patternsIpatVarNames
   {-# INLINE rule3368 #-}
   rule3368 = \ ((_patternsIunboundNames) :: Names) ->
     _patternsIunboundNames
   {-# INLINE rule3369 #-}
   rule3369 = \ ((_nameIself) :: Name) ((_patternsIself) :: Patterns) ((_rangeIself) :: Range) ->
     LeftHandSide_Function _rangeIself _nameIself _patternsIself
   {-# INLINE rule3370 #-}
   rule3370 = \ _self ->
     _self
   {-# INLINE rule3371 #-}
   rule3371 = \ ((_patternsIbetaUnique) :: Int) ->
     _patternsIbetaUnique
   {-# INLINE rule3372 #-}
   rule3372 = \ ((_patternsIbetas) :: Tps) ->
     _patternsIbetas
   {-# INLINE rule3373 #-}
   rule3373 = \ _constraints ->
     _constraints
   {-# INLINE rule3374 #-}
   rule3374 = \ ((_patternsIcounter) :: Int) ->
     _patternsIcounter
   {-# INLINE rule3375 #-}
   rule3375 = \ ((_patternsIenvironment) :: PatternAssumptions) ->
     _patternsIenvironment
   {-# INLINE rule3376 #-}
   rule3376 = \ ((_patternsInumberOfPatterns) :: Int) ->
     _patternsInumberOfPatterns
   {-# INLINE rule3377 #-}
   rule3377 = \ ((_patternsIpatternMatchWarnings) :: [Warning]) ->
     _patternsIpatternMatchWarnings
   {-# INLINE rule3378 #-}
   rule3378 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule3379 #-}
   rule3379 = \ ((_lhsIbetaUnique) :: Int) ->
     _lhsIbetaUnique
   {-# INLINE rule3380 #-}
   rule3380 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule3381 #-}
   rule3381 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule3382 #-}
   rule3382 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule3383 #-}
   rule3383 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule3384 #-}
   rule3384 = \ ((_lhsIparentTree) :: InfoTree) ->
     _lhsIparentTree
   {-# INLINE rule3385 #-}
   rule3385 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule3386 #-}
   rule3386 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
{-# NOINLINE sem_LeftHandSide_Infix #-}
sem_LeftHandSide_Infix :: T_Range  -> T_Pattern  -> T_Name  -> T_Pattern  -> T_LeftHandSide 
sem_LeftHandSide_Infix arg_range_ arg_leftPattern_ arg_operator_ arg_rightPattern_ = T_LeftHandSide (return st83) where
   {-# NOINLINE st83 #-}
   !st83 = let
      v82 :: T_LeftHandSide_v82 
      v82 = \ !(T_LeftHandSide_vIn82 _lhsIambiguousConflicts _lhsIbetaUnique _lhsIcounter _lhsIimportEnvironment _lhsImonos _lhsInamesInScope _lhsIparentTree _lhsIpatternMatchWarnings _lhsItypeConstructors) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _leftPatternX119 = Control.Monad.Identity.runIdentity (attach_T_Pattern (arg_leftPattern_))
         _operatorX113 = Control.Monad.Identity.runIdentity (attach_T_Name (arg_operator_))
         _rightPatternX119 = Control.Monad.Identity.runIdentity (attach_T_Pattern (arg_rightPattern_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_Pattern_vOut118 _leftPatternIbeta _leftPatternIbetaUnique _leftPatternIconstraints _leftPatternIcounter _leftPatternIelements _leftPatternIenvironment _leftPatternIinfoTree _leftPatternIpatVarNames _leftPatternIpatternMatchWarnings _leftPatternIself _leftPatternIunboundNames) = inv_Pattern_s119 _leftPatternX119 (T_Pattern_vIn118 _leftPatternOambiguousConflicts _leftPatternObetaUnique _leftPatternOcounter _leftPatternOimportEnvironment _leftPatternOmonos _leftPatternOnamesInScope _leftPatternOparentTree _leftPatternOpatternMatchWarnings _leftPatternOtypeConstructors)
         (T_Name_vOut112 _operatorIself) = inv_Name_s113 _operatorX113 (T_Name_vIn112 )
         (T_Pattern_vOut118 _rightPatternIbeta _rightPatternIbetaUnique _rightPatternIconstraints _rightPatternIcounter _rightPatternIelements _rightPatternIenvironment _rightPatternIinfoTree _rightPatternIpatVarNames _rightPatternIpatternMatchWarnings _rightPatternIself _rightPatternIunboundNames) = inv_Pattern_s119 _rightPatternX119 (T_Pattern_vIn118 _rightPatternOambiguousConflicts _rightPatternObetaUnique _rightPatternOcounter _rightPatternOimportEnvironment _rightPatternOmonos _rightPatternOnamesInScope _rightPatternOparentTree _rightPatternOpatternMatchWarnings _rightPatternOtypeConstructors)
         _lhsOelements ::   [PatternElement]        
         _lhsOelements = rule3387 _leftPatternIelements _rightPatternIelements
         _lhsOargcount :: Int
         _lhsOargcount = rule3388  ()
         _lhsOinfoTrees :: InfoTrees
         _lhsOinfoTrees = rule3389 _leftPatternIinfoTree _rightPatternIinfoTree
         _lhsOnumberOfPatterns :: Int
         _lhsOnumberOfPatterns = rule3390  ()
         _lhsOenvironment :: PatternAssumptions
         _lhsOenvironment = rule3391 _leftPatternIenvironment _rightPatternIenvironment
         _lhsObetas :: Tps
         _lhsObetas = rule3392 _leftPatternIbeta _rightPatternIbeta
         _lhsOname :: Name
         _lhsOname = rule3393 _operatorIself
         _constraints = rule3394 _leftPatternIconstraints _rightPatternIconstraints
         _lhsOpatVarNames :: Names
         _lhsOpatVarNames = rule3395 _leftPatternIpatVarNames _rightPatternIpatVarNames
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule3396 _leftPatternIunboundNames _rightPatternIunboundNames
         _self = rule3397 _leftPatternIself _operatorIself _rangeIself _rightPatternIself
         _lhsOself :: LeftHandSide
         _lhsOself = rule3398 _self
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule3399 _rightPatternIbetaUnique
         _lhsOconstraints :: ConstraintSet
         _lhsOconstraints = rule3400 _constraints
         _lhsOcounter :: Int
         _lhsOcounter = rule3401 _rightPatternIcounter
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule3402 _rightPatternIpatternMatchWarnings
         _leftPatternOambiguousConflicts = rule3403 _lhsIambiguousConflicts
         _leftPatternObetaUnique = rule3404 _lhsIbetaUnique
         _leftPatternOcounter = rule3405 _lhsIcounter
         _leftPatternOimportEnvironment = rule3406 _lhsIimportEnvironment
         _leftPatternOmonos = rule3407 _lhsImonos
         _leftPatternOnamesInScope = rule3408 _lhsInamesInScope
         _leftPatternOparentTree = rule3409 _lhsIparentTree
         _leftPatternOpatternMatchWarnings = rule3410 _lhsIpatternMatchWarnings
         _leftPatternOtypeConstructors = rule3411 _lhsItypeConstructors
         _rightPatternOambiguousConflicts = rule3412 _lhsIambiguousConflicts
         _rightPatternObetaUnique = rule3413 _leftPatternIbetaUnique
         _rightPatternOcounter = rule3414 _leftPatternIcounter
         _rightPatternOimportEnvironment = rule3415 _lhsIimportEnvironment
         _rightPatternOmonos = rule3416 _lhsImonos
         _rightPatternOnamesInScope = rule3417 _lhsInamesInScope
         _rightPatternOparentTree = rule3418 _lhsIparentTree
         _rightPatternOpatternMatchWarnings = rule3419 _leftPatternIpatternMatchWarnings
         _rightPatternOtypeConstructors = rule3420 _lhsItypeConstructors
         !__result_ = T_LeftHandSide_vOut82 _lhsOargcount _lhsObetaUnique _lhsObetas _lhsOconstraints _lhsOcounter _lhsOelements _lhsOenvironment _lhsOinfoTrees _lhsOname _lhsOnumberOfPatterns _lhsOpatVarNames _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames
         in __result_ )
     in C_LeftHandSide_s83 v82
   {-# INLINE rule3387 #-}
   rule3387 = \ ((_leftPatternIelements) ::   [PatternElement]        ) ((_rightPatternIelements) ::   [PatternElement]        ) ->
                                         _leftPatternIelements ++ _rightPatternIelements
   {-# INLINE rule3388 #-}
   rule3388 = \  (_ :: ()) ->
                                         2
   {-# INLINE rule3389 #-}
   rule3389 = \ ((_leftPatternIinfoTree) :: InfoTree) ((_rightPatternIinfoTree) :: InfoTree) ->
                                       [_leftPatternIinfoTree, _rightPatternIinfoTree]
   {-# INLINE rule3390 #-}
   rule3390 = \  (_ :: ()) ->
                                 2
   {-# INLINE rule3391 #-}
   rule3391 = \ ((_leftPatternIenvironment) :: PatternAssumptions) ((_rightPatternIenvironment) :: PatternAssumptions) ->
                                 _leftPatternIenvironment `M.union` _rightPatternIenvironment
   {-# INLINE rule3392 #-}
   rule3392 = \ ((_leftPatternIbeta) :: Tp) ((_rightPatternIbeta) :: Tp) ->
                                 [_leftPatternIbeta,_rightPatternIbeta]
   {-# INLINE rule3393 #-}
   rule3393 = \ ((_operatorIself) :: Name) ->
                                 _operatorIself
   {-# INLINE rule3394 #-}
   rule3394 = \ ((_leftPatternIconstraints) :: ConstraintSet) ((_rightPatternIconstraints) :: ConstraintSet) ->
                                 Node [ _leftPatternIconstraints
                                      , _rightPatternIconstraints
                                      ]
   {-# INLINE rule3395 #-}
   rule3395 = \ ((_leftPatternIpatVarNames) :: Names) ((_rightPatternIpatVarNames) :: Names) ->
     _leftPatternIpatVarNames ++ _rightPatternIpatVarNames
   {-# INLINE rule3396 #-}
   rule3396 = \ ((_leftPatternIunboundNames) :: Names) ((_rightPatternIunboundNames) :: Names) ->
     ((++) _leftPatternIunboundNames _rightPatternIunboundNames)
   {-# INLINE rule3397 #-}
   rule3397 = \ ((_leftPatternIself) :: Pattern) ((_operatorIself) :: Name) ((_rangeIself) :: Range) ((_rightPatternIself) :: Pattern) ->
     LeftHandSide_Infix _rangeIself _leftPatternIself _operatorIself _rightPatternIself
   {-# INLINE rule3398 #-}
   rule3398 = \ _self ->
     _self
   {-# INLINE rule3399 #-}
   rule3399 = \ ((_rightPatternIbetaUnique) :: Int) ->
     _rightPatternIbetaUnique
   {-# INLINE rule3400 #-}
   rule3400 = \ _constraints ->
     _constraints
   {-# INLINE rule3401 #-}
   rule3401 = \ ((_rightPatternIcounter) :: Int) ->
     _rightPatternIcounter
   {-# INLINE rule3402 #-}
   rule3402 = \ ((_rightPatternIpatternMatchWarnings) :: [Warning]) ->
     _rightPatternIpatternMatchWarnings
   {-# INLINE rule3403 #-}
   rule3403 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule3404 #-}
   rule3404 = \ ((_lhsIbetaUnique) :: Int) ->
     _lhsIbetaUnique
   {-# INLINE rule3405 #-}
   rule3405 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule3406 #-}
   rule3406 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule3407 #-}
   rule3407 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule3408 #-}
   rule3408 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule3409 #-}
   rule3409 = \ ((_lhsIparentTree) :: InfoTree) ->
     _lhsIparentTree
   {-# INLINE rule3410 #-}
   rule3410 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule3411 #-}
   rule3411 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
   {-# INLINE rule3412 #-}
   rule3412 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule3413 #-}
   rule3413 = \ ((_leftPatternIbetaUnique) :: Int) ->
     _leftPatternIbetaUnique
   {-# INLINE rule3414 #-}
   rule3414 = \ ((_leftPatternIcounter) :: Int) ->
     _leftPatternIcounter
   {-# INLINE rule3415 #-}
   rule3415 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule3416 #-}
   rule3416 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule3417 #-}
   rule3417 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule3418 #-}
   rule3418 = \ ((_lhsIparentTree) :: InfoTree) ->
     _lhsIparentTree
   {-# INLINE rule3419 #-}
   rule3419 = \ ((_leftPatternIpatternMatchWarnings) :: [Warning]) ->
     _leftPatternIpatternMatchWarnings
   {-# INLINE rule3420 #-}
   rule3420 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
{-# NOINLINE sem_LeftHandSide_Parenthesized #-}
sem_LeftHandSide_Parenthesized :: T_Range  -> T_LeftHandSide  -> T_Patterns  -> T_LeftHandSide 
sem_LeftHandSide_Parenthesized arg_range_ arg_lefthandside_ arg_patterns_ = T_LeftHandSide (return st83) where
   {-# NOINLINE st83 #-}
   !st83 = let
      v82 :: T_LeftHandSide_v82 
      v82 = \ !(T_LeftHandSide_vIn82 _lhsIambiguousConflicts _lhsIbetaUnique _lhsIcounter _lhsIimportEnvironment _lhsImonos _lhsInamesInScope _lhsIparentTree _lhsIpatternMatchWarnings _lhsItypeConstructors) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _lefthandsideX83 = Control.Monad.Identity.runIdentity (attach_T_LeftHandSide (arg_lefthandside_))
         _patternsX122 = Control.Monad.Identity.runIdentity (attach_T_Patterns (arg_patterns_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_LeftHandSide_vOut82 _lefthandsideIargcount _lefthandsideIbetaUnique _lefthandsideIbetas _lefthandsideIconstraints _lefthandsideIcounter _lefthandsideIelements _lefthandsideIenvironment _lefthandsideIinfoTrees _lefthandsideIname _lefthandsideInumberOfPatterns _lefthandsideIpatVarNames _lefthandsideIpatternMatchWarnings _lefthandsideIself _lefthandsideIunboundNames) = inv_LeftHandSide_s83 _lefthandsideX83 (T_LeftHandSide_vIn82 _lefthandsideOambiguousConflicts _lefthandsideObetaUnique _lefthandsideOcounter _lefthandsideOimportEnvironment _lefthandsideOmonos _lefthandsideOnamesInScope _lefthandsideOparentTree _lefthandsideOpatternMatchWarnings _lefthandsideOtypeConstructors)
         (T_Patterns_vOut121 _patternsIbetaUnique _patternsIbetas _patternsIconstraintslist _patternsIcounter _patternsIelementss _patternsIenvironment _patternsIinfoTrees _patternsInumberOfPatterns _patternsIpatVarNames _patternsIpatternMatchWarnings _patternsIself _patternsIunboundNames) = inv_Patterns_s122 _patternsX122 (T_Patterns_vIn121 _patternsOambiguousConflicts _patternsObetaUnique _patternsOcounter _patternsOimportEnvironment _patternsOmonos _patternsOnamesInScope _patternsOparentTree _patternsOpatternMatchWarnings _patternsOtypeConstructors)
         _lhsOinfoTrees :: InfoTrees
         _lhsOinfoTrees = rule3421 _lefthandsideIinfoTrees _patternsIinfoTrees
         _lhsOnumberOfPatterns :: Int
         _lhsOnumberOfPatterns = rule3422 _lefthandsideInumberOfPatterns _patternsInumberOfPatterns
         _lhsOenvironment :: PatternAssumptions
         _lhsOenvironment = rule3423 _lefthandsideIenvironment _patternsIenvironment
         _lhsObetas :: Tps
         _lhsObetas = rule3424 _lefthandsideIbetas _patternsIbetas
         _constraints = rule3425 _lefthandsideIconstraints _patternsIconstraintslist
         _lhsOpatVarNames :: Names
         _lhsOpatVarNames = rule3426 _lefthandsideIpatVarNames _patternsIpatVarNames
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule3427 _lefthandsideIunboundNames _patternsIunboundNames
         _self = rule3428 _lefthandsideIself _patternsIself _rangeIself
         _lhsOself :: LeftHandSide
         _lhsOself = rule3429 _self
         _lhsOargcount :: Int
         _lhsOargcount = rule3430 _lefthandsideIargcount
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule3431 _patternsIbetaUnique
         _lhsOconstraints :: ConstraintSet
         _lhsOconstraints = rule3432 _constraints
         _lhsOcounter :: Int
         _lhsOcounter = rule3433 _patternsIcounter
         _lhsOelements ::   [PatternElement]        
         _lhsOelements = rule3434 _lefthandsideIelements
         _lhsOname :: Name
         _lhsOname = rule3435 _lefthandsideIname
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule3436 _patternsIpatternMatchWarnings
         _lefthandsideOambiguousConflicts = rule3437 _lhsIambiguousConflicts
         _lefthandsideObetaUnique = rule3438 _lhsIbetaUnique
         _lefthandsideOcounter = rule3439 _lhsIcounter
         _lefthandsideOimportEnvironment = rule3440 _lhsIimportEnvironment
         _lefthandsideOmonos = rule3441 _lhsImonos
         _lefthandsideOnamesInScope = rule3442 _lhsInamesInScope
         _lefthandsideOparentTree = rule3443 _lhsIparentTree
         _lefthandsideOpatternMatchWarnings = rule3444 _lhsIpatternMatchWarnings
         _lefthandsideOtypeConstructors = rule3445 _lhsItypeConstructors
         _patternsOambiguousConflicts = rule3446 _lhsIambiguousConflicts
         _patternsObetaUnique = rule3447 _lefthandsideIbetaUnique
         _patternsOcounter = rule3448 _lefthandsideIcounter
         _patternsOimportEnvironment = rule3449 _lhsIimportEnvironment
         _patternsOmonos = rule3450 _lhsImonos
         _patternsOnamesInScope = rule3451 _lhsInamesInScope
         _patternsOparentTree = rule3452 _lhsIparentTree
         _patternsOpatternMatchWarnings = rule3453 _lefthandsideIpatternMatchWarnings
         _patternsOtypeConstructors = rule3454 _lhsItypeConstructors
         !__result_ = T_LeftHandSide_vOut82 _lhsOargcount _lhsObetaUnique _lhsObetas _lhsOconstraints _lhsOcounter _lhsOelements _lhsOenvironment _lhsOinfoTrees _lhsOname _lhsOnumberOfPatterns _lhsOpatVarNames _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames
         in __result_ )
     in C_LeftHandSide_s83 v82
   {-# INLINE rule3421 #-}
   rule3421 = \ ((_lefthandsideIinfoTrees) :: InfoTrees) ((_patternsIinfoTrees) :: InfoTrees) ->
                                       _lefthandsideIinfoTrees ++ _patternsIinfoTrees
   {-# INLINE rule3422 #-}
   rule3422 = \ ((_lefthandsideInumberOfPatterns) :: Int) ((_patternsInumberOfPatterns) :: Int) ->
                                 _lefthandsideInumberOfPatterns + _patternsInumberOfPatterns
   {-# INLINE rule3423 #-}
   rule3423 = \ ((_lefthandsideIenvironment) :: PatternAssumptions) ((_patternsIenvironment) :: PatternAssumptions) ->
                                 _lefthandsideIenvironment `M.union` _patternsIenvironment
   {-# INLINE rule3424 #-}
   rule3424 = \ ((_lefthandsideIbetas) :: Tps) ((_patternsIbetas) :: Tps) ->
                                 _lefthandsideIbetas ++ _patternsIbetas
   {-# INLINE rule3425 #-}
   rule3425 = \ ((_lefthandsideIconstraints) :: ConstraintSet) ((_patternsIconstraintslist) :: ConstraintSets) ->
                                 Node ( _lefthandsideIconstraints : _patternsIconstraintslist )
   {-# INLINE rule3426 #-}
   rule3426 = \ ((_lefthandsideIpatVarNames) :: Names) ((_patternsIpatVarNames) :: Names) ->
     _lefthandsideIpatVarNames ++ _patternsIpatVarNames
   {-# INLINE rule3427 #-}
   rule3427 = \ ((_lefthandsideIunboundNames) :: Names) ((_patternsIunboundNames) :: Names) ->
     ((++) _lefthandsideIunboundNames _patternsIunboundNames)
   {-# INLINE rule3428 #-}
   rule3428 = \ ((_lefthandsideIself) :: LeftHandSide) ((_patternsIself) :: Patterns) ((_rangeIself) :: Range) ->
     LeftHandSide_Parenthesized _rangeIself _lefthandsideIself _patternsIself
   {-# INLINE rule3429 #-}
   rule3429 = \ _self ->
     _self
   {-# INLINE rule3430 #-}
   rule3430 = \ ((_lefthandsideIargcount) :: Int) ->
     _lefthandsideIargcount
   {-# INLINE rule3431 #-}
   rule3431 = \ ((_patternsIbetaUnique) :: Int) ->
     _patternsIbetaUnique
   {-# INLINE rule3432 #-}
   rule3432 = \ _constraints ->
     _constraints
   {-# INLINE rule3433 #-}
   rule3433 = \ ((_patternsIcounter) :: Int) ->
     _patternsIcounter
   {-# INLINE rule3434 #-}
   rule3434 = \ ((_lefthandsideIelements) ::   [PatternElement]        ) ->
     _lefthandsideIelements
   {-# INLINE rule3435 #-}
   rule3435 = \ ((_lefthandsideIname) :: Name) ->
     _lefthandsideIname
   {-# INLINE rule3436 #-}
   rule3436 = \ ((_patternsIpatternMatchWarnings) :: [Warning]) ->
     _patternsIpatternMatchWarnings
   {-# INLINE rule3437 #-}
   rule3437 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule3438 #-}
   rule3438 = \ ((_lhsIbetaUnique) :: Int) ->
     _lhsIbetaUnique
   {-# INLINE rule3439 #-}
   rule3439 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule3440 #-}
   rule3440 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule3441 #-}
   rule3441 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule3442 #-}
   rule3442 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule3443 #-}
   rule3443 = \ ((_lhsIparentTree) :: InfoTree) ->
     _lhsIparentTree
   {-# INLINE rule3444 #-}
   rule3444 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule3445 #-}
   rule3445 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
   {-# INLINE rule3446 #-}
   rule3446 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule3447 #-}
   rule3447 = \ ((_lefthandsideIbetaUnique) :: Int) ->
     _lefthandsideIbetaUnique
   {-# INLINE rule3448 #-}
   rule3448 = \ ((_lefthandsideIcounter) :: Int) ->
     _lefthandsideIcounter
   {-# INLINE rule3449 #-}
   rule3449 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule3450 #-}
   rule3450 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule3451 #-}
   rule3451 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule3452 #-}
   rule3452 = \ ((_lhsIparentTree) :: InfoTree) ->
     _lhsIparentTree
   {-# INLINE rule3453 #-}
   rule3453 = \ ((_lefthandsideIpatternMatchWarnings) :: [Warning]) ->
     _lefthandsideIpatternMatchWarnings
   {-# INLINE rule3454 #-}
   rule3454 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors

-- Literal -----------------------------------------------------
-- wrapper
data Inh_Literal  = Inh_Literal {  }
data Syn_Literal  = Syn_Literal { elements_Syn_Literal :: !(  [PatternElement]        ), literalType_Syn_Literal :: !(Tp), self_Syn_Literal :: !(Literal) }
{-# INLINABLE wrap_Literal #-}
wrap_Literal :: T_Literal  -> Inh_Literal  -> (Syn_Literal )
wrap_Literal !(T_Literal act) !(Inh_Literal ) =
   Control.Monad.Identity.runIdentity (
     do !sem <- act
        let arg85 = T_Literal_vIn85 
        !(T_Literal_vOut85 _lhsOelements _lhsOliteralType _lhsOself) <- return (inv_Literal_s86 sem arg85)
        return (Syn_Literal _lhsOelements _lhsOliteralType _lhsOself)
   )

-- cata
{-# NOINLINE sem_Literal #-}
sem_Literal :: Literal  -> T_Literal 
sem_Literal ( Literal_Int range_ !value_ ) = sem_Literal_Int ( sem_Range range_ ) value_
sem_Literal ( Literal_Char range_ !value_ ) = sem_Literal_Char ( sem_Range range_ ) value_
sem_Literal ( Literal_Float range_ !value_ ) = sem_Literal_Float ( sem_Range range_ ) value_
sem_Literal ( Literal_String range_ !value_ ) = sem_Literal_String ( sem_Range range_ ) value_

-- semantic domain
newtype T_Literal  = T_Literal {
                               attach_T_Literal :: Identity (T_Literal_s86 )
                               }
newtype T_Literal_s86  = C_Literal_s86 {
                                       inv_Literal_s86 :: (T_Literal_v85 )
                                       }
data T_Literal_s87  = C_Literal_s87
type T_Literal_v85  = (T_Literal_vIn85 ) -> (T_Literal_vOut85 )
data T_Literal_vIn85  = T_Literal_vIn85 
data T_Literal_vOut85  = T_Literal_vOut85 (  [PatternElement]        ) (Tp) (Literal)
{-# NOINLINE sem_Literal_Int #-}
sem_Literal_Int :: T_Range  -> (String) -> T_Literal 
sem_Literal_Int arg_range_ !arg_value_ = T_Literal (return st86) where
   {-# NOINLINE st86 #-}
   !st86 = let
      v85 :: T_Literal_v85 
      v85 = \ !(T_Literal_vIn85 ) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         _lhsOelements ::   [PatternElement]        
         _lhsOelements = rule3455 arg_value_
         _lhsOliteralType :: Tp
         _lhsOliteralType = rule3456  ()
         _self = rule3457 _rangeIself arg_value_
         _lhsOself :: Literal
         _lhsOself = rule3458 _self
         !__result_ = T_Literal_vOut85 _lhsOelements _lhsOliteralType _lhsOself
         in __result_ )
     in C_Literal_s86 v85
   {-# INLINE rule3455 #-}
   rule3455 = \ value_ ->
                                         [InfiniteElement value_]
   {-# INLINE rule3456 #-}
   rule3456 = \  (_ :: ()) ->
                                  intQualType
   {-# INLINE rule3457 #-}
   rule3457 = \ ((_rangeIself) :: Range) value_ ->
     Literal_Int _rangeIself value_
   {-# INLINE rule3458 #-}
   rule3458 = \ _self ->
     _self
{-# NOINLINE sem_Literal_Char #-}
sem_Literal_Char :: T_Range  -> (String) -> T_Literal 
sem_Literal_Char arg_range_ !arg_value_ = T_Literal (return st86) where
   {-# NOINLINE st86 #-}
   !st86 = let
      v85 :: T_Literal_v85 
      v85 = \ !(T_Literal_vIn85 ) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         _lhsOelements ::   [PatternElement]        
         _lhsOelements = rule3459 arg_value_
         _lhsOliteralType :: Tp
         _lhsOliteralType = rule3460  ()
         _self = rule3461 _rangeIself arg_value_
         _lhsOself :: Literal
         _lhsOself = rule3462 _self
         !__result_ = T_Literal_vOut85 _lhsOelements _lhsOliteralType _lhsOself
         in __result_ )
     in C_Literal_s86 v85
   {-# INLINE rule3459 #-}
   rule3459 = \ value_ ->
                                         [InfiniteElement value_]
   {-# INLINE rule3460 #-}
   rule3460 = \  (_ :: ()) ->
                                  charQualType
   {-# INLINE rule3461 #-}
   rule3461 = \ ((_rangeIself) :: Range) value_ ->
     Literal_Char _rangeIself value_
   {-# INLINE rule3462 #-}
   rule3462 = \ _self ->
     _self
{-# NOINLINE sem_Literal_Float #-}
sem_Literal_Float :: T_Range  -> (String) -> T_Literal 
sem_Literal_Float arg_range_ !arg_value_ = T_Literal (return st86) where
   {-# NOINLINE st86 #-}
   !st86 = let
      v85 :: T_Literal_v85 
      v85 = \ !(T_Literal_vIn85 ) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         _lhsOelements ::   [PatternElement]        
         _lhsOelements = rule3463 arg_value_
         _lhsOliteralType :: Tp
         _lhsOliteralType = rule3464  ()
         _self = rule3465 _rangeIself arg_value_
         _lhsOself :: Literal
         _lhsOself = rule3466 _self
         !__result_ = T_Literal_vOut85 _lhsOelements _lhsOliteralType _lhsOself
         in __result_ )
     in C_Literal_s86 v85
   {-# INLINE rule3463 #-}
   rule3463 = \ value_ ->
                                         [InfiniteElement value_]
   {-# INLINE rule3464 #-}
   rule3464 = \  (_ :: ()) ->
                                  floatQualType
   {-# INLINE rule3465 #-}
   rule3465 = \ ((_rangeIself) :: Range) value_ ->
     Literal_Float _rangeIself value_
   {-# INLINE rule3466 #-}
   rule3466 = \ _self ->
     _self
{-# NOINLINE sem_Literal_String #-}
sem_Literal_String :: T_Range  -> (String) -> T_Literal 
sem_Literal_String arg_range_ !arg_value_ = T_Literal (return st86) where
   {-# NOINLINE st86 #-}
   !st86 = let
      v85 :: T_Literal_v85 
      v85 = \ !(T_Literal_vIn85 ) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         _lhsOelements ::   [PatternElement]        
         _lhsOelements = rule3467 arg_value_
         _lhsOliteralType :: Tp
         _lhsOliteralType = rule3468  ()
         _self = rule3469 _rangeIself arg_value_
         _lhsOself :: Literal
         _lhsOself = rule3470 _self
         !__result_ = T_Literal_vOut85 _lhsOelements _lhsOliteralType _lhsOself
         in __result_ )
     in C_Literal_s86 v85
   {-# INLINE rule3467 #-}
   rule3467 = \ value_ ->
                                         stringPat value_
   {-# INLINE rule3468 #-}
   rule3468 = \  (_ :: ()) ->
                                  stringQualType
   {-# INLINE rule3469 #-}
   rule3469 = \ ((_rangeIself) :: Range) value_ ->
     Literal_String _rangeIself value_
   {-# INLINE rule3470 #-}
   rule3470 = \ _self ->
     _self

-- MaybeDeclarations -------------------------------------------
-- wrapper
data Inh_MaybeDeclarations  = Inh_MaybeDeclarations { allPatterns_Inh_MaybeDeclarations :: !([((Expression, [String]), Core_TypingStrategy)]), allTypeSchemes_Inh_MaybeDeclarations :: !(M.Map NameWithRange TpScheme), ambiguousConflicts_Inh_MaybeDeclarations :: !([[Name]]), assumptions_Inh_MaybeDeclarations :: !(Assumptions), availablePredicates_Inh_MaybeDeclarations :: !([PredicateWithSource]), betaUnique_Inh_MaybeDeclarations :: !(Int), classEnvironment_Inh_MaybeDeclarations :: !(ClassEnvironment), classMemberEnv_Inh_MaybeDeclarations :: !(ClassMemberEnvironment), classMemberTypeSchemes_Inh_MaybeDeclarations :: !(Maybe [(Name, TpScheme)]), classNamesEnv_Inh_MaybeDeclarations :: !(ClassNameEnvironment), classPredicate_Inh_MaybeDeclarations :: !(Maybe (Name, Names)), classTypeSchemes_Inh_MaybeDeclarations :: !(M.Map Name TpScheme), collectErrors_Inh_MaybeDeclarations :: !(TypeErrors), collectWarnings_Inh_MaybeDeclarations :: !(Warnings), constraints_Inh_MaybeDeclarations :: !(ConstraintSet), counter_Inh_MaybeDeclarations :: !(Int), curClassPred_Inh_MaybeDeclarations :: !(Maybe Predicate), curPred_Inh_MaybeDeclarations :: !(Maybe Predicate), currentChunk_Inh_MaybeDeclarations :: !(Int), dictionaryEnvironment_Inh_MaybeDeclarations :: !(DictionaryEnvironment), importEnvironment_Inh_MaybeDeclarations :: !(ImportEnvironment), instanceName_Inh_MaybeDeclarations :: !(Maybe Name), instanceTypes_Inh_MaybeDeclarations :: !([(Name, TpScheme)]), matchIO_Inh_MaybeDeclarations :: !(IO ()), moduleName_Inh_MaybeDeclarations :: !(Maybe Name), monos_Inh_MaybeDeclarations :: !(Monos), namesInScope_Inh_MaybeDeclarations :: !(Names), orderedTypeSynonyms_Inh_MaybeDeclarations :: !(OrderedTypeSynonyms), parentTree_Inh_MaybeDeclarations :: !(InfoTree), patternMatchWarnings_Inh_MaybeDeclarations :: !([Warning]), requiredPredicates_Inh_MaybeDeclarations :: !(Predicates), substitution_Inh_MaybeDeclarations :: !(FixpointSubstitution), typeConstructors_Inh_MaybeDeclarations :: !(TypeConstructorEnvironment), typeschemeMap_Inh_MaybeDeclarations :: !(M.Map Int (Scheme Predicates)), unboundNames_Inh_MaybeDeclarations :: !(Names), uniqueChunk_Inh_MaybeDeclarations :: !(Int), variableMapping_Inh_MaybeDeclarations :: !(Maybe [(Name, Tp)]) }
data Syn_MaybeDeclarations  = Syn_MaybeDeclarations { assumptions_Syn_MaybeDeclarations :: !(Assumptions), betaUnique_Syn_MaybeDeclarations :: !(Int), boundBetas_Syn_MaybeDeclarations :: !([(Name, Tp, [Tp])]), collectErrors_Syn_MaybeDeclarations :: !(TypeErrors), collectInstances_Syn_MaybeDeclarations :: !([(Name, Instance)]), collectWarnings_Syn_MaybeDeclarations :: !(Warnings), constraints_Syn_MaybeDeclarations :: !(ConstraintSet), counter_Syn_MaybeDeclarations :: !(Int), declVarNames_Syn_MaybeDeclarations :: !(Names), dictionaryEnvironment_Syn_MaybeDeclarations :: !(DictionaryEnvironment), infoTrees_Syn_MaybeDeclarations :: !(InfoTrees), localTypes_Syn_MaybeDeclarations :: !(M.Map NameWithRange TpScheme), matchIO_Syn_MaybeDeclarations :: !(IO ()), namesInScope_Syn_MaybeDeclarations :: !(Names), patternMatchWarnings_Syn_MaybeDeclarations :: !([Warning]), self_Syn_MaybeDeclarations :: !(MaybeDeclarations), typeMemberBindings_Syn_MaybeDeclarations :: !([(Name, TpScheme)]), unboundNames_Syn_MaybeDeclarations :: !(Names), uniqueChunk_Syn_MaybeDeclarations :: !(Int) }
{-# INLINABLE wrap_MaybeDeclarations #-}
wrap_MaybeDeclarations :: T_MaybeDeclarations  -> Inh_MaybeDeclarations  -> (Syn_MaybeDeclarations )
wrap_MaybeDeclarations !(T_MaybeDeclarations act) !(Inh_MaybeDeclarations _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIassumptions _lhsIavailablePredicates _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIconstraints _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeConstructors _lhsItypeschemeMap _lhsIunboundNames _lhsIuniqueChunk _lhsIvariableMapping) =
   Control.Monad.Identity.runIdentity (
     do !sem <- act
        let arg88 = T_MaybeDeclarations_vIn88 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIassumptions _lhsIavailablePredicates _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIconstraints _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeConstructors _lhsItypeschemeMap _lhsIunboundNames _lhsIuniqueChunk _lhsIvariableMapping
        !(T_MaybeDeclarations_vOut88 _lhsOassumptions _lhsObetaUnique _lhsOboundBetas _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraints _lhsOcounter _lhsOdeclVarNames _lhsOdictionaryEnvironment _lhsOinfoTrees _lhsOlocalTypes _lhsOmatchIO _lhsOnamesInScope _lhsOpatternMatchWarnings _lhsOself _lhsOtypeMemberBindings _lhsOunboundNames _lhsOuniqueChunk) <- return (inv_MaybeDeclarations_s89 sem arg88)
        return (Syn_MaybeDeclarations _lhsOassumptions _lhsObetaUnique _lhsOboundBetas _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraints _lhsOcounter _lhsOdeclVarNames _lhsOdictionaryEnvironment _lhsOinfoTrees _lhsOlocalTypes _lhsOmatchIO _lhsOnamesInScope _lhsOpatternMatchWarnings _lhsOself _lhsOtypeMemberBindings _lhsOunboundNames _lhsOuniqueChunk)
   )

-- cata
{-# NOINLINE sem_MaybeDeclarations #-}
sem_MaybeDeclarations :: MaybeDeclarations  -> T_MaybeDeclarations 
sem_MaybeDeclarations ( MaybeDeclarations_Nothing  ) = sem_MaybeDeclarations_Nothing 
sem_MaybeDeclarations ( MaybeDeclarations_Just declarations_ ) = sem_MaybeDeclarations_Just ( sem_Declarations declarations_ )

-- semantic domain
newtype T_MaybeDeclarations  = T_MaybeDeclarations {
                                                   attach_T_MaybeDeclarations :: Identity (T_MaybeDeclarations_s89 )
                                                   }
newtype T_MaybeDeclarations_s89  = C_MaybeDeclarations_s89 {
                                                           inv_MaybeDeclarations_s89 :: (T_MaybeDeclarations_v88 )
                                                           }
data T_MaybeDeclarations_s90  = C_MaybeDeclarations_s90
type T_MaybeDeclarations_v88  = (T_MaybeDeclarations_vIn88 ) -> (T_MaybeDeclarations_vOut88 )
data T_MaybeDeclarations_vIn88  = T_MaybeDeclarations_vIn88 ([((Expression, [String]), Core_TypingStrategy)]) (M.Map NameWithRange TpScheme) ([[Name]]) (Assumptions) ([PredicateWithSource]) (Int) (ClassEnvironment) (ClassMemberEnvironment) (Maybe [(Name, TpScheme)]) (ClassNameEnvironment) (Maybe (Name, Names)) (M.Map Name TpScheme) (TypeErrors) (Warnings) (ConstraintSet) (Int) (Maybe Predicate) (Maybe Predicate) (Int) (DictionaryEnvironment) (ImportEnvironment) (Maybe Name) ([(Name, TpScheme)]) (IO ()) (Maybe Name) (Monos) (Names) (OrderedTypeSynonyms) (InfoTree) ([Warning]) (Predicates) (FixpointSubstitution) (TypeConstructorEnvironment) (M.Map Int (Scheme Predicates)) (Names) (Int) (Maybe [(Name, Tp)])
data T_MaybeDeclarations_vOut88  = T_MaybeDeclarations_vOut88 (Assumptions) (Int) ([(Name, Tp, [Tp])]) (TypeErrors) ([(Name, Instance)]) (Warnings) (ConstraintSet) (Int) (Names) (DictionaryEnvironment) (InfoTrees) (M.Map NameWithRange TpScheme) (IO ()) (Names) ([Warning]) (MaybeDeclarations) ([(Name, TpScheme)]) (Names) (Int)
{-# NOINLINE sem_MaybeDeclarations_Nothing #-}
sem_MaybeDeclarations_Nothing ::  T_MaybeDeclarations 
sem_MaybeDeclarations_Nothing  = T_MaybeDeclarations (return st89) where
   {-# NOINLINE st89 #-}
   !st89 = let
      v88 :: T_MaybeDeclarations_v88 
      v88 = \ !(T_MaybeDeclarations_vIn88 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIassumptions _lhsIavailablePredicates _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIconstraints _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeConstructors _lhsItypeschemeMap _lhsIunboundNames _lhsIuniqueChunk _lhsIvariableMapping) -> ( let
         _lhsOdeclVarNames :: Names
         _lhsOdeclVarNames = rule3471  ()
         _lhsOinfoTrees :: InfoTrees
         _lhsOinfoTrees = rule3472  ()
         _lhsOlocalTypes :: M.Map NameWithRange TpScheme
         _lhsOlocalTypes = rule3473  ()
         _lhsOboundBetas :: [(Name, Tp, [Tp])]
         _lhsOboundBetas = rule3474  ()
         _lhsOcollectInstances :: [(Name, Instance)]
         _lhsOcollectInstances = rule3475  ()
         _lhsOtypeMemberBindings :: [(Name, TpScheme)]
         _lhsOtypeMemberBindings = rule3476  ()
         _self = rule3477  ()
         _lhsOself :: MaybeDeclarations
         _lhsOself = rule3478 _self
         _lhsOassumptions :: Assumptions
         _lhsOassumptions = rule3479 _lhsIassumptions
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule3480 _lhsIbetaUnique
         _lhsOcollectErrors :: TypeErrors
         _lhsOcollectErrors = rule3481 _lhsIcollectErrors
         _lhsOcollectWarnings :: Warnings
         _lhsOcollectWarnings = rule3482 _lhsIcollectWarnings
         _lhsOconstraints :: ConstraintSet
         _lhsOconstraints = rule3483 _lhsIconstraints
         _lhsOcounter :: Int
         _lhsOcounter = rule3484 _lhsIcounter
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule3485 _lhsIdictionaryEnvironment
         _lhsOmatchIO :: IO ()
         _lhsOmatchIO = rule3486 _lhsImatchIO
         _lhsOnamesInScope :: Names
         _lhsOnamesInScope = rule3487 _lhsInamesInScope
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule3488 _lhsIpatternMatchWarnings
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule3489 _lhsIunboundNames
         _lhsOuniqueChunk :: Int
         _lhsOuniqueChunk = rule3490 _lhsIuniqueChunk
         !__result_ = T_MaybeDeclarations_vOut88 _lhsOassumptions _lhsObetaUnique _lhsOboundBetas _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraints _lhsOcounter _lhsOdeclVarNames _lhsOdictionaryEnvironment _lhsOinfoTrees _lhsOlocalTypes _lhsOmatchIO _lhsOnamesInScope _lhsOpatternMatchWarnings _lhsOself _lhsOtypeMemberBindings _lhsOunboundNames _lhsOuniqueChunk
         in __result_ )
     in C_MaybeDeclarations_s89 v88
   {-# INLINE rule3471 #-}
   rule3471 = \  (_ :: ()) ->
                                                                []
   {-# INLINE rule3472 #-}
   rule3472 = \  (_ :: ()) ->
                                 []
   {-# INLINE rule3473 #-}
   rule3473 = \  (_ :: ()) ->
                                   M.empty
   {-# INLINE rule3474 #-}
   rule3474 = \  (_ :: ()) ->
     []
   {-# INLINE rule3475 #-}
   rule3475 = \  (_ :: ()) ->
     []
   {-# INLINE rule3476 #-}
   rule3476 = \  (_ :: ()) ->
     []
   {-# INLINE rule3477 #-}
   rule3477 = \  (_ :: ()) ->
     MaybeDeclarations_Nothing
   {-# INLINE rule3478 #-}
   rule3478 = \ _self ->
     _self
   {-# INLINE rule3479 #-}
   rule3479 = \ ((_lhsIassumptions) :: Assumptions) ->
     _lhsIassumptions
   {-# INLINE rule3480 #-}
   rule3480 = \ ((_lhsIbetaUnique) :: Int) ->
     _lhsIbetaUnique
   {-# INLINE rule3481 #-}
   rule3481 = \ ((_lhsIcollectErrors) :: TypeErrors) ->
     _lhsIcollectErrors
   {-# INLINE rule3482 #-}
   rule3482 = \ ((_lhsIcollectWarnings) :: Warnings) ->
     _lhsIcollectWarnings
   {-# INLINE rule3483 #-}
   rule3483 = \ ((_lhsIconstraints) :: ConstraintSet) ->
     _lhsIconstraints
   {-# INLINE rule3484 #-}
   rule3484 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule3485 #-}
   rule3485 = \ ((_lhsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _lhsIdictionaryEnvironment
   {-# INLINE rule3486 #-}
   rule3486 = \ ((_lhsImatchIO) :: IO ()) ->
     _lhsImatchIO
   {-# INLINE rule3487 #-}
   rule3487 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule3488 #-}
   rule3488 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule3489 #-}
   rule3489 = \ ((_lhsIunboundNames) :: Names) ->
     _lhsIunboundNames
   {-# INLINE rule3490 #-}
   rule3490 = \ ((_lhsIuniqueChunk) :: Int) ->
     _lhsIuniqueChunk
{-# NOINLINE sem_MaybeDeclarations_Just #-}
sem_MaybeDeclarations_Just :: T_Declarations  -> T_MaybeDeclarations 
sem_MaybeDeclarations_Just arg_declarations_ = T_MaybeDeclarations (return st89) where
   {-# NOINLINE st89 #-}
   !st89 = let
      v88 :: T_MaybeDeclarations_v88 
      v88 = \ !(T_MaybeDeclarations_vIn88 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIassumptions _lhsIavailablePredicates _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIconstraints _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeConstructors _lhsItypeschemeMap _lhsIunboundNames _lhsIuniqueChunk _lhsIvariableMapping) -> ( let
         _declarationsX32 = Control.Monad.Identity.runIdentity (attach_T_Declarations (arg_declarations_))
         (T_Declarations_vOut31 _declarationsIbetaUnique _declarationsIbindingGroups _declarationsIboundBetas _declarationsIclassMemberNames _declarationsIcollectErrors _declarationsIcollectInstances _declarationsIcollectWarnings _declarationsIcounter _declarationsIdeclVarNames _declarationsIdictionaryEnvironment _declarationsIinfoTrees _declarationsImatchIO _declarationsIpatternMatchWarnings _declarationsIrestrictedNames _declarationsIself _declarationsIsimplePatNames _declarationsItypeMemberBindings _declarationsItypeSignatures _declarationsIunboundNames _declarationsIuniqueChunk) = inv_Declarations_s32 _declarationsX32 (T_Declarations_vIn31 _declarationsOallPatterns _declarationsOallTypeSchemes _declarationsOambiguousConflicts _declarationsOavailablePredicates _declarationsObetaUnique _declarationsObindingGroups _declarationsOclassEnvironment _declarationsOclassMemberEnv _declarationsOclassMemberTypeSchemes _declarationsOclassNamesEnv _declarationsOclassPredicate _declarationsOclassTypeSchemes _declarationsOcollectErrors _declarationsOcollectWarnings _declarationsOcounter _declarationsOcurClassPred _declarationsOcurPred _declarationsOcurrentChunk _declarationsOdictionaryEnvironment _declarationsOimportEnvironment _declarationsOinheritedBDG _declarationsOinstanceName _declarationsOinstanceTypes _declarationsOisTopLevel _declarationsOmatchIO _declarationsOmoduleName _declarationsOmoduleQual _declarationsOmonos _declarationsOnamesInScope _declarationsOorderedTypeSynonyms _declarationsOparentTree _declarationsOpatternMatchWarnings _declarationsOrequiredPredicates _declarationsOsubstitution _declarationsOtypeConstructors _declarationsOtypeSignatures _declarationsOtypeschemeMap _declarationsOuniqueChunk _declarationsOvariableMapping)
         (_namesInScope,_unboundNames,_scopeInfo) = rule3491 _declarationsIdeclVarNames _declarationsIunboundNames _lhsInamesInScope _lhsIunboundNames
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule3492 _unboundNames
         _lhsOdeclVarNames :: Names
         _lhsOdeclVarNames = rule3493 _declarationsIdeclVarNames
         (_collectTypeConstructors,_collectValueConstructors,_collectTypeSynonyms,_collectConstructorEnv,_derivedFunctions,_moduleQual) = rule3494  ()
         _theNode = rule3495 _declInfo _declarationsIinfoTrees _lhsIparentTree
         _lhsOinfoTrees :: InfoTrees
         _lhsOinfoTrees = rule3496 _theNode
         _declarationsOparentTree = rule3497 _theNode
         _declInfo = rule3498 _declarationsIself _lhsImonos
         _inferredTypes = rule3499 _implicitsFM _lhsItypeschemeMap
         _lhsOcollectWarnings :: Warnings
         _lhsOcollectWarnings = rule3500 _declarationsIcollectWarnings _declarationsIsimplePatNames _inferredTypes _lhsIimportEnvironment
         _lhsOcollectErrors :: TypeErrors
         _lhsOcollectErrors = rule3501 _declarationsIcollectErrors _declarationsIrestrictedNames _inferredTypes _lhsIimportEnvironment
         _lhsOlocalTypes :: M.Map NameWithRange TpScheme
         _lhsOlocalTypes = rule3502 _declarationsIbindingGroups _declarationsItypeSignatures _inferredTypes
         _declarationsOtypeSignatures = rule3503  ()
         _lhsOuniqueChunk :: Int
         _lhsOuniqueChunk = rule3504 _chunkNr
         _declarationsObindingGroups = rule3505  ()
         _lhsOassumptions :: Assumptions
         _lhsOconstraints :: ConstraintSet
         _lhsObetaUnique :: Int
         (_lhsOassumptions,_lhsOconstraints,_inheritedBDG,_chunkNr,_lhsObetaUnique,_implicitsFM) = rule3506 _declarationsIbetaUnique _declarationsIbindingGroups _declarationsItypeSignatures _declarationsIuniqueChunk _lhsIassumptions _lhsIconstraints _lhsIcurrentChunk _lhsImonos
         _isTopLevel = rule3507  ()
         _lhsOboundBetas :: [(Name, Tp, [Tp])]
         _lhsOboundBetas = rule3508 _declarationsIboundBetas
         _lhsOcollectInstances :: [(Name, Instance)]
         _lhsOcollectInstances = rule3509 _declarationsIcollectInstances
         _lhsOtypeMemberBindings :: [(Name, TpScheme)]
         _lhsOtypeMemberBindings = rule3510 _declarationsItypeMemberBindings
         _self = rule3511 _declarationsIself
         _lhsOself :: MaybeDeclarations
         _lhsOself = rule3512 _self
         _lhsOcounter :: Int
         _lhsOcounter = rule3513 _declarationsIcounter
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule3514 _declarationsIdictionaryEnvironment
         _lhsOmatchIO :: IO ()
         _lhsOmatchIO = rule3515 _declarationsImatchIO
         _lhsOnamesInScope :: Names
         _lhsOnamesInScope = rule3516 _namesInScope
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule3517 _declarationsIpatternMatchWarnings
         _declarationsOallPatterns = rule3518 _lhsIallPatterns
         _declarationsOallTypeSchemes = rule3519 _lhsIallTypeSchemes
         _declarationsOambiguousConflicts = rule3520 _lhsIambiguousConflicts
         _declarationsOavailablePredicates = rule3521 _lhsIavailablePredicates
         _declarationsObetaUnique = rule3522 _lhsIbetaUnique
         _declarationsOclassEnvironment = rule3523 _lhsIclassEnvironment
         _declarationsOclassMemberEnv = rule3524 _lhsIclassMemberEnv
         _declarationsOclassMemberTypeSchemes = rule3525 _lhsIclassMemberTypeSchemes
         _declarationsOclassNamesEnv = rule3526 _lhsIclassNamesEnv
         _declarationsOclassPredicate = rule3527 _lhsIclassPredicate
         _declarationsOclassTypeSchemes = rule3528 _lhsIclassTypeSchemes
         _declarationsOcollectErrors = rule3529 _lhsIcollectErrors
         _declarationsOcollectWarnings = rule3530 _lhsIcollectWarnings
         _declarationsOcounter = rule3531 _lhsIcounter
         _declarationsOcurClassPred = rule3532 _lhsIcurClassPred
         _declarationsOcurPred = rule3533 _lhsIcurPred
         _declarationsOcurrentChunk = rule3534 _lhsIcurrentChunk
         _declarationsOdictionaryEnvironment = rule3535 _lhsIdictionaryEnvironment
         _declarationsOimportEnvironment = rule3536 _lhsIimportEnvironment
         _declarationsOinheritedBDG = rule3537 _inheritedBDG
         _declarationsOinstanceName = rule3538 _lhsIinstanceName
         _declarationsOinstanceTypes = rule3539 _lhsIinstanceTypes
         _declarationsOisTopLevel = rule3540 _isTopLevel
         _declarationsOmatchIO = rule3541 _lhsImatchIO
         _declarationsOmoduleName = rule3542 _lhsImoduleName
         _declarationsOmoduleQual = rule3543 _moduleQual
         _declarationsOmonos = rule3544 _lhsImonos
         _declarationsOnamesInScope = rule3545 _namesInScope
         _declarationsOorderedTypeSynonyms = rule3546 _lhsIorderedTypeSynonyms
         _declarationsOpatternMatchWarnings = rule3547 _lhsIpatternMatchWarnings
         _declarationsOrequiredPredicates = rule3548 _lhsIrequiredPredicates
         _declarationsOsubstitution = rule3549 _lhsIsubstitution
         _declarationsOtypeConstructors = rule3550 _lhsItypeConstructors
         _declarationsOtypeschemeMap = rule3551 _lhsItypeschemeMap
         _declarationsOuniqueChunk = rule3552 _lhsIuniqueChunk
         _declarationsOvariableMapping = rule3553 _lhsIvariableMapping
         !__result_ = T_MaybeDeclarations_vOut88 _lhsOassumptions _lhsObetaUnique _lhsOboundBetas _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraints _lhsOcounter _lhsOdeclVarNames _lhsOdictionaryEnvironment _lhsOinfoTrees _lhsOlocalTypes _lhsOmatchIO _lhsOnamesInScope _lhsOpatternMatchWarnings _lhsOself _lhsOtypeMemberBindings _lhsOunboundNames _lhsOuniqueChunk
         in __result_ )
     in C_MaybeDeclarations_s89 v88
   {-# INLINE rule3491 #-}
   rule3491 = \ ((_declarationsIdeclVarNames) :: Names) ((_declarationsIunboundNames) :: Names) ((_lhsInamesInScope) :: Names) ((_lhsIunboundNames) :: Names) ->
                                                               changeOfScope _declarationsIdeclVarNames (_declarationsIunboundNames ++ _lhsIunboundNames) _lhsInamesInScope
   {-# INLINE rule3492 #-}
   rule3492 = \ _unboundNames ->
                                  _unboundNames
   {-# INLINE rule3493 #-}
   rule3493 = \ ((_declarationsIdeclVarNames) :: Names) ->
                                                                _declarationsIdeclVarNames
   {-# INLINE rule3494 #-}
   rule3494 = \  (_ :: ()) ->
                                                                                                                                              internalError "PartialSyntax.ag" "n/a" "toplevel MaybeDeclaration"
   {-# INLINE rule3495 #-}
   rule3495 = \ _declInfo ((_declarationsIinfoTrees) :: InfoTrees) ((_lhsIparentTree) :: InfoTree) ->
                                 node _lhsIparentTree _declInfo _declarationsIinfoTrees
   {-# INLINE rule3496 #-}
   rule3496 = \ _theNode ->
                                 [_theNode]
   {-# INLINE rule3497 #-}
   rule3497 = \ _theNode ->
                                           _theNode
   {-# INLINE rule3498 #-}
   rule3498 = \ ((_declarationsIself) :: Declarations) ((_lhsImonos) :: Monos) ->
                          LocalInfo { self = UHA_Decls _declarationsIself
                                    , assignedType = Nothing
                                    , monos = _lhsImonos
                                    }
   {-# INLINE rule3499 #-}
   rule3499 = \ _implicitsFM ((_lhsItypeschemeMap) :: M.Map Int (Scheme Predicates)) ->
                                        findInferredTypes _lhsItypeschemeMap _implicitsFM
   {-# INLINE rule3500 #-}
   rule3500 = \ ((_declarationsIcollectWarnings) :: Warnings) ((_declarationsIsimplePatNames) :: Names) _inferredTypes ((_lhsIimportEnvironment) :: ImportEnvironment) ->
                                        missingTypeSignature False _declarationsIsimplePatNames _inferredTypes _lhsIimportEnvironment
                                        ++ _declarationsIcollectWarnings
   {-# INLINE rule3501 #-}
   rule3501 = \ ((_declarationsIcollectErrors) :: TypeErrors) ((_declarationsIrestrictedNames) :: Names) _inferredTypes ((_lhsIimportEnvironment) :: ImportEnvironment) ->
                                        restrictedNameErrors _lhsIimportEnvironment _inferredTypes _declarationsIrestrictedNames
                                        ++ _declarationsIcollectErrors
   {-# INLINE rule3502 #-}
   rule3502 = \ ((_declarationsIbindingGroups) :: BindingGroups) ((_declarationsItypeSignatures) :: TypeEnvironment) _inferredTypes ->
                                   makeLocalTypeEnv (_declarationsItypeSignatures `M.union` _inferredTypes) _declarationsIbindingGroups
   {-# INLINE rule3503 #-}
   rule3503 = \  (_ :: ()) ->
                                                                  M.empty
   {-# INLINE rule3504 #-}
   rule3504 = \ _chunkNr ->
                                                     _chunkNr
   {-# INLINE rule3505 #-}
   rule3505 = \  (_ :: ()) ->
                                        []
   {-# INLINE rule3506 #-}
   rule3506 = \ ((_declarationsIbetaUnique) :: Int) ((_declarationsIbindingGroups) :: BindingGroups) ((_declarationsItypeSignatures) :: TypeEnvironment) ((_declarationsIuniqueChunk) :: Int) ((_lhsIassumptions) :: Assumptions) ((_lhsIconstraints) :: ConstraintSet) ((_lhsIcurrentChunk) :: Int) ((_lhsImonos) :: Monos) ->
           let inputBDG   = (False, _lhsIcurrentChunk, _declarationsIuniqueChunk, _lhsImonos, _declarationsItypeSignatures, mybdggroup, _declarationsIbetaUnique)
               mybdggroup = Just (_lhsIassumptions, [_lhsIconstraints])
           in performBindingGroup inputBDG _declarationsIbindingGroups
   {-# INLINE rule3507 #-}
   rule3507 = \  (_ :: ()) ->
                               False
   {-# INLINE rule3508 #-}
   rule3508 = \ ((_declarationsIboundBetas) :: [(Name, Tp, [Tp])]) ->
     _declarationsIboundBetas
   {-# INLINE rule3509 #-}
   rule3509 = \ ((_declarationsIcollectInstances) :: [(Name, Instance)]) ->
     _declarationsIcollectInstances
   {-# INLINE rule3510 #-}
   rule3510 = \ ((_declarationsItypeMemberBindings) :: [(Name, TpScheme)]) ->
     _declarationsItypeMemberBindings
   {-# INLINE rule3511 #-}
   rule3511 = \ ((_declarationsIself) :: Declarations) ->
     MaybeDeclarations_Just _declarationsIself
   {-# INLINE rule3512 #-}
   rule3512 = \ _self ->
     _self
   {-# INLINE rule3513 #-}
   rule3513 = \ ((_declarationsIcounter) :: Int) ->
     _declarationsIcounter
   {-# INLINE rule3514 #-}
   rule3514 = \ ((_declarationsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _declarationsIdictionaryEnvironment
   {-# INLINE rule3515 #-}
   rule3515 = \ ((_declarationsImatchIO) :: IO ()) ->
     _declarationsImatchIO
   {-# INLINE rule3516 #-}
   rule3516 = \ _namesInScope ->
     _namesInScope
   {-# INLINE rule3517 #-}
   rule3517 = \ ((_declarationsIpatternMatchWarnings) :: [Warning]) ->
     _declarationsIpatternMatchWarnings
   {-# INLINE rule3518 #-}
   rule3518 = \ ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ->
     _lhsIallPatterns
   {-# INLINE rule3519 #-}
   rule3519 = \ ((_lhsIallTypeSchemes) :: M.Map NameWithRange TpScheme) ->
     _lhsIallTypeSchemes
   {-# INLINE rule3520 #-}
   rule3520 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule3521 #-}
   rule3521 = \ ((_lhsIavailablePredicates) :: [PredicateWithSource]) ->
     _lhsIavailablePredicates
   {-# INLINE rule3522 #-}
   rule3522 = \ ((_lhsIbetaUnique) :: Int) ->
     _lhsIbetaUnique
   {-# INLINE rule3523 #-}
   rule3523 = \ ((_lhsIclassEnvironment) :: ClassEnvironment) ->
     _lhsIclassEnvironment
   {-# INLINE rule3524 #-}
   rule3524 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule3525 #-}
   rule3525 = \ ((_lhsIclassMemberTypeSchemes) :: Maybe [(Name, TpScheme)]) ->
     _lhsIclassMemberTypeSchemes
   {-# INLINE rule3526 #-}
   rule3526 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule3527 #-}
   rule3527 = \ ((_lhsIclassPredicate) :: Maybe (Name, Names)) ->
     _lhsIclassPredicate
   {-# INLINE rule3528 #-}
   rule3528 = \ ((_lhsIclassTypeSchemes) :: M.Map Name TpScheme) ->
     _lhsIclassTypeSchemes
   {-# INLINE rule3529 #-}
   rule3529 = \ ((_lhsIcollectErrors) :: TypeErrors) ->
     _lhsIcollectErrors
   {-# INLINE rule3530 #-}
   rule3530 = \ ((_lhsIcollectWarnings) :: Warnings) ->
     _lhsIcollectWarnings
   {-# INLINE rule3531 #-}
   rule3531 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule3532 #-}
   rule3532 = \ ((_lhsIcurClassPred) :: Maybe Predicate) ->
     _lhsIcurClassPred
   {-# INLINE rule3533 #-}
   rule3533 = \ ((_lhsIcurPred) :: Maybe Predicate) ->
     _lhsIcurPred
   {-# INLINE rule3534 #-}
   rule3534 = \ ((_lhsIcurrentChunk) :: Int) ->
     _lhsIcurrentChunk
   {-# INLINE rule3535 #-}
   rule3535 = \ ((_lhsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _lhsIdictionaryEnvironment
   {-# INLINE rule3536 #-}
   rule3536 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule3537 #-}
   rule3537 = \ _inheritedBDG ->
     _inheritedBDG
   {-# INLINE rule3538 #-}
   rule3538 = \ ((_lhsIinstanceName) :: Maybe Name) ->
     _lhsIinstanceName
   {-# INLINE rule3539 #-}
   rule3539 = \ ((_lhsIinstanceTypes) :: [(Name, TpScheme)]) ->
     _lhsIinstanceTypes
   {-# INLINE rule3540 #-}
   rule3540 = \ _isTopLevel ->
     _isTopLevel
   {-# INLINE rule3541 #-}
   rule3541 = \ ((_lhsImatchIO) :: IO ()) ->
     _lhsImatchIO
   {-# INLINE rule3542 #-}
   rule3542 = \ ((_lhsImoduleName) :: Maybe Name) ->
     _lhsImoduleName
   {-# INLINE rule3543 #-}
   rule3543 = \ _moduleQual ->
     _moduleQual
   {-# INLINE rule3544 #-}
   rule3544 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule3545 #-}
   rule3545 = \ _namesInScope ->
     _namesInScope
   {-# INLINE rule3546 #-}
   rule3546 = \ ((_lhsIorderedTypeSynonyms) :: OrderedTypeSynonyms) ->
     _lhsIorderedTypeSynonyms
   {-# INLINE rule3547 #-}
   rule3547 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule3548 #-}
   rule3548 = \ ((_lhsIrequiredPredicates) :: Predicates) ->
     _lhsIrequiredPredicates
   {-# INLINE rule3549 #-}
   rule3549 = \ ((_lhsIsubstitution) :: FixpointSubstitution) ->
     _lhsIsubstitution
   {-# INLINE rule3550 #-}
   rule3550 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
   {-# INLINE rule3551 #-}
   rule3551 = \ ((_lhsItypeschemeMap) :: M.Map Int (Scheme Predicates)) ->
     _lhsItypeschemeMap
   {-# INLINE rule3552 #-}
   rule3552 = \ ((_lhsIuniqueChunk) :: Int) ->
     _lhsIuniqueChunk
   {-# INLINE rule3553 #-}
   rule3553 = \ ((_lhsIvariableMapping) :: Maybe [(Name, Tp)]) ->
     _lhsIvariableMapping

-- MaybeExports ------------------------------------------------
-- wrapper
data Inh_MaybeExports  = Inh_MaybeExports {  }
data Syn_MaybeExports  = Syn_MaybeExports { self_Syn_MaybeExports :: !(MaybeExports) }
{-# INLINABLE wrap_MaybeExports #-}
wrap_MaybeExports :: T_MaybeExports  -> Inh_MaybeExports  -> (Syn_MaybeExports )
wrap_MaybeExports !(T_MaybeExports act) !(Inh_MaybeExports ) =
   Control.Monad.Identity.runIdentity (
     do !sem <- act
        let arg91 = T_MaybeExports_vIn91 
        !(T_MaybeExports_vOut91 _lhsOself) <- return (inv_MaybeExports_s92 sem arg91)
        return (Syn_MaybeExports _lhsOself)
   )

-- cata
{-# NOINLINE sem_MaybeExports #-}
sem_MaybeExports :: MaybeExports  -> T_MaybeExports 
sem_MaybeExports ( MaybeExports_Nothing  ) = sem_MaybeExports_Nothing 
sem_MaybeExports ( MaybeExports_Just exports_ ) = sem_MaybeExports_Just ( sem_Exports exports_ )

-- semantic domain
newtype T_MaybeExports  = T_MaybeExports {
                                         attach_T_MaybeExports :: Identity (T_MaybeExports_s92 )
                                         }
newtype T_MaybeExports_s92  = C_MaybeExports_s92 {
                                                 inv_MaybeExports_s92 :: (T_MaybeExports_v91 )
                                                 }
data T_MaybeExports_s93  = C_MaybeExports_s93
type T_MaybeExports_v91  = (T_MaybeExports_vIn91 ) -> (T_MaybeExports_vOut91 )
data T_MaybeExports_vIn91  = T_MaybeExports_vIn91 
data T_MaybeExports_vOut91  = T_MaybeExports_vOut91 (MaybeExports)
{-# NOINLINE sem_MaybeExports_Nothing #-}
sem_MaybeExports_Nothing ::  T_MaybeExports 
sem_MaybeExports_Nothing  = T_MaybeExports (return st92) where
   {-# NOINLINE st92 #-}
   !st92 = let
      v91 :: T_MaybeExports_v91 
      v91 = \ !(T_MaybeExports_vIn91 ) -> ( let
         _self = rule3554  ()
         _lhsOself :: MaybeExports
         _lhsOself = rule3555 _self
         !__result_ = T_MaybeExports_vOut91 _lhsOself
         in __result_ )
     in C_MaybeExports_s92 v91
   {-# INLINE rule3554 #-}
   rule3554 = \  (_ :: ()) ->
     MaybeExports_Nothing
   {-# INLINE rule3555 #-}
   rule3555 = \ _self ->
     _self
{-# NOINLINE sem_MaybeExports_Just #-}
sem_MaybeExports_Just :: T_Exports  -> T_MaybeExports 
sem_MaybeExports_Just arg_exports_ = T_MaybeExports (return st92) where
   {-# NOINLINE st92 #-}
   !st92 = let
      v91 :: T_MaybeExports_v91 
      v91 = \ !(T_MaybeExports_vIn91 ) -> ( let
         _exportsX38 = Control.Monad.Identity.runIdentity (attach_T_Exports (arg_exports_))
         (T_Exports_vOut37 _exportsIself) = inv_Exports_s38 _exportsX38 (T_Exports_vIn37 )
         _self = rule3556 _exportsIself
         _lhsOself :: MaybeExports
         _lhsOself = rule3557 _self
         !__result_ = T_MaybeExports_vOut91 _lhsOself
         in __result_ )
     in C_MaybeExports_s92 v91
   {-# INLINE rule3556 #-}
   rule3556 = \ ((_exportsIself) :: Exports) ->
     MaybeExports_Just _exportsIself
   {-# INLINE rule3557 #-}
   rule3557 = \ _self ->
     _self

-- MaybeExpression ---------------------------------------------
-- wrapper
data Inh_MaybeExpression  = Inh_MaybeExpression { allPatterns_Inh_MaybeExpression :: !([((Expression, [String]), Core_TypingStrategy)]), allTypeSchemes_Inh_MaybeExpression :: !(M.Map NameWithRange TpScheme), ambiguousConflicts_Inh_MaybeExpression :: !([[Name]]), availablePredicates_Inh_MaybeExpression :: !([PredicateWithSource]), betaUnique_Inh_MaybeExpression :: !(Int), classEnvironment_Inh_MaybeExpression :: !(ClassEnvironment), classMemberEnv_Inh_MaybeExpression :: !(ClassMemberEnvironment), classMemberTypeSchemes_Inh_MaybeExpression :: !(Maybe [(Name, TpScheme)]), classNamesEnv_Inh_MaybeExpression :: !(ClassNameEnvironment), classPredicate_Inh_MaybeExpression :: !(Maybe (Name, Names)), classTypeSchemes_Inh_MaybeExpression :: !(M.Map Name TpScheme), collectErrors_Inh_MaybeExpression :: !(TypeErrors), collectWarnings_Inh_MaybeExpression :: !(Warnings), counter_Inh_MaybeExpression :: !(Int), curClassPred_Inh_MaybeExpression :: !(Maybe Predicate), curPred_Inh_MaybeExpression :: !(Maybe Predicate), currentChunk_Inh_MaybeExpression :: !(Int), dictionaryEnvironment_Inh_MaybeExpression :: !(DictionaryEnvironment), importEnvironment_Inh_MaybeExpression :: !(ImportEnvironment), instanceName_Inh_MaybeExpression :: !(Maybe Name), instanceTypes_Inh_MaybeExpression :: !([(Name, TpScheme)]), matchIO_Inh_MaybeExpression :: !(IO ()), moduleName_Inh_MaybeExpression :: !(Maybe Name), monos_Inh_MaybeExpression :: !(Monos), namesInScope_Inh_MaybeExpression :: !(Names), orderedTypeSynonyms_Inh_MaybeExpression :: !(OrderedTypeSynonyms), parentTree_Inh_MaybeExpression :: !(InfoTree), patternMatchWarnings_Inh_MaybeExpression :: !([Warning]), requiredPredicates_Inh_MaybeExpression :: !(Predicates), substitution_Inh_MaybeExpression :: !(FixpointSubstitution), tryPatterns_Inh_MaybeExpression :: !([(MaybeExpression, [String])]), typeConstructors_Inh_MaybeExpression :: !(TypeConstructorEnvironment), typeschemeMap_Inh_MaybeExpression :: !(M.Map Int (Scheme Predicates)), uniqueChunk_Inh_MaybeExpression :: !(Int), uniqueSecondRound_Inh_MaybeExpression :: !(Int), variableMapping_Inh_MaybeExpression :: !(Maybe [(Name, Tp)]) }
data Syn_MaybeExpression  = Syn_MaybeExpression { assumptions_Syn_MaybeExpression :: !(Assumptions), beta_Syn_MaybeExpression :: !(Tp), betaUnique_Syn_MaybeExpression :: !(Int), collectErrors_Syn_MaybeExpression :: !(TypeErrors), collectInstances_Syn_MaybeExpression :: !([(Name, Instance)]), collectWarnings_Syn_MaybeExpression :: !(Warnings), constraints_Syn_MaybeExpression :: !(ConstraintSet), counter_Syn_MaybeExpression :: !(Int), dictionaryEnvironment_Syn_MaybeExpression :: !(DictionaryEnvironment), infoTrees_Syn_MaybeExpression :: !(InfoTrees), matchIO_Syn_MaybeExpression :: !(IO ()), matches_Syn_MaybeExpression :: !([Maybe MetaVariableTable]), patternMatchWarnings_Syn_MaybeExpression :: !([Warning]), section_Syn_MaybeExpression :: !(Bool), self_Syn_MaybeExpression :: !(MaybeExpression), unboundNames_Syn_MaybeExpression :: !(Names), uniqueChunk_Syn_MaybeExpression :: !(Int), uniqueSecondRound_Syn_MaybeExpression :: !(Int) }
{-# INLINABLE wrap_MaybeExpression #-}
wrap_MaybeExpression :: T_MaybeExpression  -> Inh_MaybeExpression  -> (Syn_MaybeExpression )
wrap_MaybeExpression !(T_MaybeExpression act) !(Inh_MaybeExpression _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItryPatterns _lhsItypeConstructors _lhsItypeschemeMap _lhsIuniqueChunk _lhsIuniqueSecondRound _lhsIvariableMapping) =
   Control.Monad.Identity.runIdentity (
     do !sem <- act
        let arg94 = T_MaybeExpression_vIn94 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItryPatterns _lhsItypeConstructors _lhsItypeschemeMap _lhsIuniqueChunk _lhsIuniqueSecondRound _lhsIvariableMapping
        !(T_MaybeExpression_vOut94 _lhsOassumptions _lhsObeta _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraints _lhsOcounter _lhsOdictionaryEnvironment _lhsOinfoTrees _lhsOmatchIO _lhsOmatches _lhsOpatternMatchWarnings _lhsOsection _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOuniqueSecondRound) <- return (inv_MaybeExpression_s95 sem arg94)
        return (Syn_MaybeExpression _lhsOassumptions _lhsObeta _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraints _lhsOcounter _lhsOdictionaryEnvironment _lhsOinfoTrees _lhsOmatchIO _lhsOmatches _lhsOpatternMatchWarnings _lhsOsection _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOuniqueSecondRound)
   )

-- cata
{-# NOINLINE sem_MaybeExpression #-}
sem_MaybeExpression :: MaybeExpression  -> T_MaybeExpression 
sem_MaybeExpression ( MaybeExpression_Nothing  ) = sem_MaybeExpression_Nothing 
sem_MaybeExpression ( MaybeExpression_Just expression_ ) = sem_MaybeExpression_Just ( sem_Expression expression_ )

-- semantic domain
newtype T_MaybeExpression  = T_MaybeExpression {
                                               attach_T_MaybeExpression :: Identity (T_MaybeExpression_s95 )
                                               }
newtype T_MaybeExpression_s95  = C_MaybeExpression_s95 {
                                                       inv_MaybeExpression_s95 :: (T_MaybeExpression_v94 )
                                                       }
data T_MaybeExpression_s96  = C_MaybeExpression_s96
type T_MaybeExpression_v94  = (T_MaybeExpression_vIn94 ) -> (T_MaybeExpression_vOut94 )
data T_MaybeExpression_vIn94  = T_MaybeExpression_vIn94 ([((Expression, [String]), Core_TypingStrategy)]) (M.Map NameWithRange TpScheme) ([[Name]]) ([PredicateWithSource]) (Int) (ClassEnvironment) (ClassMemberEnvironment) (Maybe [(Name, TpScheme)]) (ClassNameEnvironment) (Maybe (Name, Names)) (M.Map Name TpScheme) (TypeErrors) (Warnings) (Int) (Maybe Predicate) (Maybe Predicate) (Int) (DictionaryEnvironment) (ImportEnvironment) (Maybe Name) ([(Name, TpScheme)]) (IO ()) (Maybe Name) (Monos) (Names) (OrderedTypeSynonyms) (InfoTree) ([Warning]) (Predicates) (FixpointSubstitution) ([(MaybeExpression, [String])]) (TypeConstructorEnvironment) (M.Map Int (Scheme Predicates)) (Int) (Int) (Maybe [(Name, Tp)])
data T_MaybeExpression_vOut94  = T_MaybeExpression_vOut94 (Assumptions) (Tp) (Int) (TypeErrors) ([(Name, Instance)]) (Warnings) (ConstraintSet) (Int) (DictionaryEnvironment) (InfoTrees) (IO ()) ([Maybe MetaVariableTable]) ([Warning]) (Bool) (MaybeExpression) (Names) (Int) (Int)
{-# NOINLINE sem_MaybeExpression_Nothing #-}
sem_MaybeExpression_Nothing ::  T_MaybeExpression 
sem_MaybeExpression_Nothing  = T_MaybeExpression (return st95) where
   {-# NOINLINE st95 #-}
   !st95 = let
      v94 :: T_MaybeExpression_v94 
      v94 = \ !(T_MaybeExpression_vIn94 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItryPatterns _lhsItypeConstructors _lhsItypeschemeMap _lhsIuniqueChunk _lhsIuniqueSecondRound _lhsIvariableMapping) -> ( let
         _lhsOmatches :: [Maybe MetaVariableTable]
         ((),_lhsOmatches,_,_,_,_) = rule3558 _lhsItryPatterns
         _lhsOinfoTrees :: InfoTrees
         _lhsOinfoTrees = rule3559  ()
         _lhsOsection :: Bool
         _lhsOsection = rule3560  ()
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule3561 _lhsIbetaUnique
         _lhsOassumptions :: Assumptions
         _lhsOassumptions = rule3562  ()
         _lhsOconstraints :: ConstraintSet
         _lhsOconstraints = rule3563  ()
         _beta = rule3564 _lhsIbetaUnique
         _lhsOcollectInstances :: [(Name, Instance)]
         _lhsOcollectInstances = rule3565  ()
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule3566  ()
         _self = rule3567  ()
         _lhsOself :: MaybeExpression
         _lhsOself = rule3568 _self
         _lhsObeta :: Tp
         _lhsObeta = rule3569 _beta
         _lhsOcollectErrors :: TypeErrors
         _lhsOcollectErrors = rule3570 _lhsIcollectErrors
         _lhsOcollectWarnings :: Warnings
         _lhsOcollectWarnings = rule3571 _lhsIcollectWarnings
         _lhsOcounter :: Int
         _lhsOcounter = rule3572 _lhsIcounter
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule3573 _lhsIdictionaryEnvironment
         _lhsOmatchIO :: IO ()
         _lhsOmatchIO = rule3574 _lhsImatchIO
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule3575 _lhsIpatternMatchWarnings
         _lhsOuniqueChunk :: Int
         _lhsOuniqueChunk = rule3576 _lhsIuniqueChunk
         _lhsOuniqueSecondRound :: Int
         _lhsOuniqueSecondRound = rule3577 _lhsIuniqueSecondRound
         !__result_ = T_MaybeExpression_vOut94 _lhsOassumptions _lhsObeta _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraints _lhsOcounter _lhsOdictionaryEnvironment _lhsOinfoTrees _lhsOmatchIO _lhsOmatches _lhsOpatternMatchWarnings _lhsOsection _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOuniqueSecondRound
         in __result_ )
     in C_MaybeExpression_s95 v94
   {-# INLINE rule3558 #-}
   rule3558 = \ ((_lhsItryPatterns) :: [(MaybeExpression, [String])]) ->
            match0' match_MaybeExpression_Nothing _lhsItryPatterns [] []
   {-# INLINE rule3559 #-}
   rule3559 = \  (_ :: ()) ->
                                 []
   {-# INLINE rule3560 #-}
   rule3560 = \  (_ :: ()) ->
                            True
   {-# INLINE rule3561 #-}
   rule3561 = \ ((_lhsIbetaUnique) :: Int) ->
                            _lhsIbetaUnique + 1
   {-# INLINE rule3562 #-}
   rule3562 = \  (_ :: ()) ->
                            noAssumptions
   {-# INLINE rule3563 #-}
   rule3563 = \  (_ :: ()) ->
                            emptyTree
   {-# INLINE rule3564 #-}
   rule3564 = \ ((_lhsIbetaUnique) :: Int) ->
                            TVar _lhsIbetaUnique
   {-# INLINE rule3565 #-}
   rule3565 = \  (_ :: ()) ->
     []
   {-# INLINE rule3566 #-}
   rule3566 = \  (_ :: ()) ->
     []
   {-# INLINE rule3567 #-}
   rule3567 = \  (_ :: ()) ->
     MaybeExpression_Nothing
   {-# INLINE rule3568 #-}
   rule3568 = \ _self ->
     _self
   {-# INLINE rule3569 #-}
   rule3569 = \ _beta ->
     _beta
   {-# INLINE rule3570 #-}
   rule3570 = \ ((_lhsIcollectErrors) :: TypeErrors) ->
     _lhsIcollectErrors
   {-# INLINE rule3571 #-}
   rule3571 = \ ((_lhsIcollectWarnings) :: Warnings) ->
     _lhsIcollectWarnings
   {-# INLINE rule3572 #-}
   rule3572 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule3573 #-}
   rule3573 = \ ((_lhsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _lhsIdictionaryEnvironment
   {-# INLINE rule3574 #-}
   rule3574 = \ ((_lhsImatchIO) :: IO ()) ->
     _lhsImatchIO
   {-# INLINE rule3575 #-}
   rule3575 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule3576 #-}
   rule3576 = \ ((_lhsIuniqueChunk) :: Int) ->
     _lhsIuniqueChunk
   {-# INLINE rule3577 #-}
   rule3577 = \ ((_lhsIuniqueSecondRound) :: Int) ->
     _lhsIuniqueSecondRound
{-# NOINLINE sem_MaybeExpression_Just #-}
sem_MaybeExpression_Just :: T_Expression  -> T_MaybeExpression 
sem_MaybeExpression_Just arg_expression_ = T_MaybeExpression (return st95) where
   {-# NOINLINE st95 #-}
   !st95 = let
      v94 :: T_MaybeExpression_v94 
      v94 = \ !(T_MaybeExpression_vIn94 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItryPatterns _lhsItypeConstructors _lhsItypeschemeMap _lhsIuniqueChunk _lhsIuniqueSecondRound _lhsIvariableMapping) -> ( let
         _expressionX41 = Control.Monad.Identity.runIdentity (attach_T_Expression (arg_expression_))
         (T_Expression_vOut40 _expressionIassumptions _expressionIbeta _expressionIbetaUnique _expressionIcollectErrors _expressionIcollectInstances _expressionIcollectWarnings _expressionIconstraints _expressionIcounter _expressionIdictionaryEnvironment _expressionIinfoTree _expressionImatchIO _expressionImatches _expressionIpatternMatchWarnings _expressionIself _expressionIunboundNames _expressionIuniqueChunk _expressionIuniqueSecondRound) = inv_Expression_s41 _expressionX41 (T_Expression_vIn40 _expressionOallPatterns _expressionOallTypeSchemes _expressionOambiguousConflicts _expressionOavailablePredicates _expressionObetaUnique _expressionOclassEnvironment _expressionOclassMemberEnv _expressionOclassMemberTypeSchemes _expressionOclassNamesEnv _expressionOclassPredicate _expressionOclassTypeSchemes _expressionOcollectErrors _expressionOcollectWarnings _expressionOcounter _expressionOcurClassPred _expressionOcurPred _expressionOcurrentChunk _expressionOdictionaryEnvironment _expressionOimportEnvironment _expressionOinstanceName _expressionOinstanceTypes _expressionOmatchIO _expressionOmoduleName _expressionOmonos _expressionOnamesInScope _expressionOorderedTypeSynonyms _expressionOparentTree _expressionOpatternMatchWarnings _expressionOrequiredPredicates _expressionOsubstitution _expressionOtryPatterns _expressionOtypeConstructors _expressionOtypeschemeMap _expressionOuniqueChunk _expressionOuniqueSecondRound _expressionOvariableMapping)
         _lhsOmatches :: [Maybe MetaVariableTable]
         (_expressionOtryPatterns,_lhsOmatches,_,_,_,_) = rule3578 _expressionImatches _lhsItryPatterns
         _lhsOinfoTrees :: InfoTrees
         _lhsOinfoTrees = rule3579 _expressionIinfoTree
         _lhsOsection :: Bool
         _lhsOsection = rule3580  ()
         _lhsOcollectInstances :: [(Name, Instance)]
         _lhsOcollectInstances = rule3581 _expressionIcollectInstances
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule3582 _expressionIunboundNames
         _self = rule3583 _expressionIself
         _lhsOself :: MaybeExpression
         _lhsOself = rule3584 _self
         _lhsOassumptions :: Assumptions
         _lhsOassumptions = rule3585 _expressionIassumptions
         _lhsObeta :: Tp
         _lhsObeta = rule3586 _expressionIbeta
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule3587 _expressionIbetaUnique
         _lhsOcollectErrors :: TypeErrors
         _lhsOcollectErrors = rule3588 _expressionIcollectErrors
         _lhsOcollectWarnings :: Warnings
         _lhsOcollectWarnings = rule3589 _expressionIcollectWarnings
         _lhsOconstraints :: ConstraintSet
         _lhsOconstraints = rule3590 _expressionIconstraints
         _lhsOcounter :: Int
         _lhsOcounter = rule3591 _expressionIcounter
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule3592 _expressionIdictionaryEnvironment
         _lhsOmatchIO :: IO ()
         _lhsOmatchIO = rule3593 _expressionImatchIO
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule3594 _expressionIpatternMatchWarnings
         _lhsOuniqueChunk :: Int
         _lhsOuniqueChunk = rule3595 _expressionIuniqueChunk
         _lhsOuniqueSecondRound :: Int
         _lhsOuniqueSecondRound = rule3596 _expressionIuniqueSecondRound
         _expressionOallPatterns = rule3597 _lhsIallPatterns
         _expressionOallTypeSchemes = rule3598 _lhsIallTypeSchemes
         _expressionOambiguousConflicts = rule3599 _lhsIambiguousConflicts
         _expressionOavailablePredicates = rule3600 _lhsIavailablePredicates
         _expressionObetaUnique = rule3601 _lhsIbetaUnique
         _expressionOclassEnvironment = rule3602 _lhsIclassEnvironment
         _expressionOclassMemberEnv = rule3603 _lhsIclassMemberEnv
         _expressionOclassMemberTypeSchemes = rule3604 _lhsIclassMemberTypeSchemes
         _expressionOclassNamesEnv = rule3605 _lhsIclassNamesEnv
         _expressionOclassPredicate = rule3606 _lhsIclassPredicate
         _expressionOclassTypeSchemes = rule3607 _lhsIclassTypeSchemes
         _expressionOcollectErrors = rule3608 _lhsIcollectErrors
         _expressionOcollectWarnings = rule3609 _lhsIcollectWarnings
         _expressionOcounter = rule3610 _lhsIcounter
         _expressionOcurClassPred = rule3611 _lhsIcurClassPred
         _expressionOcurPred = rule3612 _lhsIcurPred
         _expressionOcurrentChunk = rule3613 _lhsIcurrentChunk
         _expressionOdictionaryEnvironment = rule3614 _lhsIdictionaryEnvironment
         _expressionOimportEnvironment = rule3615 _lhsIimportEnvironment
         _expressionOinstanceName = rule3616 _lhsIinstanceName
         _expressionOinstanceTypes = rule3617 _lhsIinstanceTypes
         _expressionOmatchIO = rule3618 _lhsImatchIO
         _expressionOmoduleName = rule3619 _lhsImoduleName
         _expressionOmonos = rule3620 _lhsImonos
         _expressionOnamesInScope = rule3621 _lhsInamesInScope
         _expressionOorderedTypeSynonyms = rule3622 _lhsIorderedTypeSynonyms
         _expressionOparentTree = rule3623 _lhsIparentTree
         _expressionOpatternMatchWarnings = rule3624 _lhsIpatternMatchWarnings
         _expressionOrequiredPredicates = rule3625 _lhsIrequiredPredicates
         _expressionOsubstitution = rule3626 _lhsIsubstitution
         _expressionOtypeConstructors = rule3627 _lhsItypeConstructors
         _expressionOtypeschemeMap = rule3628 _lhsItypeschemeMap
         _expressionOuniqueChunk = rule3629 _lhsIuniqueChunk
         _expressionOuniqueSecondRound = rule3630 _lhsIuniqueSecondRound
         _expressionOvariableMapping = rule3631 _lhsIvariableMapping
         !__result_ = T_MaybeExpression_vOut94 _lhsOassumptions _lhsObeta _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraints _lhsOcounter _lhsOdictionaryEnvironment _lhsOinfoTrees _lhsOmatchIO _lhsOmatches _lhsOpatternMatchWarnings _lhsOsection _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOuniqueSecondRound
         in __result_ )
     in C_MaybeExpression_s95 v94
   {-# INLINE rule3578 #-}
   rule3578 = \ ((_expressionImatches) :: [Maybe MetaVariableTable]) ((_lhsItryPatterns) :: [(MaybeExpression, [String])]) ->
            match1' match_MaybeExpression_Just _lhsItryPatterns [] [_expressionImatches]
   {-# INLINE rule3579 #-}
   rule3579 = \ ((_expressionIinfoTree) :: InfoTree) ->
                                 [_expressionIinfoTree]
   {-# INLINE rule3580 #-}
   rule3580 = \  (_ :: ()) ->
                        False
   {-# INLINE rule3581 #-}
   rule3581 = \ ((_expressionIcollectInstances) :: [(Name, Instance)]) ->
     _expressionIcollectInstances
   {-# INLINE rule3582 #-}
   rule3582 = \ ((_expressionIunboundNames) :: Names) ->
     _expressionIunboundNames
   {-# INLINE rule3583 #-}
   rule3583 = \ ((_expressionIself) :: Expression) ->
     MaybeExpression_Just _expressionIself
   {-# INLINE rule3584 #-}
   rule3584 = \ _self ->
     _self
   {-# INLINE rule3585 #-}
   rule3585 = \ ((_expressionIassumptions) :: Assumptions) ->
     _expressionIassumptions
   {-# INLINE rule3586 #-}
   rule3586 = \ ((_expressionIbeta) :: Tp) ->
     _expressionIbeta
   {-# INLINE rule3587 #-}
   rule3587 = \ ((_expressionIbetaUnique) :: Int) ->
     _expressionIbetaUnique
   {-# INLINE rule3588 #-}
   rule3588 = \ ((_expressionIcollectErrors) :: TypeErrors) ->
     _expressionIcollectErrors
   {-# INLINE rule3589 #-}
   rule3589 = \ ((_expressionIcollectWarnings) :: Warnings) ->
     _expressionIcollectWarnings
   {-# INLINE rule3590 #-}
   rule3590 = \ ((_expressionIconstraints) :: ConstraintSet) ->
     _expressionIconstraints
   {-# INLINE rule3591 #-}
   rule3591 = \ ((_expressionIcounter) :: Int) ->
     _expressionIcounter
   {-# INLINE rule3592 #-}
   rule3592 = \ ((_expressionIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _expressionIdictionaryEnvironment
   {-# INLINE rule3593 #-}
   rule3593 = \ ((_expressionImatchIO) :: IO ()) ->
     _expressionImatchIO
   {-# INLINE rule3594 #-}
   rule3594 = \ ((_expressionIpatternMatchWarnings) :: [Warning]) ->
     _expressionIpatternMatchWarnings
   {-# INLINE rule3595 #-}
   rule3595 = \ ((_expressionIuniqueChunk) :: Int) ->
     _expressionIuniqueChunk
   {-# INLINE rule3596 #-}
   rule3596 = \ ((_expressionIuniqueSecondRound) :: Int) ->
     _expressionIuniqueSecondRound
   {-# INLINE rule3597 #-}
   rule3597 = \ ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ->
     _lhsIallPatterns
   {-# INLINE rule3598 #-}
   rule3598 = \ ((_lhsIallTypeSchemes) :: M.Map NameWithRange TpScheme) ->
     _lhsIallTypeSchemes
   {-# INLINE rule3599 #-}
   rule3599 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule3600 #-}
   rule3600 = \ ((_lhsIavailablePredicates) :: [PredicateWithSource]) ->
     _lhsIavailablePredicates
   {-# INLINE rule3601 #-}
   rule3601 = \ ((_lhsIbetaUnique) :: Int) ->
     _lhsIbetaUnique
   {-# INLINE rule3602 #-}
   rule3602 = \ ((_lhsIclassEnvironment) :: ClassEnvironment) ->
     _lhsIclassEnvironment
   {-# INLINE rule3603 #-}
   rule3603 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule3604 #-}
   rule3604 = \ ((_lhsIclassMemberTypeSchemes) :: Maybe [(Name, TpScheme)]) ->
     _lhsIclassMemberTypeSchemes
   {-# INLINE rule3605 #-}
   rule3605 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule3606 #-}
   rule3606 = \ ((_lhsIclassPredicate) :: Maybe (Name, Names)) ->
     _lhsIclassPredicate
   {-# INLINE rule3607 #-}
   rule3607 = \ ((_lhsIclassTypeSchemes) :: M.Map Name TpScheme) ->
     _lhsIclassTypeSchemes
   {-# INLINE rule3608 #-}
   rule3608 = \ ((_lhsIcollectErrors) :: TypeErrors) ->
     _lhsIcollectErrors
   {-# INLINE rule3609 #-}
   rule3609 = \ ((_lhsIcollectWarnings) :: Warnings) ->
     _lhsIcollectWarnings
   {-# INLINE rule3610 #-}
   rule3610 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule3611 #-}
   rule3611 = \ ((_lhsIcurClassPred) :: Maybe Predicate) ->
     _lhsIcurClassPred
   {-# INLINE rule3612 #-}
   rule3612 = \ ((_lhsIcurPred) :: Maybe Predicate) ->
     _lhsIcurPred
   {-# INLINE rule3613 #-}
   rule3613 = \ ((_lhsIcurrentChunk) :: Int) ->
     _lhsIcurrentChunk
   {-# INLINE rule3614 #-}
   rule3614 = \ ((_lhsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _lhsIdictionaryEnvironment
   {-# INLINE rule3615 #-}
   rule3615 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule3616 #-}
   rule3616 = \ ((_lhsIinstanceName) :: Maybe Name) ->
     _lhsIinstanceName
   {-# INLINE rule3617 #-}
   rule3617 = \ ((_lhsIinstanceTypes) :: [(Name, TpScheme)]) ->
     _lhsIinstanceTypes
   {-# INLINE rule3618 #-}
   rule3618 = \ ((_lhsImatchIO) :: IO ()) ->
     _lhsImatchIO
   {-# INLINE rule3619 #-}
   rule3619 = \ ((_lhsImoduleName) :: Maybe Name) ->
     _lhsImoduleName
   {-# INLINE rule3620 #-}
   rule3620 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule3621 #-}
   rule3621 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule3622 #-}
   rule3622 = \ ((_lhsIorderedTypeSynonyms) :: OrderedTypeSynonyms) ->
     _lhsIorderedTypeSynonyms
   {-# INLINE rule3623 #-}
   rule3623 = \ ((_lhsIparentTree) :: InfoTree) ->
     _lhsIparentTree
   {-# INLINE rule3624 #-}
   rule3624 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule3625 #-}
   rule3625 = \ ((_lhsIrequiredPredicates) :: Predicates) ->
     _lhsIrequiredPredicates
   {-# INLINE rule3626 #-}
   rule3626 = \ ((_lhsIsubstitution) :: FixpointSubstitution) ->
     _lhsIsubstitution
   {-# INLINE rule3627 #-}
   rule3627 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
   {-# INLINE rule3628 #-}
   rule3628 = \ ((_lhsItypeschemeMap) :: M.Map Int (Scheme Predicates)) ->
     _lhsItypeschemeMap
   {-# INLINE rule3629 #-}
   rule3629 = \ ((_lhsIuniqueChunk) :: Int) ->
     _lhsIuniqueChunk
   {-# INLINE rule3630 #-}
   rule3630 = \ ((_lhsIuniqueSecondRound) :: Int) ->
     _lhsIuniqueSecondRound
   {-# INLINE rule3631 #-}
   rule3631 = \ ((_lhsIvariableMapping) :: Maybe [(Name, Tp)]) ->
     _lhsIvariableMapping

-- MaybeImportSpecification ------------------------------------
-- wrapper
data Inh_MaybeImportSpecification  = Inh_MaybeImportSpecification {  }
data Syn_MaybeImportSpecification  = Syn_MaybeImportSpecification { self_Syn_MaybeImportSpecification :: !(MaybeImportSpecification) }
{-# INLINABLE wrap_MaybeImportSpecification #-}
wrap_MaybeImportSpecification :: T_MaybeImportSpecification  -> Inh_MaybeImportSpecification  -> (Syn_MaybeImportSpecification )
wrap_MaybeImportSpecification !(T_MaybeImportSpecification act) !(Inh_MaybeImportSpecification ) =
   Control.Monad.Identity.runIdentity (
     do !sem <- act
        let arg97 = T_MaybeImportSpecification_vIn97 
        !(T_MaybeImportSpecification_vOut97 _lhsOself) <- return (inv_MaybeImportSpecification_s98 sem arg97)
        return (Syn_MaybeImportSpecification _lhsOself)
   )

-- cata
{-# NOINLINE sem_MaybeImportSpecification #-}
sem_MaybeImportSpecification :: MaybeImportSpecification  -> T_MaybeImportSpecification 
sem_MaybeImportSpecification ( MaybeImportSpecification_Nothing  ) = sem_MaybeImportSpecification_Nothing 
sem_MaybeImportSpecification ( MaybeImportSpecification_Just importspecification_ ) = sem_MaybeImportSpecification_Just ( sem_ImportSpecification importspecification_ )

-- semantic domain
newtype T_MaybeImportSpecification  = T_MaybeImportSpecification {
                                                                 attach_T_MaybeImportSpecification :: Identity (T_MaybeImportSpecification_s98 )
                                                                 }
newtype T_MaybeImportSpecification_s98  = C_MaybeImportSpecification_s98 {
                                                                         inv_MaybeImportSpecification_s98 :: (T_MaybeImportSpecification_v97 )
                                                                         }
data T_MaybeImportSpecification_s99  = C_MaybeImportSpecification_s99
type T_MaybeImportSpecification_v97  = (T_MaybeImportSpecification_vIn97 ) -> (T_MaybeImportSpecification_vOut97 )
data T_MaybeImportSpecification_vIn97  = T_MaybeImportSpecification_vIn97 
data T_MaybeImportSpecification_vOut97  = T_MaybeImportSpecification_vOut97 (MaybeImportSpecification)
{-# NOINLINE sem_MaybeImportSpecification_Nothing #-}
sem_MaybeImportSpecification_Nothing ::  T_MaybeImportSpecification 
sem_MaybeImportSpecification_Nothing  = T_MaybeImportSpecification (return st98) where
   {-# NOINLINE st98 #-}
   !st98 = let
      v97 :: T_MaybeImportSpecification_v97 
      v97 = \ !(T_MaybeImportSpecification_vIn97 ) -> ( let
         _self = rule3632  ()
         _lhsOself :: MaybeImportSpecification
         _lhsOself = rule3633 _self
         !__result_ = T_MaybeImportSpecification_vOut97 _lhsOself
         in __result_ )
     in C_MaybeImportSpecification_s98 v97
   {-# INLINE rule3632 #-}
   rule3632 = \  (_ :: ()) ->
     MaybeImportSpecification_Nothing
   {-# INLINE rule3633 #-}
   rule3633 = \ _self ->
     _self
{-# NOINLINE sem_MaybeImportSpecification_Just #-}
sem_MaybeImportSpecification_Just :: T_ImportSpecification  -> T_MaybeImportSpecification 
sem_MaybeImportSpecification_Just arg_importspecification_ = T_MaybeImportSpecification (return st98) where
   {-# NOINLINE st98 #-}
   !st98 = let
      v97 :: T_MaybeImportSpecification_v97 
      v97 = \ !(T_MaybeImportSpecification_vIn97 ) -> ( let
         _importspecificationX77 = Control.Monad.Identity.runIdentity (attach_T_ImportSpecification (arg_importspecification_))
         (T_ImportSpecification_vOut76 _importspecificationIself) = inv_ImportSpecification_s77 _importspecificationX77 (T_ImportSpecification_vIn76 )
         _self = rule3634 _importspecificationIself
         _lhsOself :: MaybeImportSpecification
         _lhsOself = rule3635 _self
         !__result_ = T_MaybeImportSpecification_vOut97 _lhsOself
         in __result_ )
     in C_MaybeImportSpecification_s98 v97
   {-# INLINE rule3634 #-}
   rule3634 = \ ((_importspecificationIself) :: ImportSpecification) ->
     MaybeImportSpecification_Just _importspecificationIself
   {-# INLINE rule3635 #-}
   rule3635 = \ _self ->
     _self

-- MaybeInt ----------------------------------------------------
-- wrapper
data Inh_MaybeInt  = Inh_MaybeInt {  }
data Syn_MaybeInt  = Syn_MaybeInt { self_Syn_MaybeInt :: !(MaybeInt) }
{-# INLINABLE wrap_MaybeInt #-}
wrap_MaybeInt :: T_MaybeInt  -> Inh_MaybeInt  -> (Syn_MaybeInt )
wrap_MaybeInt !(T_MaybeInt act) !(Inh_MaybeInt ) =
   Control.Monad.Identity.runIdentity (
     do !sem <- act
        let arg100 = T_MaybeInt_vIn100 
        !(T_MaybeInt_vOut100 _lhsOself) <- return (inv_MaybeInt_s101 sem arg100)
        return (Syn_MaybeInt _lhsOself)
   )

-- cata
{-# NOINLINE sem_MaybeInt #-}
sem_MaybeInt :: MaybeInt  -> T_MaybeInt 
sem_MaybeInt ( MaybeInt_Nothing  ) = sem_MaybeInt_Nothing 
sem_MaybeInt ( MaybeInt_Just !int_ ) = sem_MaybeInt_Just int_

-- semantic domain
newtype T_MaybeInt  = T_MaybeInt {
                                 attach_T_MaybeInt :: Identity (T_MaybeInt_s101 )
                                 }
newtype T_MaybeInt_s101  = C_MaybeInt_s101 {
                                           inv_MaybeInt_s101 :: (T_MaybeInt_v100 )
                                           }
data T_MaybeInt_s102  = C_MaybeInt_s102
type T_MaybeInt_v100  = (T_MaybeInt_vIn100 ) -> (T_MaybeInt_vOut100 )
data T_MaybeInt_vIn100  = T_MaybeInt_vIn100 
data T_MaybeInt_vOut100  = T_MaybeInt_vOut100 (MaybeInt)
{-# NOINLINE sem_MaybeInt_Nothing #-}
sem_MaybeInt_Nothing ::  T_MaybeInt 
sem_MaybeInt_Nothing  = T_MaybeInt (return st101) where
   {-# NOINLINE st101 #-}
   !st101 = let
      v100 :: T_MaybeInt_v100 
      v100 = \ !(T_MaybeInt_vIn100 ) -> ( let
         _self = rule3636  ()
         _lhsOself :: MaybeInt
         _lhsOself = rule3637 _self
         !__result_ = T_MaybeInt_vOut100 _lhsOself
         in __result_ )
     in C_MaybeInt_s101 v100
   {-# INLINE rule3636 #-}
   rule3636 = \  (_ :: ()) ->
     MaybeInt_Nothing
   {-# INLINE rule3637 #-}
   rule3637 = \ _self ->
     _self
{-# NOINLINE sem_MaybeInt_Just #-}
sem_MaybeInt_Just :: (Int) -> T_MaybeInt 
sem_MaybeInt_Just !arg_int_ = T_MaybeInt (return st101) where
   {-# NOINLINE st101 #-}
   !st101 = let
      v100 :: T_MaybeInt_v100 
      v100 = \ !(T_MaybeInt_vIn100 ) -> ( let
         _self = rule3638 arg_int_
         _lhsOself :: MaybeInt
         _lhsOself = rule3639 _self
         !__result_ = T_MaybeInt_vOut100 _lhsOself
         in __result_ )
     in C_MaybeInt_s101 v100
   {-# INLINE rule3638 #-}
   rule3638 = \ int_ ->
     MaybeInt_Just int_
   {-# INLINE rule3639 #-}
   rule3639 = \ _self ->
     _self

-- MaybeName ---------------------------------------------------
-- wrapper
data Inh_MaybeName  = Inh_MaybeName {  }
data Syn_MaybeName  = Syn_MaybeName { isNothing_Syn_MaybeName :: !(Bool), name_Syn_MaybeName :: !( Maybe Name ), self_Syn_MaybeName :: !(MaybeName) }
{-# INLINABLE wrap_MaybeName #-}
wrap_MaybeName :: T_MaybeName  -> Inh_MaybeName  -> (Syn_MaybeName )
wrap_MaybeName !(T_MaybeName act) !(Inh_MaybeName ) =
   Control.Monad.Identity.runIdentity (
     do !sem <- act
        let arg103 = T_MaybeName_vIn103 
        !(T_MaybeName_vOut103 _lhsOisNothing _lhsOname _lhsOself) <- return (inv_MaybeName_s104 sem arg103)
        return (Syn_MaybeName _lhsOisNothing _lhsOname _lhsOself)
   )

-- cata
{-# NOINLINE sem_MaybeName #-}
sem_MaybeName :: MaybeName  -> T_MaybeName 
sem_MaybeName ( MaybeName_Nothing  ) = sem_MaybeName_Nothing 
sem_MaybeName ( MaybeName_Just name_ ) = sem_MaybeName_Just ( sem_Name name_ )

-- semantic domain
newtype T_MaybeName  = T_MaybeName {
                                   attach_T_MaybeName :: Identity (T_MaybeName_s104 )
                                   }
newtype T_MaybeName_s104  = C_MaybeName_s104 {
                                             inv_MaybeName_s104 :: (T_MaybeName_v103 )
                                             }
data T_MaybeName_s105  = C_MaybeName_s105
type T_MaybeName_v103  = (T_MaybeName_vIn103 ) -> (T_MaybeName_vOut103 )
data T_MaybeName_vIn103  = T_MaybeName_vIn103 
data T_MaybeName_vOut103  = T_MaybeName_vOut103 (Bool) ( Maybe Name ) (MaybeName)
{-# NOINLINE sem_MaybeName_Nothing #-}
sem_MaybeName_Nothing ::  T_MaybeName 
sem_MaybeName_Nothing  = T_MaybeName (return st104) where
   {-# NOINLINE st104 #-}
   !st104 = let
      v103 :: T_MaybeName_v103 
      v103 = \ !(T_MaybeName_vIn103 ) -> ( let
         _lhsOisNothing :: Bool
         _lhsOisNothing = rule3640  ()
         _lhsOname ::  Maybe Name 
         _lhsOname = rule3641  ()
         _self = rule3642  ()
         _lhsOself :: MaybeName
         _lhsOself = rule3643 _self
         !__result_ = T_MaybeName_vOut103 _lhsOisNothing _lhsOname _lhsOself
         in __result_ )
     in C_MaybeName_s104 v103
   {-# INLINE rule3640 #-}
   rule3640 = \  (_ :: ()) ->
                                            True
   {-# INLINE rule3641 #-}
   rule3641 = \  (_ :: ()) ->
                                            Nothing
   {-# INLINE rule3642 #-}
   rule3642 = \  (_ :: ()) ->
     MaybeName_Nothing
   {-# INLINE rule3643 #-}
   rule3643 = \ _self ->
     _self
{-# NOINLINE sem_MaybeName_Just #-}
sem_MaybeName_Just :: T_Name  -> T_MaybeName 
sem_MaybeName_Just arg_name_ = T_MaybeName (return st104) where
   {-# NOINLINE st104 #-}
   !st104 = let
      v103 :: T_MaybeName_v103 
      v103 = \ !(T_MaybeName_vIn103 ) -> ( let
         _nameX113 = Control.Monad.Identity.runIdentity (attach_T_Name (arg_name_))
         (T_Name_vOut112 _nameIself) = inv_Name_s113 _nameX113 (T_Name_vIn112 )
         _lhsOisNothing :: Bool
         _lhsOisNothing = rule3644  ()
         _lhsOname ::  Maybe Name 
         _lhsOname = rule3645 _nameIself
         _self = rule3646 _nameIself
         _lhsOself :: MaybeName
         _lhsOself = rule3647 _self
         !__result_ = T_MaybeName_vOut103 _lhsOisNothing _lhsOname _lhsOself
         in __result_ )
     in C_MaybeName_s104 v103
   {-# INLINE rule3644 #-}
   rule3644 = \  (_ :: ()) ->
                                            False
   {-# INLINE rule3645 #-}
   rule3645 = \ ((_nameIself) :: Name) ->
                                            Just _nameIself
   {-# INLINE rule3646 #-}
   rule3646 = \ ((_nameIself) :: Name) ->
     MaybeName_Just _nameIself
   {-# INLINE rule3647 #-}
   rule3647 = \ _self ->
     _self

-- MaybeNames --------------------------------------------------
-- wrapper
data Inh_MaybeNames  = Inh_MaybeNames {  }
data Syn_MaybeNames  = Syn_MaybeNames { self_Syn_MaybeNames :: !(MaybeNames) }
{-# INLINABLE wrap_MaybeNames #-}
wrap_MaybeNames :: T_MaybeNames  -> Inh_MaybeNames  -> (Syn_MaybeNames )
wrap_MaybeNames !(T_MaybeNames act) !(Inh_MaybeNames ) =
   Control.Monad.Identity.runIdentity (
     do !sem <- act
        let arg106 = T_MaybeNames_vIn106 
        !(T_MaybeNames_vOut106 _lhsOself) <- return (inv_MaybeNames_s107 sem arg106)
        return (Syn_MaybeNames _lhsOself)
   )

-- cata
{-# NOINLINE sem_MaybeNames #-}
sem_MaybeNames :: MaybeNames  -> T_MaybeNames 
sem_MaybeNames ( MaybeNames_Nothing  ) = sem_MaybeNames_Nothing 
sem_MaybeNames ( MaybeNames_Just names_ ) = sem_MaybeNames_Just ( sem_Names names_ )

-- semantic domain
newtype T_MaybeNames  = T_MaybeNames {
                                     attach_T_MaybeNames :: Identity (T_MaybeNames_s107 )
                                     }
newtype T_MaybeNames_s107  = C_MaybeNames_s107 {
                                               inv_MaybeNames_s107 :: (T_MaybeNames_v106 )
                                               }
data T_MaybeNames_s108  = C_MaybeNames_s108
type T_MaybeNames_v106  = (T_MaybeNames_vIn106 ) -> (T_MaybeNames_vOut106 )
data T_MaybeNames_vIn106  = T_MaybeNames_vIn106 
data T_MaybeNames_vOut106  = T_MaybeNames_vOut106 (MaybeNames)
{-# NOINLINE sem_MaybeNames_Nothing #-}
sem_MaybeNames_Nothing ::  T_MaybeNames 
sem_MaybeNames_Nothing  = T_MaybeNames (return st107) where
   {-# NOINLINE st107 #-}
   !st107 = let
      v106 :: T_MaybeNames_v106 
      v106 = \ !(T_MaybeNames_vIn106 ) -> ( let
         _self = rule3648  ()
         _lhsOself :: MaybeNames
         _lhsOself = rule3649 _self
         !__result_ = T_MaybeNames_vOut106 _lhsOself
         in __result_ )
     in C_MaybeNames_s107 v106
   {-# INLINE rule3648 #-}
   rule3648 = \  (_ :: ()) ->
     MaybeNames_Nothing
   {-# INLINE rule3649 #-}
   rule3649 = \ _self ->
     _self
{-# NOINLINE sem_MaybeNames_Just #-}
sem_MaybeNames_Just :: T_Names  -> T_MaybeNames 
sem_MaybeNames_Just arg_names_ = T_MaybeNames (return st107) where
   {-# NOINLINE st107 #-}
   !st107 = let
      v106 :: T_MaybeNames_v106 
      v106 = \ !(T_MaybeNames_vIn106 ) -> ( let
         _namesX116 = Control.Monad.Identity.runIdentity (attach_T_Names (arg_names_))
         (T_Names_vOut115 _namesIself) = inv_Names_s116 _namesX116 (T_Names_vIn115 )
         _self = rule3650 _namesIself
         _lhsOself :: MaybeNames
         _lhsOself = rule3651 _self
         !__result_ = T_MaybeNames_vOut106 _lhsOself
         in __result_ )
     in C_MaybeNames_s107 v106
   {-# INLINE rule3650 #-}
   rule3650 = \ ((_namesIself) :: Names) ->
     MaybeNames_Just _namesIself
   {-# INLINE rule3651 #-}
   rule3651 = \ _self ->
     _self

-- Module ------------------------------------------------------
-- wrapper
data Inh_Module  = Inh_Module { importEnvironment_Inh_Module :: !(ImportEnvironment), options_Inh_Module :: !([Option]) }
data Syn_Module  = Syn_Module { assumptions_Syn_Module :: !(Assumptions), dictionaryEnvironment_Syn_Module :: !(DictionaryEnvironment), infoTree_Syn_Module :: !(InfoTree), logEntries_Syn_Module :: !(LogEntries), self_Syn_Module :: !(Module), solveResult_Syn_Module :: !(SolveResult ConstraintInfo), toplevelTypes_Syn_Module :: !(TypeEnvironment), typeErrors_Syn_Module :: !(TypeErrors), warnings_Syn_Module :: !(Warnings) }
{-# INLINABLE wrap_Module #-}
wrap_Module :: T_Module  -> Inh_Module  -> (Syn_Module )
wrap_Module !(T_Module act) !(Inh_Module _lhsIimportEnvironment _lhsIoptions) =
   Control.Monad.Identity.runIdentity (
     do !sem <- act
        let arg109 = T_Module_vIn109 _lhsIimportEnvironment _lhsIoptions
        !(T_Module_vOut109 _lhsOassumptions _lhsOdictionaryEnvironment _lhsOinfoTree _lhsOlogEntries _lhsOself _lhsOsolveResult _lhsOtoplevelTypes _lhsOtypeErrors _lhsOwarnings) <- return (inv_Module_s110 sem arg109)
        return (Syn_Module _lhsOassumptions _lhsOdictionaryEnvironment _lhsOinfoTree _lhsOlogEntries _lhsOself _lhsOsolveResult _lhsOtoplevelTypes _lhsOtypeErrors _lhsOwarnings)
   )

-- cata
{-# INLINE sem_Module #-}
sem_Module :: Module  -> T_Module 
sem_Module ( Module_Module range_ name_ exports_ body_ ) = sem_Module_Module ( sem_Range range_ ) ( sem_MaybeName name_ ) ( sem_MaybeExports exports_ ) ( sem_Body body_ )

-- semantic domain
newtype T_Module  = T_Module {
                             attach_T_Module :: Identity (T_Module_s110 )
                             }
newtype T_Module_s110  = C_Module_s110 {
                                       inv_Module_s110 :: (T_Module_v109 )
                                       }
data T_Module_s111  = C_Module_s111
type T_Module_v109  = (T_Module_vIn109 ) -> (T_Module_vOut109 )
data T_Module_vIn109  = T_Module_vIn109 (ImportEnvironment) ([Option])
data T_Module_vOut109  = T_Module_vOut109 (Assumptions) (DictionaryEnvironment) (InfoTree) (LogEntries) (Module) (SolveResult ConstraintInfo) (TypeEnvironment) (TypeErrors) (Warnings)
{-# NOINLINE sem_Module_Module #-}
sem_Module_Module :: T_Range  -> T_MaybeName  -> T_MaybeExports  -> T_Body  -> T_Module 
sem_Module_Module arg_range_ arg_name_ arg_exports_ arg_body_ = T_Module (return st110) where
   {-# NOINLINE st110 #-}
   !st110 = let
      v109 :: T_Module_v109 
      v109 = \ !(T_Module_vIn109 _lhsIimportEnvironment _lhsIoptions) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _nameX104 = Control.Monad.Identity.runIdentity (attach_T_MaybeName (arg_name_))
         _exportsX92 = Control.Monad.Identity.runIdentity (attach_T_MaybeExports (arg_exports_))
         _bodyX14 = Control.Monad.Identity.runIdentity (attach_T_Body (arg_body_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_MaybeName_vOut103 _nameIisNothing _nameIname _nameIself) = inv_MaybeName_s104 _nameX104 (T_MaybeName_vIn103 )
         (T_MaybeExports_vOut91 _exportsIself) = inv_MaybeExports_s92 _exportsX92 (T_MaybeExports_vIn91 )
         (T_Body_vOut13 _bodyIassumptions _bodyIbetaUnique _bodyIclassMemberNames _bodyIcollectErrors _bodyIcollectInstances _bodyIcollectWarnings _bodyIconstraints _bodyIcounter _bodyIdeclVarNames _bodyIdictionaryEnvironment _bodyIinfoTree _bodyImatchIO _bodyIpatternMatchWarnings _bodyIself _bodyItoplevelTypes _bodyIunboundNames _bodyIuniqueChunk) = inv_Body_s14 _bodyX14 (T_Body_vIn13 _bodyOallPatterns _bodyOallTypeSchemes _bodyOambiguousConflicts _bodyOavailablePredicates _bodyObetaUnique _bodyOclassEnvironment _bodyOclassMemberEnv _bodyOclassMemberTypeSchemes _bodyOclassNamesEnv _bodyOclassPredicate _bodyOclassTypeSchemes _bodyOcollectErrors _bodyOcollectWarnings _bodyOcounter _bodyOcurClassPred _bodyOcurPred _bodyOcurrentChunk _bodyOdictionaryEnvironment _bodyOimportEnvironment _bodyOinstanceName _bodyOinstanceTypes _bodyOisTopLevel _bodyOmatchIO _bodyOmoduleName _bodyOmoduleQual _bodyOmonos _bodyOnamesInScope _bodyOorderedTypeSynonyms _bodyOpatternMatchWarnings _bodyOrequiredPredicates _bodyOsubstitution _bodyOtypeConstructors _bodyOtypeschemeMap _bodyOuniqueChunk _bodyOvariableMapping)
         _bodyOpatternMatchWarnings = rule3652  ()
         _bodyOmatchIO = rule3653  ()
         _bodyOallPatterns = rule3654 _lhsIimportEnvironment
         (_namesInScope,_unboundNames,_scopeInfo) = rule3655 _bodyIunboundNames _scopeNoConflicts
         (_scopeNoConflicts,_ambiguousConflicts) = rule3656 _declNoConflicts _initialScope
         (_declNoConflicts,_declDouble) = rule3657 _bodyIclassMemberNames _bodyIdeclVarNames _moduleQual
         _bodyOcounter = rule3658  ()
         _bodyOcollectWarnings = rule3659  ()
         _bodyOcollectErrors = rule3660  ()
         _bodyOclassTypeSchemes = rule3661  ()
         _bodyOallTypeSchemes = rule3662 _lhsIimportEnvironment
         _bodyOcurrentChunk = rule3663  ()
         _bodyOuniqueChunk = rule3664  ()
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule3665 _bodyIdictionaryEnvironment _lhsIoptions
         _bodyOdictionaryEnvironment = rule3666  ()
         _bodyOclassEnvironment = rule3667 _classEnv
         _bodyOclassMemberEnv = rule3668 _lhsIimportEnvironment
         _bodyOclassNamesEnv = rule3669 _lhsIimportEnvironment
         _bodyOavailablePredicates = rule3670  ()
         _bodyOinstanceName = rule3671  ()
         _bodyOclassPredicate = rule3672  ()
         _bodyOcurClassPred = rule3673  ()
         _bodyOcurPred = rule3674  ()
         (SolveResult _betaUniqueAtTheEnd _substitution _typeschemeMap _predicates _solveErrors) = rule3675 _solveResult
         (_solveResult,_logEntries) = rule3676 _bodyIbetaUnique _bodyIconstraints _classEnv _lhsIimportEnvironment _lhsIoptions _orderedTypeSynonyms
         _orderedTypeSynonyms = rule3677 _lhsIimportEnvironment
         _classEnv = rule3678 _bodyIcollectInstances _lhsIimportEnvironment
         _tyConEnv = rule3679 _lhsIimportEnvironment
         _typeErrors = rule3680 _tyConEnv _typeErrorsBase
         _typeErrorsBase = rule3681 _bodyIcollectErrors _classEnv _lhsIimportEnvironment _lhsIoptions _orderedTypeSynonyms _solveErrors _substitution
         _warnings = rule3682 _bodyIcollectWarnings
         _assumptions = rule3683 _bodyIassumptions _substitution
         _initialScope = rule3684 _lhsIimportEnvironment
         _monos = rule3685 _monomorphics
         _monomorphics = rule3686 _lhsIimportEnvironment
         _typeConstructors = rule3687 _lhsIimportEnvironment
         _classMemberTypeSchemes = rule3688  ()
         _bodyOtypeschemeMap = rule3689 _typeschemeMap
         _bodyObetaUnique = rule3690 _monomorphics
         _bodyOinstanceTypes = rule3691  ()
         _bodyOvariableMapping = rule3692  ()
         _bodyOrequiredPredicates = rule3693 _predicates
         _bodyOmoduleName = rule3694 _nameIname
         _lhsOwarnings :: Warnings
         _lhsOwarnings = rule3695 _bodyIpatternMatchWarnings _warnings
         _moduleQual = rule3696 _nameIname
         _isTopLevel = rule3697  ()
         _self = rule3698 _bodyIself _exportsIself _nameIself _rangeIself
         _lhsOself :: Module
         _lhsOself = rule3699 _self
         _lhsOassumptions :: Assumptions
         _lhsOassumptions = rule3700 _assumptions
         _lhsOinfoTree :: InfoTree
         _lhsOinfoTree = rule3701 _bodyIinfoTree
         _lhsOlogEntries :: LogEntries
         _lhsOlogEntries = rule3702 _logEntries
         _lhsOsolveResult :: SolveResult ConstraintInfo
         _lhsOsolveResult = rule3703 _solveResult
         _lhsOtoplevelTypes :: TypeEnvironment
         _lhsOtoplevelTypes = rule3704 _bodyItoplevelTypes
         _lhsOtypeErrors :: TypeErrors
         _lhsOtypeErrors = rule3705 _typeErrors
         _bodyOambiguousConflicts = rule3706 _ambiguousConflicts
         _bodyOclassMemberTypeSchemes = rule3707 _classMemberTypeSchemes
         _bodyOimportEnvironment = rule3708 _lhsIimportEnvironment
         _bodyOisTopLevel = rule3709 _isTopLevel
         _bodyOmoduleQual = rule3710 _moduleQual
         _bodyOmonos = rule3711 _monos
         _bodyOnamesInScope = rule3712 _namesInScope
         _bodyOorderedTypeSynonyms = rule3713 _orderedTypeSynonyms
         _bodyOsubstitution = rule3714 _substitution
         _bodyOtypeConstructors = rule3715 _typeConstructors
         !__result_ = T_Module_vOut109 _lhsOassumptions _lhsOdictionaryEnvironment _lhsOinfoTree _lhsOlogEntries _lhsOself _lhsOsolveResult _lhsOtoplevelTypes _lhsOtypeErrors _lhsOwarnings
         in __result_ )
     in C_Module_s110 v109
   {-# INLINE rule3652 #-}
   rule3652 = \  (_ :: ()) ->
                                              []
   {-# INLINE rule3653 #-}
   rule3653 = \  (_ :: ()) ->
                                        return ()
   {-# INLINE rule3654 #-}
   rule3654 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
                              [ (matchInfo, typingStrategy)
                              | typingStrategy <- typingStrategies _lhsIimportEnvironment
                              , matchInfo      <- matchInformation
                                                   _lhsIimportEnvironment
                                                   typingStrategy
                              ]
   {-# INLINE rule3655 #-}
   rule3655 = \ ((_bodyIunboundNames) :: Names) _scopeNoConflicts ->
                                                               changeOfScope (_scopeNoConflicts) _bodyIunboundNames []
   {-# INLINE rule3656 #-}
   rule3656 = \ _declNoConflicts _initialScope ->
                                                              uniqueAppearance (mergeSameOriginName (_initialScope ++ _declNoConflicts))
   {-# INLINE rule3657 #-}
   rule3657 = \ ((_bodyIclassMemberNames) :: Names) ((_bodyIdeclVarNames) :: Names) _moduleQual ->
                                                      (\(x,y) -> (concatMap (includeQualifiedName _moduleQual) x, y)) $ uniqueAppearance (_bodyIdeclVarNames ++ _bodyIclassMemberNames)
   {-# INLINE rule3658 #-}
   rule3658 = \  (_ :: ()) ->
                                0
   {-# INLINE rule3659 #-}
   rule3659 = \  (_ :: ()) ->
                                       []
   {-# INLINE rule3660 #-}
   rule3660 = \  (_ :: ()) ->
                                       []
   {-# INLINE rule3661 #-}
   rule3661 = \  (_ :: ()) ->
                                        M.empty
   {-# INLINE rule3662 #-}
   rule3662 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
                                      M.fromList [ (NameWithRange name, scheme) | (name, scheme) <- M.assocs (typeEnvironment _lhsIimportEnvironment) ]
   {-# INLINE rule3663 #-}
   rule3663 = \  (_ :: ()) ->
                                            0
   {-# INLINE rule3664 #-}
   rule3664 = \  (_ :: ()) ->
                                            1
   {-# INLINE rule3665 #-}
   rule3665 = \ ((_bodyIdictionaryEnvironment) :: DictionaryEnvironment) ((_lhsIoptions) :: [Option]) ->
                                        if Overloading `elem` _lhsIoptions
                                          then _bodyIdictionaryEnvironment
                                          else emptyDictionaryEnvironment
   {-# INLINE rule3666 #-}
   rule3666 = \  (_ :: ()) ->
                                        emptyDictionaryEnvironment
   {-# INLINE rule3667 #-}
   rule3667 = \ _classEnv ->
                                        _classEnv
   {-# INLINE rule3668 #-}
   rule3668 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
                                        classMemberEnvironment _lhsIimportEnvironment
   {-# INLINE rule3669 #-}
   rule3669 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
                                        classNameEnvironment _lhsIimportEnvironment
   {-# INLINE rule3670 #-}
   rule3670 = \  (_ :: ()) ->
                                        []
   {-# INLINE rule3671 #-}
   rule3671 = \  (_ :: ()) ->
                                        Nothing
   {-# INLINE rule3672 #-}
   rule3672 = \  (_ :: ()) ->
                                        Nothing
   {-# INLINE rule3673 #-}
   rule3673 = \  (_ :: ()) ->
                                        Nothing
   {-# INLINE rule3674 #-}
   rule3674 = \  (_ :: ()) ->
                                        Nothing
   {-# INLINE rule3675 #-}
   rule3675 = \ _solveResult ->
                                                                                                    _solveResult
   {-# INLINE rule3676 #-}
   rule3676 = \ ((_bodyIbetaUnique) :: Int) ((_bodyIconstraints) :: ConstraintSet) _classEnv ((_lhsIimportEnvironment) :: ImportEnvironment) ((_lhsIoptions) :: [Option]) _orderedTypeSynonyms ->
                  (selectConstraintSolver _lhsIoptions (setClassEnvironment _classEnv _lhsIimportEnvironment))
                     _classEnv
                     _orderedTypeSynonyms
                     _bodyIbetaUnique
                     _bodyIconstraints
   {-# INLINE rule3677 #-}
   rule3677 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
                                     getOrderedTypeSynonyms _lhsIimportEnvironment
   {-# INLINE rule3678 #-}
   rule3678 = \ ((_bodyIcollectInstances) :: [(Name, Instance)]) ((_lhsIimportEnvironment) :: ImportEnvironment) ->
                                     foldr (\(n, i) -> insertInstance (show n) i)
                                           (classEnvironment _lhsIimportEnvironment)
                                           _bodyIcollectInstances
   {-# INLINE rule3679 #-}
   rule3679 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
                                     typeConstructors _lhsIimportEnvironment
   {-# INLINE rule3680 #-}
   rule3680 = \ _tyConEnv _typeErrorsBase ->
                                     map (convertTypeError (fromQualName (convertMap _tyConEnv))) _typeErrorsBase
   {-# INLINE rule3681 #-}
   rule3681 = \ ((_bodyIcollectErrors) :: TypeErrors) _classEnv ((_lhsIimportEnvironment) :: ImportEnvironment) ((_lhsIoptions) :: [Option]) _orderedTypeSynonyms _solveErrors _substitution ->
                                      let unqualifier = unQualifyName _lhsIimportEnvironment
                                      in case makeTypeErrors _lhsIoptions _classEnv unqualifier _orderedTypeSynonyms _substitution _solveErrors of
                                          []   -> if NoOverloadingTypeCheck `elem` _lhsIoptions
                                                     then filter (\(TypeError _ ms _ _) -> not $ isInfixOf "Illegal overloaded type" $ show ms) _bodyIcollectErrors
                                                     else _bodyIcollectErrors
                                          errs -> reverse errs
   {-# INLINE rule3682 #-}
   rule3682 = \ ((_bodyIcollectWarnings) :: Warnings) ->
                                     _bodyIcollectWarnings
   {-# INLINE rule3683 #-}
   rule3683 = \ ((_bodyIassumptions) :: Assumptions) _substitution ->
                                     let f xs = [ (n, _substitution |-> tp) | (n, tp) <- xs ]
                                     in M.map f _bodyIassumptions
   {-# INLINE rule3684 #-}
   rule3684 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
                                     M.keys (typeEnvironment _lhsIimportEnvironment)
   {-# INLINE rule3685 #-}
   rule3685 = \ _monomorphics ->
                                     map TVar _monomorphics
   {-# INLINE rule3686 #-}
   rule3686 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
                                     ftv (  (map (\(_, scheme) -> scheme) $ M.elems $ valueConstructors _lhsIimportEnvironment)
                                         ++ (M.elems $ typeEnvironment   _lhsIimportEnvironment)
                                         )
   {-# INLINE rule3687 #-}
   rule3687 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
                                     typeConstructors _lhsIimportEnvironment
   {-# INLINE rule3688 #-}
   rule3688 = \  (_ :: ()) ->
                                        Nothing
   {-# INLINE rule3689 #-}
   rule3689 = \ _typeschemeMap ->
                               M.fromList (M.assocs _typeschemeMap)
   {-# INLINE rule3690 #-}
   rule3690 = \ _monomorphics ->
                                     if null _monomorphics
                                       then 0
                                       else maximum _monomorphics + 1
   {-# INLINE rule3691 #-}
   rule3691 = \  (_ :: ()) ->
                                    []
   {-# INLINE rule3692 #-}
   rule3692 = \  (_ :: ()) ->
                                    Nothing
   {-# INLINE rule3693 #-}
   rule3693 = \ _predicates ->
                                     _predicates
   {-# INLINE rule3694 #-}
   rule3694 = \ ((_nameIname) ::  Maybe Name ) ->
                             _nameIname
   {-# INLINE rule3695 #-}
   rule3695 = \ ((_bodyIpatternMatchWarnings) :: [Warning]) _warnings ->
                              _warnings     ++ _bodyIpatternMatchWarnings
   {-# INLINE rule3696 #-}
   rule3696 = \ ((_nameIname) ::  Maybe Name ) ->
                                         maybe ["Main"] getQualified _nameIname
   {-# INLINE rule3697 #-}
   rule3697 = \  (_ :: ()) ->
                                         True
   {-# INLINE rule3698 #-}
   rule3698 = \ ((_bodyIself) :: Body) ((_exportsIself) :: MaybeExports) ((_nameIself) :: MaybeName) ((_rangeIself) :: Range) ->
     Module_Module _rangeIself _nameIself _exportsIself _bodyIself
   {-# INLINE rule3699 #-}
   rule3699 = \ _self ->
     _self
   {-# INLINE rule3700 #-}
   rule3700 = \ _assumptions ->
     _assumptions
   {-# INLINE rule3701 #-}
   rule3701 = \ ((_bodyIinfoTree) :: InfoTree) ->
     _bodyIinfoTree
   {-# INLINE rule3702 #-}
   rule3702 = \ _logEntries ->
     _logEntries
   {-# INLINE rule3703 #-}
   rule3703 = \ _solveResult ->
     _solveResult
   {-# INLINE rule3704 #-}
   rule3704 = \ ((_bodyItoplevelTypes) :: TypeEnvironment) ->
     _bodyItoplevelTypes
   {-# INLINE rule3705 #-}
   rule3705 = \ _typeErrors ->
     _typeErrors
   {-# INLINE rule3706 #-}
   rule3706 = \ _ambiguousConflicts ->
     _ambiguousConflicts
   {-# INLINE rule3707 #-}
   rule3707 = \ _classMemberTypeSchemes ->
     _classMemberTypeSchemes
   {-# INLINE rule3708 #-}
   rule3708 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule3709 #-}
   rule3709 = \ _isTopLevel ->
     _isTopLevel
   {-# INLINE rule3710 #-}
   rule3710 = \ _moduleQual ->
     _moduleQual
   {-# INLINE rule3711 #-}
   rule3711 = \ _monos ->
     _monos
   {-# INLINE rule3712 #-}
   rule3712 = \ _namesInScope ->
     _namesInScope
   {-# INLINE rule3713 #-}
   rule3713 = \ _orderedTypeSynonyms ->
     _orderedTypeSynonyms
   {-# INLINE rule3714 #-}
   rule3714 = \ _substitution ->
     _substitution
   {-# INLINE rule3715 #-}
   rule3715 = \ _typeConstructors ->
     _typeConstructors

-- Name --------------------------------------------------------
-- wrapper
data Inh_Name  = Inh_Name {  }
data Syn_Name  = Syn_Name { self_Syn_Name :: !(Name) }
{-# INLINABLE wrap_Name #-}
wrap_Name :: T_Name  -> Inh_Name  -> (Syn_Name )
wrap_Name !(T_Name act) !(Inh_Name ) =
   Control.Monad.Identity.runIdentity (
     do !sem <- act
        let arg112 = T_Name_vIn112 
        !(T_Name_vOut112 _lhsOself) <- return (inv_Name_s113 sem arg112)
        return (Syn_Name _lhsOself)
   )

-- cata
{-# NOINLINE sem_Name #-}
sem_Name :: Name  -> T_Name 
sem_Name ( Name_Identifier range_ module_ !origin_ !name_ ) = sem_Name_Identifier ( sem_Range range_ ) ( sem_Strings module_ ) origin_ name_
sem_Name ( Name_Operator range_ module_ !origin_ !name_ ) = sem_Name_Operator ( sem_Range range_ ) ( sem_Strings module_ ) origin_ name_
sem_Name ( Name_Special range_ module_ !origin_ !name_ ) = sem_Name_Special ( sem_Range range_ ) ( sem_Strings module_ ) origin_ name_

-- semantic domain
newtype T_Name  = T_Name {
                         attach_T_Name :: Identity (T_Name_s113 )
                         }
newtype T_Name_s113  = C_Name_s113 {
                                   inv_Name_s113 :: (T_Name_v112 )
                                   }
data T_Name_s114  = C_Name_s114
type T_Name_v112  = (T_Name_vIn112 ) -> (T_Name_vOut112 )
data T_Name_vIn112  = T_Name_vIn112 
data T_Name_vOut112  = T_Name_vOut112 (Name)
{-# NOINLINE sem_Name_Identifier #-}
sem_Name_Identifier :: T_Range  -> T_Strings  -> (String) -> (String) -> T_Name 
sem_Name_Identifier arg_range_ arg_module_ !arg_origin_ !arg_name_ = T_Name (return st113) where
   {-# NOINLINE st113 #-}
   !st113 = let
      v112 :: T_Name_v112 
      v112 = \ !(T_Name_vIn112 ) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _moduleX161 = Control.Monad.Identity.runIdentity (attach_T_Strings (arg_module_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_Strings_vOut160 _moduleIself) = inv_Strings_s161 _moduleX161 (T_Strings_vIn160 )
         _self = rule3716 _moduleIself _rangeIself arg_name_ arg_origin_
         _lhsOself :: Name
         _lhsOself = rule3717 _self
         !__result_ = T_Name_vOut112 _lhsOself
         in __result_ )
     in C_Name_s113 v112
   {-# INLINE rule3716 #-}
   rule3716 = \ ((_moduleIself) :: Strings) ((_rangeIself) :: Range) name_ origin_ ->
     Name_Identifier _rangeIself _moduleIself origin_ name_
   {-# INLINE rule3717 #-}
   rule3717 = \ _self ->
     _self
{-# NOINLINE sem_Name_Operator #-}
sem_Name_Operator :: T_Range  -> T_Strings  -> (String) -> (String) -> T_Name 
sem_Name_Operator arg_range_ arg_module_ !arg_origin_ !arg_name_ = T_Name (return st113) where
   {-# NOINLINE st113 #-}
   !st113 = let
      v112 :: T_Name_v112 
      v112 = \ !(T_Name_vIn112 ) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _moduleX161 = Control.Monad.Identity.runIdentity (attach_T_Strings (arg_module_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_Strings_vOut160 _moduleIself) = inv_Strings_s161 _moduleX161 (T_Strings_vIn160 )
         _self = rule3718 _moduleIself _rangeIself arg_name_ arg_origin_
         _lhsOself :: Name
         _lhsOself = rule3719 _self
         !__result_ = T_Name_vOut112 _lhsOself
         in __result_ )
     in C_Name_s113 v112
   {-# INLINE rule3718 #-}
   rule3718 = \ ((_moduleIself) :: Strings) ((_rangeIself) :: Range) name_ origin_ ->
     Name_Operator _rangeIself _moduleIself origin_ name_
   {-# INLINE rule3719 #-}
   rule3719 = \ _self ->
     _self
{-# NOINLINE sem_Name_Special #-}
sem_Name_Special :: T_Range  -> T_Strings  -> (String) -> (String) -> T_Name 
sem_Name_Special arg_range_ arg_module_ !arg_origin_ !arg_name_ = T_Name (return st113) where
   {-# NOINLINE st113 #-}
   !st113 = let
      v112 :: T_Name_v112 
      v112 = \ !(T_Name_vIn112 ) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _moduleX161 = Control.Monad.Identity.runIdentity (attach_T_Strings (arg_module_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_Strings_vOut160 _moduleIself) = inv_Strings_s161 _moduleX161 (T_Strings_vIn160 )
         _self = rule3720 _moduleIself _rangeIself arg_name_ arg_origin_
         _lhsOself :: Name
         _lhsOself = rule3721 _self
         !__result_ = T_Name_vOut112 _lhsOself
         in __result_ )
     in C_Name_s113 v112
   {-# INLINE rule3720 #-}
   rule3720 = \ ((_moduleIself) :: Strings) ((_rangeIself) :: Range) name_ origin_ ->
     Name_Special _rangeIself _moduleIself origin_ name_
   {-# INLINE rule3721 #-}
   rule3721 = \ _self ->
     _self

-- Names -------------------------------------------------------
-- wrapper
data Inh_Names  = Inh_Names {  }
data Syn_Names  = Syn_Names { self_Syn_Names :: !(Names) }
{-# INLINABLE wrap_Names #-}
wrap_Names :: T_Names  -> Inh_Names  -> (Syn_Names )
wrap_Names !(T_Names act) !(Inh_Names ) =
   Control.Monad.Identity.runIdentity (
     do !sem <- act
        let arg115 = T_Names_vIn115 
        !(T_Names_vOut115 _lhsOself) <- return (inv_Names_s116 sem arg115)
        return (Syn_Names _lhsOself)
   )

-- cata
{-# NOINLINE sem_Names #-}
sem_Names :: Names  -> T_Names 
sem_Names list = Prelude.foldr sem_Names_Cons sem_Names_Nil (Prelude.map sem_Name list)

-- semantic domain
newtype T_Names  = T_Names {
                           attach_T_Names :: Identity (T_Names_s116 )
                           }
newtype T_Names_s116  = C_Names_s116 {
                                     inv_Names_s116 :: (T_Names_v115 )
                                     }
data T_Names_s117  = C_Names_s117
type T_Names_v115  = (T_Names_vIn115 ) -> (T_Names_vOut115 )
data T_Names_vIn115  = T_Names_vIn115 
data T_Names_vOut115  = T_Names_vOut115 (Names)
{-# NOINLINE sem_Names_Cons #-}
sem_Names_Cons :: T_Name  -> T_Names  -> T_Names 
sem_Names_Cons arg_hd_ arg_tl_ = T_Names (return st116) where
   {-# NOINLINE st116 #-}
   !st116 = let
      v115 :: T_Names_v115 
      v115 = \ !(T_Names_vIn115 ) -> ( let
         _hdX113 = Control.Monad.Identity.runIdentity (attach_T_Name (arg_hd_))
         _tlX116 = Control.Monad.Identity.runIdentity (attach_T_Names (arg_tl_))
         (T_Name_vOut112 _hdIself) = inv_Name_s113 _hdX113 (T_Name_vIn112 )
         (T_Names_vOut115 _tlIself) = inv_Names_s116 _tlX116 (T_Names_vIn115 )
         _self = rule3722 _hdIself _tlIself
         _lhsOself :: Names
         _lhsOself = rule3723 _self
         !__result_ = T_Names_vOut115 _lhsOself
         in __result_ )
     in C_Names_s116 v115
   {-# INLINE rule3722 #-}
   rule3722 = \ ((_hdIself) :: Name) ((_tlIself) :: Names) ->
     (:) _hdIself _tlIself
   {-# INLINE rule3723 #-}
   rule3723 = \ _self ->
     _self
{-# NOINLINE sem_Names_Nil #-}
sem_Names_Nil ::  T_Names 
sem_Names_Nil  = T_Names (return st116) where
   {-# NOINLINE st116 #-}
   !st116 = let
      v115 :: T_Names_v115 
      v115 = \ !(T_Names_vIn115 ) -> ( let
         _self = rule3724  ()
         _lhsOself :: Names
         _lhsOself = rule3725 _self
         !__result_ = T_Names_vOut115 _lhsOself
         in __result_ )
     in C_Names_s116 v115
   {-# INLINE rule3724 #-}
   rule3724 = \  (_ :: ()) ->
     []
   {-# INLINE rule3725 #-}
   rule3725 = \ _self ->
     _self

-- Pattern -----------------------------------------------------
-- wrapper
data Inh_Pattern  = Inh_Pattern { ambiguousConflicts_Inh_Pattern :: !([[Name]]), betaUnique_Inh_Pattern :: !(Int), counter_Inh_Pattern :: !(Int), importEnvironment_Inh_Pattern :: !(ImportEnvironment), monos_Inh_Pattern :: !(Monos), namesInScope_Inh_Pattern :: !(Names), parentTree_Inh_Pattern :: !(InfoTree), patternMatchWarnings_Inh_Pattern :: !([Warning]), typeConstructors_Inh_Pattern :: !(TypeConstructorEnvironment) }
data Syn_Pattern  = Syn_Pattern { beta_Syn_Pattern :: !(Tp), betaUnique_Syn_Pattern :: !(Int), constraints_Syn_Pattern :: !(ConstraintSet), counter_Syn_Pattern :: !(Int), elements_Syn_Pattern :: !(  [PatternElement]        ), environment_Syn_Pattern :: !(PatternAssumptions), infoTree_Syn_Pattern :: !(InfoTree), patVarNames_Syn_Pattern :: !(Names), patternMatchWarnings_Syn_Pattern :: !([Warning]), self_Syn_Pattern :: !(Pattern), unboundNames_Syn_Pattern :: !(Names) }
{-# INLINABLE wrap_Pattern #-}
wrap_Pattern :: T_Pattern  -> Inh_Pattern  -> (Syn_Pattern )
wrap_Pattern !(T_Pattern act) !(Inh_Pattern _lhsIambiguousConflicts _lhsIbetaUnique _lhsIcounter _lhsIimportEnvironment _lhsImonos _lhsInamesInScope _lhsIparentTree _lhsIpatternMatchWarnings _lhsItypeConstructors) =
   Control.Monad.Identity.runIdentity (
     do !sem <- act
        let arg118 = T_Pattern_vIn118 _lhsIambiguousConflicts _lhsIbetaUnique _lhsIcounter _lhsIimportEnvironment _lhsImonos _lhsInamesInScope _lhsIparentTree _lhsIpatternMatchWarnings _lhsItypeConstructors
        !(T_Pattern_vOut118 _lhsObeta _lhsObetaUnique _lhsOconstraints _lhsOcounter _lhsOelements _lhsOenvironment _lhsOinfoTree _lhsOpatVarNames _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames) <- return (inv_Pattern_s119 sem arg118)
        return (Syn_Pattern _lhsObeta _lhsObetaUnique _lhsOconstraints _lhsOcounter _lhsOelements _lhsOenvironment _lhsOinfoTree _lhsOpatVarNames _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames)
   )

-- cata
{-# NOINLINE sem_Pattern #-}
sem_Pattern :: Pattern  -> T_Pattern 
sem_Pattern ( Pattern_Hole range_ !id_ ) = sem_Pattern_Hole ( sem_Range range_ ) id_
sem_Pattern ( Pattern_Literal range_ literal_ ) = sem_Pattern_Literal ( sem_Range range_ ) ( sem_Literal literal_ )
sem_Pattern ( Pattern_Variable range_ name_ ) = sem_Pattern_Variable ( sem_Range range_ ) ( sem_Name name_ )
sem_Pattern ( Pattern_Constructor range_ name_ patterns_ ) = sem_Pattern_Constructor ( sem_Range range_ ) ( sem_Name name_ ) ( sem_Patterns patterns_ )
sem_Pattern ( Pattern_Parenthesized range_ pattern_ ) = sem_Pattern_Parenthesized ( sem_Range range_ ) ( sem_Pattern pattern_ )
sem_Pattern ( Pattern_InfixConstructor range_ leftPattern_ constructorOperator_ rightPattern_ ) = sem_Pattern_InfixConstructor ( sem_Range range_ ) ( sem_Pattern leftPattern_ ) ( sem_Name constructorOperator_ ) ( sem_Pattern rightPattern_ )
sem_Pattern ( Pattern_List range_ patterns_ ) = sem_Pattern_List ( sem_Range range_ ) ( sem_Patterns patterns_ )
sem_Pattern ( Pattern_Tuple range_ patterns_ ) = sem_Pattern_Tuple ( sem_Range range_ ) ( sem_Patterns patterns_ )
sem_Pattern ( Pattern_Record range_ name_ recordPatternBindings_ ) = sem_Pattern_Record ( sem_Range range_ ) ( sem_Name name_ ) ( sem_RecordPatternBindings recordPatternBindings_ )
sem_Pattern ( Pattern_Negate range_ literal_ ) = sem_Pattern_Negate ( sem_Range range_ ) ( sem_Literal literal_ )
sem_Pattern ( Pattern_As range_ name_ pattern_ ) = sem_Pattern_As ( sem_Range range_ ) ( sem_Name name_ ) ( sem_Pattern pattern_ )
sem_Pattern ( Pattern_Wildcard range_ ) = sem_Pattern_Wildcard ( sem_Range range_ )
sem_Pattern ( Pattern_Irrefutable range_ pattern_ ) = sem_Pattern_Irrefutable ( sem_Range range_ ) ( sem_Pattern pattern_ )
sem_Pattern ( Pattern_Successor range_ name_ literal_ ) = sem_Pattern_Successor ( sem_Range range_ ) ( sem_Name name_ ) ( sem_Literal literal_ )
sem_Pattern ( Pattern_NegateFloat range_ literal_ ) = sem_Pattern_NegateFloat ( sem_Range range_ ) ( sem_Literal literal_ )

-- semantic domain
newtype T_Pattern  = T_Pattern {
                               attach_T_Pattern :: Identity (T_Pattern_s119 )
                               }
newtype T_Pattern_s119  = C_Pattern_s119 {
                                         inv_Pattern_s119 :: (T_Pattern_v118 )
                                         }
data T_Pattern_s120  = C_Pattern_s120
type T_Pattern_v118  = (T_Pattern_vIn118 ) -> (T_Pattern_vOut118 )
data T_Pattern_vIn118  = T_Pattern_vIn118 ([[Name]]) (Int) (Int) (ImportEnvironment) (Monos) (Names) (InfoTree) ([Warning]) (TypeConstructorEnvironment)
data T_Pattern_vOut118  = T_Pattern_vOut118 (Tp) (Int) (ConstraintSet) (Int) (  [PatternElement]        ) (PatternAssumptions) (InfoTree) (Names) ([Warning]) (Pattern) (Names)
{-# NOINLINE sem_Pattern_Hole #-}
sem_Pattern_Hole :: T_Range  -> (String) -> T_Pattern 
sem_Pattern_Hole arg_range_ !arg_id_ = T_Pattern (return st119) where
   {-# NOINLINE st119 #-}
   !st119 = let
      v118 :: T_Pattern_v118 
      v118 = \ !(T_Pattern_vIn118 _lhsIambiguousConflicts _lhsIbetaUnique _lhsIcounter _lhsIimportEnvironment _lhsImonos _lhsInamesInScope _lhsIparentTree _lhsIpatternMatchWarnings _lhsItypeConstructors) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         _lhsOelements ::   [PatternElement]        
         _lhsOelements = rule3726  ()
         _lhsOpatVarNames :: Names
         _lhsOpatVarNames = rule3727 _i
         _parentTree = rule3728 _lhsIparentTree _localInfo
         _lhsOinfoTree :: InfoTree
         _lhsOinfoTree = rule3729 _parentTree
         _localInfo = rule3730 _beta _lhsImonos _self
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule3731 _lhsIbetaUnique
         _lhsOenvironment :: PatternAssumptions
         _lhsOenvironment = rule3732  ()
         _constraints = rule3733  ()
         _beta = rule3734 _lhsIbetaUnique
         _lhsOcounter :: Int
         _i :: Int
         (_lhsOcounter,_i) = rule3735 _lhsIcounter
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule3736  ()
         _self = rule3737 _rangeIself arg_id_
         _lhsOself :: Pattern
         _lhsOself = rule3738 _self
         _lhsObeta :: Tp
         _lhsObeta = rule3739 _beta
         _lhsOconstraints :: ConstraintSet
         _lhsOconstraints = rule3740 _constraints
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule3741 _lhsIpatternMatchWarnings
         !__result_ = T_Pattern_vOut118 _lhsObeta _lhsObetaUnique _lhsOconstraints _lhsOcounter _lhsOelements _lhsOenvironment _lhsOinfoTree _lhsOpatVarNames _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames
         in __result_ )
     in C_Pattern_s119 v118
   {-# INLINE rule3726 #-}
   rule3726 = \  (_ :: ()) ->
                                         [FiniteElement hole]
   {-# INLINE rule3727 #-}
   rule3727 = \ ((_i) :: Int) ->
                                     [ Name_Special noRange [] [] ("hole" ++ show _i    ) ]
   {-# INLINE rule3728 #-}
   rule3728 = \ ((_lhsIparentTree) :: InfoTree) _localInfo ->
                            node _lhsIparentTree _localInfo []
   {-# INLINE rule3729 #-}
   rule3729 = \ _parentTree ->
                            _parentTree
   {-# INLINE rule3730 #-}
   rule3730 = \ _beta ((_lhsImonos) :: Monos) _self ->
                            LocalInfo { self = UHA_Pat _self
                                      , assignedType = Just _beta
                                      , monos = _lhsImonos
                                      }
   {-# INLINE rule3731 #-}
   rule3731 = \ ((_lhsIbetaUnique) :: Int) ->
                            _lhsIbetaUnique + 1
   {-# INLINE rule3732 #-}
   rule3732 = \  (_ :: ()) ->
                            noAssumptions
   {-# INLINE rule3733 #-}
   rule3733 = \  (_ :: ()) ->
                            emptyTree
   {-# INLINE rule3734 #-}
   rule3734 = \ ((_lhsIbetaUnique) :: Int) ->
                            TVar _lhsIbetaUnique
   {-# INLINE rule3735 #-}
   rule3735 = \ ((_lhsIcounter) :: Int) ->
     let __cont = _lhsIcounter in seq __cont ( case nextUnique __cont of { (__cont, i) -> (__cont,i)} )
   {-# INLINE rule3736 #-}
   rule3736 = \  (_ :: ()) ->
     []
   {-# INLINE rule3737 #-}
   rule3737 = \ ((_rangeIself) :: Range) id_ ->
     Pattern_Hole _rangeIself id_
   {-# INLINE rule3738 #-}
   rule3738 = \ _self ->
     _self
   {-# INLINE rule3739 #-}
   rule3739 = \ _beta ->
     _beta
   {-# INLINE rule3740 #-}
   rule3740 = \ _constraints ->
     _constraints
   {-# INLINE rule3741 #-}
   rule3741 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
{-# NOINLINE sem_Pattern_Literal #-}
sem_Pattern_Literal :: T_Range  -> T_Literal  -> T_Pattern 
sem_Pattern_Literal arg_range_ arg_literal_ = T_Pattern (return st119) where
   {-# NOINLINE st119 #-}
   !st119 = let
      v118 :: T_Pattern_v118 
      v118 = \ !(T_Pattern_vIn118 _lhsIambiguousConflicts _lhsIbetaUnique _lhsIcounter _lhsIimportEnvironment _lhsImonos _lhsInamesInScope _lhsIparentTree _lhsIpatternMatchWarnings _lhsItypeConstructors) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _literalX86 = Control.Monad.Identity.runIdentity (attach_T_Literal (arg_literal_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_Literal_vOut85 _literalIelements _literalIliteralType _literalIself) = inv_Literal_s86 _literalX86 (T_Literal_vIn85 )
         _parentTree = rule3742 _lhsIparentTree _localInfo
         _lhsOinfoTree :: InfoTree
         _lhsOinfoTree = rule3743 _parentTree
         _localInfo = rule3744 _beta _lhsImonos _self
         _cinfo = rule3745 _parentTree
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule3746 _lhsIbetaUnique
         _lhsOenvironment :: PatternAssumptions
         _lhsOenvironment = rule3747  ()
         _constraints = rule3748 _beta _cinfo _literalIliteralType
         _beta = rule3749 _lhsIbetaUnique
         _lhsOpatVarNames :: Names
         _lhsOpatVarNames = rule3750  ()
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule3751  ()
         _self = rule3752 _literalIself _rangeIself
         _lhsOself :: Pattern
         _lhsOself = rule3753 _self
         _lhsObeta :: Tp
         _lhsObeta = rule3754 _beta
         _lhsOconstraints :: ConstraintSet
         _lhsOconstraints = rule3755 _constraints
         _lhsOcounter :: Int
         _lhsOcounter = rule3756 _lhsIcounter
         _lhsOelements ::   [PatternElement]        
         _lhsOelements = rule3757 _literalIelements
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule3758 _lhsIpatternMatchWarnings
         !__result_ = T_Pattern_vOut118 _lhsObeta _lhsObetaUnique _lhsOconstraints _lhsOcounter _lhsOelements _lhsOenvironment _lhsOinfoTree _lhsOpatVarNames _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames
         in __result_ )
     in C_Pattern_s119 v118
   {-# INLINE rule3742 #-}
   rule3742 = \ ((_lhsIparentTree) :: InfoTree) _localInfo ->
                            node _lhsIparentTree _localInfo []
   {-# INLINE rule3743 #-}
   rule3743 = \ _parentTree ->
                            _parentTree
   {-# INLINE rule3744 #-}
   rule3744 = \ _beta ((_lhsImonos) :: Monos) _self ->
                            LocalInfo { self = UHA_Pat _self
                                      , assignedType = Just _beta
                                      , monos = _lhsImonos
                                      }
   {-# INLINE rule3745 #-}
   rule3745 = \ _parentTree ->
     resultConstraint "literal pattern" _parentTree
        [ FolkloreConstraint, HasTrustFactor 10.0 ]
   {-# INLINE rule3746 #-}
   rule3746 = \ ((_lhsIbetaUnique) :: Int) ->
                            _lhsIbetaUnique + 1
   {-# INLINE rule3747 #-}
   rule3747 = \  (_ :: ()) ->
                            noAssumptions
   {-# INLINE rule3748 #-}
   rule3748 = \ _beta _cinfo ((_literalIliteralType) :: Tp) ->
                            unitTree ((_literalIliteralType .==. _beta) _cinfo)
   {-# INLINE rule3749 #-}
   rule3749 = \ ((_lhsIbetaUnique) :: Int) ->
                            TVar _lhsIbetaUnique
   {-# INLINE rule3750 #-}
   rule3750 = \  (_ :: ()) ->
     []
   {-# INLINE rule3751 #-}
   rule3751 = \  (_ :: ()) ->
     []
   {-# INLINE rule3752 #-}
   rule3752 = \ ((_literalIself) :: Literal) ((_rangeIself) :: Range) ->
     Pattern_Literal _rangeIself _literalIself
   {-# INLINE rule3753 #-}
   rule3753 = \ _self ->
     _self
   {-# INLINE rule3754 #-}
   rule3754 = \ _beta ->
     _beta
   {-# INLINE rule3755 #-}
   rule3755 = \ _constraints ->
     _constraints
   {-# INLINE rule3756 #-}
   rule3756 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule3757 #-}
   rule3757 = \ ((_literalIelements) ::   [PatternElement]        ) ->
     _literalIelements
   {-# INLINE rule3758 #-}
   rule3758 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
{-# NOINLINE sem_Pattern_Variable #-}
sem_Pattern_Variable :: T_Range  -> T_Name  -> T_Pattern 
sem_Pattern_Variable arg_range_ arg_name_ = T_Pattern (return st119) where
   {-# NOINLINE st119 #-}
   !st119 = let
      v118 :: T_Pattern_v118 
      v118 = \ !(T_Pattern_vIn118 _lhsIambiguousConflicts _lhsIbetaUnique _lhsIcounter _lhsIimportEnvironment _lhsImonos _lhsInamesInScope _lhsIparentTree _lhsIpatternMatchWarnings _lhsItypeConstructors) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _nameX113 = Control.Monad.Identity.runIdentity (attach_T_Name (arg_name_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_Name_vOut112 _nameIself) = inv_Name_s113 _nameX113 (T_Name_vIn112 )
         _lhsOelements ::   [PatternElement]        
         _lhsOelements = rule3759  ()
         _lhsOpatVarNames :: Names
         _lhsOpatVarNames = rule3760 _nameIself
         _parentTree = rule3761 _lhsIparentTree _localInfo
         _lhsOinfoTree :: InfoTree
         _lhsOinfoTree = rule3762 _parentTree
         _localInfo = rule3763 _beta _lhsImonos _self
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule3764 _lhsIbetaUnique
         _lhsOenvironment :: PatternAssumptions
         _lhsOenvironment = rule3765 _beta _nameIself
         _constraints = rule3766 _lhsIbetaUnique
         _beta = rule3767 _lhsIbetaUnique
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule3768  ()
         _self = rule3769 _nameIself _rangeIself
         _lhsOself :: Pattern
         _lhsOself = rule3770 _self
         _lhsObeta :: Tp
         _lhsObeta = rule3771 _beta
         _lhsOconstraints :: ConstraintSet
         _lhsOconstraints = rule3772 _constraints
         _lhsOcounter :: Int
         _lhsOcounter = rule3773 _lhsIcounter
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule3774 _lhsIpatternMatchWarnings
         !__result_ = T_Pattern_vOut118 _lhsObeta _lhsObetaUnique _lhsOconstraints _lhsOcounter _lhsOelements _lhsOenvironment _lhsOinfoTree _lhsOpatVarNames _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames
         in __result_ )
     in C_Pattern_s119 v118
   {-# INLINE rule3759 #-}
   rule3759 = \  (_ :: ()) ->
                                         [WildcardElement]
   {-# INLINE rule3760 #-}
   rule3760 = \ ((_nameIself) :: Name) ->
                                     [ _nameIself ]
   {-# INLINE rule3761 #-}
   rule3761 = \ ((_lhsIparentTree) :: InfoTree) _localInfo ->
                            node _lhsIparentTree _localInfo []
   {-# INLINE rule3762 #-}
   rule3762 = \ _parentTree ->
                            _parentTree
   {-# INLINE rule3763 #-}
   rule3763 = \ _beta ((_lhsImonos) :: Monos) _self ->
                            LocalInfo { self = UHA_Pat _self
                                      , assignedType = Just _beta
                                      , monos = _lhsImonos
                                      }
   {-# INLINE rule3764 #-}
   rule3764 = \ ((_lhsIbetaUnique) :: Int) ->
                            _lhsIbetaUnique + 1
   {-# INLINE rule3765 #-}
   rule3765 = \ _beta ((_nameIself) :: Name) ->
                            M.singleton _nameIself _beta
   {-# INLINE rule3766 #-}
   rule3766 = \ ((_lhsIbetaUnique) :: Int) ->
                            Receive _lhsIbetaUnique
   {-# INLINE rule3767 #-}
   rule3767 = \ ((_lhsIbetaUnique) :: Int) ->
                            TVar _lhsIbetaUnique
   {-# INLINE rule3768 #-}
   rule3768 = \  (_ :: ()) ->
     []
   {-# INLINE rule3769 #-}
   rule3769 = \ ((_nameIself) :: Name) ((_rangeIself) :: Range) ->
     Pattern_Variable _rangeIself _nameIself
   {-# INLINE rule3770 #-}
   rule3770 = \ _self ->
     _self
   {-# INLINE rule3771 #-}
   rule3771 = \ _beta ->
     _beta
   {-# INLINE rule3772 #-}
   rule3772 = \ _constraints ->
     _constraints
   {-# INLINE rule3773 #-}
   rule3773 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule3774 #-}
   rule3774 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
{-# NOINLINE sem_Pattern_Constructor #-}
sem_Pattern_Constructor :: T_Range  -> T_Name  -> T_Patterns  -> T_Pattern 
sem_Pattern_Constructor arg_range_ arg_name_ arg_patterns_ = T_Pattern (return st119) where
   {-# NOINLINE st119 #-}
   !st119 = let
      v118 :: T_Pattern_v118 
      v118 = \ !(T_Pattern_vIn118 _lhsIambiguousConflicts _lhsIbetaUnique _lhsIcounter _lhsIimportEnvironment _lhsImonos _lhsInamesInScope _lhsIparentTree _lhsIpatternMatchWarnings _lhsItypeConstructors) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _nameX113 = Control.Monad.Identity.runIdentity (attach_T_Name (arg_name_))
         _patternsX122 = Control.Monad.Identity.runIdentity (attach_T_Patterns (arg_patterns_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_Name_vOut112 _nameIself) = inv_Name_s113 _nameX113 (T_Name_vIn112 )
         (T_Patterns_vOut121 _patternsIbetaUnique _patternsIbetas _patternsIconstraintslist _patternsIcounter _patternsIelementss _patternsIenvironment _patternsIinfoTrees _patternsInumberOfPatterns _patternsIpatVarNames _patternsIpatternMatchWarnings _patternsIself _patternsIunboundNames) = inv_Patterns_s122 _patternsX122 (T_Patterns_vIn121 _patternsOambiguousConflicts _patternsObetaUnique _patternsOcounter _patternsOimportEnvironment _patternsOmonos _patternsOnamesInScope _patternsOparentTree _patternsOpatternMatchWarnings _patternsOtypeConstructors)
         _lhsOelements ::   [PatternElement]        
         _lhsOelements = rule3775 _nameIself _patternsIelementss
         _parentTree = rule3776 _lhsIparentTree _localInfo _patternsIinfoTrees
         _lhsOinfoTree :: InfoTree
         _lhsOinfoTree = rule3777 _parentTree
         _localInfo = rule3778 _beta _lhsImonos _self
         _cinfoConstructor = rule3779 _parentTree
         _cinfoApply = rule3780 _localInfo _nameIself _parentTree _patternsIinfoTrees
         _cinfoEmpty = rule3781 _parentTree
         _patternsObetaUnique = rule3782 _lhsIbetaUnique
         _constraints = rule3783 _conApply _conConstructor _patternsIconstraintslist
         _beta = rule3784 _lhsIbetaUnique
         _betaCon = rule3785 _lhsIbetaUnique
         _conApply = rule3786 _beta _betaCon _cinfoApply _cinfoEmpty _patternsIbetas _patternsInumberOfPatterns
         _conConstructor = rule3787 _betaCon _cinfoConstructor _lhsIimportEnvironment _nameIself
         _lhsOpatVarNames :: Names
         _lhsOpatVarNames = rule3788 _patternsIpatVarNames
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule3789 _patternsIunboundNames
         _self = rule3790 _nameIself _patternsIself _rangeIself
         _lhsOself :: Pattern
         _lhsOself = rule3791 _self
         _lhsObeta :: Tp
         _lhsObeta = rule3792 _beta
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule3793 _patternsIbetaUnique
         _lhsOconstraints :: ConstraintSet
         _lhsOconstraints = rule3794 _constraints
         _lhsOcounter :: Int
         _lhsOcounter = rule3795 _patternsIcounter
         _lhsOenvironment :: PatternAssumptions
         _lhsOenvironment = rule3796 _patternsIenvironment
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule3797 _patternsIpatternMatchWarnings
         _patternsOambiguousConflicts = rule3798 _lhsIambiguousConflicts
         _patternsOcounter = rule3799 _lhsIcounter
         _patternsOimportEnvironment = rule3800 _lhsIimportEnvironment
         _patternsOmonos = rule3801 _lhsImonos
         _patternsOnamesInScope = rule3802 _lhsInamesInScope
         _patternsOparentTree = rule3803 _parentTree
         _patternsOpatternMatchWarnings = rule3804 _lhsIpatternMatchWarnings
         _patternsOtypeConstructors = rule3805 _lhsItypeConstructors
         !__result_ = T_Pattern_vOut118 _lhsObeta _lhsObetaUnique _lhsOconstraints _lhsOcounter _lhsOelements _lhsOenvironment _lhsOinfoTree _lhsOpatVarNames _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames
         in __result_ )
     in C_Pattern_s119 v118
   {-# INLINE rule3775 #-}
   rule3775 = \ ((_nameIself) :: Name) ((_patternsIelementss) :: [ [PatternElement]       ]) ->
                                         FiniteElement (getOnlyName _nameIself) : concat _patternsIelementss
   {-# INLINE rule3776 #-}
   rule3776 = \ ((_lhsIparentTree) :: InfoTree) _localInfo ((_patternsIinfoTrees) :: InfoTrees) ->
                            node _lhsIparentTree _localInfo _patternsIinfoTrees
   {-# INLINE rule3777 #-}
   rule3777 = \ _parentTree ->
                            _parentTree
   {-# INLINE rule3778 #-}
   rule3778 = \ _beta ((_lhsImonos) :: Monos) _self ->
                            LocalInfo { self = UHA_Pat _self
                                      , assignedType = Just _beta
                                      , monos = _lhsImonos
                                      }
   {-# INLINE rule3779 #-}
   rule3779 = \ _parentTree ->
     resultConstraint "pattern constructor" _parentTree
        [ FolkloreConstraint, HasTrustFactor 10.0 ]
   {-# INLINE rule3780 #-}
   rule3780 = \ _localInfo ((_nameIself) :: Name) _parentTree ((_patternsIinfoTrees) :: InfoTrees) ->
     specialConstraint "pattern application" _parentTree
        (self _localInfo, Just $ nameToUHA_Pat _nameIself)
        [ ApplicationEdge False (map attribute _patternsIinfoTrees) ]
   {-# INLINE rule3781 #-}
   rule3781 = \ _parentTree ->
     resultConstraint "pattern constructor" _parentTree
        [ HasTrustFactor 10.0 ]
   {-# INLINE rule3782 #-}
   rule3782 = \ ((_lhsIbetaUnique) :: Int) ->
                                    _lhsIbetaUnique + 2
   {-# INLINE rule3783 #-}
   rule3783 = \ _conApply _conConstructor ((_patternsIconstraintslist) :: ConstraintSets) ->
                                    _conApply .>.
                                    Node [ listTree _conConstructor
                                         , Node _patternsIconstraintslist
                                         ]
   {-# INLINE rule3784 #-}
   rule3784 = \ ((_lhsIbetaUnique) :: Int) ->
                                    TVar (_lhsIbetaUnique)
   {-# INLINE rule3785 #-}
   rule3785 = \ ((_lhsIbetaUnique) :: Int) ->
                                    TVar (_lhsIbetaUnique + 1)
   {-# INLINE rule3786 #-}
   rule3786 = \ _beta _betaCon _cinfoApply _cinfoEmpty ((_patternsIbetas) :: Tps) ((_patternsInumberOfPatterns) :: Int) ->
                                    [ (_betaCon .==. foldr (.->.) _beta _patternsIbetas)
                                      (if _patternsInumberOfPatterns == 0  then _cinfoEmpty else _cinfoApply) ]
   {-# INLINE rule3787 #-}
   rule3787 = \ _betaCon _cinfoConstructor ((_lhsIimportEnvironment) :: ImportEnvironment) ((_nameIself) :: Name) ->
                                    case M.lookup _nameIself (valueConstructors _lhsIimportEnvironment) of
                                       Nothing            -> []
                                       Just (_, ctp) -> [ (_betaCon .::. ctp) _cinfoConstructor ]
   {-# INLINE rule3788 #-}
   rule3788 = \ ((_patternsIpatVarNames) :: Names) ->
     _patternsIpatVarNames
   {-# INLINE rule3789 #-}
   rule3789 = \ ((_patternsIunboundNames) :: Names) ->
     _patternsIunboundNames
   {-# INLINE rule3790 #-}
   rule3790 = \ ((_nameIself) :: Name) ((_patternsIself) :: Patterns) ((_rangeIself) :: Range) ->
     Pattern_Constructor _rangeIself _nameIself _patternsIself
   {-# INLINE rule3791 #-}
   rule3791 = \ _self ->
     _self
   {-# INLINE rule3792 #-}
   rule3792 = \ _beta ->
     _beta
   {-# INLINE rule3793 #-}
   rule3793 = \ ((_patternsIbetaUnique) :: Int) ->
     _patternsIbetaUnique
   {-# INLINE rule3794 #-}
   rule3794 = \ _constraints ->
     _constraints
   {-# INLINE rule3795 #-}
   rule3795 = \ ((_patternsIcounter) :: Int) ->
     _patternsIcounter
   {-# INLINE rule3796 #-}
   rule3796 = \ ((_patternsIenvironment) :: PatternAssumptions) ->
     _patternsIenvironment
   {-# INLINE rule3797 #-}
   rule3797 = \ ((_patternsIpatternMatchWarnings) :: [Warning]) ->
     _patternsIpatternMatchWarnings
   {-# INLINE rule3798 #-}
   rule3798 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule3799 #-}
   rule3799 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule3800 #-}
   rule3800 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule3801 #-}
   rule3801 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule3802 #-}
   rule3802 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule3803 #-}
   rule3803 = \ _parentTree ->
     _parentTree
   {-# INLINE rule3804 #-}
   rule3804 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule3805 #-}
   rule3805 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
{-# NOINLINE sem_Pattern_Parenthesized #-}
sem_Pattern_Parenthesized :: T_Range  -> T_Pattern  -> T_Pattern 
sem_Pattern_Parenthesized arg_range_ arg_pattern_ = T_Pattern (return st119) where
   {-# NOINLINE st119 #-}
   !st119 = let
      v118 :: T_Pattern_v118 
      v118 = \ !(T_Pattern_vIn118 _lhsIambiguousConflicts _lhsIbetaUnique _lhsIcounter _lhsIimportEnvironment _lhsImonos _lhsInamesInScope _lhsIparentTree _lhsIpatternMatchWarnings _lhsItypeConstructors) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _patternX119 = Control.Monad.Identity.runIdentity (attach_T_Pattern (arg_pattern_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_Pattern_vOut118 _patternIbeta _patternIbetaUnique _patternIconstraints _patternIcounter _patternIelements _patternIenvironment _patternIinfoTree _patternIpatVarNames _patternIpatternMatchWarnings _patternIself _patternIunboundNames) = inv_Pattern_s119 _patternX119 (T_Pattern_vIn118 _patternOambiguousConflicts _patternObetaUnique _patternOcounter _patternOimportEnvironment _patternOmonos _patternOnamesInScope _patternOparentTree _patternOpatternMatchWarnings _patternOtypeConstructors)
         _lhsOpatVarNames :: Names
         _lhsOpatVarNames = rule3806 _patternIpatVarNames
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule3807 _patternIunboundNames
         _self = rule3808 _patternIself _rangeIself
         _lhsOself :: Pattern
         _lhsOself = rule3809 _self
         _lhsObeta :: Tp
         _lhsObeta = rule3810 _patternIbeta
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule3811 _patternIbetaUnique
         _lhsOconstraints :: ConstraintSet
         _lhsOconstraints = rule3812 _patternIconstraints
         _lhsOcounter :: Int
         _lhsOcounter = rule3813 _patternIcounter
         _lhsOelements ::   [PatternElement]        
         _lhsOelements = rule3814 _patternIelements
         _lhsOenvironment :: PatternAssumptions
         _lhsOenvironment = rule3815 _patternIenvironment
         _lhsOinfoTree :: InfoTree
         _lhsOinfoTree = rule3816 _patternIinfoTree
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule3817 _patternIpatternMatchWarnings
         _patternOambiguousConflicts = rule3818 _lhsIambiguousConflicts
         _patternObetaUnique = rule3819 _lhsIbetaUnique
         _patternOcounter = rule3820 _lhsIcounter
         _patternOimportEnvironment = rule3821 _lhsIimportEnvironment
         _patternOmonos = rule3822 _lhsImonos
         _patternOnamesInScope = rule3823 _lhsInamesInScope
         _patternOparentTree = rule3824 _lhsIparentTree
         _patternOpatternMatchWarnings = rule3825 _lhsIpatternMatchWarnings
         _patternOtypeConstructors = rule3826 _lhsItypeConstructors
         !__result_ = T_Pattern_vOut118 _lhsObeta _lhsObetaUnique _lhsOconstraints _lhsOcounter _lhsOelements _lhsOenvironment _lhsOinfoTree _lhsOpatVarNames _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames
         in __result_ )
     in C_Pattern_s119 v118
   {-# INLINE rule3806 #-}
   rule3806 = \ ((_patternIpatVarNames) :: Names) ->
     _patternIpatVarNames
   {-# INLINE rule3807 #-}
   rule3807 = \ ((_patternIunboundNames) :: Names) ->
     _patternIunboundNames
   {-# INLINE rule3808 #-}
   rule3808 = \ ((_patternIself) :: Pattern) ((_rangeIself) :: Range) ->
     Pattern_Parenthesized _rangeIself _patternIself
   {-# INLINE rule3809 #-}
   rule3809 = \ _self ->
     _self
   {-# INLINE rule3810 #-}
   rule3810 = \ ((_patternIbeta) :: Tp) ->
     _patternIbeta
   {-# INLINE rule3811 #-}
   rule3811 = \ ((_patternIbetaUnique) :: Int) ->
     _patternIbetaUnique
   {-# INLINE rule3812 #-}
   rule3812 = \ ((_patternIconstraints) :: ConstraintSet) ->
     _patternIconstraints
   {-# INLINE rule3813 #-}
   rule3813 = \ ((_patternIcounter) :: Int) ->
     _patternIcounter
   {-# INLINE rule3814 #-}
   rule3814 = \ ((_patternIelements) ::   [PatternElement]        ) ->
     _patternIelements
   {-# INLINE rule3815 #-}
   rule3815 = \ ((_patternIenvironment) :: PatternAssumptions) ->
     _patternIenvironment
   {-# INLINE rule3816 #-}
   rule3816 = \ ((_patternIinfoTree) :: InfoTree) ->
     _patternIinfoTree
   {-# INLINE rule3817 #-}
   rule3817 = \ ((_patternIpatternMatchWarnings) :: [Warning]) ->
     _patternIpatternMatchWarnings
   {-# INLINE rule3818 #-}
   rule3818 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule3819 #-}
   rule3819 = \ ((_lhsIbetaUnique) :: Int) ->
     _lhsIbetaUnique
   {-# INLINE rule3820 #-}
   rule3820 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule3821 #-}
   rule3821 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule3822 #-}
   rule3822 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule3823 #-}
   rule3823 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule3824 #-}
   rule3824 = \ ((_lhsIparentTree) :: InfoTree) ->
     _lhsIparentTree
   {-# INLINE rule3825 #-}
   rule3825 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule3826 #-}
   rule3826 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
{-# NOINLINE sem_Pattern_InfixConstructor #-}
sem_Pattern_InfixConstructor :: T_Range  -> T_Pattern  -> T_Name  -> T_Pattern  -> T_Pattern 
sem_Pattern_InfixConstructor arg_range_ arg_leftPattern_ arg_constructorOperator_ arg_rightPattern_ = T_Pattern (return st119) where
   {-# NOINLINE st119 #-}
   !st119 = let
      v118 :: T_Pattern_v118 
      v118 = \ !(T_Pattern_vIn118 _lhsIambiguousConflicts _lhsIbetaUnique _lhsIcounter _lhsIimportEnvironment _lhsImonos _lhsInamesInScope _lhsIparentTree _lhsIpatternMatchWarnings _lhsItypeConstructors) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _leftPatternX119 = Control.Monad.Identity.runIdentity (attach_T_Pattern (arg_leftPattern_))
         _constructorOperatorX113 = Control.Monad.Identity.runIdentity (attach_T_Name (arg_constructorOperator_))
         _rightPatternX119 = Control.Monad.Identity.runIdentity (attach_T_Pattern (arg_rightPattern_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_Pattern_vOut118 _leftPatternIbeta _leftPatternIbetaUnique _leftPatternIconstraints _leftPatternIcounter _leftPatternIelements _leftPatternIenvironment _leftPatternIinfoTree _leftPatternIpatVarNames _leftPatternIpatternMatchWarnings _leftPatternIself _leftPatternIunboundNames) = inv_Pattern_s119 _leftPatternX119 (T_Pattern_vIn118 _leftPatternOambiguousConflicts _leftPatternObetaUnique _leftPatternOcounter _leftPatternOimportEnvironment _leftPatternOmonos _leftPatternOnamesInScope _leftPatternOparentTree _leftPatternOpatternMatchWarnings _leftPatternOtypeConstructors)
         (T_Name_vOut112 _constructorOperatorIself) = inv_Name_s113 _constructorOperatorX113 (T_Name_vIn112 )
         (T_Pattern_vOut118 _rightPatternIbeta _rightPatternIbetaUnique _rightPatternIconstraints _rightPatternIcounter _rightPatternIelements _rightPatternIenvironment _rightPatternIinfoTree _rightPatternIpatVarNames _rightPatternIpatternMatchWarnings _rightPatternIself _rightPatternIunboundNames) = inv_Pattern_s119 _rightPatternX119 (T_Pattern_vIn118 _rightPatternOambiguousConflicts _rightPatternObetaUnique _rightPatternOcounter _rightPatternOimportEnvironment _rightPatternOmonos _rightPatternOnamesInScope _rightPatternOparentTree _rightPatternOpatternMatchWarnings _rightPatternOtypeConstructors)
         _lhsOelements ::   [PatternElement]        
         _lhsOelements = rule3827 _constructorOperatorIself _leftPatternIelements _rightPatternIelements
         _parentTree = rule3828 _leftPatternIinfoTree _lhsIparentTree _localInfo _rightPatternIinfoTree
         _lhsOinfoTree :: InfoTree
         _lhsOinfoTree = rule3829 _parentTree
         _localInfo = rule3830 _beta _lhsImonos _self
         _cinfoConstructor = rule3831 _constructorOperatorIself
         _cinfoApply = rule3832 _constructorOperatorIself _leftPatternIinfoTree _localInfo _parentTree _rightPatternIinfoTree
         _lhsOenvironment :: PatternAssumptions
         _lhsOenvironment = rule3833 _leftPatternIenvironment _rightPatternIenvironment
         _leftPatternObetaUnique = rule3834 _lhsIbetaUnique
         _constraints = rule3835 _conApply _conConstructor _leftPatternIconstraints _rightPatternIconstraints
         _beta = rule3836 _lhsIbetaUnique
         _betaCon = rule3837 _lhsIbetaUnique
         _conApply = rule3838 _beta _betaCon _cinfoApply _leftPatternIbeta _rightPatternIbeta
         _conConstructor = rule3839 _betaCon _cinfoConstructor _constructorOperatorIself _lhsIimportEnvironment
         _lhsOpatVarNames :: Names
         _lhsOpatVarNames = rule3840 _leftPatternIpatVarNames _rightPatternIpatVarNames
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule3841 _leftPatternIunboundNames _rightPatternIunboundNames
         _self = rule3842 _constructorOperatorIself _leftPatternIself _rangeIself _rightPatternIself
         _lhsOself :: Pattern
         _lhsOself = rule3843 _self
         _lhsObeta :: Tp
         _lhsObeta = rule3844 _beta
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule3845 _rightPatternIbetaUnique
         _lhsOconstraints :: ConstraintSet
         _lhsOconstraints = rule3846 _constraints
         _lhsOcounter :: Int
         _lhsOcounter = rule3847 _rightPatternIcounter
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule3848 _rightPatternIpatternMatchWarnings
         _leftPatternOambiguousConflicts = rule3849 _lhsIambiguousConflicts
         _leftPatternOcounter = rule3850 _lhsIcounter
         _leftPatternOimportEnvironment = rule3851 _lhsIimportEnvironment
         _leftPatternOmonos = rule3852 _lhsImonos
         _leftPatternOnamesInScope = rule3853 _lhsInamesInScope
         _leftPatternOparentTree = rule3854 _parentTree
         _leftPatternOpatternMatchWarnings = rule3855 _lhsIpatternMatchWarnings
         _leftPatternOtypeConstructors = rule3856 _lhsItypeConstructors
         _rightPatternOambiguousConflicts = rule3857 _lhsIambiguousConflicts
         _rightPatternObetaUnique = rule3858 _leftPatternIbetaUnique
         _rightPatternOcounter = rule3859 _leftPatternIcounter
         _rightPatternOimportEnvironment = rule3860 _lhsIimportEnvironment
         _rightPatternOmonos = rule3861 _lhsImonos
         _rightPatternOnamesInScope = rule3862 _lhsInamesInScope
         _rightPatternOparentTree = rule3863 _parentTree
         _rightPatternOpatternMatchWarnings = rule3864 _leftPatternIpatternMatchWarnings
         _rightPatternOtypeConstructors = rule3865 _lhsItypeConstructors
         !__result_ = T_Pattern_vOut118 _lhsObeta _lhsObetaUnique _lhsOconstraints _lhsOcounter _lhsOelements _lhsOenvironment _lhsOinfoTree _lhsOpatVarNames _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames
         in __result_ )
     in C_Pattern_s119 v118
   {-# INLINE rule3827 #-}
   rule3827 = \ ((_constructorOperatorIself) :: Name) ((_leftPatternIelements) ::   [PatternElement]        ) ((_rightPatternIelements) ::   [PatternElement]        ) ->
                                         FiniteElement (getOnlyName _constructorOperatorIself) : _leftPatternIelements ++ _rightPatternIelements
   {-# INLINE rule3828 #-}
   rule3828 = \ ((_leftPatternIinfoTree) :: InfoTree) ((_lhsIparentTree) :: InfoTree) _localInfo ((_rightPatternIinfoTree) :: InfoTree) ->
                            node _lhsIparentTree _localInfo [_leftPatternIinfoTree, _rightPatternIinfoTree]
   {-# INLINE rule3829 #-}
   rule3829 = \ _parentTree ->
                            _parentTree
   {-# INLINE rule3830 #-}
   rule3830 = \ _beta ((_lhsImonos) :: Monos) _self ->
                            LocalInfo { self = UHA_Pat _self
                                      , assignedType = Just _beta
                                      , monos = _lhsImonos
                                      }
   {-# INLINE rule3831 #-}
   rule3831 = \ ((_constructorOperatorIself) :: Name) ->
     variableConstraint "pattern constructor" (nameToUHA_Pat _constructorOperatorIself)
        [ FolkloreConstraint, HasTrustFactor 10.0 ]
   {-# INLINE rule3832 #-}
   rule3832 = \ ((_constructorOperatorIself) :: Name) ((_leftPatternIinfoTree) :: InfoTree) _localInfo _parentTree ((_rightPatternIinfoTree) :: InfoTree) ->
     specialConstraint "infix pattern application" _parentTree
        (self _localInfo, Just $ nameToUHA_Pat  _constructorOperatorIself)
        [ ApplicationEdge True (map attribute [_leftPatternIinfoTree, _rightPatternIinfoTree]) ]
   {-# INLINE rule3833 #-}
   rule3833 = \ ((_leftPatternIenvironment) :: PatternAssumptions) ((_rightPatternIenvironment) :: PatternAssumptions) ->
                                       _leftPatternIenvironment `M.union` _rightPatternIenvironment
   {-# INLINE rule3834 #-}
   rule3834 = \ ((_lhsIbetaUnique) :: Int) ->
                                       _lhsIbetaUnique + 2
   {-# INLINE rule3835 #-}
   rule3835 = \ _conApply _conConstructor ((_leftPatternIconstraints) :: ConstraintSet) ((_rightPatternIconstraints) :: ConstraintSet) ->
                                       _conApply .>.
                                       Node [ listTree _conConstructor
                                            , _leftPatternIconstraints
                                            , _rightPatternIconstraints
                                            ]
   {-# INLINE rule3836 #-}
   rule3836 = \ ((_lhsIbetaUnique) :: Int) ->
                                       TVar _lhsIbetaUnique
   {-# INLINE rule3837 #-}
   rule3837 = \ ((_lhsIbetaUnique) :: Int) ->
                                       TVar (_lhsIbetaUnique + 1)
   {-# INLINE rule3838 #-}
   rule3838 = \ _beta _betaCon _cinfoApply ((_leftPatternIbeta) :: Tp) ((_rightPatternIbeta) :: Tp) ->
                                       [ (_betaCon .==. _leftPatternIbeta .->. _rightPatternIbeta .->. _beta) _cinfoApply ]
   {-# INLINE rule3839 #-}
   rule3839 = \ _betaCon _cinfoConstructor ((_constructorOperatorIself) :: Name) ((_lhsIimportEnvironment) :: ImportEnvironment) ->
                                       case M.lookup _constructorOperatorIself (valueConstructors _lhsIimportEnvironment) of
                                          Nothing            -> []
                                          Just (_, ctp) -> [ (_betaCon .::. ctp) _cinfoConstructor ]
   {-# INLINE rule3840 #-}
   rule3840 = \ ((_leftPatternIpatVarNames) :: Names) ((_rightPatternIpatVarNames) :: Names) ->
     _leftPatternIpatVarNames ++ _rightPatternIpatVarNames
   {-# INLINE rule3841 #-}
   rule3841 = \ ((_leftPatternIunboundNames) :: Names) ((_rightPatternIunboundNames) :: Names) ->
     ((++) _leftPatternIunboundNames _rightPatternIunboundNames)
   {-# INLINE rule3842 #-}
   rule3842 = \ ((_constructorOperatorIself) :: Name) ((_leftPatternIself) :: Pattern) ((_rangeIself) :: Range) ((_rightPatternIself) :: Pattern) ->
     Pattern_InfixConstructor _rangeIself _leftPatternIself _constructorOperatorIself _rightPatternIself
   {-# INLINE rule3843 #-}
   rule3843 = \ _self ->
     _self
   {-# INLINE rule3844 #-}
   rule3844 = \ _beta ->
     _beta
   {-# INLINE rule3845 #-}
   rule3845 = \ ((_rightPatternIbetaUnique) :: Int) ->
     _rightPatternIbetaUnique
   {-# INLINE rule3846 #-}
   rule3846 = \ _constraints ->
     _constraints
   {-# INLINE rule3847 #-}
   rule3847 = \ ((_rightPatternIcounter) :: Int) ->
     _rightPatternIcounter
   {-# INLINE rule3848 #-}
   rule3848 = \ ((_rightPatternIpatternMatchWarnings) :: [Warning]) ->
     _rightPatternIpatternMatchWarnings
   {-# INLINE rule3849 #-}
   rule3849 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule3850 #-}
   rule3850 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule3851 #-}
   rule3851 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule3852 #-}
   rule3852 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule3853 #-}
   rule3853 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule3854 #-}
   rule3854 = \ _parentTree ->
     _parentTree
   {-# INLINE rule3855 #-}
   rule3855 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule3856 #-}
   rule3856 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
   {-# INLINE rule3857 #-}
   rule3857 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule3858 #-}
   rule3858 = \ ((_leftPatternIbetaUnique) :: Int) ->
     _leftPatternIbetaUnique
   {-# INLINE rule3859 #-}
   rule3859 = \ ((_leftPatternIcounter) :: Int) ->
     _leftPatternIcounter
   {-# INLINE rule3860 #-}
   rule3860 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule3861 #-}
   rule3861 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule3862 #-}
   rule3862 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule3863 #-}
   rule3863 = \ _parentTree ->
     _parentTree
   {-# INLINE rule3864 #-}
   rule3864 = \ ((_leftPatternIpatternMatchWarnings) :: [Warning]) ->
     _leftPatternIpatternMatchWarnings
   {-# INLINE rule3865 #-}
   rule3865 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
{-# NOINLINE sem_Pattern_List #-}
sem_Pattern_List :: T_Range  -> T_Patterns  -> T_Pattern 
sem_Pattern_List arg_range_ arg_patterns_ = T_Pattern (return st119) where
   {-# NOINLINE st119 #-}
   !st119 = let
      v118 :: T_Pattern_v118 
      v118 = \ !(T_Pattern_vIn118 _lhsIambiguousConflicts _lhsIbetaUnique _lhsIcounter _lhsIimportEnvironment _lhsImonos _lhsInamesInScope _lhsIparentTree _lhsIpatternMatchWarnings _lhsItypeConstructors) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _patternsX122 = Control.Monad.Identity.runIdentity (attach_T_Patterns (arg_patterns_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_Patterns_vOut121 _patternsIbetaUnique _patternsIbetas _patternsIconstraintslist _patternsIcounter _patternsIelementss _patternsIenvironment _patternsIinfoTrees _patternsInumberOfPatterns _patternsIpatVarNames _patternsIpatternMatchWarnings _patternsIself _patternsIunboundNames) = inv_Patterns_s122 _patternsX122 (T_Patterns_vIn121 _patternsOambiguousConflicts _patternsObetaUnique _patternsOcounter _patternsOimportEnvironment _patternsOmonos _patternsOnamesInScope _patternsOparentTree _patternsOpatternMatchWarnings _patternsOtypeConstructors)
         _lhsOelements ::   [PatternElement]        
         _lhsOelements = rule3866 _patternsIelementss
         _parentTree = rule3867 _lhsIparentTree _localInfo _patternsIinfoTrees
         _lhsOinfoTree :: InfoTree
         _lhsOinfoTree = rule3868 _parentTree
         _localInfo = rule3869 _beta _lhsImonos _self
         _cinfoElem = rule3870 _beta' _localInfo _parentTree _patternsIconstraintslist
         _cinfoResult = rule3871 _parentTree
         _patternsObetaUnique = rule3872 _lhsIbetaUnique
         _constraints = rule3873 _newcon _patternsIbetas _patternsIconstraintslist _zipf
         _beta = rule3874 _lhsIbetaUnique
         _beta' = rule3875 _lhsIbetaUnique
         _newcon = rule3876 _beta _beta' _cinfoResult
         _zipf = rule3877 _beta' _cinfoElem
         _lhsOpatVarNames :: Names
         _lhsOpatVarNames = rule3878 _patternsIpatVarNames
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule3879 _patternsIunboundNames
         _self = rule3880 _patternsIself _rangeIself
         _lhsOself :: Pattern
         _lhsOself = rule3881 _self
         _lhsObeta :: Tp
         _lhsObeta = rule3882 _beta
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule3883 _patternsIbetaUnique
         _lhsOconstraints :: ConstraintSet
         _lhsOconstraints = rule3884 _constraints
         _lhsOcounter :: Int
         _lhsOcounter = rule3885 _patternsIcounter
         _lhsOenvironment :: PatternAssumptions
         _lhsOenvironment = rule3886 _patternsIenvironment
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule3887 _patternsIpatternMatchWarnings
         _patternsOambiguousConflicts = rule3888 _lhsIambiguousConflicts
         _patternsOcounter = rule3889 _lhsIcounter
         _patternsOimportEnvironment = rule3890 _lhsIimportEnvironment
         _patternsOmonos = rule3891 _lhsImonos
         _patternsOnamesInScope = rule3892 _lhsInamesInScope
         _patternsOparentTree = rule3893 _parentTree
         _patternsOpatternMatchWarnings = rule3894 _lhsIpatternMatchWarnings
         _patternsOtypeConstructors = rule3895 _lhsItypeConstructors
         !__result_ = T_Pattern_vOut118 _lhsObeta _lhsObetaUnique _lhsOconstraints _lhsOcounter _lhsOelements _lhsOenvironment _lhsOinfoTree _lhsOpatVarNames _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames
         in __result_ )
     in C_Pattern_s119 v118
   {-# INLINE rule3866 #-}
   rule3866 = \ ((_patternsIelementss) :: [ [PatternElement]       ]) ->
                                         listPat _patternsIelementss
   {-# INLINE rule3867 #-}
   rule3867 = \ ((_lhsIparentTree) :: InfoTree) _localInfo ((_patternsIinfoTrees) :: InfoTrees) ->
                            node _lhsIparentTree _localInfo _patternsIinfoTrees
   {-# INLINE rule3868 #-}
   rule3868 = \ _parentTree ->
                            _parentTree
   {-# INLINE rule3869 #-}
   rule3869 = \ _beta ((_lhsImonos) :: Monos) _self ->
                            LocalInfo { self = UHA_Pat _self
                                      , assignedType = Just _beta
                                      , monos = _lhsImonos
                                      }
   {-# INLINE rule3870 #-}
   rule3870 = \ _beta' _localInfo _parentTree ((_patternsIconstraintslist) :: ConstraintSets) ->
     \elemNr ->
     childConstraint elemNr "element of pattern list" _parentTree $
        [ HasTrustFactor 10.0 | length _patternsIconstraintslist < 2 ] ++
        [ Unifier (head (ftv _beta')) ("pattern list", _localInfo, ordinal False (elemNr+1) ++ " element") ]
   {-# INLINE rule3871 #-}
   rule3871 = \ _parentTree ->
     resultConstraint "pattern list" _parentTree
        [ FolkloreConstraint ]
   {-# INLINE rule3872 #-}
   rule3872 = \ ((_lhsIbetaUnique) :: Int) ->
                                  _lhsIbetaUnique + 2
   {-# INLINE rule3873 #-}
   rule3873 = \ _newcon ((_patternsIbetas) :: Tps) ((_patternsIconstraintslist) :: ConstraintSets) _zipf ->
                                  _newcon .>.
                                  Node (zipWith3 _zipf _patternsIbetas [0..] _patternsIconstraintslist)
   {-# INLINE rule3874 #-}
   rule3874 = \ ((_lhsIbetaUnique) :: Int) ->
                                  TVar _lhsIbetaUnique
   {-# INLINE rule3875 #-}
   rule3875 = \ ((_lhsIbetaUnique) :: Int) ->
                                  TVar (_lhsIbetaUnique + 1)
   {-# INLINE rule3876 #-}
   rule3876 = \ _beta _beta' _cinfoResult ->
                                  [ (listType _beta' .==. _beta) _cinfoResult ]
   {-# INLINE rule3877 #-}
   rule3877 = \ _beta' _cinfoElem ->
                                  \tp elemNr ctree -> [ (tp .==. _beta') (_cinfoElem elemNr) ] .<. ctree
   {-# INLINE rule3878 #-}
   rule3878 = \ ((_patternsIpatVarNames) :: Names) ->
     _patternsIpatVarNames
   {-# INLINE rule3879 #-}
   rule3879 = \ ((_patternsIunboundNames) :: Names) ->
     _patternsIunboundNames
   {-# INLINE rule3880 #-}
   rule3880 = \ ((_patternsIself) :: Patterns) ((_rangeIself) :: Range) ->
     Pattern_List _rangeIself _patternsIself
   {-# INLINE rule3881 #-}
   rule3881 = \ _self ->
     _self
   {-# INLINE rule3882 #-}
   rule3882 = \ _beta ->
     _beta
   {-# INLINE rule3883 #-}
   rule3883 = \ ((_patternsIbetaUnique) :: Int) ->
     _patternsIbetaUnique
   {-# INLINE rule3884 #-}
   rule3884 = \ _constraints ->
     _constraints
   {-# INLINE rule3885 #-}
   rule3885 = \ ((_patternsIcounter) :: Int) ->
     _patternsIcounter
   {-# INLINE rule3886 #-}
   rule3886 = \ ((_patternsIenvironment) :: PatternAssumptions) ->
     _patternsIenvironment
   {-# INLINE rule3887 #-}
   rule3887 = \ ((_patternsIpatternMatchWarnings) :: [Warning]) ->
     _patternsIpatternMatchWarnings
   {-# INLINE rule3888 #-}
   rule3888 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule3889 #-}
   rule3889 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule3890 #-}
   rule3890 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule3891 #-}
   rule3891 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule3892 #-}
   rule3892 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule3893 #-}
   rule3893 = \ _parentTree ->
     _parentTree
   {-# INLINE rule3894 #-}
   rule3894 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule3895 #-}
   rule3895 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
{-# NOINLINE sem_Pattern_Tuple #-}
sem_Pattern_Tuple :: T_Range  -> T_Patterns  -> T_Pattern 
sem_Pattern_Tuple arg_range_ arg_patterns_ = T_Pattern (return st119) where
   {-# NOINLINE st119 #-}
   !st119 = let
      v118 :: T_Pattern_v118 
      v118 = \ !(T_Pattern_vIn118 _lhsIambiguousConflicts _lhsIbetaUnique _lhsIcounter _lhsIimportEnvironment _lhsImonos _lhsInamesInScope _lhsIparentTree _lhsIpatternMatchWarnings _lhsItypeConstructors) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _patternsX122 = Control.Monad.Identity.runIdentity (attach_T_Patterns (arg_patterns_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_Patterns_vOut121 _patternsIbetaUnique _patternsIbetas _patternsIconstraintslist _patternsIcounter _patternsIelementss _patternsIenvironment _patternsIinfoTrees _patternsInumberOfPatterns _patternsIpatVarNames _patternsIpatternMatchWarnings _patternsIself _patternsIunboundNames) = inv_Patterns_s122 _patternsX122 (T_Patterns_vIn121 _patternsOambiguousConflicts _patternsObetaUnique _patternsOcounter _patternsOimportEnvironment _patternsOmonos _patternsOnamesInScope _patternsOparentTree _patternsOpatternMatchWarnings _patternsOtypeConstructors)
         _lhsOelements ::   [PatternElement]        
         _lhsOelements = rule3896 _patternsIelementss _patternsIself
         _parentTree = rule3897 _lhsIparentTree _localInfo _patternsIinfoTrees
         _lhsOinfoTree :: InfoTree
         _lhsOinfoTree = rule3898 _parentTree
         _localInfo = rule3899 _beta _lhsImonos _self
         _cinfo = rule3900 _parentTree
         _patternsObetaUnique = rule3901 _lhsIbetaUnique
         _constraints = rule3902 _newcon _patternsIconstraintslist
         _beta = rule3903 _lhsIbetaUnique
         _newcon = rule3904 _beta _cinfo _patternsIbetas
         _lhsOpatVarNames :: Names
         _lhsOpatVarNames = rule3905 _patternsIpatVarNames
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule3906 _patternsIunboundNames
         _self = rule3907 _patternsIself _rangeIself
         _lhsOself :: Pattern
         _lhsOself = rule3908 _self
         _lhsObeta :: Tp
         _lhsObeta = rule3909 _beta
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule3910 _patternsIbetaUnique
         _lhsOconstraints :: ConstraintSet
         _lhsOconstraints = rule3911 _constraints
         _lhsOcounter :: Int
         _lhsOcounter = rule3912 _patternsIcounter
         _lhsOenvironment :: PatternAssumptions
         _lhsOenvironment = rule3913 _patternsIenvironment
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule3914 _patternsIpatternMatchWarnings
         _patternsOambiguousConflicts = rule3915 _lhsIambiguousConflicts
         _patternsOcounter = rule3916 _lhsIcounter
         _patternsOimportEnvironment = rule3917 _lhsIimportEnvironment
         _patternsOmonos = rule3918 _lhsImonos
         _patternsOnamesInScope = rule3919 _lhsInamesInScope
         _patternsOparentTree = rule3920 _parentTree
         _patternsOpatternMatchWarnings = rule3921 _lhsIpatternMatchWarnings
         _patternsOtypeConstructors = rule3922 _lhsItypeConstructors
         !__result_ = T_Pattern_vOut118 _lhsObeta _lhsObetaUnique _lhsOconstraints _lhsOcounter _lhsOelements _lhsOenvironment _lhsOinfoTree _lhsOpatVarNames _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames
         in __result_ )
     in C_Pattern_s119 v118
   {-# INLINE rule3896 #-}
   rule3896 = \ ((_patternsIelementss) :: [ [PatternElement]       ]) ((_patternsIself) :: Patterns) ->
                                         FiniteElement ("(" ++ replicate (length $ tail _patternsIself) ',' ++ ")") : concat _patternsIelementss
   {-# INLINE rule3897 #-}
   rule3897 = \ ((_lhsIparentTree) :: InfoTree) _localInfo ((_patternsIinfoTrees) :: InfoTrees) ->
                            node _lhsIparentTree _localInfo _patternsIinfoTrees
   {-# INLINE rule3898 #-}
   rule3898 = \ _parentTree ->
                            _parentTree
   {-# INLINE rule3899 #-}
   rule3899 = \ _beta ((_lhsImonos) :: Monos) _self ->
                            LocalInfo { self = UHA_Pat _self
                                      , assignedType = Just _beta
                                      , monos = _lhsImonos
                                      }
   {-# INLINE rule3900 #-}
   rule3900 = \ _parentTree ->
     resultConstraint "pattern tuple" _parentTree
     [ FolkloreConstraint ]
   {-# INLINE rule3901 #-}
   rule3901 = \ ((_lhsIbetaUnique) :: Int) ->
                                 _lhsIbetaUnique + 1
   {-# INLINE rule3902 #-}
   rule3902 = \ _newcon ((_patternsIconstraintslist) :: ConstraintSets) ->
                                 _newcon .>. Node _patternsIconstraintslist
   {-# INLINE rule3903 #-}
   rule3903 = \ ((_lhsIbetaUnique) :: Int) ->
                                 TVar _lhsIbetaUnique
   {-# INLINE rule3904 #-}
   rule3904 = \ _beta _cinfo ((_patternsIbetas) :: Tps) ->
                                 [ (tupleType _patternsIbetas .==. _beta) _cinfo ]
   {-# INLINE rule3905 #-}
   rule3905 = \ ((_patternsIpatVarNames) :: Names) ->
     _patternsIpatVarNames
   {-# INLINE rule3906 #-}
   rule3906 = \ ((_patternsIunboundNames) :: Names) ->
     _patternsIunboundNames
   {-# INLINE rule3907 #-}
   rule3907 = \ ((_patternsIself) :: Patterns) ((_rangeIself) :: Range) ->
     Pattern_Tuple _rangeIself _patternsIself
   {-# INLINE rule3908 #-}
   rule3908 = \ _self ->
     _self
   {-# INLINE rule3909 #-}
   rule3909 = \ _beta ->
     _beta
   {-# INLINE rule3910 #-}
   rule3910 = \ ((_patternsIbetaUnique) :: Int) ->
     _patternsIbetaUnique
   {-# INLINE rule3911 #-}
   rule3911 = \ _constraints ->
     _constraints
   {-# INLINE rule3912 #-}
   rule3912 = \ ((_patternsIcounter) :: Int) ->
     _patternsIcounter
   {-# INLINE rule3913 #-}
   rule3913 = \ ((_patternsIenvironment) :: PatternAssumptions) ->
     _patternsIenvironment
   {-# INLINE rule3914 #-}
   rule3914 = \ ((_patternsIpatternMatchWarnings) :: [Warning]) ->
     _patternsIpatternMatchWarnings
   {-# INLINE rule3915 #-}
   rule3915 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule3916 #-}
   rule3916 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule3917 #-}
   rule3917 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule3918 #-}
   rule3918 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule3919 #-}
   rule3919 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule3920 #-}
   rule3920 = \ _parentTree ->
     _parentTree
   {-# INLINE rule3921 #-}
   rule3921 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule3922 #-}
   rule3922 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
{-# NOINLINE sem_Pattern_Record #-}
sem_Pattern_Record :: T_Range  -> T_Name  -> T_RecordPatternBindings  -> T_Pattern 
sem_Pattern_Record arg_range_ arg_name_ arg_recordPatternBindings_ = T_Pattern (return st119) where
   {-# NOINLINE st119 #-}
   !st119 = let
      v118 :: T_Pattern_v118 
      v118 = \ !(T_Pattern_vIn118 _lhsIambiguousConflicts _lhsIbetaUnique _lhsIcounter _lhsIimportEnvironment _lhsImonos _lhsInamesInScope _lhsIparentTree _lhsIpatternMatchWarnings _lhsItypeConstructors) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _nameX113 = Control.Monad.Identity.runIdentity (attach_T_Name (arg_name_))
         _recordPatternBindingsX146 = Control.Monad.Identity.runIdentity (attach_T_RecordPatternBindings (arg_recordPatternBindings_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_Name_vOut112 _nameIself) = inv_Name_s113 _nameX113 (T_Name_vIn112 )
         (T_RecordPatternBindings_vOut145 _recordPatternBindingsIcounter _recordPatternBindingsIpatternMatchWarnings _recordPatternBindingsIself _recordPatternBindingsIunboundNames) = inv_RecordPatternBindings_s146 _recordPatternBindingsX146 (T_RecordPatternBindings_vIn145 _recordPatternBindingsOambiguousConflicts _recordPatternBindingsOcounter _recordPatternBindingsOnamesInScope _recordPatternBindingsOpatternMatchWarnings)
         _lhsOelements ::   [PatternElement]        
         _lhsOelements = rule3923  ()
         (_beta,_constraints,_environment) = rule3924  ()
         _infoTree = rule3925  ()
         _lhsOpatVarNames :: Names
         _lhsOpatVarNames = rule3926  ()
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule3927 _recordPatternBindingsIunboundNames
         _self = rule3928 _nameIself _rangeIself _recordPatternBindingsIself
         _lhsOself :: Pattern
         _lhsOself = rule3929 _self
         _lhsObeta :: Tp
         _lhsObeta = rule3930 _beta
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule3931 _lhsIbetaUnique
         _lhsOconstraints :: ConstraintSet
         _lhsOconstraints = rule3932 _constraints
         _lhsOcounter :: Int
         _lhsOcounter = rule3933 _recordPatternBindingsIcounter
         _lhsOenvironment :: PatternAssumptions
         _lhsOenvironment = rule3934 _environment
         _lhsOinfoTree :: InfoTree
         _lhsOinfoTree = rule3935 _infoTree
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule3936 _recordPatternBindingsIpatternMatchWarnings
         _recordPatternBindingsOambiguousConflicts = rule3937 _lhsIambiguousConflicts
         _recordPatternBindingsOcounter = rule3938 _lhsIcounter
         _recordPatternBindingsOnamesInScope = rule3939 _lhsInamesInScope
         _recordPatternBindingsOpatternMatchWarnings = rule3940 _lhsIpatternMatchWarnings
         !__result_ = T_Pattern_vOut118 _lhsObeta _lhsObetaUnique _lhsOconstraints _lhsOcounter _lhsOelements _lhsOenvironment _lhsOinfoTree _lhsOpatVarNames _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames
         in __result_ )
     in C_Pattern_s119 v118
   {-# INLINE rule3923 #-}
   rule3923 = \  (_ :: ()) ->
                                         pmError "Pattern_Record.elements" "Records are not supported"
   {-# INLINE rule3924 #-}
   rule3924 = \  (_ :: ()) ->
                                                       internalError "PartialSyntax.ag" "n/a" "Pattern.Record"
   {-# INLINE rule3925 #-}
   rule3925 = \  (_ :: ()) ->
                                                                            globalInfoError
   {-# INLINE rule3926 #-}
   rule3926 = \  (_ :: ()) ->
     []
   {-# INLINE rule3927 #-}
   rule3927 = \ ((_recordPatternBindingsIunboundNames) :: Names) ->
     _recordPatternBindingsIunboundNames
   {-# INLINE rule3928 #-}
   rule3928 = \ ((_nameIself) :: Name) ((_rangeIself) :: Range) ((_recordPatternBindingsIself) :: RecordPatternBindings) ->
     Pattern_Record _rangeIself _nameIself _recordPatternBindingsIself
   {-# INLINE rule3929 #-}
   rule3929 = \ _self ->
     _self
   {-# INLINE rule3930 #-}
   rule3930 = \ _beta ->
     _beta
   {-# INLINE rule3931 #-}
   rule3931 = \ ((_lhsIbetaUnique) :: Int) ->
     _lhsIbetaUnique
   {-# INLINE rule3932 #-}
   rule3932 = \ _constraints ->
     _constraints
   {-# INLINE rule3933 #-}
   rule3933 = \ ((_recordPatternBindingsIcounter) :: Int) ->
     _recordPatternBindingsIcounter
   {-# INLINE rule3934 #-}
   rule3934 = \ _environment ->
     _environment
   {-# INLINE rule3935 #-}
   rule3935 = \ _infoTree ->
     _infoTree
   {-# INLINE rule3936 #-}
   rule3936 = \ ((_recordPatternBindingsIpatternMatchWarnings) :: [Warning]) ->
     _recordPatternBindingsIpatternMatchWarnings
   {-# INLINE rule3937 #-}
   rule3937 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule3938 #-}
   rule3938 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule3939 #-}
   rule3939 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule3940 #-}
   rule3940 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
{-# NOINLINE sem_Pattern_Negate #-}
sem_Pattern_Negate :: T_Range  -> T_Literal  -> T_Pattern 
sem_Pattern_Negate arg_range_ arg_literal_ = T_Pattern (return st119) where
   {-# NOINLINE st119 #-}
   !st119 = let
      v118 :: T_Pattern_v118 
      v118 = \ !(T_Pattern_vIn118 _lhsIambiguousConflicts _lhsIbetaUnique _lhsIcounter _lhsIimportEnvironment _lhsImonos _lhsInamesInScope _lhsIparentTree _lhsIpatternMatchWarnings _lhsItypeConstructors) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _literalX86 = Control.Monad.Identity.runIdentity (attach_T_Literal (arg_literal_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_Literal_vOut85 _literalIelements _literalIliteralType _literalIself) = inv_Literal_s86 _literalX86 (T_Literal_vIn85 )
         _parentTree = rule3941 _lhsIparentTree _localInfo
         _lhsOinfoTree :: InfoTree
         _lhsOinfoTree = rule3942 _parentTree
         _localInfo = rule3943 _beta _lhsImonos _self
         _cinfo = rule3944 _parentTree
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule3945 _lhsIbetaUnique
         _lhsOenvironment :: PatternAssumptions
         _lhsOenvironment = rule3946  ()
         _constraints = rule3947 _newcon
         _beta = rule3948 _lhsIbetaUnique
         _newcon = rule3949 _beta _cinfo _lhsIimportEnvironment _literalIliteralType
         _lhsOpatVarNames :: Names
         _lhsOpatVarNames = rule3950  ()
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule3951  ()
         _self = rule3952 _literalIself _rangeIself
         _lhsOself :: Pattern
         _lhsOself = rule3953 _self
         _lhsObeta :: Tp
         _lhsObeta = rule3954 _beta
         _lhsOconstraints :: ConstraintSet
         _lhsOconstraints = rule3955 _constraints
         _lhsOcounter :: Int
         _lhsOcounter = rule3956 _lhsIcounter
         _lhsOelements ::   [PatternElement]        
         _lhsOelements = rule3957 _literalIelements
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule3958 _lhsIpatternMatchWarnings
         !__result_ = T_Pattern_vOut118 _lhsObeta _lhsObetaUnique _lhsOconstraints _lhsOcounter _lhsOelements _lhsOenvironment _lhsOinfoTree _lhsOpatVarNames _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames
         in __result_ )
     in C_Pattern_s119 v118
   {-# INLINE rule3941 #-}
   rule3941 = \ ((_lhsIparentTree) :: InfoTree) _localInfo ->
                            node _lhsIparentTree _localInfo []
   {-# INLINE rule3942 #-}
   rule3942 = \ _parentTree ->
                            _parentTree
   {-# INLINE rule3943 #-}
   rule3943 = \ _beta ((_lhsImonos) :: Monos) _self ->
                            LocalInfo { self = UHA_Pat _self
                                      , assignedType = Just _beta
                                      , monos = _lhsImonos
                                      }
   {-# INLINE rule3944 #-}
   rule3944 = \ _parentTree ->
     resultConstraint "pattern negation" _parentTree
        [ FolkloreConstraint ]
   {-# INLINE rule3945 #-}
   rule3945 = \ ((_lhsIbetaUnique) :: Int) ->
                            _lhsIbetaUnique + 1
   {-# INLINE rule3946 #-}
   rule3946 = \  (_ :: ()) ->
                            noAssumptions
   {-# INLINE rule3947 #-}
   rule3947 = \ _newcon ->
                            listTree _newcon
   {-# INLINE rule3948 #-}
   rule3948 = \ ((_lhsIbetaUnique) :: Int) ->
                            TVar _lhsIbetaUnique
   {-# INLINE rule3949 #-}
   rule3949 = \ _beta _cinfo ((_lhsIimportEnvironment) :: ImportEnvironment) ((_literalIliteralType) :: Tp) ->
                            let standard = makeScheme [] [Predicate "Num" (TVar 0)] (TVar 0 .->. TVar 0)
                                tpscheme = M.findWithDefault standard (nameFromString "negate") (typeEnvironment _lhsIimportEnvironment)
                            in [ (_literalIliteralType .->. _beta .::. tpscheme) _cinfo]
   {-# INLINE rule3950 #-}
   rule3950 = \  (_ :: ()) ->
     []
   {-# INLINE rule3951 #-}
   rule3951 = \  (_ :: ()) ->
     []
   {-# INLINE rule3952 #-}
   rule3952 = \ ((_literalIself) :: Literal) ((_rangeIself) :: Range) ->
     Pattern_Negate _rangeIself _literalIself
   {-# INLINE rule3953 #-}
   rule3953 = \ _self ->
     _self
   {-# INLINE rule3954 #-}
   rule3954 = \ _beta ->
     _beta
   {-# INLINE rule3955 #-}
   rule3955 = \ _constraints ->
     _constraints
   {-# INLINE rule3956 #-}
   rule3956 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule3957 #-}
   rule3957 = \ ((_literalIelements) ::   [PatternElement]        ) ->
     _literalIelements
   {-# INLINE rule3958 #-}
   rule3958 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
{-# NOINLINE sem_Pattern_As #-}
sem_Pattern_As :: T_Range  -> T_Name  -> T_Pattern  -> T_Pattern 
sem_Pattern_As arg_range_ arg_name_ arg_pattern_ = T_Pattern (return st119) where
   {-# NOINLINE st119 #-}
   !st119 = let
      v118 :: T_Pattern_v118 
      v118 = \ !(T_Pattern_vIn118 _lhsIambiguousConflicts _lhsIbetaUnique _lhsIcounter _lhsIimportEnvironment _lhsImonos _lhsInamesInScope _lhsIparentTree _lhsIpatternMatchWarnings _lhsItypeConstructors) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _nameX113 = Control.Monad.Identity.runIdentity (attach_T_Name (arg_name_))
         _patternX119 = Control.Monad.Identity.runIdentity (attach_T_Pattern (arg_pattern_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_Name_vOut112 _nameIself) = inv_Name_s113 _nameX113 (T_Name_vIn112 )
         (T_Pattern_vOut118 _patternIbeta _patternIbetaUnique _patternIconstraints _patternIcounter _patternIelements _patternIenvironment _patternIinfoTree _patternIpatVarNames _patternIpatternMatchWarnings _patternIself _patternIunboundNames) = inv_Pattern_s119 _patternX119 (T_Pattern_vIn118 _patternOambiguousConflicts _patternObetaUnique _patternOcounter _patternOimportEnvironment _patternOmonos _patternOnamesInScope _patternOparentTree _patternOpatternMatchWarnings _patternOtypeConstructors)
         _lhsOpatVarNames :: Names
         _lhsOpatVarNames = rule3959 _nameIself _patternIpatVarNames
         _parentTree = rule3960 _lhsIparentTree _localInfo _patternIinfoTree
         _lhsOinfoTree :: InfoTree
         _lhsOinfoTree = rule3961 _parentTree
         _localInfo = rule3962 _beta _lhsImonos _self
         _cinfo = rule3963 _localInfo _nameIself _parentTree
         _lhsOenvironment :: PatternAssumptions
         _lhsOenvironment = rule3964 _beta _nameIself _patternIenvironment
         _patternObetaUnique = rule3965 _lhsIbetaUnique
         _constraints = rule3966 _lhsIbetaUnique _newcon _patternIconstraints
         _beta = rule3967 _lhsIbetaUnique
         _newcon = rule3968 _beta _cinfo _patternIbeta
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule3969 _patternIunboundNames
         _self = rule3970 _nameIself _patternIself _rangeIself
         _lhsOself :: Pattern
         _lhsOself = rule3971 _self
         _lhsObeta :: Tp
         _lhsObeta = rule3972 _beta
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule3973 _patternIbetaUnique
         _lhsOconstraints :: ConstraintSet
         _lhsOconstraints = rule3974 _constraints
         _lhsOcounter :: Int
         _lhsOcounter = rule3975 _patternIcounter
         _lhsOelements ::   [PatternElement]        
         _lhsOelements = rule3976 _patternIelements
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule3977 _patternIpatternMatchWarnings
         _patternOambiguousConflicts = rule3978 _lhsIambiguousConflicts
         _patternOcounter = rule3979 _lhsIcounter
         _patternOimportEnvironment = rule3980 _lhsIimportEnvironment
         _patternOmonos = rule3981 _lhsImonos
         _patternOnamesInScope = rule3982 _lhsInamesInScope
         _patternOparentTree = rule3983 _parentTree
         _patternOpatternMatchWarnings = rule3984 _lhsIpatternMatchWarnings
         _patternOtypeConstructors = rule3985 _lhsItypeConstructors
         !__result_ = T_Pattern_vOut118 _lhsObeta _lhsObetaUnique _lhsOconstraints _lhsOcounter _lhsOelements _lhsOenvironment _lhsOinfoTree _lhsOpatVarNames _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames
         in __result_ )
     in C_Pattern_s119 v118
   {-# INLINE rule3959 #-}
   rule3959 = \ ((_nameIself) :: Name) ((_patternIpatVarNames) :: Names) ->
                                     _nameIself : _patternIpatVarNames
   {-# INLINE rule3960 #-}
   rule3960 = \ ((_lhsIparentTree) :: InfoTree) _localInfo ((_patternIinfoTree) :: InfoTree) ->
                            node _lhsIparentTree _localInfo [_patternIinfoTree]
   {-# INLINE rule3961 #-}
   rule3961 = \ _parentTree ->
                            _parentTree
   {-# INLINE rule3962 #-}
   rule3962 = \ _beta ((_lhsImonos) :: Monos) _self ->
                            LocalInfo { self = UHA_Pat _self
                                      , assignedType = Just _beta
                                      , monos = _lhsImonos
                                      }
   {-# INLINE rule3963 #-}
   rule3963 = \ _localInfo ((_nameIself) :: Name) _parentTree ->
     specialConstraint "as pattern" _parentTree
        (self _localInfo, Just $ nameToUHA_Pat _nameIself)
        []
   {-# INLINE rule3964 #-}
   rule3964 = \ _beta ((_nameIself) :: Name) ((_patternIenvironment) :: PatternAssumptions) ->
                                M.insert _nameIself _beta _patternIenvironment
   {-# INLINE rule3965 #-}
   rule3965 = \ ((_lhsIbetaUnique) :: Int) ->
                                _lhsIbetaUnique + 1
   {-# INLINE rule3966 #-}
   rule3966 = \ ((_lhsIbetaUnique) :: Int) _newcon ((_patternIconstraints) :: ConstraintSet) ->
                                _newcon .>.
                                Node [ Receive _lhsIbetaUnique
                                     , _patternIconstraints
                                     ]
   {-# INLINE rule3967 #-}
   rule3967 = \ ((_lhsIbetaUnique) :: Int) ->
                                TVar _lhsIbetaUnique
   {-# INLINE rule3968 #-}
   rule3968 = \ _beta _cinfo ((_patternIbeta) :: Tp) ->
                                [ (_beta .==. _patternIbeta) _cinfo ]
   {-# INLINE rule3969 #-}
   rule3969 = \ ((_patternIunboundNames) :: Names) ->
     _patternIunboundNames
   {-# INLINE rule3970 #-}
   rule3970 = \ ((_nameIself) :: Name) ((_patternIself) :: Pattern) ((_rangeIself) :: Range) ->
     Pattern_As _rangeIself _nameIself _patternIself
   {-# INLINE rule3971 #-}
   rule3971 = \ _self ->
     _self
   {-# INLINE rule3972 #-}
   rule3972 = \ _beta ->
     _beta
   {-# INLINE rule3973 #-}
   rule3973 = \ ((_patternIbetaUnique) :: Int) ->
     _patternIbetaUnique
   {-# INLINE rule3974 #-}
   rule3974 = \ _constraints ->
     _constraints
   {-# INLINE rule3975 #-}
   rule3975 = \ ((_patternIcounter) :: Int) ->
     _patternIcounter
   {-# INLINE rule3976 #-}
   rule3976 = \ ((_patternIelements) ::   [PatternElement]        ) ->
     _patternIelements
   {-# INLINE rule3977 #-}
   rule3977 = \ ((_patternIpatternMatchWarnings) :: [Warning]) ->
     _patternIpatternMatchWarnings
   {-# INLINE rule3978 #-}
   rule3978 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule3979 #-}
   rule3979 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule3980 #-}
   rule3980 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule3981 #-}
   rule3981 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule3982 #-}
   rule3982 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule3983 #-}
   rule3983 = \ _parentTree ->
     _parentTree
   {-# INLINE rule3984 #-}
   rule3984 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule3985 #-}
   rule3985 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
{-# NOINLINE sem_Pattern_Wildcard #-}
sem_Pattern_Wildcard :: T_Range  -> T_Pattern 
sem_Pattern_Wildcard arg_range_ = T_Pattern (return st119) where
   {-# NOINLINE st119 #-}
   !st119 = let
      v118 :: T_Pattern_v118 
      v118 = \ !(T_Pattern_vIn118 _lhsIambiguousConflicts _lhsIbetaUnique _lhsIcounter _lhsIimportEnvironment _lhsImonos _lhsInamesInScope _lhsIparentTree _lhsIpatternMatchWarnings _lhsItypeConstructors) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         _lhsOelements ::   [PatternElement]        
         _lhsOelements = rule3986  ()
         _parentTree = rule3987 _lhsIparentTree _localInfo
         _lhsOinfoTree :: InfoTree
         _lhsOinfoTree = rule3988 _parentTree
         _localInfo = rule3989 _beta _lhsImonos _self
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule3990 _lhsIbetaUnique
         _lhsOenvironment :: PatternAssumptions
         _lhsOenvironment = rule3991  ()
         _constraints = rule3992  ()
         _beta = rule3993 _lhsIbetaUnique
         _lhsOpatVarNames :: Names
         _lhsOpatVarNames = rule3994  ()
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule3995  ()
         _self = rule3996 _rangeIself
         _lhsOself :: Pattern
         _lhsOself = rule3997 _self
         _lhsObeta :: Tp
         _lhsObeta = rule3998 _beta
         _lhsOconstraints :: ConstraintSet
         _lhsOconstraints = rule3999 _constraints
         _lhsOcounter :: Int
         _lhsOcounter = rule4000 _lhsIcounter
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule4001 _lhsIpatternMatchWarnings
         !__result_ = T_Pattern_vOut118 _lhsObeta _lhsObetaUnique _lhsOconstraints _lhsOcounter _lhsOelements _lhsOenvironment _lhsOinfoTree _lhsOpatVarNames _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames
         in __result_ )
     in C_Pattern_s119 v118
   {-# INLINE rule3986 #-}
   rule3986 = \  (_ :: ()) ->
                                         [WildcardElement]
   {-# INLINE rule3987 #-}
   rule3987 = \ ((_lhsIparentTree) :: InfoTree) _localInfo ->
                            node _lhsIparentTree _localInfo []
   {-# INLINE rule3988 #-}
   rule3988 = \ _parentTree ->
                            _parentTree
   {-# INLINE rule3989 #-}
   rule3989 = \ _beta ((_lhsImonos) :: Monos) _self ->
                            LocalInfo { self = UHA_Pat _self
                                      , assignedType = Just _beta
                                      , monos = _lhsImonos
                                      }
   {-# INLINE rule3990 #-}
   rule3990 = \ ((_lhsIbetaUnique) :: Int) ->
                            _lhsIbetaUnique + 1
   {-# INLINE rule3991 #-}
   rule3991 = \  (_ :: ()) ->
                            noAssumptions
   {-# INLINE rule3992 #-}
   rule3992 = \  (_ :: ()) ->
                            emptyTree
   {-# INLINE rule3993 #-}
   rule3993 = \ ((_lhsIbetaUnique) :: Int) ->
                            TVar _lhsIbetaUnique
   {-# INLINE rule3994 #-}
   rule3994 = \  (_ :: ()) ->
     []
   {-# INLINE rule3995 #-}
   rule3995 = \  (_ :: ()) ->
     []
   {-# INLINE rule3996 #-}
   rule3996 = \ ((_rangeIself) :: Range) ->
     Pattern_Wildcard _rangeIself
   {-# INLINE rule3997 #-}
   rule3997 = \ _self ->
     _self
   {-# INLINE rule3998 #-}
   rule3998 = \ _beta ->
     _beta
   {-# INLINE rule3999 #-}
   rule3999 = \ _constraints ->
     _constraints
   {-# INLINE rule4000 #-}
   rule4000 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule4001 #-}
   rule4001 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
{-# NOINLINE sem_Pattern_Irrefutable #-}
sem_Pattern_Irrefutable :: T_Range  -> T_Pattern  -> T_Pattern 
sem_Pattern_Irrefutable arg_range_ arg_pattern_ = T_Pattern (return st119) where
   {-# NOINLINE st119 #-}
   !st119 = let
      v118 :: T_Pattern_v118 
      v118 = \ !(T_Pattern_vIn118 _lhsIambiguousConflicts _lhsIbetaUnique _lhsIcounter _lhsIimportEnvironment _lhsImonos _lhsInamesInScope _lhsIparentTree _lhsIpatternMatchWarnings _lhsItypeConstructors) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _patternX119 = Control.Monad.Identity.runIdentity (attach_T_Pattern (arg_pattern_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_Pattern_vOut118 _patternIbeta _patternIbetaUnique _patternIconstraints _patternIcounter _patternIelements _patternIenvironment _patternIinfoTree _patternIpatVarNames _patternIpatternMatchWarnings _patternIself _patternIunboundNames) = inv_Pattern_s119 _patternX119 (T_Pattern_vIn118 _patternOambiguousConflicts _patternObetaUnique _patternOcounter _patternOimportEnvironment _patternOmonos _patternOnamesInScope _patternOparentTree _patternOpatternMatchWarnings _patternOtypeConstructors)
         _lhsOpatVarNames :: Names
         _lhsOpatVarNames = rule4002 _patternIpatVarNames
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule4003 _patternIunboundNames
         _self = rule4004 _patternIself _rangeIself
         _lhsOself :: Pattern
         _lhsOself = rule4005 _self
         _lhsObeta :: Tp
         _lhsObeta = rule4006 _patternIbeta
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule4007 _patternIbetaUnique
         _lhsOconstraints :: ConstraintSet
         _lhsOconstraints = rule4008 _patternIconstraints
         _lhsOcounter :: Int
         _lhsOcounter = rule4009 _patternIcounter
         _lhsOelements ::   [PatternElement]        
         _lhsOelements = rule4010 _patternIelements
         _lhsOenvironment :: PatternAssumptions
         _lhsOenvironment = rule4011 _patternIenvironment
         _lhsOinfoTree :: InfoTree
         _lhsOinfoTree = rule4012 _patternIinfoTree
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule4013 _patternIpatternMatchWarnings
         _patternOambiguousConflicts = rule4014 _lhsIambiguousConflicts
         _patternObetaUnique = rule4015 _lhsIbetaUnique
         _patternOcounter = rule4016 _lhsIcounter
         _patternOimportEnvironment = rule4017 _lhsIimportEnvironment
         _patternOmonos = rule4018 _lhsImonos
         _patternOnamesInScope = rule4019 _lhsInamesInScope
         _patternOparentTree = rule4020 _lhsIparentTree
         _patternOpatternMatchWarnings = rule4021 _lhsIpatternMatchWarnings
         _patternOtypeConstructors = rule4022 _lhsItypeConstructors
         !__result_ = T_Pattern_vOut118 _lhsObeta _lhsObetaUnique _lhsOconstraints _lhsOcounter _lhsOelements _lhsOenvironment _lhsOinfoTree _lhsOpatVarNames _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames
         in __result_ )
     in C_Pattern_s119 v118
   {-# INLINE rule4002 #-}
   rule4002 = \ ((_patternIpatVarNames) :: Names) ->
     _patternIpatVarNames
   {-# INLINE rule4003 #-}
   rule4003 = \ ((_patternIunboundNames) :: Names) ->
     _patternIunboundNames
   {-# INLINE rule4004 #-}
   rule4004 = \ ((_patternIself) :: Pattern) ((_rangeIself) :: Range) ->
     Pattern_Irrefutable _rangeIself _patternIself
   {-# INLINE rule4005 #-}
   rule4005 = \ _self ->
     _self
   {-# INLINE rule4006 #-}
   rule4006 = \ ((_patternIbeta) :: Tp) ->
     _patternIbeta
   {-# INLINE rule4007 #-}
   rule4007 = \ ((_patternIbetaUnique) :: Int) ->
     _patternIbetaUnique
   {-# INLINE rule4008 #-}
   rule4008 = \ ((_patternIconstraints) :: ConstraintSet) ->
     _patternIconstraints
   {-# INLINE rule4009 #-}
   rule4009 = \ ((_patternIcounter) :: Int) ->
     _patternIcounter
   {-# INLINE rule4010 #-}
   rule4010 = \ ((_patternIelements) ::   [PatternElement]        ) ->
     _patternIelements
   {-# INLINE rule4011 #-}
   rule4011 = \ ((_patternIenvironment) :: PatternAssumptions) ->
     _patternIenvironment
   {-# INLINE rule4012 #-}
   rule4012 = \ ((_patternIinfoTree) :: InfoTree) ->
     _patternIinfoTree
   {-# INLINE rule4013 #-}
   rule4013 = \ ((_patternIpatternMatchWarnings) :: [Warning]) ->
     _patternIpatternMatchWarnings
   {-# INLINE rule4014 #-}
   rule4014 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule4015 #-}
   rule4015 = \ ((_lhsIbetaUnique) :: Int) ->
     _lhsIbetaUnique
   {-# INLINE rule4016 #-}
   rule4016 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule4017 #-}
   rule4017 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule4018 #-}
   rule4018 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule4019 #-}
   rule4019 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule4020 #-}
   rule4020 = \ ((_lhsIparentTree) :: InfoTree) ->
     _lhsIparentTree
   {-# INLINE rule4021 #-}
   rule4021 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule4022 #-}
   rule4022 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
{-# NOINLINE sem_Pattern_Successor #-}
sem_Pattern_Successor :: T_Range  -> T_Name  -> T_Literal  -> T_Pattern 
sem_Pattern_Successor arg_range_ arg_name_ arg_literal_ = T_Pattern (return st119) where
   {-# NOINLINE st119 #-}
   !st119 = let
      v118 :: T_Pattern_v118 
      v118 = \ !(T_Pattern_vIn118 _lhsIambiguousConflicts _lhsIbetaUnique _lhsIcounter _lhsIimportEnvironment _lhsImonos _lhsInamesInScope _lhsIparentTree _lhsIpatternMatchWarnings _lhsItypeConstructors) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _nameX113 = Control.Monad.Identity.runIdentity (attach_T_Name (arg_name_))
         _literalX86 = Control.Monad.Identity.runIdentity (attach_T_Literal (arg_literal_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_Name_vOut112 _nameIself) = inv_Name_s113 _nameX113 (T_Name_vIn112 )
         (T_Literal_vOut85 _literalIelements _literalIliteralType _literalIself) = inv_Literal_s86 _literalX86 (T_Literal_vIn85 )
         _lhsOelements ::   [PatternElement]        
         _lhsOelements = rule4023  ()
         (_beta,_constraints,_environment) = rule4024  ()
         _infoTree = rule4025  ()
         _lhsOpatVarNames :: Names
         _lhsOpatVarNames = rule4026  ()
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule4027  ()
         _self = rule4028 _literalIself _nameIself _rangeIself
         _lhsOself :: Pattern
         _lhsOself = rule4029 _self
         _lhsObeta :: Tp
         _lhsObeta = rule4030 _beta
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule4031 _lhsIbetaUnique
         _lhsOconstraints :: ConstraintSet
         _lhsOconstraints = rule4032 _constraints
         _lhsOcounter :: Int
         _lhsOcounter = rule4033 _lhsIcounter
         _lhsOenvironment :: PatternAssumptions
         _lhsOenvironment = rule4034 _environment
         _lhsOinfoTree :: InfoTree
         _lhsOinfoTree = rule4035 _infoTree
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule4036 _lhsIpatternMatchWarnings
         !__result_ = T_Pattern_vOut118 _lhsObeta _lhsObetaUnique _lhsOconstraints _lhsOcounter _lhsOelements _lhsOenvironment _lhsOinfoTree _lhsOpatVarNames _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames
         in __result_ )
     in C_Pattern_s119 v118
   {-# INLINE rule4023 #-}
   rule4023 = \  (_ :: ()) ->
                                         pmError "Pattern_Successor.elements" "Successors are not supported"
   {-# INLINE rule4024 #-}
   rule4024 = \  (_ :: ()) ->
                                                       internalError "PartialSyntax.ag" "n/a" "Pattern.Successor"
   {-# INLINE rule4025 #-}
   rule4025 = \  (_ :: ()) ->
                                                                            globalInfoError
   {-# INLINE rule4026 #-}
   rule4026 = \  (_ :: ()) ->
     []
   {-# INLINE rule4027 #-}
   rule4027 = \  (_ :: ()) ->
     []
   {-# INLINE rule4028 #-}
   rule4028 = \ ((_literalIself) :: Literal) ((_nameIself) :: Name) ((_rangeIself) :: Range) ->
     Pattern_Successor _rangeIself _nameIself _literalIself
   {-# INLINE rule4029 #-}
   rule4029 = \ _self ->
     _self
   {-# INLINE rule4030 #-}
   rule4030 = \ _beta ->
     _beta
   {-# INLINE rule4031 #-}
   rule4031 = \ ((_lhsIbetaUnique) :: Int) ->
     _lhsIbetaUnique
   {-# INLINE rule4032 #-}
   rule4032 = \ _constraints ->
     _constraints
   {-# INLINE rule4033 #-}
   rule4033 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule4034 #-}
   rule4034 = \ _environment ->
     _environment
   {-# INLINE rule4035 #-}
   rule4035 = \ _infoTree ->
     _infoTree
   {-# INLINE rule4036 #-}
   rule4036 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
{-# NOINLINE sem_Pattern_NegateFloat #-}
sem_Pattern_NegateFloat :: T_Range  -> T_Literal  -> T_Pattern 
sem_Pattern_NegateFloat arg_range_ arg_literal_ = T_Pattern (return st119) where
   {-# NOINLINE st119 #-}
   !st119 = let
      v118 :: T_Pattern_v118 
      v118 = \ !(T_Pattern_vIn118 _lhsIambiguousConflicts _lhsIbetaUnique _lhsIcounter _lhsIimportEnvironment _lhsImonos _lhsInamesInScope _lhsIparentTree _lhsIpatternMatchWarnings _lhsItypeConstructors) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _literalX86 = Control.Monad.Identity.runIdentity (attach_T_Literal (arg_literal_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_Literal_vOut85 _literalIelements _literalIliteralType _literalIself) = inv_Literal_s86 _literalX86 (T_Literal_vIn85 )
         _parentTree = rule4037 _lhsIparentTree _localInfo
         _lhsOinfoTree :: InfoTree
         _lhsOinfoTree = rule4038 _parentTree
         _localInfo = rule4039 _beta _lhsImonos _self
         _cinfo = rule4040 _parentTree
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule4041 _lhsIbetaUnique
         _lhsOenvironment :: PatternAssumptions
         _lhsOenvironment = rule4042  ()
         _constraints = rule4043 _newcon
         _beta = rule4044 _lhsIbetaUnique
         _newcon = rule4045 _beta _cinfo
         _lhsOpatVarNames :: Names
         _lhsOpatVarNames = rule4046  ()
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule4047  ()
         _self = rule4048 _literalIself _rangeIself
         _lhsOself :: Pattern
         _lhsOself = rule4049 _self
         _lhsObeta :: Tp
         _lhsObeta = rule4050 _beta
         _lhsOconstraints :: ConstraintSet
         _lhsOconstraints = rule4051 _constraints
         _lhsOcounter :: Int
         _lhsOcounter = rule4052 _lhsIcounter
         _lhsOelements ::   [PatternElement]        
         _lhsOelements = rule4053 _literalIelements
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule4054 _lhsIpatternMatchWarnings
         !__result_ = T_Pattern_vOut118 _lhsObeta _lhsObetaUnique _lhsOconstraints _lhsOcounter _lhsOelements _lhsOenvironment _lhsOinfoTree _lhsOpatVarNames _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames
         in __result_ )
     in C_Pattern_s119 v118
   {-# INLINE rule4037 #-}
   rule4037 = \ ((_lhsIparentTree) :: InfoTree) _localInfo ->
                            node _lhsIparentTree _localInfo []
   {-# INLINE rule4038 #-}
   rule4038 = \ _parentTree ->
                            _parentTree
   {-# INLINE rule4039 #-}
   rule4039 = \ _beta ((_lhsImonos) :: Monos) _self ->
                            LocalInfo { self = UHA_Pat _self
                                      , assignedType = Just _beta
                                      , monos = _lhsImonos
                                      }
   {-# INLINE rule4040 #-}
   rule4040 = \ _parentTree ->
     resultConstraint "pattern negation" _parentTree
        [ FolkloreConstraint ]
   {-# INLINE rule4041 #-}
   rule4041 = \ ((_lhsIbetaUnique) :: Int) ->
                            _lhsIbetaUnique + 1
   {-# INLINE rule4042 #-}
   rule4042 = \  (_ :: ()) ->
                            noAssumptions
   {-# INLINE rule4043 #-}
   rule4043 = \ _newcon ->
                            listTree _newcon
   {-# INLINE rule4044 #-}
   rule4044 = \ ((_lhsIbetaUnique) :: Int) ->
                            TVar _lhsIbetaUnique
   {-# INLINE rule4045 #-}
   rule4045 = \ _beta _cinfo ->
                            [ (floatQualType .==. _beta) _cinfo ]
   {-# INLINE rule4046 #-}
   rule4046 = \  (_ :: ()) ->
     []
   {-# INLINE rule4047 #-}
   rule4047 = \  (_ :: ()) ->
     []
   {-# INLINE rule4048 #-}
   rule4048 = \ ((_literalIself) :: Literal) ((_rangeIself) :: Range) ->
     Pattern_NegateFloat _rangeIself _literalIself
   {-# INLINE rule4049 #-}
   rule4049 = \ _self ->
     _self
   {-# INLINE rule4050 #-}
   rule4050 = \ _beta ->
     _beta
   {-# INLINE rule4051 #-}
   rule4051 = \ _constraints ->
     _constraints
   {-# INLINE rule4052 #-}
   rule4052 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule4053 #-}
   rule4053 = \ ((_literalIelements) ::   [PatternElement]        ) ->
     _literalIelements
   {-# INLINE rule4054 #-}
   rule4054 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings

-- Patterns ----------------------------------------------------
-- wrapper
data Inh_Patterns  = Inh_Patterns { ambiguousConflicts_Inh_Patterns :: !([[Name]]), betaUnique_Inh_Patterns :: !(Int), counter_Inh_Patterns :: !(Int), importEnvironment_Inh_Patterns :: !(ImportEnvironment), monos_Inh_Patterns :: !(Monos), namesInScope_Inh_Patterns :: !(Names), parentTree_Inh_Patterns :: !(InfoTree), patternMatchWarnings_Inh_Patterns :: !([Warning]), typeConstructors_Inh_Patterns :: !(TypeConstructorEnvironment) }
data Syn_Patterns  = Syn_Patterns { betaUnique_Syn_Patterns :: !(Int), betas_Syn_Patterns :: !(Tps), constraintslist_Syn_Patterns :: !(ConstraintSets), counter_Syn_Patterns :: !(Int), elementss_Syn_Patterns :: !([ [PatternElement]       ]), environment_Syn_Patterns :: !(PatternAssumptions), infoTrees_Syn_Patterns :: !(InfoTrees), numberOfPatterns_Syn_Patterns :: !(Int), patVarNames_Syn_Patterns :: !(Names), patternMatchWarnings_Syn_Patterns :: !([Warning]), self_Syn_Patterns :: !(Patterns), unboundNames_Syn_Patterns :: !(Names) }
{-# INLINABLE wrap_Patterns #-}
wrap_Patterns :: T_Patterns  -> Inh_Patterns  -> (Syn_Patterns )
wrap_Patterns !(T_Patterns act) !(Inh_Patterns _lhsIambiguousConflicts _lhsIbetaUnique _lhsIcounter _lhsIimportEnvironment _lhsImonos _lhsInamesInScope _lhsIparentTree _lhsIpatternMatchWarnings _lhsItypeConstructors) =
   Control.Monad.Identity.runIdentity (
     do !sem <- act
        let arg121 = T_Patterns_vIn121 _lhsIambiguousConflicts _lhsIbetaUnique _lhsIcounter _lhsIimportEnvironment _lhsImonos _lhsInamesInScope _lhsIparentTree _lhsIpatternMatchWarnings _lhsItypeConstructors
        !(T_Patterns_vOut121 _lhsObetaUnique _lhsObetas _lhsOconstraintslist _lhsOcounter _lhsOelementss _lhsOenvironment _lhsOinfoTrees _lhsOnumberOfPatterns _lhsOpatVarNames _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames) <- return (inv_Patterns_s122 sem arg121)
        return (Syn_Patterns _lhsObetaUnique _lhsObetas _lhsOconstraintslist _lhsOcounter _lhsOelementss _lhsOenvironment _lhsOinfoTrees _lhsOnumberOfPatterns _lhsOpatVarNames _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames)
   )

-- cata
{-# NOINLINE sem_Patterns #-}
sem_Patterns :: Patterns  -> T_Patterns 
sem_Patterns list = Prelude.foldr sem_Patterns_Cons sem_Patterns_Nil (Prelude.map sem_Pattern list)

-- semantic domain
newtype T_Patterns  = T_Patterns {
                                 attach_T_Patterns :: Identity (T_Patterns_s122 )
                                 }
newtype T_Patterns_s122  = C_Patterns_s122 {
                                           inv_Patterns_s122 :: (T_Patterns_v121 )
                                           }
data T_Patterns_s123  = C_Patterns_s123
type T_Patterns_v121  = (T_Patterns_vIn121 ) -> (T_Patterns_vOut121 )
data T_Patterns_vIn121  = T_Patterns_vIn121 ([[Name]]) (Int) (Int) (ImportEnvironment) (Monos) (Names) (InfoTree) ([Warning]) (TypeConstructorEnvironment)
data T_Patterns_vOut121  = T_Patterns_vOut121 (Int) (Tps) (ConstraintSets) (Int) ([ [PatternElement]       ]) (PatternAssumptions) (InfoTrees) (Int) (Names) ([Warning]) (Patterns) (Names)
{-# NOINLINE sem_Patterns_Cons #-}
sem_Patterns_Cons :: T_Pattern  -> T_Patterns  -> T_Patterns 
sem_Patterns_Cons arg_hd_ arg_tl_ = T_Patterns (return st122) where
   {-# NOINLINE st122 #-}
   !st122 = let
      v121 :: T_Patterns_v121 
      v121 = \ !(T_Patterns_vIn121 _lhsIambiguousConflicts _lhsIbetaUnique _lhsIcounter _lhsIimportEnvironment _lhsImonos _lhsInamesInScope _lhsIparentTree _lhsIpatternMatchWarnings _lhsItypeConstructors) -> ( let
         _hdX119 = Control.Monad.Identity.runIdentity (attach_T_Pattern (arg_hd_))
         _tlX122 = Control.Monad.Identity.runIdentity (attach_T_Patterns (arg_tl_))
         (T_Pattern_vOut118 _hdIbeta _hdIbetaUnique _hdIconstraints _hdIcounter _hdIelements _hdIenvironment _hdIinfoTree _hdIpatVarNames _hdIpatternMatchWarnings _hdIself _hdIunboundNames) = inv_Pattern_s119 _hdX119 (T_Pattern_vIn118 _hdOambiguousConflicts _hdObetaUnique _hdOcounter _hdOimportEnvironment _hdOmonos _hdOnamesInScope _hdOparentTree _hdOpatternMatchWarnings _hdOtypeConstructors)
         (T_Patterns_vOut121 _tlIbetaUnique _tlIbetas _tlIconstraintslist _tlIcounter _tlIelementss _tlIenvironment _tlIinfoTrees _tlInumberOfPatterns _tlIpatVarNames _tlIpatternMatchWarnings _tlIself _tlIunboundNames) = inv_Patterns_s122 _tlX122 (T_Patterns_vIn121 _tlOambiguousConflicts _tlObetaUnique _tlOcounter _tlOimportEnvironment _tlOmonos _tlOnamesInScope _tlOparentTree _tlOpatternMatchWarnings _tlOtypeConstructors)
         _lhsOelementss :: [ [PatternElement]       ]
         _lhsOelementss = rule4055 _hdIelements _tlIelementss
         _lhsOinfoTrees :: InfoTrees
         _lhsOinfoTrees = rule4056 _hdIinfoTree _tlIinfoTrees
         _lhsObetas :: Tps
         _lhsObetas = rule4057 _hdIbeta _tlIbetas
         _lhsOenvironment :: PatternAssumptions
         _lhsOenvironment = rule4058 _hdIenvironment _tlIenvironment
         _lhsOnumberOfPatterns :: Int
         _lhsOnumberOfPatterns = rule4059 _tlInumberOfPatterns
         _lhsOconstraintslist :: ConstraintSets
         _lhsOconstraintslist = rule4060 _hdIconstraints _tlIconstraintslist
         _lhsOpatVarNames :: Names
         _lhsOpatVarNames = rule4061 _hdIpatVarNames _tlIpatVarNames
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule4062 _hdIunboundNames _tlIunboundNames
         _self = rule4063 _hdIself _tlIself
         _lhsOself :: Patterns
         _lhsOself = rule4064 _self
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule4065 _tlIbetaUnique
         _lhsOcounter :: Int
         _lhsOcounter = rule4066 _tlIcounter
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule4067 _tlIpatternMatchWarnings
         _hdOambiguousConflicts = rule4068 _lhsIambiguousConflicts
         _hdObetaUnique = rule4069 _lhsIbetaUnique
         _hdOcounter = rule4070 _lhsIcounter
         _hdOimportEnvironment = rule4071 _lhsIimportEnvironment
         _hdOmonos = rule4072 _lhsImonos
         _hdOnamesInScope = rule4073 _lhsInamesInScope
         _hdOparentTree = rule4074 _lhsIparentTree
         _hdOpatternMatchWarnings = rule4075 _lhsIpatternMatchWarnings
         _hdOtypeConstructors = rule4076 _lhsItypeConstructors
         _tlOambiguousConflicts = rule4077 _lhsIambiguousConflicts
         _tlObetaUnique = rule4078 _hdIbetaUnique
         _tlOcounter = rule4079 _hdIcounter
         _tlOimportEnvironment = rule4080 _lhsIimportEnvironment
         _tlOmonos = rule4081 _lhsImonos
         _tlOnamesInScope = rule4082 _lhsInamesInScope
         _tlOparentTree = rule4083 _lhsIparentTree
         _tlOpatternMatchWarnings = rule4084 _hdIpatternMatchWarnings
         _tlOtypeConstructors = rule4085 _lhsItypeConstructors
         !__result_ = T_Patterns_vOut121 _lhsObetaUnique _lhsObetas _lhsOconstraintslist _lhsOcounter _lhsOelementss _lhsOenvironment _lhsOinfoTrees _lhsOnumberOfPatterns _lhsOpatVarNames _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames
         in __result_ )
     in C_Patterns_s122 v121
   {-# INLINE rule4055 #-}
   rule4055 = \ ((_hdIelements) ::   [PatternElement]        ) ((_tlIelementss) :: [ [PatternElement]       ]) ->
                                         _hdIelements : _tlIelementss
   {-# INLINE rule4056 #-}
   rule4056 = \ ((_hdIinfoTree) :: InfoTree) ((_tlIinfoTrees) :: InfoTrees) ->
                               _hdIinfoTree : _tlIinfoTrees
   {-# INLINE rule4057 #-}
   rule4057 = \ ((_hdIbeta) :: Tp) ((_tlIbetas) :: Tps) ->
                                 _hdIbeta : _tlIbetas
   {-# INLINE rule4058 #-}
   rule4058 = \ ((_hdIenvironment) :: PatternAssumptions) ((_tlIenvironment) :: PatternAssumptions) ->
                                 _hdIenvironment `M.union` _tlIenvironment
   {-# INLINE rule4059 #-}
   rule4059 = \ ((_tlInumberOfPatterns) :: Int) ->
                                 1 + _tlInumberOfPatterns
   {-# INLINE rule4060 #-}
   rule4060 = \ ((_hdIconstraints) :: ConstraintSet) ((_tlIconstraintslist) :: ConstraintSets) ->
                                 _hdIconstraints : _tlIconstraintslist
   {-# INLINE rule4061 #-}
   rule4061 = \ ((_hdIpatVarNames) :: Names) ((_tlIpatVarNames) :: Names) ->
     _hdIpatVarNames ++ _tlIpatVarNames
   {-# INLINE rule4062 #-}
   rule4062 = \ ((_hdIunboundNames) :: Names) ((_tlIunboundNames) :: Names) ->
     ((++) _hdIunboundNames _tlIunboundNames)
   {-# INLINE rule4063 #-}
   rule4063 = \ ((_hdIself) :: Pattern) ((_tlIself) :: Patterns) ->
     (:) _hdIself _tlIself
   {-# INLINE rule4064 #-}
   rule4064 = \ _self ->
     _self
   {-# INLINE rule4065 #-}
   rule4065 = \ ((_tlIbetaUnique) :: Int) ->
     _tlIbetaUnique
   {-# INLINE rule4066 #-}
   rule4066 = \ ((_tlIcounter) :: Int) ->
     _tlIcounter
   {-# INLINE rule4067 #-}
   rule4067 = \ ((_tlIpatternMatchWarnings) :: [Warning]) ->
     _tlIpatternMatchWarnings
   {-# INLINE rule4068 #-}
   rule4068 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule4069 #-}
   rule4069 = \ ((_lhsIbetaUnique) :: Int) ->
     _lhsIbetaUnique
   {-# INLINE rule4070 #-}
   rule4070 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule4071 #-}
   rule4071 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule4072 #-}
   rule4072 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule4073 #-}
   rule4073 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule4074 #-}
   rule4074 = \ ((_lhsIparentTree) :: InfoTree) ->
     _lhsIparentTree
   {-# INLINE rule4075 #-}
   rule4075 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule4076 #-}
   rule4076 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
   {-# INLINE rule4077 #-}
   rule4077 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule4078 #-}
   rule4078 = \ ((_hdIbetaUnique) :: Int) ->
     _hdIbetaUnique
   {-# INLINE rule4079 #-}
   rule4079 = \ ((_hdIcounter) :: Int) ->
     _hdIcounter
   {-# INLINE rule4080 #-}
   rule4080 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule4081 #-}
   rule4081 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule4082 #-}
   rule4082 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule4083 #-}
   rule4083 = \ ((_lhsIparentTree) :: InfoTree) ->
     _lhsIparentTree
   {-# INLINE rule4084 #-}
   rule4084 = \ ((_hdIpatternMatchWarnings) :: [Warning]) ->
     _hdIpatternMatchWarnings
   {-# INLINE rule4085 #-}
   rule4085 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
{-# NOINLINE sem_Patterns_Nil #-}
sem_Patterns_Nil ::  T_Patterns 
sem_Patterns_Nil  = T_Patterns (return st122) where
   {-# NOINLINE st122 #-}
   !st122 = let
      v121 :: T_Patterns_v121 
      v121 = \ !(T_Patterns_vIn121 _lhsIambiguousConflicts _lhsIbetaUnique _lhsIcounter _lhsIimportEnvironment _lhsImonos _lhsInamesInScope _lhsIparentTree _lhsIpatternMatchWarnings _lhsItypeConstructors) -> ( let
         _lhsOelementss :: [ [PatternElement]       ]
         _lhsOelementss = rule4086  ()
         _lhsOinfoTrees :: InfoTrees
         _lhsOinfoTrees = rule4087  ()
         _lhsObetas :: Tps
         _lhsObetas = rule4088  ()
         _lhsOenvironment :: PatternAssumptions
         _lhsOenvironment = rule4089  ()
         _lhsOnumberOfPatterns :: Int
         _lhsOnumberOfPatterns = rule4090  ()
         _lhsOconstraintslist :: ConstraintSets
         _lhsOconstraintslist = rule4091  ()
         _lhsOpatVarNames :: Names
         _lhsOpatVarNames = rule4092  ()
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule4093  ()
         _self = rule4094  ()
         _lhsOself :: Patterns
         _lhsOself = rule4095 _self
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule4096 _lhsIbetaUnique
         _lhsOcounter :: Int
         _lhsOcounter = rule4097 _lhsIcounter
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule4098 _lhsIpatternMatchWarnings
         !__result_ = T_Patterns_vOut121 _lhsObetaUnique _lhsObetas _lhsOconstraintslist _lhsOcounter _lhsOelementss _lhsOenvironment _lhsOinfoTrees _lhsOnumberOfPatterns _lhsOpatVarNames _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames
         in __result_ )
     in C_Patterns_s122 v121
   {-# INLINE rule4086 #-}
   rule4086 = \  (_ :: ()) ->
                                         []
   {-# INLINE rule4087 #-}
   rule4087 = \  (_ :: ()) ->
                               []
   {-# INLINE rule4088 #-}
   rule4088 = \  (_ :: ()) ->
                                 []
   {-# INLINE rule4089 #-}
   rule4089 = \  (_ :: ()) ->
                                 noAssumptions
   {-# INLINE rule4090 #-}
   rule4090 = \  (_ :: ()) ->
                                 0
   {-# INLINE rule4091 #-}
   rule4091 = \  (_ :: ()) ->
                                 []
   {-# INLINE rule4092 #-}
   rule4092 = \  (_ :: ()) ->
     []
   {-# INLINE rule4093 #-}
   rule4093 = \  (_ :: ()) ->
     []
   {-# INLINE rule4094 #-}
   rule4094 = \  (_ :: ()) ->
     []
   {-# INLINE rule4095 #-}
   rule4095 = \ _self ->
     _self
   {-# INLINE rule4096 #-}
   rule4096 = \ ((_lhsIbetaUnique) :: Int) ->
     _lhsIbetaUnique
   {-# INLINE rule4097 #-}
   rule4097 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule4098 #-}
   rule4098 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings

-- Position ----------------------------------------------------
-- wrapper
data Inh_Position  = Inh_Position {  }
data Syn_Position  = Syn_Position { self_Syn_Position :: !(Position) }
{-# INLINABLE wrap_Position #-}
wrap_Position :: T_Position  -> Inh_Position  -> (Syn_Position )
wrap_Position !(T_Position act) !(Inh_Position ) =
   Control.Monad.Identity.runIdentity (
     do !sem <- act
        let arg124 = T_Position_vIn124 
        !(T_Position_vOut124 _lhsOself) <- return (inv_Position_s125 sem arg124)
        return (Syn_Position _lhsOself)
   )

-- cata
{-# NOINLINE sem_Position #-}
sem_Position :: Position  -> T_Position 
sem_Position ( Position_Position !filename_ !line_ !column_ ) = sem_Position_Position filename_ line_ column_
sem_Position ( Position_Unknown  ) = sem_Position_Unknown 

-- semantic domain
newtype T_Position  = T_Position {
                                 attach_T_Position :: Identity (T_Position_s125 )
                                 }
newtype T_Position_s125  = C_Position_s125 {
                                           inv_Position_s125 :: (T_Position_v124 )
                                           }
data T_Position_s126  = C_Position_s126
type T_Position_v124  = (T_Position_vIn124 ) -> (T_Position_vOut124 )
data T_Position_vIn124  = T_Position_vIn124 
data T_Position_vOut124  = T_Position_vOut124 (Position)
{-# NOINLINE sem_Position_Position #-}
sem_Position_Position :: (String) -> (Int) -> (Int) -> T_Position 
sem_Position_Position !arg_filename_ !arg_line_ !arg_column_ = T_Position (return st125) where
   {-# NOINLINE st125 #-}
   !st125 = let
      v124 :: T_Position_v124 
      v124 = \ !(T_Position_vIn124 ) -> ( let
         _self = rule4099 arg_column_ arg_filename_ arg_line_
         _lhsOself :: Position
         _lhsOself = rule4100 _self
         !__result_ = T_Position_vOut124 _lhsOself
         in __result_ )
     in C_Position_s125 v124
   {-# INLINE rule4099 #-}
   rule4099 = \ column_ filename_ line_ ->
     Position_Position filename_ line_ column_
   {-# INLINE rule4100 #-}
   rule4100 = \ _self ->
     _self
{-# NOINLINE sem_Position_Unknown #-}
sem_Position_Unknown ::  T_Position 
sem_Position_Unknown  = T_Position (return st125) where
   {-# NOINLINE st125 #-}
   !st125 = let
      v124 :: T_Position_v124 
      v124 = \ !(T_Position_vIn124 ) -> ( let
         _self = rule4101  ()
         _lhsOself :: Position
         _lhsOself = rule4102 _self
         !__result_ = T_Position_vOut124 _lhsOself
         in __result_ )
     in C_Position_s125 v124
   {-# INLINE rule4101 #-}
   rule4101 = \  (_ :: ()) ->
     Position_Unknown
   {-# INLINE rule4102 #-}
   rule4102 = \ _self ->
     _self

-- Qualifier ---------------------------------------------------
-- wrapper
data Inh_Qualifier  = Inh_Qualifier { allPatterns_Inh_Qualifier :: !([((Expression, [String]), Core_TypingStrategy)]), allTypeSchemes_Inh_Qualifier :: !(M.Map NameWithRange TpScheme), ambiguousConflicts_Inh_Qualifier :: !([[Name]]), assumptions_Inh_Qualifier :: !(Assumptions), availablePredicates_Inh_Qualifier :: !([PredicateWithSource]), betaUnique_Inh_Qualifier :: !(Int), classEnvironment_Inh_Qualifier :: !(ClassEnvironment), classMemberEnv_Inh_Qualifier :: !(ClassMemberEnvironment), classMemberTypeSchemes_Inh_Qualifier :: !(Maybe [(Name, TpScheme)]), classNamesEnv_Inh_Qualifier :: !(ClassNameEnvironment), classPredicate_Inh_Qualifier :: !(Maybe (Name, Names)), classTypeSchemes_Inh_Qualifier :: !(M.Map Name TpScheme), collectErrors_Inh_Qualifier :: !(TypeErrors), collectWarnings_Inh_Qualifier :: !(Warnings), constraints_Inh_Qualifier :: !(ConstraintSet), counter_Inh_Qualifier :: !(Int), curClassPred_Inh_Qualifier :: !(Maybe Predicate), curPred_Inh_Qualifier :: !(Maybe Predicate), currentChunk_Inh_Qualifier :: !(Int), dictionaryEnvironment_Inh_Qualifier :: !(DictionaryEnvironment), importEnvironment_Inh_Qualifier :: !(ImportEnvironment), instanceName_Inh_Qualifier :: !(Maybe Name), instanceTypes_Inh_Qualifier :: !([(Name, TpScheme)]), matchIO_Inh_Qualifier :: !(IO ()), moduleName_Inh_Qualifier :: !(Maybe Name), monos_Inh_Qualifier :: !(Monos), namesInScope_Inh_Qualifier :: !(Names), orderedTypeSynonyms_Inh_Qualifier :: !(OrderedTypeSynonyms), parentTree_Inh_Qualifier :: !(InfoTree), patternMatchWarnings_Inh_Qualifier :: !([Warning]), requiredPredicates_Inh_Qualifier :: !(Predicates), substitution_Inh_Qualifier :: !(FixpointSubstitution), typeConstructors_Inh_Qualifier :: !(TypeConstructorEnvironment), typeschemeMap_Inh_Qualifier :: !(M.Map Int (Scheme Predicates)), unboundNames_Inh_Qualifier :: !(Names), uniqueChunk_Inh_Qualifier :: !(Int), uniqueSecondRound_Inh_Qualifier :: !(Int), variableMapping_Inh_Qualifier :: !(Maybe [(Name, Tp)]) }
data Syn_Qualifier  = Syn_Qualifier { assumptions_Syn_Qualifier :: !(Assumptions), betaUnique_Syn_Qualifier :: !(Int), collectErrors_Syn_Qualifier :: !(TypeErrors), collectInstances_Syn_Qualifier :: !([(Name, Instance)]), collectWarnings_Syn_Qualifier :: !(Warnings), constraints_Syn_Qualifier :: !(ConstraintSet), counter_Syn_Qualifier :: !(Int), dictionaryEnvironment_Syn_Qualifier :: !(DictionaryEnvironment), infoTree_Syn_Qualifier :: !(InfoTree), matchIO_Syn_Qualifier :: !(IO ()), monos_Syn_Qualifier :: !(Monos), namesInScope_Syn_Qualifier :: !(Names), patternMatchWarnings_Syn_Qualifier :: !([Warning]), self_Syn_Qualifier :: !(Qualifier), unboundNames_Syn_Qualifier :: !(Names), uniqueChunk_Syn_Qualifier :: !(Int), uniqueSecondRound_Syn_Qualifier :: !(Int) }
{-# INLINABLE wrap_Qualifier #-}
wrap_Qualifier :: T_Qualifier  -> Inh_Qualifier  -> (Syn_Qualifier )
wrap_Qualifier !(T_Qualifier act) !(Inh_Qualifier _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIassumptions _lhsIavailablePredicates _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIconstraints _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeConstructors _lhsItypeschemeMap _lhsIunboundNames _lhsIuniqueChunk _lhsIuniqueSecondRound _lhsIvariableMapping) =
   Control.Monad.Identity.runIdentity (
     do !sem <- act
        let arg127 = T_Qualifier_vIn127 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIassumptions _lhsIavailablePredicates _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIconstraints _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeConstructors _lhsItypeschemeMap _lhsIunboundNames _lhsIuniqueChunk _lhsIuniqueSecondRound _lhsIvariableMapping
        !(T_Qualifier_vOut127 _lhsOassumptions _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraints _lhsOcounter _lhsOdictionaryEnvironment _lhsOinfoTree _lhsOmatchIO _lhsOmonos _lhsOnamesInScope _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOuniqueSecondRound) <- return (inv_Qualifier_s128 sem arg127)
        return (Syn_Qualifier _lhsOassumptions _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraints _lhsOcounter _lhsOdictionaryEnvironment _lhsOinfoTree _lhsOmatchIO _lhsOmonos _lhsOnamesInScope _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOuniqueSecondRound)
   )

-- cata
{-# NOINLINE sem_Qualifier #-}
sem_Qualifier :: Qualifier  -> T_Qualifier 
sem_Qualifier ( Qualifier_Guard range_ guard_ ) = sem_Qualifier_Guard ( sem_Range range_ ) ( sem_Expression guard_ )
sem_Qualifier ( Qualifier_Let range_ declarations_ ) = sem_Qualifier_Let ( sem_Range range_ ) ( sem_Declarations declarations_ )
sem_Qualifier ( Qualifier_Generator range_ pattern_ expression_ ) = sem_Qualifier_Generator ( sem_Range range_ ) ( sem_Pattern pattern_ ) ( sem_Expression expression_ )
sem_Qualifier ( Qualifier_Empty range_ ) = sem_Qualifier_Empty ( sem_Range range_ )

-- semantic domain
newtype T_Qualifier  = T_Qualifier {
                                   attach_T_Qualifier :: Identity (T_Qualifier_s128 )
                                   }
newtype T_Qualifier_s128  = C_Qualifier_s128 {
                                             inv_Qualifier_s128 :: (T_Qualifier_v127 )
                                             }
data T_Qualifier_s129  = C_Qualifier_s129
type T_Qualifier_v127  = (T_Qualifier_vIn127 ) -> (T_Qualifier_vOut127 )
data T_Qualifier_vIn127  = T_Qualifier_vIn127 ([((Expression, [String]), Core_TypingStrategy)]) (M.Map NameWithRange TpScheme) ([[Name]]) (Assumptions) ([PredicateWithSource]) (Int) (ClassEnvironment) (ClassMemberEnvironment) (Maybe [(Name, TpScheme)]) (ClassNameEnvironment) (Maybe (Name, Names)) (M.Map Name TpScheme) (TypeErrors) (Warnings) (ConstraintSet) (Int) (Maybe Predicate) (Maybe Predicate) (Int) (DictionaryEnvironment) (ImportEnvironment) (Maybe Name) ([(Name, TpScheme)]) (IO ()) (Maybe Name) (Monos) (Names) (OrderedTypeSynonyms) (InfoTree) ([Warning]) (Predicates) (FixpointSubstitution) (TypeConstructorEnvironment) (M.Map Int (Scheme Predicates)) (Names) (Int) (Int) (Maybe [(Name, Tp)])
data T_Qualifier_vOut127  = T_Qualifier_vOut127 (Assumptions) (Int) (TypeErrors) ([(Name, Instance)]) (Warnings) (ConstraintSet) (Int) (DictionaryEnvironment) (InfoTree) (IO ()) (Monos) (Names) ([Warning]) (Qualifier) (Names) (Int) (Int)
{-# NOINLINE sem_Qualifier_Guard #-}
sem_Qualifier_Guard :: T_Range  -> T_Expression  -> T_Qualifier 
sem_Qualifier_Guard arg_range_ arg_guard_ = T_Qualifier (return st128) where
   {-# NOINLINE st128 #-}
   !st128 = let
      v127 :: T_Qualifier_v127 
      v127 = \ !(T_Qualifier_vIn127 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIassumptions _lhsIavailablePredicates _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIconstraints _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeConstructors _lhsItypeschemeMap _lhsIunboundNames _lhsIuniqueChunk _lhsIuniqueSecondRound _lhsIvariableMapping) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _guardX41 = Control.Monad.Identity.runIdentity (attach_T_Expression (arg_guard_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_Expression_vOut40 _guardIassumptions _guardIbeta _guardIbetaUnique _guardIcollectErrors _guardIcollectInstances _guardIcollectWarnings _guardIconstraints _guardIcounter _guardIdictionaryEnvironment _guardIinfoTree _guardImatchIO _guardImatches _guardIpatternMatchWarnings _guardIself _guardIunboundNames _guardIuniqueChunk _guardIuniqueSecondRound) = inv_Expression_s41 _guardX41 (T_Expression_vIn40 _guardOallPatterns _guardOallTypeSchemes _guardOambiguousConflicts _guardOavailablePredicates _guardObetaUnique _guardOclassEnvironment _guardOclassMemberEnv _guardOclassMemberTypeSchemes _guardOclassNamesEnv _guardOclassPredicate _guardOclassTypeSchemes _guardOcollectErrors _guardOcollectWarnings _guardOcounter _guardOcurClassPred _guardOcurPred _guardOcurrentChunk _guardOdictionaryEnvironment _guardOimportEnvironment _guardOinstanceName _guardOinstanceTypes _guardOmatchIO _guardOmoduleName _guardOmonos _guardOnamesInScope _guardOorderedTypeSynonyms _guardOparentTree _guardOpatternMatchWarnings _guardOrequiredPredicates _guardOsubstitution _guardOtryPatterns _guardOtypeConstructors _guardOtypeschemeMap _guardOuniqueChunk _guardOuniqueSecondRound _guardOvariableMapping)
         _guardOtryPatterns = rule4103  ()
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule4104 _guardIunboundNames _lhsIunboundNames
         _parentTree = rule4105 _guardIinfoTree _lhsIparentTree _localInfo
         _lhsOinfoTree :: InfoTree
         _lhsOinfoTree = rule4106 _parentTree
         _localInfo = rule4107 _lhsImonos _self
         _cinfo = rule4108 _parentTree
         _lhsOassumptions :: Assumptions
         _lhsOassumptions = rule4109 _guardIassumptions _lhsIassumptions
         _lhsOconstraints :: ConstraintSet
         _lhsOconstraints = rule4110 _locConstraints
         _locConstraints = rule4111 _guardIconstraints _lhsIconstraints _newcon
         _newcon = rule4112 _cinfo _guardIbeta
         _lhsOcollectInstances :: [(Name, Instance)]
         _lhsOcollectInstances = rule4113 _guardIcollectInstances
         _self = rule4114 _guardIself _rangeIself
         _lhsOself :: Qualifier
         _lhsOself = rule4115 _self
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule4116 _guardIbetaUnique
         _lhsOcollectErrors :: TypeErrors
         _lhsOcollectErrors = rule4117 _guardIcollectErrors
         _lhsOcollectWarnings :: Warnings
         _lhsOcollectWarnings = rule4118 _guardIcollectWarnings
         _lhsOcounter :: Int
         _lhsOcounter = rule4119 _guardIcounter
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule4120 _guardIdictionaryEnvironment
         _lhsOmatchIO :: IO ()
         _lhsOmatchIO = rule4121 _guardImatchIO
         _lhsOmonos :: Monos
         _lhsOmonos = rule4122 _lhsImonos
         _lhsOnamesInScope :: Names
         _lhsOnamesInScope = rule4123 _lhsInamesInScope
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule4124 _guardIpatternMatchWarnings
         _lhsOuniqueChunk :: Int
         _lhsOuniqueChunk = rule4125 _guardIuniqueChunk
         _lhsOuniqueSecondRound :: Int
         _lhsOuniqueSecondRound = rule4126 _guardIuniqueSecondRound
         _guardOallPatterns = rule4127 _lhsIallPatterns
         _guardOallTypeSchemes = rule4128 _lhsIallTypeSchemes
         _guardOambiguousConflicts = rule4129 _lhsIambiguousConflicts
         _guardOavailablePredicates = rule4130 _lhsIavailablePredicates
         _guardObetaUnique = rule4131 _lhsIbetaUnique
         _guardOclassEnvironment = rule4132 _lhsIclassEnvironment
         _guardOclassMemberEnv = rule4133 _lhsIclassMemberEnv
         _guardOclassMemberTypeSchemes = rule4134 _lhsIclassMemberTypeSchemes
         _guardOclassNamesEnv = rule4135 _lhsIclassNamesEnv
         _guardOclassPredicate = rule4136 _lhsIclassPredicate
         _guardOclassTypeSchemes = rule4137 _lhsIclassTypeSchemes
         _guardOcollectErrors = rule4138 _lhsIcollectErrors
         _guardOcollectWarnings = rule4139 _lhsIcollectWarnings
         _guardOcounter = rule4140 _lhsIcounter
         _guardOcurClassPred = rule4141 _lhsIcurClassPred
         _guardOcurPred = rule4142 _lhsIcurPred
         _guardOcurrentChunk = rule4143 _lhsIcurrentChunk
         _guardOdictionaryEnvironment = rule4144 _lhsIdictionaryEnvironment
         _guardOimportEnvironment = rule4145 _lhsIimportEnvironment
         _guardOinstanceName = rule4146 _lhsIinstanceName
         _guardOinstanceTypes = rule4147 _lhsIinstanceTypes
         _guardOmatchIO = rule4148 _lhsImatchIO
         _guardOmoduleName = rule4149 _lhsImoduleName
         _guardOmonos = rule4150 _lhsImonos
         _guardOnamesInScope = rule4151 _lhsInamesInScope
         _guardOorderedTypeSynonyms = rule4152 _lhsIorderedTypeSynonyms
         _guardOparentTree = rule4153 _parentTree
         _guardOpatternMatchWarnings = rule4154 _lhsIpatternMatchWarnings
         _guardOrequiredPredicates = rule4155 _lhsIrequiredPredicates
         _guardOsubstitution = rule4156 _lhsIsubstitution
         _guardOtypeConstructors = rule4157 _lhsItypeConstructors
         _guardOtypeschemeMap = rule4158 _lhsItypeschemeMap
         _guardOuniqueChunk = rule4159 _lhsIuniqueChunk
         _guardOuniqueSecondRound = rule4160 _lhsIuniqueSecondRound
         _guardOvariableMapping = rule4161 _lhsIvariableMapping
         !__result_ = T_Qualifier_vOut127 _lhsOassumptions _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraints _lhsOcounter _lhsOdictionaryEnvironment _lhsOinfoTree _lhsOmatchIO _lhsOmonos _lhsOnamesInScope _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOuniqueSecondRound
         in __result_ )
     in C_Qualifier_s128 v127
   {-# INLINE rule4103 #-}
   rule4103 = \  (_ :: ()) ->
                                                     []
   {-# INLINE rule4104 #-}
   rule4104 = \ ((_guardIunboundNames) :: Names) ((_lhsIunboundNames) :: Names) ->
                                              _guardIunboundNames ++ _lhsIunboundNames
   {-# INLINE rule4105 #-}
   rule4105 = \ ((_guardIinfoTree) :: InfoTree) ((_lhsIparentTree) :: InfoTree) _localInfo ->
                            node _lhsIparentTree _localInfo [_guardIinfoTree]
   {-# INLINE rule4106 #-}
   rule4106 = \ _parentTree ->
                            _parentTree
   {-# INLINE rule4107 #-}
   rule4107 = \ ((_lhsImonos) :: Monos) _self ->
                            LocalInfo { self = UHA_Qual _self
                                      , assignedType = Nothing
                                      , monos = _lhsImonos
                                      }
   {-# INLINE rule4108 #-}
   rule4108 = \ _parentTree ->
     orphanConstraint 0 "boolean qualifier" _parentTree
        []
   {-# INLINE rule4109 #-}
   rule4109 = \ ((_guardIassumptions) :: Assumptions) ((_lhsIassumptions) :: Assumptions) ->
                            _lhsIassumptions `combine` _guardIassumptions
   {-# INLINE rule4110 #-}
   rule4110 = \ _locConstraints ->
                            _locConstraints
   {-# INLINE rule4111 #-}
   rule4111 = \ ((_guardIconstraints) :: ConstraintSet) ((_lhsIconstraints) :: ConstraintSet) _newcon ->
                               Node [ _newcon .<. _guardIconstraints
                                    , _lhsIconstraints
                                    ]
   {-# INLINE rule4112 #-}
   rule4112 = \ _cinfo ((_guardIbeta) :: Tp) ->
                            [ (_guardIbeta .==. boolQualType) _cinfo ]
   {-# INLINE rule4113 #-}
   rule4113 = \ ((_guardIcollectInstances) :: [(Name, Instance)]) ->
     _guardIcollectInstances
   {-# INLINE rule4114 #-}
   rule4114 = \ ((_guardIself) :: Expression) ((_rangeIself) :: Range) ->
     Qualifier_Guard _rangeIself _guardIself
   {-# INLINE rule4115 #-}
   rule4115 = \ _self ->
     _self
   {-# INLINE rule4116 #-}
   rule4116 = \ ((_guardIbetaUnique) :: Int) ->
     _guardIbetaUnique
   {-# INLINE rule4117 #-}
   rule4117 = \ ((_guardIcollectErrors) :: TypeErrors) ->
     _guardIcollectErrors
   {-# INLINE rule4118 #-}
   rule4118 = \ ((_guardIcollectWarnings) :: Warnings) ->
     _guardIcollectWarnings
   {-# INLINE rule4119 #-}
   rule4119 = \ ((_guardIcounter) :: Int) ->
     _guardIcounter
   {-# INLINE rule4120 #-}
   rule4120 = \ ((_guardIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _guardIdictionaryEnvironment
   {-# INLINE rule4121 #-}
   rule4121 = \ ((_guardImatchIO) :: IO ()) ->
     _guardImatchIO
   {-# INLINE rule4122 #-}
   rule4122 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule4123 #-}
   rule4123 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule4124 #-}
   rule4124 = \ ((_guardIpatternMatchWarnings) :: [Warning]) ->
     _guardIpatternMatchWarnings
   {-# INLINE rule4125 #-}
   rule4125 = \ ((_guardIuniqueChunk) :: Int) ->
     _guardIuniqueChunk
   {-# INLINE rule4126 #-}
   rule4126 = \ ((_guardIuniqueSecondRound) :: Int) ->
     _guardIuniqueSecondRound
   {-# INLINE rule4127 #-}
   rule4127 = \ ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ->
     _lhsIallPatterns
   {-# INLINE rule4128 #-}
   rule4128 = \ ((_lhsIallTypeSchemes) :: M.Map NameWithRange TpScheme) ->
     _lhsIallTypeSchemes
   {-# INLINE rule4129 #-}
   rule4129 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule4130 #-}
   rule4130 = \ ((_lhsIavailablePredicates) :: [PredicateWithSource]) ->
     _lhsIavailablePredicates
   {-# INLINE rule4131 #-}
   rule4131 = \ ((_lhsIbetaUnique) :: Int) ->
     _lhsIbetaUnique
   {-# INLINE rule4132 #-}
   rule4132 = \ ((_lhsIclassEnvironment) :: ClassEnvironment) ->
     _lhsIclassEnvironment
   {-# INLINE rule4133 #-}
   rule4133 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule4134 #-}
   rule4134 = \ ((_lhsIclassMemberTypeSchemes) :: Maybe [(Name, TpScheme)]) ->
     _lhsIclassMemberTypeSchemes
   {-# INLINE rule4135 #-}
   rule4135 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule4136 #-}
   rule4136 = \ ((_lhsIclassPredicate) :: Maybe (Name, Names)) ->
     _lhsIclassPredicate
   {-# INLINE rule4137 #-}
   rule4137 = \ ((_lhsIclassTypeSchemes) :: M.Map Name TpScheme) ->
     _lhsIclassTypeSchemes
   {-# INLINE rule4138 #-}
   rule4138 = \ ((_lhsIcollectErrors) :: TypeErrors) ->
     _lhsIcollectErrors
   {-# INLINE rule4139 #-}
   rule4139 = \ ((_lhsIcollectWarnings) :: Warnings) ->
     _lhsIcollectWarnings
   {-# INLINE rule4140 #-}
   rule4140 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule4141 #-}
   rule4141 = \ ((_lhsIcurClassPred) :: Maybe Predicate) ->
     _lhsIcurClassPred
   {-# INLINE rule4142 #-}
   rule4142 = \ ((_lhsIcurPred) :: Maybe Predicate) ->
     _lhsIcurPred
   {-# INLINE rule4143 #-}
   rule4143 = \ ((_lhsIcurrentChunk) :: Int) ->
     _lhsIcurrentChunk
   {-# INLINE rule4144 #-}
   rule4144 = \ ((_lhsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _lhsIdictionaryEnvironment
   {-# INLINE rule4145 #-}
   rule4145 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule4146 #-}
   rule4146 = \ ((_lhsIinstanceName) :: Maybe Name) ->
     _lhsIinstanceName
   {-# INLINE rule4147 #-}
   rule4147 = \ ((_lhsIinstanceTypes) :: [(Name, TpScheme)]) ->
     _lhsIinstanceTypes
   {-# INLINE rule4148 #-}
   rule4148 = \ ((_lhsImatchIO) :: IO ()) ->
     _lhsImatchIO
   {-# INLINE rule4149 #-}
   rule4149 = \ ((_lhsImoduleName) :: Maybe Name) ->
     _lhsImoduleName
   {-# INLINE rule4150 #-}
   rule4150 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule4151 #-}
   rule4151 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule4152 #-}
   rule4152 = \ ((_lhsIorderedTypeSynonyms) :: OrderedTypeSynonyms) ->
     _lhsIorderedTypeSynonyms
   {-# INLINE rule4153 #-}
   rule4153 = \ _parentTree ->
     _parentTree
   {-# INLINE rule4154 #-}
   rule4154 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule4155 #-}
   rule4155 = \ ((_lhsIrequiredPredicates) :: Predicates) ->
     _lhsIrequiredPredicates
   {-# INLINE rule4156 #-}
   rule4156 = \ ((_lhsIsubstitution) :: FixpointSubstitution) ->
     _lhsIsubstitution
   {-# INLINE rule4157 #-}
   rule4157 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
   {-# INLINE rule4158 #-}
   rule4158 = \ ((_lhsItypeschemeMap) :: M.Map Int (Scheme Predicates)) ->
     _lhsItypeschemeMap
   {-# INLINE rule4159 #-}
   rule4159 = \ ((_lhsIuniqueChunk) :: Int) ->
     _lhsIuniqueChunk
   {-# INLINE rule4160 #-}
   rule4160 = \ ((_lhsIuniqueSecondRound) :: Int) ->
     _lhsIuniqueSecondRound
   {-# INLINE rule4161 #-}
   rule4161 = \ ((_lhsIvariableMapping) :: Maybe [(Name, Tp)]) ->
     _lhsIvariableMapping
{-# NOINLINE sem_Qualifier_Let #-}
sem_Qualifier_Let :: T_Range  -> T_Declarations  -> T_Qualifier 
sem_Qualifier_Let arg_range_ arg_declarations_ = T_Qualifier (return st128) where
   {-# NOINLINE st128 #-}
   !st128 = let
      v127 :: T_Qualifier_v127 
      v127 = \ !(T_Qualifier_vIn127 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIassumptions _lhsIavailablePredicates _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIconstraints _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeConstructors _lhsItypeschemeMap _lhsIunboundNames _lhsIuniqueChunk _lhsIuniqueSecondRound _lhsIvariableMapping) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _declarationsX32 = Control.Monad.Identity.runIdentity (attach_T_Declarations (arg_declarations_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_Declarations_vOut31 _declarationsIbetaUnique _declarationsIbindingGroups _declarationsIboundBetas _declarationsIclassMemberNames _declarationsIcollectErrors _declarationsIcollectInstances _declarationsIcollectWarnings _declarationsIcounter _declarationsIdeclVarNames _declarationsIdictionaryEnvironment _declarationsIinfoTrees _declarationsImatchIO _declarationsIpatternMatchWarnings _declarationsIrestrictedNames _declarationsIself _declarationsIsimplePatNames _declarationsItypeMemberBindings _declarationsItypeSignatures _declarationsIunboundNames _declarationsIuniqueChunk) = inv_Declarations_s32 _declarationsX32 (T_Declarations_vIn31 _declarationsOallPatterns _declarationsOallTypeSchemes _declarationsOambiguousConflicts _declarationsOavailablePredicates _declarationsObetaUnique _declarationsObindingGroups _declarationsOclassEnvironment _declarationsOclassMemberEnv _declarationsOclassMemberTypeSchemes _declarationsOclassNamesEnv _declarationsOclassPredicate _declarationsOclassTypeSchemes _declarationsOcollectErrors _declarationsOcollectWarnings _declarationsOcounter _declarationsOcurClassPred _declarationsOcurPred _declarationsOcurrentChunk _declarationsOdictionaryEnvironment _declarationsOimportEnvironment _declarationsOinheritedBDG _declarationsOinstanceName _declarationsOinstanceTypes _declarationsOisTopLevel _declarationsOmatchIO _declarationsOmoduleName _declarationsOmoduleQual _declarationsOmonos _declarationsOnamesInScope _declarationsOorderedTypeSynonyms _declarationsOparentTree _declarationsOpatternMatchWarnings _declarationsOrequiredPredicates _declarationsOsubstitution _declarationsOtypeConstructors _declarationsOtypeSignatures _declarationsOtypeschemeMap _declarationsOuniqueChunk _declarationsOvariableMapping)
         (_namesInScope,_unboundNames,_scopeInfo) = rule4162 _declarationsIdeclVarNames _declarationsIunboundNames _lhsInamesInScope _lhsIunboundNames
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule4163 _unboundNames
         (_collectTypeConstructors,_collectValueConstructors,_collectTypeSynonyms,_collectConstructorEnv,_derivedFunctions,_operatorFixities,_moduleQual) = rule4164  ()
         _thisTree = rule4165 _declTree _lhsIparentTree _localInfo
         _declTree = rule4166 _declInfo _declarationsIinfoTrees _thisTree
         _lhsOinfoTree :: InfoTree
         _lhsOinfoTree = rule4167 _thisTree
         _declarationsOparentTree = rule4168 _declTree
         _localInfo = rule4169 _lhsImonos _self
         _declInfo = rule4170 _declarationsIself _lhsImonos
         _inferredTypes = rule4171 _implicitsFM _lhsItypeschemeMap
         _lhsOcollectWarnings :: Warnings
         _lhsOcollectWarnings = rule4172 _declarationsIcollectWarnings _declarationsIsimplePatNames _inferredTypes _lhsIimportEnvironment
         _lhsOcollectErrors :: TypeErrors
         _lhsOcollectErrors = rule4173 _declarationsIcollectErrors _declarationsIrestrictedNames _inferredTypes _lhsIimportEnvironment
         _allTypeSchemes = rule4174 _lhsIallTypeSchemes _localTypes
         _localTypes = rule4175 _declarationsIbindingGroups _declarationsItypeSignatures _inferredTypes
         _declarationsOtypeSignatures = rule4176  ()
         _lhsOuniqueChunk :: Int
         _lhsOuniqueChunk = rule4177 _chunkNr
         _declarationsObindingGroups = rule4178  ()
         _lhsOassumptions :: Assumptions
         _lhsOconstraints :: ConstraintSet
         _lhsObetaUnique :: Int
         (_lhsOassumptions,_lhsOconstraints,_inheritedBDG,_chunkNr,_lhsObetaUnique,_implicitsFM) = rule4179 _declarationsIbetaUnique _declarationsIbindingGroups _declarationsItypeSignatures _declarationsIuniqueChunk _lhsIassumptions _lhsIconstraints _lhsIcurrentChunk _lhsImonos
         _isTopLevel = rule4180  ()
         _lhsOcollectInstances :: [(Name, Instance)]
         _lhsOcollectInstances = rule4181 _declarationsIcollectInstances
         _self = rule4182 _declarationsIself _rangeIself
         _lhsOself :: Qualifier
         _lhsOself = rule4183 _self
         _lhsOcounter :: Int
         _lhsOcounter = rule4184 _declarationsIcounter
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule4185 _declarationsIdictionaryEnvironment
         _lhsOmatchIO :: IO ()
         _lhsOmatchIO = rule4186 _declarationsImatchIO
         _lhsOmonos :: Monos
         _lhsOmonos = rule4187 _lhsImonos
         _lhsOnamesInScope :: Names
         _lhsOnamesInScope = rule4188 _namesInScope
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule4189 _declarationsIpatternMatchWarnings
         _lhsOuniqueSecondRound :: Int
         _lhsOuniqueSecondRound = rule4190 _lhsIuniqueSecondRound
         _declarationsOallPatterns = rule4191 _lhsIallPatterns
         _declarationsOallTypeSchemes = rule4192 _allTypeSchemes
         _declarationsOambiguousConflicts = rule4193 _lhsIambiguousConflicts
         _declarationsOavailablePredicates = rule4194 _lhsIavailablePredicates
         _declarationsObetaUnique = rule4195 _lhsIbetaUnique
         _declarationsOclassEnvironment = rule4196 _lhsIclassEnvironment
         _declarationsOclassMemberEnv = rule4197 _lhsIclassMemberEnv
         _declarationsOclassMemberTypeSchemes = rule4198 _lhsIclassMemberTypeSchemes
         _declarationsOclassNamesEnv = rule4199 _lhsIclassNamesEnv
         _declarationsOclassPredicate = rule4200 _lhsIclassPredicate
         _declarationsOclassTypeSchemes = rule4201 _lhsIclassTypeSchemes
         _declarationsOcollectErrors = rule4202 _lhsIcollectErrors
         _declarationsOcollectWarnings = rule4203 _lhsIcollectWarnings
         _declarationsOcounter = rule4204 _lhsIcounter
         _declarationsOcurClassPred = rule4205 _lhsIcurClassPred
         _declarationsOcurPred = rule4206 _lhsIcurPred
         _declarationsOcurrentChunk = rule4207 _lhsIcurrentChunk
         _declarationsOdictionaryEnvironment = rule4208 _lhsIdictionaryEnvironment
         _declarationsOimportEnvironment = rule4209 _lhsIimportEnvironment
         _declarationsOinheritedBDG = rule4210 _inheritedBDG
         _declarationsOinstanceName = rule4211 _lhsIinstanceName
         _declarationsOinstanceTypes = rule4212 _lhsIinstanceTypes
         _declarationsOisTopLevel = rule4213 _isTopLevel
         _declarationsOmatchIO = rule4214 _lhsImatchIO
         _declarationsOmoduleName = rule4215 _lhsImoduleName
         _declarationsOmoduleQual = rule4216 _moduleQual
         _declarationsOmonos = rule4217 _lhsImonos
         _declarationsOnamesInScope = rule4218 _namesInScope
         _declarationsOorderedTypeSynonyms = rule4219 _lhsIorderedTypeSynonyms
         _declarationsOpatternMatchWarnings = rule4220 _lhsIpatternMatchWarnings
         _declarationsOrequiredPredicates = rule4221 _lhsIrequiredPredicates
         _declarationsOsubstitution = rule4222 _lhsIsubstitution
         _declarationsOtypeConstructors = rule4223 _lhsItypeConstructors
         _declarationsOtypeschemeMap = rule4224 _lhsItypeschemeMap
         _declarationsOuniqueChunk = rule4225 _lhsIuniqueChunk
         _declarationsOvariableMapping = rule4226 _lhsIvariableMapping
         !__result_ = T_Qualifier_vOut127 _lhsOassumptions _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraints _lhsOcounter _lhsOdictionaryEnvironment _lhsOinfoTree _lhsOmatchIO _lhsOmonos _lhsOnamesInScope _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOuniqueSecondRound
         in __result_ )
     in C_Qualifier_s128 v127
   {-# INLINE rule4162 #-}
   rule4162 = \ ((_declarationsIdeclVarNames) :: Names) ((_declarationsIunboundNames) :: Names) ((_lhsInamesInScope) :: Names) ((_lhsIunboundNames) :: Names) ->
                                                             changeOfScope _declarationsIdeclVarNames (_declarationsIunboundNames ++ _lhsIunboundNames) _lhsInamesInScope
   {-# INLINE rule4163 #-}
   rule4163 = \ _unboundNames ->
                                              _unboundNames
   {-# INLINE rule4164 #-}
   rule4164 = \  (_ :: ()) ->
                                                                                                                                                               internalError "PartialSyntax.ag" "n/a" "toplevel Qualifier"
   {-# INLINE rule4165 #-}
   rule4165 = \ _declTree ((_lhsIparentTree) :: InfoTree) _localInfo ->
                          node _lhsIparentTree _localInfo [_declTree]
   {-# INLINE rule4166 #-}
   rule4166 = \ _declInfo ((_declarationsIinfoTrees) :: InfoTrees) _thisTree ->
                          node _thisTree _declInfo _declarationsIinfoTrees
   {-# INLINE rule4167 #-}
   rule4167 = \ _thisTree ->
                          _thisTree
   {-# INLINE rule4168 #-}
   rule4168 = \ _declTree ->
                                     _declTree
   {-# INLINE rule4169 #-}
   rule4169 = \ ((_lhsImonos) :: Monos) _self ->
                            LocalInfo { self = UHA_Qual _self
                                      , assignedType = Nothing
                                      , monos = _lhsImonos
                                      }
   {-# INLINE rule4170 #-}
   rule4170 = \ ((_declarationsIself) :: Declarations) ((_lhsImonos) :: Monos) ->
                          LocalInfo { self = UHA_Decls _declarationsIself
                                    , assignedType = Nothing
                                    , monos = _lhsImonos
                                    }
   {-# INLINE rule4171 #-}
   rule4171 = \ _implicitsFM ((_lhsItypeschemeMap) :: M.Map Int (Scheme Predicates)) ->
                                        findInferredTypes _lhsItypeschemeMap _implicitsFM
   {-# INLINE rule4172 #-}
   rule4172 = \ ((_declarationsIcollectWarnings) :: Warnings) ((_declarationsIsimplePatNames) :: Names) _inferredTypes ((_lhsIimportEnvironment) :: ImportEnvironment) ->
                                        missingTypeSignature False _declarationsIsimplePatNames _inferredTypes _lhsIimportEnvironment
                                        ++ _declarationsIcollectWarnings
   {-# INLINE rule4173 #-}
   rule4173 = \ ((_declarationsIcollectErrors) :: TypeErrors) ((_declarationsIrestrictedNames) :: Names) _inferredTypes ((_lhsIimportEnvironment) :: ImportEnvironment) ->
                                        restrictedNameErrors _lhsIimportEnvironment _inferredTypes _declarationsIrestrictedNames
                                        ++ _declarationsIcollectErrors
   {-# INLINE rule4174 #-}
   rule4174 = \ ((_lhsIallTypeSchemes) :: M.Map NameWithRange TpScheme) _localTypes ->
                                    _localTypes `M.union` _lhsIallTypeSchemes
   {-# INLINE rule4175 #-}
   rule4175 = \ ((_declarationsIbindingGroups) :: BindingGroups) ((_declarationsItypeSignatures) :: TypeEnvironment) _inferredTypes ->
                                    makeLocalTypeEnv (_declarationsItypeSignatures `M.union` _inferredTypes) _declarationsIbindingGroups
   {-# INLINE rule4176 #-}
   rule4176 = \  (_ :: ()) ->
                                                                  M.empty
   {-# INLINE rule4177 #-}
   rule4177 = \ _chunkNr ->
                                                     _chunkNr
   {-# INLINE rule4178 #-}
   rule4178 = \  (_ :: ()) ->
                                            []
   {-# INLINE rule4179 #-}
   rule4179 = \ ((_declarationsIbetaUnique) :: Int) ((_declarationsIbindingGroups) :: BindingGroups) ((_declarationsItypeSignatures) :: TypeEnvironment) ((_declarationsIuniqueChunk) :: Int) ((_lhsIassumptions) :: Assumptions) ((_lhsIconstraints) :: ConstraintSet) ((_lhsIcurrentChunk) :: Int) ((_lhsImonos) :: Monos) ->
               let inputBDG   = (False, _lhsIcurrentChunk, _declarationsIuniqueChunk, _lhsImonos, _declarationsItypeSignatures, mybdggroup, _declarationsIbetaUnique)
                   mybdggroup = Just (_lhsIassumptions, [_lhsIconstraints])
               in performBindingGroup inputBDG _declarationsIbindingGroups
   {-# INLINE rule4180 #-}
   rule4180 = \  (_ :: ()) ->
                               False
   {-# INLINE rule4181 #-}
   rule4181 = \ ((_declarationsIcollectInstances) :: [(Name, Instance)]) ->
     _declarationsIcollectInstances
   {-# INLINE rule4182 #-}
   rule4182 = \ ((_declarationsIself) :: Declarations) ((_rangeIself) :: Range) ->
     Qualifier_Let _rangeIself _declarationsIself
   {-# INLINE rule4183 #-}
   rule4183 = \ _self ->
     _self
   {-# INLINE rule4184 #-}
   rule4184 = \ ((_declarationsIcounter) :: Int) ->
     _declarationsIcounter
   {-# INLINE rule4185 #-}
   rule4185 = \ ((_declarationsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _declarationsIdictionaryEnvironment
   {-# INLINE rule4186 #-}
   rule4186 = \ ((_declarationsImatchIO) :: IO ()) ->
     _declarationsImatchIO
   {-# INLINE rule4187 #-}
   rule4187 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule4188 #-}
   rule4188 = \ _namesInScope ->
     _namesInScope
   {-# INLINE rule4189 #-}
   rule4189 = \ ((_declarationsIpatternMatchWarnings) :: [Warning]) ->
     _declarationsIpatternMatchWarnings
   {-# INLINE rule4190 #-}
   rule4190 = \ ((_lhsIuniqueSecondRound) :: Int) ->
     _lhsIuniqueSecondRound
   {-# INLINE rule4191 #-}
   rule4191 = \ ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ->
     _lhsIallPatterns
   {-# INLINE rule4192 #-}
   rule4192 = \ _allTypeSchemes ->
     _allTypeSchemes
   {-# INLINE rule4193 #-}
   rule4193 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule4194 #-}
   rule4194 = \ ((_lhsIavailablePredicates) :: [PredicateWithSource]) ->
     _lhsIavailablePredicates
   {-# INLINE rule4195 #-}
   rule4195 = \ ((_lhsIbetaUnique) :: Int) ->
     _lhsIbetaUnique
   {-# INLINE rule4196 #-}
   rule4196 = \ ((_lhsIclassEnvironment) :: ClassEnvironment) ->
     _lhsIclassEnvironment
   {-# INLINE rule4197 #-}
   rule4197 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule4198 #-}
   rule4198 = \ ((_lhsIclassMemberTypeSchemes) :: Maybe [(Name, TpScheme)]) ->
     _lhsIclassMemberTypeSchemes
   {-# INLINE rule4199 #-}
   rule4199 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule4200 #-}
   rule4200 = \ ((_lhsIclassPredicate) :: Maybe (Name, Names)) ->
     _lhsIclassPredicate
   {-# INLINE rule4201 #-}
   rule4201 = \ ((_lhsIclassTypeSchemes) :: M.Map Name TpScheme) ->
     _lhsIclassTypeSchemes
   {-# INLINE rule4202 #-}
   rule4202 = \ ((_lhsIcollectErrors) :: TypeErrors) ->
     _lhsIcollectErrors
   {-# INLINE rule4203 #-}
   rule4203 = \ ((_lhsIcollectWarnings) :: Warnings) ->
     _lhsIcollectWarnings
   {-# INLINE rule4204 #-}
   rule4204 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule4205 #-}
   rule4205 = \ ((_lhsIcurClassPred) :: Maybe Predicate) ->
     _lhsIcurClassPred
   {-# INLINE rule4206 #-}
   rule4206 = \ ((_lhsIcurPred) :: Maybe Predicate) ->
     _lhsIcurPred
   {-# INLINE rule4207 #-}
   rule4207 = \ ((_lhsIcurrentChunk) :: Int) ->
     _lhsIcurrentChunk
   {-# INLINE rule4208 #-}
   rule4208 = \ ((_lhsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _lhsIdictionaryEnvironment
   {-# INLINE rule4209 #-}
   rule4209 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule4210 #-}
   rule4210 = \ _inheritedBDG ->
     _inheritedBDG
   {-# INLINE rule4211 #-}
   rule4211 = \ ((_lhsIinstanceName) :: Maybe Name) ->
     _lhsIinstanceName
   {-# INLINE rule4212 #-}
   rule4212 = \ ((_lhsIinstanceTypes) :: [(Name, TpScheme)]) ->
     _lhsIinstanceTypes
   {-# INLINE rule4213 #-}
   rule4213 = \ _isTopLevel ->
     _isTopLevel
   {-# INLINE rule4214 #-}
   rule4214 = \ ((_lhsImatchIO) :: IO ()) ->
     _lhsImatchIO
   {-# INLINE rule4215 #-}
   rule4215 = \ ((_lhsImoduleName) :: Maybe Name) ->
     _lhsImoduleName
   {-# INLINE rule4216 #-}
   rule4216 = \ _moduleQual ->
     _moduleQual
   {-# INLINE rule4217 #-}
   rule4217 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule4218 #-}
   rule4218 = \ _namesInScope ->
     _namesInScope
   {-# INLINE rule4219 #-}
   rule4219 = \ ((_lhsIorderedTypeSynonyms) :: OrderedTypeSynonyms) ->
     _lhsIorderedTypeSynonyms
   {-# INLINE rule4220 #-}
   rule4220 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule4221 #-}
   rule4221 = \ ((_lhsIrequiredPredicates) :: Predicates) ->
     _lhsIrequiredPredicates
   {-# INLINE rule4222 #-}
   rule4222 = \ ((_lhsIsubstitution) :: FixpointSubstitution) ->
     _lhsIsubstitution
   {-# INLINE rule4223 #-}
   rule4223 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
   {-# INLINE rule4224 #-}
   rule4224 = \ ((_lhsItypeschemeMap) :: M.Map Int (Scheme Predicates)) ->
     _lhsItypeschemeMap
   {-# INLINE rule4225 #-}
   rule4225 = \ ((_lhsIuniqueChunk) :: Int) ->
     _lhsIuniqueChunk
   {-# INLINE rule4226 #-}
   rule4226 = \ ((_lhsIvariableMapping) :: Maybe [(Name, Tp)]) ->
     _lhsIvariableMapping
{-# NOINLINE sem_Qualifier_Generator #-}
sem_Qualifier_Generator :: T_Range  -> T_Pattern  -> T_Expression  -> T_Qualifier 
sem_Qualifier_Generator arg_range_ arg_pattern_ arg_expression_ = T_Qualifier (return st128) where
   {-# NOINLINE st128 #-}
   !st128 = let
      v127 :: T_Qualifier_v127 
      v127 = \ !(T_Qualifier_vIn127 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIassumptions _lhsIavailablePredicates _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIconstraints _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeConstructors _lhsItypeschemeMap _lhsIunboundNames _lhsIuniqueChunk _lhsIuniqueSecondRound _lhsIvariableMapping) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _patternX119 = Control.Monad.Identity.runIdentity (attach_T_Pattern (arg_pattern_))
         _expressionX41 = Control.Monad.Identity.runIdentity (attach_T_Expression (arg_expression_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_Pattern_vOut118 _patternIbeta _patternIbetaUnique _patternIconstraints _patternIcounter _patternIelements _patternIenvironment _patternIinfoTree _patternIpatVarNames _patternIpatternMatchWarnings _patternIself _patternIunboundNames) = inv_Pattern_s119 _patternX119 (T_Pattern_vIn118 _patternOambiguousConflicts _patternObetaUnique _patternOcounter _patternOimportEnvironment _patternOmonos _patternOnamesInScope _patternOparentTree _patternOpatternMatchWarnings _patternOtypeConstructors)
         (T_Expression_vOut40 _expressionIassumptions _expressionIbeta _expressionIbetaUnique _expressionIcollectErrors _expressionIcollectInstances _expressionIcollectWarnings _expressionIconstraints _expressionIcounter _expressionIdictionaryEnvironment _expressionIinfoTree _expressionImatchIO _expressionImatches _expressionIpatternMatchWarnings _expressionIself _expressionIunboundNames _expressionIuniqueChunk _expressionIuniqueSecondRound) = inv_Expression_s41 _expressionX41 (T_Expression_vIn40 _expressionOallPatterns _expressionOallTypeSchemes _expressionOambiguousConflicts _expressionOavailablePredicates _expressionObetaUnique _expressionOclassEnvironment _expressionOclassMemberEnv _expressionOclassMemberTypeSchemes _expressionOclassNamesEnv _expressionOclassPredicate _expressionOclassTypeSchemes _expressionOcollectErrors _expressionOcollectWarnings _expressionOcounter _expressionOcurClassPred _expressionOcurPred _expressionOcurrentChunk _expressionOdictionaryEnvironment _expressionOimportEnvironment _expressionOinstanceName _expressionOinstanceTypes _expressionOmatchIO _expressionOmoduleName _expressionOmonos _expressionOnamesInScope _expressionOorderedTypeSynonyms _expressionOparentTree _expressionOpatternMatchWarnings _expressionOrequiredPredicates _expressionOsubstitution _expressionOtryPatterns _expressionOtypeConstructors _expressionOtypeschemeMap _expressionOuniqueChunk _expressionOuniqueSecondRound _expressionOvariableMapping)
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule4227 _expressionIpatternMatchWarnings _lhsIimportEnvironment _lhsIsubstitution _patternIbeta _patternIelements _rangeIself
         _expressionOtryPatterns = rule4228  ()
         (_namesInScope,_unboundNames,_scopeInfo) = rule4229 _expressionIunboundNames _lhsInamesInScope _lhsIunboundNames _patternIpatVarNames
         _lhsOnamesInScope :: Names
         _lhsOnamesInScope = rule4230 _namesInScope
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule4231 _unboundNames
         _expressionOnamesInScope = rule4232 _lhsInamesInScope
         _parentTree = rule4233 _expressionIinfoTree _lhsIparentTree _localInfo _patternIinfoTree
         _lhsOinfoTree :: InfoTree
         _lhsOinfoTree = rule4234 _parentTree
         _localInfo = rule4235 _lhsImonos _self
         _cinfoResult = rule4236 _parentTree
         _cinfoBind = rule4237 _parentTree _patternIenvironment
         _lhsOassumptions :: Assumptions
         _lhsOassumptions = rule4238 _assumptions' _expressionIassumptions
         _lhsOconstraints :: ConstraintSet
         _lhsOconstraints = rule4239 _locConstraints
         _lhsOmonos :: Monos
         _lhsOmonos = rule4240 _csetBinds _lhsImonos _patternIenvironment
         _locConstraints = rule4241 _csetBinds _expressionIconstraints _lhsIconstraints _newcon _patternIconstraints
         (_csetBinds,_assumptions') = rule4242 _cinfoBind _lhsIassumptions _patternIenvironment
         _newcon = rule4243 _cinfoResult _expressionIbeta _patternIbeta
         _lhsOcollectInstances :: [(Name, Instance)]
         _lhsOcollectInstances = rule4244 _expressionIcollectInstances
         _self = rule4245 _expressionIself _patternIself _rangeIself
         _lhsOself :: Qualifier
         _lhsOself = rule4246 _self
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule4247 _expressionIbetaUnique
         _lhsOcollectErrors :: TypeErrors
         _lhsOcollectErrors = rule4248 _expressionIcollectErrors
         _lhsOcollectWarnings :: Warnings
         _lhsOcollectWarnings = rule4249 _expressionIcollectWarnings
         _lhsOcounter :: Int
         _lhsOcounter = rule4250 _expressionIcounter
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule4251 _expressionIdictionaryEnvironment
         _lhsOmatchIO :: IO ()
         _lhsOmatchIO = rule4252 _expressionImatchIO
         _lhsOuniqueChunk :: Int
         _lhsOuniqueChunk = rule4253 _expressionIuniqueChunk
         _lhsOuniqueSecondRound :: Int
         _lhsOuniqueSecondRound = rule4254 _expressionIuniqueSecondRound
         _patternOambiguousConflicts = rule4255 _lhsIambiguousConflicts
         _patternObetaUnique = rule4256 _lhsIbetaUnique
         _patternOcounter = rule4257 _lhsIcounter
         _patternOimportEnvironment = rule4258 _lhsIimportEnvironment
         _patternOmonos = rule4259 _lhsImonos
         _patternOnamesInScope = rule4260 _namesInScope
         _patternOparentTree = rule4261 _parentTree
         _patternOpatternMatchWarnings = rule4262 _lhsIpatternMatchWarnings
         _patternOtypeConstructors = rule4263 _lhsItypeConstructors
         _expressionOallPatterns = rule4264 _lhsIallPatterns
         _expressionOallTypeSchemes = rule4265 _lhsIallTypeSchemes
         _expressionOambiguousConflicts = rule4266 _lhsIambiguousConflicts
         _expressionOavailablePredicates = rule4267 _lhsIavailablePredicates
         _expressionObetaUnique = rule4268 _patternIbetaUnique
         _expressionOclassEnvironment = rule4269 _lhsIclassEnvironment
         _expressionOclassMemberEnv = rule4270 _lhsIclassMemberEnv
         _expressionOclassMemberTypeSchemes = rule4271 _lhsIclassMemberTypeSchemes
         _expressionOclassNamesEnv = rule4272 _lhsIclassNamesEnv
         _expressionOclassPredicate = rule4273 _lhsIclassPredicate
         _expressionOclassTypeSchemes = rule4274 _lhsIclassTypeSchemes
         _expressionOcollectErrors = rule4275 _lhsIcollectErrors
         _expressionOcollectWarnings = rule4276 _lhsIcollectWarnings
         _expressionOcounter = rule4277 _patternIcounter
         _expressionOcurClassPred = rule4278 _lhsIcurClassPred
         _expressionOcurPred = rule4279 _lhsIcurPred
         _expressionOcurrentChunk = rule4280 _lhsIcurrentChunk
         _expressionOdictionaryEnvironment = rule4281 _lhsIdictionaryEnvironment
         _expressionOimportEnvironment = rule4282 _lhsIimportEnvironment
         _expressionOinstanceName = rule4283 _lhsIinstanceName
         _expressionOinstanceTypes = rule4284 _lhsIinstanceTypes
         _expressionOmatchIO = rule4285 _lhsImatchIO
         _expressionOmoduleName = rule4286 _lhsImoduleName
         _expressionOmonos = rule4287 _lhsImonos
         _expressionOorderedTypeSynonyms = rule4288 _lhsIorderedTypeSynonyms
         _expressionOparentTree = rule4289 _parentTree
         _expressionOpatternMatchWarnings = rule4290 _patternIpatternMatchWarnings
         _expressionOrequiredPredicates = rule4291 _lhsIrequiredPredicates
         _expressionOsubstitution = rule4292 _lhsIsubstitution
         _expressionOtypeConstructors = rule4293 _lhsItypeConstructors
         _expressionOtypeschemeMap = rule4294 _lhsItypeschemeMap
         _expressionOuniqueChunk = rule4295 _lhsIuniqueChunk
         _expressionOuniqueSecondRound = rule4296 _lhsIuniqueSecondRound
         _expressionOvariableMapping = rule4297 _lhsIvariableMapping
         !__result_ = T_Qualifier_vOut127 _lhsOassumptions _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraints _lhsOcounter _lhsOdictionaryEnvironment _lhsOinfoTree _lhsOmatchIO _lhsOmonos _lhsOnamesInScope _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOuniqueSecondRound
         in __result_ )
     in C_Qualifier_s128 v127
   {-# INLINE rule4227 #-}
   rule4227 = \ ((_expressionIpatternMatchWarnings) :: [Warning]) ((_lhsIimportEnvironment) :: ImportEnvironment) ((_lhsIsubstitution) :: FixpointSubstitution) ((_patternIbeta) :: Tp) ((_patternIelements) ::   [PatternElement]        ) ((_rangeIself) :: Range) ->
                                                    patternMatchWarnings _lhsIimportEnvironment
                                                                         _lhsIsubstitution
                                                                         _patternIbeta
                                                                         (:[])
                                                                         [(_patternIelements, False)]
                                                                         _rangeIself
                                                                         Nothing
                                                                         False
                                                                         []
                                                                         "generator"
                                                                         "<-"
                                                    ++ _expressionIpatternMatchWarnings
   {-# INLINE rule4228 #-}
   rule4228 = \  (_ :: ()) ->
                                                     []
   {-# INLINE rule4229 #-}
   rule4229 = \ ((_expressionIunboundNames) :: Names) ((_lhsInamesInScope) :: Names) ((_lhsIunboundNames) :: Names) ((_patternIpatVarNames) :: Names) ->
                                                                        changeOfScope _patternIpatVarNames (_expressionIunboundNames  ++ _lhsIunboundNames)  _lhsInamesInScope
   {-# INLINE rule4230 #-}
   rule4230 = \ _namesInScope ->
                                              _namesInScope
   {-# INLINE rule4231 #-}
   rule4231 = \ _unboundNames ->
                                              _unboundNames
   {-# INLINE rule4232 #-}
   rule4232 = \ ((_lhsInamesInScope) :: Names) ->
                                              _lhsInamesInScope
   {-# INLINE rule4233 #-}
   rule4233 = \ ((_expressionIinfoTree) :: InfoTree) ((_lhsIparentTree) :: InfoTree) _localInfo ((_patternIinfoTree) :: InfoTree) ->
                            node _lhsIparentTree _localInfo [_patternIinfoTree, _expressionIinfoTree]
   {-# INLINE rule4234 #-}
   rule4234 = \ _parentTree ->
                            _parentTree
   {-# INLINE rule4235 #-}
   rule4235 = \ ((_lhsImonos) :: Monos) _self ->
                            LocalInfo { self = UHA_Qual _self
                                      , assignedType = Nothing
                                      , monos = _lhsImonos
                                      }
   {-# INLINE rule4236 #-}
   rule4236 = \ _parentTree ->
     childConstraint 1 "generator" _parentTree
        []
   {-# INLINE rule4237 #-}
   rule4237 = \ _parentTree ((_patternIenvironment) :: PatternAssumptions) ->
     \name -> variableConstraint "variable" (nameToUHA_Expr name)
        [ FolkloreConstraint
        , makeUnifier name "generator" _patternIenvironment _parentTree
        ]
   {-# INLINE rule4238 #-}
   rule4238 = \ _assumptions' ((_expressionIassumptions) :: Assumptions) ->
                            _assumptions' `combine` _expressionIassumptions
   {-# INLINE rule4239 #-}
   rule4239 = \ _locConstraints ->
                            _locConstraints
   {-# INLINE rule4240 #-}
   rule4240 = \ _csetBinds ((_lhsImonos) :: Monos) ((_patternIenvironment) :: PatternAssumptions) ->
                            M.elems _patternIenvironment ++ getMonos _csetBinds ++ _lhsImonos
   {-# INLINE rule4241 #-}
   rule4241 = \ _csetBinds ((_expressionIconstraints) :: ConstraintSet) ((_lhsIconstraints) :: ConstraintSet) _newcon ((_patternIconstraints) :: ConstraintSet) ->
                               _newcon .>. _csetBinds .>>.
                                  Node [ _patternIconstraints
                                       , _expressionIconstraints
                                       , _lhsIconstraints
                                       ]
   {-# INLINE rule4242 #-}
   rule4242 = \ _cinfoBind ((_lhsIassumptions) :: Assumptions) ((_patternIenvironment) :: PatternAssumptions) ->
                                         (_patternIenvironment .===. _lhsIassumptions) _cinfoBind
   {-# INLINE rule4243 #-}
   rule4243 = \ _cinfoResult ((_expressionIbeta) :: Tp) ((_patternIbeta) :: Tp) ->
                            [ (_expressionIbeta .==. listType _patternIbeta) _cinfoResult ]
   {-# INLINE rule4244 #-}
   rule4244 = \ ((_expressionIcollectInstances) :: [(Name, Instance)]) ->
     _expressionIcollectInstances
   {-# INLINE rule4245 #-}
   rule4245 = \ ((_expressionIself) :: Expression) ((_patternIself) :: Pattern) ((_rangeIself) :: Range) ->
     Qualifier_Generator _rangeIself _patternIself _expressionIself
   {-# INLINE rule4246 #-}
   rule4246 = \ _self ->
     _self
   {-# INLINE rule4247 #-}
   rule4247 = \ ((_expressionIbetaUnique) :: Int) ->
     _expressionIbetaUnique
   {-# INLINE rule4248 #-}
   rule4248 = \ ((_expressionIcollectErrors) :: TypeErrors) ->
     _expressionIcollectErrors
   {-# INLINE rule4249 #-}
   rule4249 = \ ((_expressionIcollectWarnings) :: Warnings) ->
     _expressionIcollectWarnings
   {-# INLINE rule4250 #-}
   rule4250 = \ ((_expressionIcounter) :: Int) ->
     _expressionIcounter
   {-# INLINE rule4251 #-}
   rule4251 = \ ((_expressionIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _expressionIdictionaryEnvironment
   {-# INLINE rule4252 #-}
   rule4252 = \ ((_expressionImatchIO) :: IO ()) ->
     _expressionImatchIO
   {-# INLINE rule4253 #-}
   rule4253 = \ ((_expressionIuniqueChunk) :: Int) ->
     _expressionIuniqueChunk
   {-# INLINE rule4254 #-}
   rule4254 = \ ((_expressionIuniqueSecondRound) :: Int) ->
     _expressionIuniqueSecondRound
   {-# INLINE rule4255 #-}
   rule4255 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule4256 #-}
   rule4256 = \ ((_lhsIbetaUnique) :: Int) ->
     _lhsIbetaUnique
   {-# INLINE rule4257 #-}
   rule4257 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule4258 #-}
   rule4258 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule4259 #-}
   rule4259 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule4260 #-}
   rule4260 = \ _namesInScope ->
     _namesInScope
   {-# INLINE rule4261 #-}
   rule4261 = \ _parentTree ->
     _parentTree
   {-# INLINE rule4262 #-}
   rule4262 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule4263 #-}
   rule4263 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
   {-# INLINE rule4264 #-}
   rule4264 = \ ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ->
     _lhsIallPatterns
   {-# INLINE rule4265 #-}
   rule4265 = \ ((_lhsIallTypeSchemes) :: M.Map NameWithRange TpScheme) ->
     _lhsIallTypeSchemes
   {-# INLINE rule4266 #-}
   rule4266 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule4267 #-}
   rule4267 = \ ((_lhsIavailablePredicates) :: [PredicateWithSource]) ->
     _lhsIavailablePredicates
   {-# INLINE rule4268 #-}
   rule4268 = \ ((_patternIbetaUnique) :: Int) ->
     _patternIbetaUnique
   {-# INLINE rule4269 #-}
   rule4269 = \ ((_lhsIclassEnvironment) :: ClassEnvironment) ->
     _lhsIclassEnvironment
   {-# INLINE rule4270 #-}
   rule4270 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule4271 #-}
   rule4271 = \ ((_lhsIclassMemberTypeSchemes) :: Maybe [(Name, TpScheme)]) ->
     _lhsIclassMemberTypeSchemes
   {-# INLINE rule4272 #-}
   rule4272 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule4273 #-}
   rule4273 = \ ((_lhsIclassPredicate) :: Maybe (Name, Names)) ->
     _lhsIclassPredicate
   {-# INLINE rule4274 #-}
   rule4274 = \ ((_lhsIclassTypeSchemes) :: M.Map Name TpScheme) ->
     _lhsIclassTypeSchemes
   {-# INLINE rule4275 #-}
   rule4275 = \ ((_lhsIcollectErrors) :: TypeErrors) ->
     _lhsIcollectErrors
   {-# INLINE rule4276 #-}
   rule4276 = \ ((_lhsIcollectWarnings) :: Warnings) ->
     _lhsIcollectWarnings
   {-# INLINE rule4277 #-}
   rule4277 = \ ((_patternIcounter) :: Int) ->
     _patternIcounter
   {-# INLINE rule4278 #-}
   rule4278 = \ ((_lhsIcurClassPred) :: Maybe Predicate) ->
     _lhsIcurClassPred
   {-# INLINE rule4279 #-}
   rule4279 = \ ((_lhsIcurPred) :: Maybe Predicate) ->
     _lhsIcurPred
   {-# INLINE rule4280 #-}
   rule4280 = \ ((_lhsIcurrentChunk) :: Int) ->
     _lhsIcurrentChunk
   {-# INLINE rule4281 #-}
   rule4281 = \ ((_lhsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _lhsIdictionaryEnvironment
   {-# INLINE rule4282 #-}
   rule4282 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule4283 #-}
   rule4283 = \ ((_lhsIinstanceName) :: Maybe Name) ->
     _lhsIinstanceName
   {-# INLINE rule4284 #-}
   rule4284 = \ ((_lhsIinstanceTypes) :: [(Name, TpScheme)]) ->
     _lhsIinstanceTypes
   {-# INLINE rule4285 #-}
   rule4285 = \ ((_lhsImatchIO) :: IO ()) ->
     _lhsImatchIO
   {-# INLINE rule4286 #-}
   rule4286 = \ ((_lhsImoduleName) :: Maybe Name) ->
     _lhsImoduleName
   {-# INLINE rule4287 #-}
   rule4287 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule4288 #-}
   rule4288 = \ ((_lhsIorderedTypeSynonyms) :: OrderedTypeSynonyms) ->
     _lhsIorderedTypeSynonyms
   {-# INLINE rule4289 #-}
   rule4289 = \ _parentTree ->
     _parentTree
   {-# INLINE rule4290 #-}
   rule4290 = \ ((_patternIpatternMatchWarnings) :: [Warning]) ->
     _patternIpatternMatchWarnings
   {-# INLINE rule4291 #-}
   rule4291 = \ ((_lhsIrequiredPredicates) :: Predicates) ->
     _lhsIrequiredPredicates
   {-# INLINE rule4292 #-}
   rule4292 = \ ((_lhsIsubstitution) :: FixpointSubstitution) ->
     _lhsIsubstitution
   {-# INLINE rule4293 #-}
   rule4293 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
   {-# INLINE rule4294 #-}
   rule4294 = \ ((_lhsItypeschemeMap) :: M.Map Int (Scheme Predicates)) ->
     _lhsItypeschemeMap
   {-# INLINE rule4295 #-}
   rule4295 = \ ((_lhsIuniqueChunk) :: Int) ->
     _lhsIuniqueChunk
   {-# INLINE rule4296 #-}
   rule4296 = \ ((_lhsIuniqueSecondRound) :: Int) ->
     _lhsIuniqueSecondRound
   {-# INLINE rule4297 #-}
   rule4297 = \ ((_lhsIvariableMapping) :: Maybe [(Name, Tp)]) ->
     _lhsIvariableMapping
{-# NOINLINE sem_Qualifier_Empty #-}
sem_Qualifier_Empty :: T_Range  -> T_Qualifier 
sem_Qualifier_Empty arg_range_ = T_Qualifier (return st128) where
   {-# NOINLINE st128 #-}
   !st128 = let
      v127 :: T_Qualifier_v127 
      v127 = \ !(T_Qualifier_vIn127 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIassumptions _lhsIavailablePredicates _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIconstraints _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeConstructors _lhsItypeschemeMap _lhsIunboundNames _lhsIuniqueChunk _lhsIuniqueSecondRound _lhsIvariableMapping) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         _parentTree = rule4298 _lhsIparentTree _localInfo
         _lhsOinfoTree :: InfoTree
         _lhsOinfoTree = rule4299 _parentTree
         _localInfo = rule4300 _lhsImonos _self
         _lhsOcollectInstances :: [(Name, Instance)]
         _lhsOcollectInstances = rule4301  ()
         _self = rule4302 _rangeIself
         _lhsOself :: Qualifier
         _lhsOself = rule4303 _self
         _lhsOassumptions :: Assumptions
         _lhsOassumptions = rule4304 _lhsIassumptions
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule4305 _lhsIbetaUnique
         _lhsOcollectErrors :: TypeErrors
         _lhsOcollectErrors = rule4306 _lhsIcollectErrors
         _lhsOcollectWarnings :: Warnings
         _lhsOcollectWarnings = rule4307 _lhsIcollectWarnings
         _lhsOconstraints :: ConstraintSet
         _lhsOconstraints = rule4308 _lhsIconstraints
         _lhsOcounter :: Int
         _lhsOcounter = rule4309 _lhsIcounter
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule4310 _lhsIdictionaryEnvironment
         _lhsOmatchIO :: IO ()
         _lhsOmatchIO = rule4311 _lhsImatchIO
         _lhsOmonos :: Monos
         _lhsOmonos = rule4312 _lhsImonos
         _lhsOnamesInScope :: Names
         _lhsOnamesInScope = rule4313 _lhsInamesInScope
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule4314 _lhsIpatternMatchWarnings
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule4315 _lhsIunboundNames
         _lhsOuniqueChunk :: Int
         _lhsOuniqueChunk = rule4316 _lhsIuniqueChunk
         _lhsOuniqueSecondRound :: Int
         _lhsOuniqueSecondRound = rule4317 _lhsIuniqueSecondRound
         !__result_ = T_Qualifier_vOut127 _lhsOassumptions _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraints _lhsOcounter _lhsOdictionaryEnvironment _lhsOinfoTree _lhsOmatchIO _lhsOmonos _lhsOnamesInScope _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOuniqueSecondRound
         in __result_ )
     in C_Qualifier_s128 v127
   {-# INLINE rule4298 #-}
   rule4298 = \ ((_lhsIparentTree) :: InfoTree) _localInfo ->
                            node _lhsIparentTree _localInfo []
   {-# INLINE rule4299 #-}
   rule4299 = \ _parentTree ->
                            _parentTree
   {-# INLINE rule4300 #-}
   rule4300 = \ ((_lhsImonos) :: Monos) _self ->
                            LocalInfo { self = UHA_Qual _self
                                      , assignedType = Nothing
                                      , monos = _lhsImonos
                                      }
   {-# INLINE rule4301 #-}
   rule4301 = \  (_ :: ()) ->
     []
   {-# INLINE rule4302 #-}
   rule4302 = \ ((_rangeIself) :: Range) ->
     Qualifier_Empty _rangeIself
   {-# INLINE rule4303 #-}
   rule4303 = \ _self ->
     _self
   {-# INLINE rule4304 #-}
   rule4304 = \ ((_lhsIassumptions) :: Assumptions) ->
     _lhsIassumptions
   {-# INLINE rule4305 #-}
   rule4305 = \ ((_lhsIbetaUnique) :: Int) ->
     _lhsIbetaUnique
   {-# INLINE rule4306 #-}
   rule4306 = \ ((_lhsIcollectErrors) :: TypeErrors) ->
     _lhsIcollectErrors
   {-# INLINE rule4307 #-}
   rule4307 = \ ((_lhsIcollectWarnings) :: Warnings) ->
     _lhsIcollectWarnings
   {-# INLINE rule4308 #-}
   rule4308 = \ ((_lhsIconstraints) :: ConstraintSet) ->
     _lhsIconstraints
   {-# INLINE rule4309 #-}
   rule4309 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule4310 #-}
   rule4310 = \ ((_lhsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _lhsIdictionaryEnvironment
   {-# INLINE rule4311 #-}
   rule4311 = \ ((_lhsImatchIO) :: IO ()) ->
     _lhsImatchIO
   {-# INLINE rule4312 #-}
   rule4312 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule4313 #-}
   rule4313 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule4314 #-}
   rule4314 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule4315 #-}
   rule4315 = \ ((_lhsIunboundNames) :: Names) ->
     _lhsIunboundNames
   {-# INLINE rule4316 #-}
   rule4316 = \ ((_lhsIuniqueChunk) :: Int) ->
     _lhsIuniqueChunk
   {-# INLINE rule4317 #-}
   rule4317 = \ ((_lhsIuniqueSecondRound) :: Int) ->
     _lhsIuniqueSecondRound

-- Qualifiers --------------------------------------------------
-- wrapper
data Inh_Qualifiers  = Inh_Qualifiers { allPatterns_Inh_Qualifiers :: !([((Expression, [String]), Core_TypingStrategy)]), allTypeSchemes_Inh_Qualifiers :: !(M.Map NameWithRange TpScheme), ambiguousConflicts_Inh_Qualifiers :: !([[Name]]), assumptions_Inh_Qualifiers :: !(Assumptions), availablePredicates_Inh_Qualifiers :: !([PredicateWithSource]), betaUnique_Inh_Qualifiers :: !(Int), classEnvironment_Inh_Qualifiers :: !(ClassEnvironment), classMemberEnv_Inh_Qualifiers :: !(ClassMemberEnvironment), classMemberTypeSchemes_Inh_Qualifiers :: !(Maybe [(Name, TpScheme)]), classNamesEnv_Inh_Qualifiers :: !(ClassNameEnvironment), classPredicate_Inh_Qualifiers :: !(Maybe (Name, Names)), classTypeSchemes_Inh_Qualifiers :: !(M.Map Name TpScheme), collectErrors_Inh_Qualifiers :: !(TypeErrors), collectWarnings_Inh_Qualifiers :: !(Warnings), constraints_Inh_Qualifiers :: !(ConstraintSet), counter_Inh_Qualifiers :: !(Int), curClassPred_Inh_Qualifiers :: !(Maybe Predicate), curPred_Inh_Qualifiers :: !(Maybe Predicate), currentChunk_Inh_Qualifiers :: !(Int), dictionaryEnvironment_Inh_Qualifiers :: !(DictionaryEnvironment), importEnvironment_Inh_Qualifiers :: !(ImportEnvironment), instanceName_Inh_Qualifiers :: !(Maybe Name), instanceTypes_Inh_Qualifiers :: !([(Name, TpScheme)]), matchIO_Inh_Qualifiers :: !(IO ()), moduleName_Inh_Qualifiers :: !(Maybe Name), monos_Inh_Qualifiers :: !(Monos), namesInScope_Inh_Qualifiers :: !(Names), orderedTypeSynonyms_Inh_Qualifiers :: !(OrderedTypeSynonyms), parentTree_Inh_Qualifiers :: !(InfoTree), patternMatchWarnings_Inh_Qualifiers :: !([Warning]), requiredPredicates_Inh_Qualifiers :: !(Predicates), substitution_Inh_Qualifiers :: !(FixpointSubstitution), typeConstructors_Inh_Qualifiers :: !(TypeConstructorEnvironment), typeschemeMap_Inh_Qualifiers :: !(M.Map Int (Scheme Predicates)), unboundNames_Inh_Qualifiers :: !(Names), uniqueChunk_Inh_Qualifiers :: !(Int), uniqueSecondRound_Inh_Qualifiers :: !(Int), variableMapping_Inh_Qualifiers :: !(Maybe [(Name, Tp)]) }
data Syn_Qualifiers  = Syn_Qualifiers { assumptions_Syn_Qualifiers :: !(Assumptions), betaUnique_Syn_Qualifiers :: !(Int), collectErrors_Syn_Qualifiers :: !(TypeErrors), collectInstances_Syn_Qualifiers :: !([(Name, Instance)]), collectWarnings_Syn_Qualifiers :: !(Warnings), constraints_Syn_Qualifiers :: !(ConstraintSet), counter_Syn_Qualifiers :: !(Int), dictionaryEnvironment_Syn_Qualifiers :: !(DictionaryEnvironment), infoTrees_Syn_Qualifiers :: !(InfoTrees), matchIO_Syn_Qualifiers :: !(IO ()), monos_Syn_Qualifiers :: !(Monos), namesInScope_Syn_Qualifiers :: !(Names), patternMatchWarnings_Syn_Qualifiers :: !([Warning]), self_Syn_Qualifiers :: !(Qualifiers), unboundNames_Syn_Qualifiers :: !(Names), uniqueChunk_Syn_Qualifiers :: !(Int), uniqueSecondRound_Syn_Qualifiers :: !(Int) }
{-# INLINABLE wrap_Qualifiers #-}
wrap_Qualifiers :: T_Qualifiers  -> Inh_Qualifiers  -> (Syn_Qualifiers )
wrap_Qualifiers !(T_Qualifiers act) !(Inh_Qualifiers _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIassumptions _lhsIavailablePredicates _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIconstraints _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeConstructors _lhsItypeschemeMap _lhsIunboundNames _lhsIuniqueChunk _lhsIuniqueSecondRound _lhsIvariableMapping) =
   Control.Monad.Identity.runIdentity (
     do !sem <- act
        let arg130 = T_Qualifiers_vIn130 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIassumptions _lhsIavailablePredicates _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIconstraints _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeConstructors _lhsItypeschemeMap _lhsIunboundNames _lhsIuniqueChunk _lhsIuniqueSecondRound _lhsIvariableMapping
        !(T_Qualifiers_vOut130 _lhsOassumptions _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraints _lhsOcounter _lhsOdictionaryEnvironment _lhsOinfoTrees _lhsOmatchIO _lhsOmonos _lhsOnamesInScope _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOuniqueSecondRound) <- return (inv_Qualifiers_s131 sem arg130)
        return (Syn_Qualifiers _lhsOassumptions _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraints _lhsOcounter _lhsOdictionaryEnvironment _lhsOinfoTrees _lhsOmatchIO _lhsOmonos _lhsOnamesInScope _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOuniqueSecondRound)
   )

-- cata
{-# NOINLINE sem_Qualifiers #-}
sem_Qualifiers :: Qualifiers  -> T_Qualifiers 
sem_Qualifiers list = Prelude.foldr sem_Qualifiers_Cons sem_Qualifiers_Nil (Prelude.map sem_Qualifier list)

-- semantic domain
newtype T_Qualifiers  = T_Qualifiers {
                                     attach_T_Qualifiers :: Identity (T_Qualifiers_s131 )
                                     }
newtype T_Qualifiers_s131  = C_Qualifiers_s131 {
                                               inv_Qualifiers_s131 :: (T_Qualifiers_v130 )
                                               }
data T_Qualifiers_s132  = C_Qualifiers_s132
type T_Qualifiers_v130  = (T_Qualifiers_vIn130 ) -> (T_Qualifiers_vOut130 )
data T_Qualifiers_vIn130  = T_Qualifiers_vIn130 ([((Expression, [String]), Core_TypingStrategy)]) (M.Map NameWithRange TpScheme) ([[Name]]) (Assumptions) ([PredicateWithSource]) (Int) (ClassEnvironment) (ClassMemberEnvironment) (Maybe [(Name, TpScheme)]) (ClassNameEnvironment) (Maybe (Name, Names)) (M.Map Name TpScheme) (TypeErrors) (Warnings) (ConstraintSet) (Int) (Maybe Predicate) (Maybe Predicate) (Int) (DictionaryEnvironment) (ImportEnvironment) (Maybe Name) ([(Name, TpScheme)]) (IO ()) (Maybe Name) (Monos) (Names) (OrderedTypeSynonyms) (InfoTree) ([Warning]) (Predicates) (FixpointSubstitution) (TypeConstructorEnvironment) (M.Map Int (Scheme Predicates)) (Names) (Int) (Int) (Maybe [(Name, Tp)])
data T_Qualifiers_vOut130  = T_Qualifiers_vOut130 (Assumptions) (Int) (TypeErrors) ([(Name, Instance)]) (Warnings) (ConstraintSet) (Int) (DictionaryEnvironment) (InfoTrees) (IO ()) (Monos) (Names) ([Warning]) (Qualifiers) (Names) (Int) (Int)
{-# NOINLINE sem_Qualifiers_Cons #-}
sem_Qualifiers_Cons :: T_Qualifier  -> T_Qualifiers  -> T_Qualifiers 
sem_Qualifiers_Cons arg_hd_ arg_tl_ = T_Qualifiers (return st131) where
   {-# NOINLINE st131 #-}
   !st131 = let
      v130 :: T_Qualifiers_v130 
      v130 = \ !(T_Qualifiers_vIn130 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIassumptions _lhsIavailablePredicates _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIconstraints _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeConstructors _lhsItypeschemeMap _lhsIunboundNames _lhsIuniqueChunk _lhsIuniqueSecondRound _lhsIvariableMapping) -> ( let
         _hdX128 = Control.Monad.Identity.runIdentity (attach_T_Qualifier (arg_hd_))
         _tlX131 = Control.Monad.Identity.runIdentity (attach_T_Qualifiers (arg_tl_))
         (T_Qualifier_vOut127 _hdIassumptions _hdIbetaUnique _hdIcollectErrors _hdIcollectInstances _hdIcollectWarnings _hdIconstraints _hdIcounter _hdIdictionaryEnvironment _hdIinfoTree _hdImatchIO _hdImonos _hdInamesInScope _hdIpatternMatchWarnings _hdIself _hdIunboundNames _hdIuniqueChunk _hdIuniqueSecondRound) = inv_Qualifier_s128 _hdX128 (T_Qualifier_vIn127 _hdOallPatterns _hdOallTypeSchemes _hdOambiguousConflicts _hdOassumptions _hdOavailablePredicates _hdObetaUnique _hdOclassEnvironment _hdOclassMemberEnv _hdOclassMemberTypeSchemes _hdOclassNamesEnv _hdOclassPredicate _hdOclassTypeSchemes _hdOcollectErrors _hdOcollectWarnings _hdOconstraints _hdOcounter _hdOcurClassPred _hdOcurPred _hdOcurrentChunk _hdOdictionaryEnvironment _hdOimportEnvironment _hdOinstanceName _hdOinstanceTypes _hdOmatchIO _hdOmoduleName _hdOmonos _hdOnamesInScope _hdOorderedTypeSynonyms _hdOparentTree _hdOpatternMatchWarnings _hdOrequiredPredicates _hdOsubstitution _hdOtypeConstructors _hdOtypeschemeMap _hdOunboundNames _hdOuniqueChunk _hdOuniqueSecondRound _hdOvariableMapping)
         (T_Qualifiers_vOut130 _tlIassumptions _tlIbetaUnique _tlIcollectErrors _tlIcollectInstances _tlIcollectWarnings _tlIconstraints _tlIcounter _tlIdictionaryEnvironment _tlIinfoTrees _tlImatchIO _tlImonos _tlInamesInScope _tlIpatternMatchWarnings _tlIself _tlIunboundNames _tlIuniqueChunk _tlIuniqueSecondRound) = inv_Qualifiers_s131 _tlX131 (T_Qualifiers_vIn130 _tlOallPatterns _tlOallTypeSchemes _tlOambiguousConflicts _tlOassumptions _tlOavailablePredicates _tlObetaUnique _tlOclassEnvironment _tlOclassMemberEnv _tlOclassMemberTypeSchemes _tlOclassNamesEnv _tlOclassPredicate _tlOclassTypeSchemes _tlOcollectErrors _tlOcollectWarnings _tlOconstraints _tlOcounter _tlOcurClassPred _tlOcurPred _tlOcurrentChunk _tlOdictionaryEnvironment _tlOimportEnvironment _tlOinstanceName _tlOinstanceTypes _tlOmatchIO _tlOmoduleName _tlOmonos _tlOnamesInScope _tlOorderedTypeSynonyms _tlOparentTree _tlOpatternMatchWarnings _tlOrequiredPredicates _tlOsubstitution _tlOtypeConstructors _tlOtypeschemeMap _tlOunboundNames _tlOuniqueChunk _tlOuniqueSecondRound _tlOvariableMapping)
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule4318 _hdIunboundNames
         _tlOunboundNames = rule4319 _lhsIunboundNames
         _hdOunboundNames = rule4320 _tlIunboundNames
         _lhsOinfoTrees :: InfoTrees
         _lhsOinfoTrees = rule4321 _hdIinfoTree _tlIinfoTrees
         _lhsOassumptions :: Assumptions
         _lhsOassumptions = rule4322 _hdIassumptions
         _lhsOconstraints :: ConstraintSet
         _lhsOconstraints = rule4323 _hdIconstraints
         _hdOassumptions = rule4324 _tlIassumptions
         _hdOconstraints = rule4325 _tlIconstraints
         _tlOassumptions = rule4326 _lhsIassumptions
         _tlOconstraints = rule4327 _lhsIconstraints
         _lhsOcollectInstances :: [(Name, Instance)]
         _lhsOcollectInstances = rule4328 _hdIcollectInstances _tlIcollectInstances
         _self = rule4329 _hdIself _tlIself
         _lhsOself :: Qualifiers
         _lhsOself = rule4330 _self
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule4331 _tlIbetaUnique
         _lhsOcollectErrors :: TypeErrors
         _lhsOcollectErrors = rule4332 _tlIcollectErrors
         _lhsOcollectWarnings :: Warnings
         _lhsOcollectWarnings = rule4333 _tlIcollectWarnings
         _lhsOcounter :: Int
         _lhsOcounter = rule4334 _tlIcounter
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule4335 _tlIdictionaryEnvironment
         _lhsOmatchIO :: IO ()
         _lhsOmatchIO = rule4336 _tlImatchIO
         _lhsOmonos :: Monos
         _lhsOmonos = rule4337 _tlImonos
         _lhsOnamesInScope :: Names
         _lhsOnamesInScope = rule4338 _tlInamesInScope
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule4339 _tlIpatternMatchWarnings
         _lhsOuniqueChunk :: Int
         _lhsOuniqueChunk = rule4340 _tlIuniqueChunk
         _lhsOuniqueSecondRound :: Int
         _lhsOuniqueSecondRound = rule4341 _tlIuniqueSecondRound
         _hdOallPatterns = rule4342 _lhsIallPatterns
         _hdOallTypeSchemes = rule4343 _lhsIallTypeSchemes
         _hdOambiguousConflicts = rule4344 _lhsIambiguousConflicts
         _hdOavailablePredicates = rule4345 _lhsIavailablePredicates
         _hdObetaUnique = rule4346 _lhsIbetaUnique
         _hdOclassEnvironment = rule4347 _lhsIclassEnvironment
         _hdOclassMemberEnv = rule4348 _lhsIclassMemberEnv
         _hdOclassMemberTypeSchemes = rule4349 _lhsIclassMemberTypeSchemes
         _hdOclassNamesEnv = rule4350 _lhsIclassNamesEnv
         _hdOclassPredicate = rule4351 _lhsIclassPredicate
         _hdOclassTypeSchemes = rule4352 _lhsIclassTypeSchemes
         _hdOcollectErrors = rule4353 _lhsIcollectErrors
         _hdOcollectWarnings = rule4354 _lhsIcollectWarnings
         _hdOcounter = rule4355 _lhsIcounter
         _hdOcurClassPred = rule4356 _lhsIcurClassPred
         _hdOcurPred = rule4357 _lhsIcurPred
         _hdOcurrentChunk = rule4358 _lhsIcurrentChunk
         _hdOdictionaryEnvironment = rule4359 _lhsIdictionaryEnvironment
         _hdOimportEnvironment = rule4360 _lhsIimportEnvironment
         _hdOinstanceName = rule4361 _lhsIinstanceName
         _hdOinstanceTypes = rule4362 _lhsIinstanceTypes
         _hdOmatchIO = rule4363 _lhsImatchIO
         _hdOmoduleName = rule4364 _lhsImoduleName
         _hdOmonos = rule4365 _lhsImonos
         _hdOnamesInScope = rule4366 _lhsInamesInScope
         _hdOorderedTypeSynonyms = rule4367 _lhsIorderedTypeSynonyms
         _hdOparentTree = rule4368 _lhsIparentTree
         _hdOpatternMatchWarnings = rule4369 _lhsIpatternMatchWarnings
         _hdOrequiredPredicates = rule4370 _lhsIrequiredPredicates
         _hdOsubstitution = rule4371 _lhsIsubstitution
         _hdOtypeConstructors = rule4372 _lhsItypeConstructors
         _hdOtypeschemeMap = rule4373 _lhsItypeschemeMap
         _hdOuniqueChunk = rule4374 _lhsIuniqueChunk
         _hdOuniqueSecondRound = rule4375 _lhsIuniqueSecondRound
         _hdOvariableMapping = rule4376 _lhsIvariableMapping
         _tlOallPatterns = rule4377 _lhsIallPatterns
         _tlOallTypeSchemes = rule4378 _lhsIallTypeSchemes
         _tlOambiguousConflicts = rule4379 _lhsIambiguousConflicts
         _tlOavailablePredicates = rule4380 _lhsIavailablePredicates
         _tlObetaUnique = rule4381 _hdIbetaUnique
         _tlOclassEnvironment = rule4382 _lhsIclassEnvironment
         _tlOclassMemberEnv = rule4383 _lhsIclassMemberEnv
         _tlOclassMemberTypeSchemes = rule4384 _lhsIclassMemberTypeSchemes
         _tlOclassNamesEnv = rule4385 _lhsIclassNamesEnv
         _tlOclassPredicate = rule4386 _lhsIclassPredicate
         _tlOclassTypeSchemes = rule4387 _lhsIclassTypeSchemes
         _tlOcollectErrors = rule4388 _hdIcollectErrors
         _tlOcollectWarnings = rule4389 _hdIcollectWarnings
         _tlOcounter = rule4390 _hdIcounter
         _tlOcurClassPred = rule4391 _lhsIcurClassPred
         _tlOcurPred = rule4392 _lhsIcurPred
         _tlOcurrentChunk = rule4393 _lhsIcurrentChunk
         _tlOdictionaryEnvironment = rule4394 _hdIdictionaryEnvironment
         _tlOimportEnvironment = rule4395 _lhsIimportEnvironment
         _tlOinstanceName = rule4396 _lhsIinstanceName
         _tlOinstanceTypes = rule4397 _lhsIinstanceTypes
         _tlOmatchIO = rule4398 _hdImatchIO
         _tlOmoduleName = rule4399 _lhsImoduleName
         _tlOmonos = rule4400 _hdImonos
         _tlOnamesInScope = rule4401 _hdInamesInScope
         _tlOorderedTypeSynonyms = rule4402 _lhsIorderedTypeSynonyms
         _tlOparentTree = rule4403 _lhsIparentTree
         _tlOpatternMatchWarnings = rule4404 _hdIpatternMatchWarnings
         _tlOrequiredPredicates = rule4405 _lhsIrequiredPredicates
         _tlOsubstitution = rule4406 _lhsIsubstitution
         _tlOtypeConstructors = rule4407 _lhsItypeConstructors
         _tlOtypeschemeMap = rule4408 _lhsItypeschemeMap
         _tlOuniqueChunk = rule4409 _hdIuniqueChunk
         _tlOuniqueSecondRound = rule4410 _hdIuniqueSecondRound
         _tlOvariableMapping = rule4411 _lhsIvariableMapping
         !__result_ = T_Qualifiers_vOut130 _lhsOassumptions _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraints _lhsOcounter _lhsOdictionaryEnvironment _lhsOinfoTrees _lhsOmatchIO _lhsOmonos _lhsOnamesInScope _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOuniqueSecondRound
         in __result_ )
     in C_Qualifiers_s131 v130
   {-# INLINE rule4318 #-}
   rule4318 = \ ((_hdIunboundNames) :: Names) ->
                                  _hdIunboundNames
   {-# INLINE rule4319 #-}
   rule4319 = \ ((_lhsIunboundNames) :: Names) ->
                                  _lhsIunboundNames
   {-# INLINE rule4320 #-}
   rule4320 = \ ((_tlIunboundNames) :: Names) ->
                                  _tlIunboundNames
   {-# INLINE rule4321 #-}
   rule4321 = \ ((_hdIinfoTree) :: InfoTree) ((_tlIinfoTrees) :: InfoTrees) ->
                               _hdIinfoTree : _tlIinfoTrees
   {-# INLINE rule4322 #-}
   rule4322 = \ ((_hdIassumptions) :: Assumptions) ->
                            _hdIassumptions
   {-# INLINE rule4323 #-}
   rule4323 = \ ((_hdIconstraints) :: ConstraintSet) ->
                            _hdIconstraints
   {-# INLINE rule4324 #-}
   rule4324 = \ ((_tlIassumptions) :: Assumptions) ->
                            _tlIassumptions
   {-# INLINE rule4325 #-}
   rule4325 = \ ((_tlIconstraints) :: ConstraintSet) ->
                            _tlIconstraints
   {-# INLINE rule4326 #-}
   rule4326 = \ ((_lhsIassumptions) :: Assumptions) ->
                            _lhsIassumptions
   {-# INLINE rule4327 #-}
   rule4327 = \ ((_lhsIconstraints) :: ConstraintSet) ->
                            _lhsIconstraints
   {-# INLINE rule4328 #-}
   rule4328 = \ ((_hdIcollectInstances) :: [(Name, Instance)]) ((_tlIcollectInstances) :: [(Name, Instance)]) ->
     _hdIcollectInstances  ++  _tlIcollectInstances
   {-# INLINE rule4329 #-}
   rule4329 = \ ((_hdIself) :: Qualifier) ((_tlIself) :: Qualifiers) ->
     (:) _hdIself _tlIself
   {-# INLINE rule4330 #-}
   rule4330 = \ _self ->
     _self
   {-# INLINE rule4331 #-}
   rule4331 = \ ((_tlIbetaUnique) :: Int) ->
     _tlIbetaUnique
   {-# INLINE rule4332 #-}
   rule4332 = \ ((_tlIcollectErrors) :: TypeErrors) ->
     _tlIcollectErrors
   {-# INLINE rule4333 #-}
   rule4333 = \ ((_tlIcollectWarnings) :: Warnings) ->
     _tlIcollectWarnings
   {-# INLINE rule4334 #-}
   rule4334 = \ ((_tlIcounter) :: Int) ->
     _tlIcounter
   {-# INLINE rule4335 #-}
   rule4335 = \ ((_tlIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _tlIdictionaryEnvironment
   {-# INLINE rule4336 #-}
   rule4336 = \ ((_tlImatchIO) :: IO ()) ->
     _tlImatchIO
   {-# INLINE rule4337 #-}
   rule4337 = \ ((_tlImonos) :: Monos) ->
     _tlImonos
   {-# INLINE rule4338 #-}
   rule4338 = \ ((_tlInamesInScope) :: Names) ->
     _tlInamesInScope
   {-# INLINE rule4339 #-}
   rule4339 = \ ((_tlIpatternMatchWarnings) :: [Warning]) ->
     _tlIpatternMatchWarnings
   {-# INLINE rule4340 #-}
   rule4340 = \ ((_tlIuniqueChunk) :: Int) ->
     _tlIuniqueChunk
   {-# INLINE rule4341 #-}
   rule4341 = \ ((_tlIuniqueSecondRound) :: Int) ->
     _tlIuniqueSecondRound
   {-# INLINE rule4342 #-}
   rule4342 = \ ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ->
     _lhsIallPatterns
   {-# INLINE rule4343 #-}
   rule4343 = \ ((_lhsIallTypeSchemes) :: M.Map NameWithRange TpScheme) ->
     _lhsIallTypeSchemes
   {-# INLINE rule4344 #-}
   rule4344 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule4345 #-}
   rule4345 = \ ((_lhsIavailablePredicates) :: [PredicateWithSource]) ->
     _lhsIavailablePredicates
   {-# INLINE rule4346 #-}
   rule4346 = \ ((_lhsIbetaUnique) :: Int) ->
     _lhsIbetaUnique
   {-# INLINE rule4347 #-}
   rule4347 = \ ((_lhsIclassEnvironment) :: ClassEnvironment) ->
     _lhsIclassEnvironment
   {-# INLINE rule4348 #-}
   rule4348 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule4349 #-}
   rule4349 = \ ((_lhsIclassMemberTypeSchemes) :: Maybe [(Name, TpScheme)]) ->
     _lhsIclassMemberTypeSchemes
   {-# INLINE rule4350 #-}
   rule4350 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule4351 #-}
   rule4351 = \ ((_lhsIclassPredicate) :: Maybe (Name, Names)) ->
     _lhsIclassPredicate
   {-# INLINE rule4352 #-}
   rule4352 = \ ((_lhsIclassTypeSchemes) :: M.Map Name TpScheme) ->
     _lhsIclassTypeSchemes
   {-# INLINE rule4353 #-}
   rule4353 = \ ((_lhsIcollectErrors) :: TypeErrors) ->
     _lhsIcollectErrors
   {-# INLINE rule4354 #-}
   rule4354 = \ ((_lhsIcollectWarnings) :: Warnings) ->
     _lhsIcollectWarnings
   {-# INLINE rule4355 #-}
   rule4355 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule4356 #-}
   rule4356 = \ ((_lhsIcurClassPred) :: Maybe Predicate) ->
     _lhsIcurClassPred
   {-# INLINE rule4357 #-}
   rule4357 = \ ((_lhsIcurPred) :: Maybe Predicate) ->
     _lhsIcurPred
   {-# INLINE rule4358 #-}
   rule4358 = \ ((_lhsIcurrentChunk) :: Int) ->
     _lhsIcurrentChunk
   {-# INLINE rule4359 #-}
   rule4359 = \ ((_lhsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _lhsIdictionaryEnvironment
   {-# INLINE rule4360 #-}
   rule4360 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule4361 #-}
   rule4361 = \ ((_lhsIinstanceName) :: Maybe Name) ->
     _lhsIinstanceName
   {-# INLINE rule4362 #-}
   rule4362 = \ ((_lhsIinstanceTypes) :: [(Name, TpScheme)]) ->
     _lhsIinstanceTypes
   {-# INLINE rule4363 #-}
   rule4363 = \ ((_lhsImatchIO) :: IO ()) ->
     _lhsImatchIO
   {-# INLINE rule4364 #-}
   rule4364 = \ ((_lhsImoduleName) :: Maybe Name) ->
     _lhsImoduleName
   {-# INLINE rule4365 #-}
   rule4365 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule4366 #-}
   rule4366 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule4367 #-}
   rule4367 = \ ((_lhsIorderedTypeSynonyms) :: OrderedTypeSynonyms) ->
     _lhsIorderedTypeSynonyms
   {-# INLINE rule4368 #-}
   rule4368 = \ ((_lhsIparentTree) :: InfoTree) ->
     _lhsIparentTree
   {-# INLINE rule4369 #-}
   rule4369 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule4370 #-}
   rule4370 = \ ((_lhsIrequiredPredicates) :: Predicates) ->
     _lhsIrequiredPredicates
   {-# INLINE rule4371 #-}
   rule4371 = \ ((_lhsIsubstitution) :: FixpointSubstitution) ->
     _lhsIsubstitution
   {-# INLINE rule4372 #-}
   rule4372 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
   {-# INLINE rule4373 #-}
   rule4373 = \ ((_lhsItypeschemeMap) :: M.Map Int (Scheme Predicates)) ->
     _lhsItypeschemeMap
   {-# INLINE rule4374 #-}
   rule4374 = \ ((_lhsIuniqueChunk) :: Int) ->
     _lhsIuniqueChunk
   {-# INLINE rule4375 #-}
   rule4375 = \ ((_lhsIuniqueSecondRound) :: Int) ->
     _lhsIuniqueSecondRound
   {-# INLINE rule4376 #-}
   rule4376 = \ ((_lhsIvariableMapping) :: Maybe [(Name, Tp)]) ->
     _lhsIvariableMapping
   {-# INLINE rule4377 #-}
   rule4377 = \ ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ->
     _lhsIallPatterns
   {-# INLINE rule4378 #-}
   rule4378 = \ ((_lhsIallTypeSchemes) :: M.Map NameWithRange TpScheme) ->
     _lhsIallTypeSchemes
   {-# INLINE rule4379 #-}
   rule4379 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule4380 #-}
   rule4380 = \ ((_lhsIavailablePredicates) :: [PredicateWithSource]) ->
     _lhsIavailablePredicates
   {-# INLINE rule4381 #-}
   rule4381 = \ ((_hdIbetaUnique) :: Int) ->
     _hdIbetaUnique
   {-# INLINE rule4382 #-}
   rule4382 = \ ((_lhsIclassEnvironment) :: ClassEnvironment) ->
     _lhsIclassEnvironment
   {-# INLINE rule4383 #-}
   rule4383 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule4384 #-}
   rule4384 = \ ((_lhsIclassMemberTypeSchemes) :: Maybe [(Name, TpScheme)]) ->
     _lhsIclassMemberTypeSchemes
   {-# INLINE rule4385 #-}
   rule4385 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule4386 #-}
   rule4386 = \ ((_lhsIclassPredicate) :: Maybe (Name, Names)) ->
     _lhsIclassPredicate
   {-# INLINE rule4387 #-}
   rule4387 = \ ((_lhsIclassTypeSchemes) :: M.Map Name TpScheme) ->
     _lhsIclassTypeSchemes
   {-# INLINE rule4388 #-}
   rule4388 = \ ((_hdIcollectErrors) :: TypeErrors) ->
     _hdIcollectErrors
   {-# INLINE rule4389 #-}
   rule4389 = \ ((_hdIcollectWarnings) :: Warnings) ->
     _hdIcollectWarnings
   {-# INLINE rule4390 #-}
   rule4390 = \ ((_hdIcounter) :: Int) ->
     _hdIcounter
   {-# INLINE rule4391 #-}
   rule4391 = \ ((_lhsIcurClassPred) :: Maybe Predicate) ->
     _lhsIcurClassPred
   {-# INLINE rule4392 #-}
   rule4392 = \ ((_lhsIcurPred) :: Maybe Predicate) ->
     _lhsIcurPred
   {-# INLINE rule4393 #-}
   rule4393 = \ ((_lhsIcurrentChunk) :: Int) ->
     _lhsIcurrentChunk
   {-# INLINE rule4394 #-}
   rule4394 = \ ((_hdIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _hdIdictionaryEnvironment
   {-# INLINE rule4395 #-}
   rule4395 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule4396 #-}
   rule4396 = \ ((_lhsIinstanceName) :: Maybe Name) ->
     _lhsIinstanceName
   {-# INLINE rule4397 #-}
   rule4397 = \ ((_lhsIinstanceTypes) :: [(Name, TpScheme)]) ->
     _lhsIinstanceTypes
   {-# INLINE rule4398 #-}
   rule4398 = \ ((_hdImatchIO) :: IO ()) ->
     _hdImatchIO
   {-# INLINE rule4399 #-}
   rule4399 = \ ((_lhsImoduleName) :: Maybe Name) ->
     _lhsImoduleName
   {-# INLINE rule4400 #-}
   rule4400 = \ ((_hdImonos) :: Monos) ->
     _hdImonos
   {-# INLINE rule4401 #-}
   rule4401 = \ ((_hdInamesInScope) :: Names) ->
     _hdInamesInScope
   {-# INLINE rule4402 #-}
   rule4402 = \ ((_lhsIorderedTypeSynonyms) :: OrderedTypeSynonyms) ->
     _lhsIorderedTypeSynonyms
   {-# INLINE rule4403 #-}
   rule4403 = \ ((_lhsIparentTree) :: InfoTree) ->
     _lhsIparentTree
   {-# INLINE rule4404 #-}
   rule4404 = \ ((_hdIpatternMatchWarnings) :: [Warning]) ->
     _hdIpatternMatchWarnings
   {-# INLINE rule4405 #-}
   rule4405 = \ ((_lhsIrequiredPredicates) :: Predicates) ->
     _lhsIrequiredPredicates
   {-# INLINE rule4406 #-}
   rule4406 = \ ((_lhsIsubstitution) :: FixpointSubstitution) ->
     _lhsIsubstitution
   {-# INLINE rule4407 #-}
   rule4407 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
   {-# INLINE rule4408 #-}
   rule4408 = \ ((_lhsItypeschemeMap) :: M.Map Int (Scheme Predicates)) ->
     _lhsItypeschemeMap
   {-# INLINE rule4409 #-}
   rule4409 = \ ((_hdIuniqueChunk) :: Int) ->
     _hdIuniqueChunk
   {-# INLINE rule4410 #-}
   rule4410 = \ ((_hdIuniqueSecondRound) :: Int) ->
     _hdIuniqueSecondRound
   {-# INLINE rule4411 #-}
   rule4411 = \ ((_lhsIvariableMapping) :: Maybe [(Name, Tp)]) ->
     _lhsIvariableMapping
{-# NOINLINE sem_Qualifiers_Nil #-}
sem_Qualifiers_Nil ::  T_Qualifiers 
sem_Qualifiers_Nil  = T_Qualifiers (return st131) where
   {-# NOINLINE st131 #-}
   !st131 = let
      v130 :: T_Qualifiers_v130 
      v130 = \ !(T_Qualifiers_vIn130 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIassumptions _lhsIavailablePredicates _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIconstraints _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeConstructors _lhsItypeschemeMap _lhsIunboundNames _lhsIuniqueChunk _lhsIuniqueSecondRound _lhsIvariableMapping) -> ( let
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule4412 _lhsIunboundNames
         _lhsOinfoTrees :: InfoTrees
         _lhsOinfoTrees = rule4413  ()
         _lhsOcollectInstances :: [(Name, Instance)]
         _lhsOcollectInstances = rule4414  ()
         _self = rule4415  ()
         _lhsOself :: Qualifiers
         _lhsOself = rule4416 _self
         _lhsOassumptions :: Assumptions
         _lhsOassumptions = rule4417 _lhsIassumptions
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule4418 _lhsIbetaUnique
         _lhsOcollectErrors :: TypeErrors
         _lhsOcollectErrors = rule4419 _lhsIcollectErrors
         _lhsOcollectWarnings :: Warnings
         _lhsOcollectWarnings = rule4420 _lhsIcollectWarnings
         _lhsOconstraints :: ConstraintSet
         _lhsOconstraints = rule4421 _lhsIconstraints
         _lhsOcounter :: Int
         _lhsOcounter = rule4422 _lhsIcounter
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule4423 _lhsIdictionaryEnvironment
         _lhsOmatchIO :: IO ()
         _lhsOmatchIO = rule4424 _lhsImatchIO
         _lhsOmonos :: Monos
         _lhsOmonos = rule4425 _lhsImonos
         _lhsOnamesInScope :: Names
         _lhsOnamesInScope = rule4426 _lhsInamesInScope
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule4427 _lhsIpatternMatchWarnings
         _lhsOuniqueChunk :: Int
         _lhsOuniqueChunk = rule4428 _lhsIuniqueChunk
         _lhsOuniqueSecondRound :: Int
         _lhsOuniqueSecondRound = rule4429 _lhsIuniqueSecondRound
         !__result_ = T_Qualifiers_vOut130 _lhsOassumptions _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraints _lhsOcounter _lhsOdictionaryEnvironment _lhsOinfoTrees _lhsOmatchIO _lhsOmonos _lhsOnamesInScope _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOuniqueSecondRound
         in __result_ )
     in C_Qualifiers_s131 v130
   {-# INLINE rule4412 #-}
   rule4412 = \ ((_lhsIunboundNames) :: Names) ->
                                  _lhsIunboundNames
   {-# INLINE rule4413 #-}
   rule4413 = \  (_ :: ()) ->
                               []
   {-# INLINE rule4414 #-}
   rule4414 = \  (_ :: ()) ->
     []
   {-# INLINE rule4415 #-}
   rule4415 = \  (_ :: ()) ->
     []
   {-# INLINE rule4416 #-}
   rule4416 = \ _self ->
     _self
   {-# INLINE rule4417 #-}
   rule4417 = \ ((_lhsIassumptions) :: Assumptions) ->
     _lhsIassumptions
   {-# INLINE rule4418 #-}
   rule4418 = \ ((_lhsIbetaUnique) :: Int) ->
     _lhsIbetaUnique
   {-# INLINE rule4419 #-}
   rule4419 = \ ((_lhsIcollectErrors) :: TypeErrors) ->
     _lhsIcollectErrors
   {-# INLINE rule4420 #-}
   rule4420 = \ ((_lhsIcollectWarnings) :: Warnings) ->
     _lhsIcollectWarnings
   {-# INLINE rule4421 #-}
   rule4421 = \ ((_lhsIconstraints) :: ConstraintSet) ->
     _lhsIconstraints
   {-# INLINE rule4422 #-}
   rule4422 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule4423 #-}
   rule4423 = \ ((_lhsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _lhsIdictionaryEnvironment
   {-# INLINE rule4424 #-}
   rule4424 = \ ((_lhsImatchIO) :: IO ()) ->
     _lhsImatchIO
   {-# INLINE rule4425 #-}
   rule4425 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule4426 #-}
   rule4426 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule4427 #-}
   rule4427 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule4428 #-}
   rule4428 = \ ((_lhsIuniqueChunk) :: Int) ->
     _lhsIuniqueChunk
   {-# INLINE rule4429 #-}
   rule4429 = \ ((_lhsIuniqueSecondRound) :: Int) ->
     _lhsIuniqueSecondRound

-- Range -------------------------------------------------------
-- wrapper
data Inh_Range  = Inh_Range {  }
data Syn_Range  = Syn_Range { self_Syn_Range :: !(Range) }
{-# INLINABLE wrap_Range #-}
wrap_Range :: T_Range  -> Inh_Range  -> (Syn_Range )
wrap_Range !(T_Range act) !(Inh_Range ) =
   Control.Monad.Identity.runIdentity (
     do !sem <- act
        let arg133 = T_Range_vIn133 
        !(T_Range_vOut133 _lhsOself) <- return (inv_Range_s134 sem arg133)
        return (Syn_Range _lhsOself)
   )

-- cata
{-# INLINE sem_Range #-}
sem_Range :: Range  -> T_Range 
sem_Range ( Range_Range start_ stop_ ) = sem_Range_Range ( sem_Position start_ ) ( sem_Position stop_ )

-- semantic domain
newtype T_Range  = T_Range {
                           attach_T_Range :: Identity (T_Range_s134 )
                           }
newtype T_Range_s134  = C_Range_s134 {
                                     inv_Range_s134 :: (T_Range_v133 )
                                     }
data T_Range_s135  = C_Range_s135
type T_Range_v133  = (T_Range_vIn133 ) -> (T_Range_vOut133 )
data T_Range_vIn133  = T_Range_vIn133 
data T_Range_vOut133  = T_Range_vOut133 (Range)
{-# NOINLINE sem_Range_Range #-}
sem_Range_Range :: T_Position  -> T_Position  -> T_Range 
sem_Range_Range arg_start_ arg_stop_ = T_Range (return st134) where
   {-# NOINLINE st134 #-}
   !st134 = let
      v133 :: T_Range_v133 
      v133 = \ !(T_Range_vIn133 ) -> ( let
         _startX125 = Control.Monad.Identity.runIdentity (attach_T_Position (arg_start_))
         _stopX125 = Control.Monad.Identity.runIdentity (attach_T_Position (arg_stop_))
         (T_Position_vOut124 _startIself) = inv_Position_s125 _startX125 (T_Position_vIn124 )
         (T_Position_vOut124 _stopIself) = inv_Position_s125 _stopX125 (T_Position_vIn124 )
         _self = rule4430 _startIself _stopIself
         _lhsOself :: Range
         _lhsOself = rule4431 _self
         !__result_ = T_Range_vOut133 _lhsOself
         in __result_ )
     in C_Range_s134 v133
   {-# INLINE rule4430 #-}
   rule4430 = \ ((_startIself) :: Position) ((_stopIself) :: Position) ->
     Range_Range _startIself _stopIself
   {-# INLINE rule4431 #-}
   rule4431 = \ _self ->
     _self

-- RecordExpressionBinding -------------------------------------
-- wrapper
data Inh_RecordExpressionBinding  = Inh_RecordExpressionBinding { allTypeSchemes_Inh_RecordExpressionBinding :: !(M.Map NameWithRange TpScheme), ambiguousConflicts_Inh_RecordExpressionBinding :: !([[Name]]), availablePredicates_Inh_RecordExpressionBinding :: !([PredicateWithSource]), classEnvironment_Inh_RecordExpressionBinding :: !(ClassEnvironment), classMemberEnv_Inh_RecordExpressionBinding :: !(ClassMemberEnvironment), classMemberTypeSchemes_Inh_RecordExpressionBinding :: !(Maybe [(Name, TpScheme)]), classNamesEnv_Inh_RecordExpressionBinding :: !(ClassNameEnvironment), classPredicate_Inh_RecordExpressionBinding :: !(Maybe (Name, Names)), classTypeSchemes_Inh_RecordExpressionBinding :: !(M.Map Name TpScheme), collectErrors_Inh_RecordExpressionBinding :: !(TypeErrors), collectWarnings_Inh_RecordExpressionBinding :: !(Warnings), counter_Inh_RecordExpressionBinding :: !(Int), curClassPred_Inh_RecordExpressionBinding :: !(Maybe Predicate), curPred_Inh_RecordExpressionBinding :: !(Maybe Predicate), currentChunk_Inh_RecordExpressionBinding :: !(Int), dictionaryEnvironment_Inh_RecordExpressionBinding :: !(DictionaryEnvironment), importEnvironment_Inh_RecordExpressionBinding :: !(ImportEnvironment), instanceName_Inh_RecordExpressionBinding :: !(Maybe Name), instanceTypes_Inh_RecordExpressionBinding :: !([(Name, TpScheme)]), moduleName_Inh_RecordExpressionBinding :: !(Maybe Name), namesInScope_Inh_RecordExpressionBinding :: !(Names), orderedTypeSynonyms_Inh_RecordExpressionBinding :: !(OrderedTypeSynonyms), patternMatchWarnings_Inh_RecordExpressionBinding :: !([Warning]), requiredPredicates_Inh_RecordExpressionBinding :: !(Predicates), substitution_Inh_RecordExpressionBinding :: !(FixpointSubstitution), typeschemeMap_Inh_RecordExpressionBinding :: !(M.Map Int (Scheme Predicates)), uniqueChunk_Inh_RecordExpressionBinding :: !(Int), variableMapping_Inh_RecordExpressionBinding :: !(Maybe [(Name, Tp)]) }
data Syn_RecordExpressionBinding  = Syn_RecordExpressionBinding { collectErrors_Syn_RecordExpressionBinding :: !(TypeErrors), collectInstances_Syn_RecordExpressionBinding :: !([(Name, Instance)]), collectWarnings_Syn_RecordExpressionBinding :: !(Warnings), counter_Syn_RecordExpressionBinding :: !(Int), dictionaryEnvironment_Syn_RecordExpressionBinding :: !(DictionaryEnvironment), patternMatchWarnings_Syn_RecordExpressionBinding :: !([Warning]), self_Syn_RecordExpressionBinding :: !(RecordExpressionBinding), unboundNames_Syn_RecordExpressionBinding :: !(Names), uniqueChunk_Syn_RecordExpressionBinding :: !(Int) }
{-# INLINABLE wrap_RecordExpressionBinding #-}
wrap_RecordExpressionBinding :: T_RecordExpressionBinding  -> Inh_RecordExpressionBinding  -> (Syn_RecordExpressionBinding )
wrap_RecordExpressionBinding !(T_RecordExpressionBinding act) !(Inh_RecordExpressionBinding _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImoduleName _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeschemeMap _lhsIuniqueChunk _lhsIvariableMapping) =
   Control.Monad.Identity.runIdentity (
     do !sem <- act
        let arg136 = T_RecordExpressionBinding_vIn136 _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImoduleName _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeschemeMap _lhsIuniqueChunk _lhsIvariableMapping
        !(T_RecordExpressionBinding_vOut136 _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOcounter _lhsOdictionaryEnvironment _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk) <- return (inv_RecordExpressionBinding_s137 sem arg136)
        return (Syn_RecordExpressionBinding _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOcounter _lhsOdictionaryEnvironment _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk)
   )

-- cata
{-# NOINLINE sem_RecordExpressionBinding #-}
sem_RecordExpressionBinding :: RecordExpressionBinding  -> T_RecordExpressionBinding 
sem_RecordExpressionBinding ( RecordExpressionBinding_RecordExpressionBinding range_ name_ expression_ ) = sem_RecordExpressionBinding_RecordExpressionBinding ( sem_Range range_ ) ( sem_Name name_ ) ( sem_Expression expression_ )

-- semantic domain
newtype T_RecordExpressionBinding  = T_RecordExpressionBinding {
                                                               attach_T_RecordExpressionBinding :: Identity (T_RecordExpressionBinding_s137 )
                                                               }
newtype T_RecordExpressionBinding_s137  = C_RecordExpressionBinding_s137 {
                                                                         inv_RecordExpressionBinding_s137 :: (T_RecordExpressionBinding_v136 )
                                                                         }
data T_RecordExpressionBinding_s138  = C_RecordExpressionBinding_s138
type T_RecordExpressionBinding_v136  = (T_RecordExpressionBinding_vIn136 ) -> (T_RecordExpressionBinding_vOut136 )
data T_RecordExpressionBinding_vIn136  = T_RecordExpressionBinding_vIn136 (M.Map NameWithRange TpScheme) ([[Name]]) ([PredicateWithSource]) (ClassEnvironment) (ClassMemberEnvironment) (Maybe [(Name, TpScheme)]) (ClassNameEnvironment) (Maybe (Name, Names)) (M.Map Name TpScheme) (TypeErrors) (Warnings) (Int) (Maybe Predicate) (Maybe Predicate) (Int) (DictionaryEnvironment) (ImportEnvironment) (Maybe Name) ([(Name, TpScheme)]) (Maybe Name) (Names) (OrderedTypeSynonyms) ([Warning]) (Predicates) (FixpointSubstitution) (M.Map Int (Scheme Predicates)) (Int) (Maybe [(Name, Tp)])
data T_RecordExpressionBinding_vOut136  = T_RecordExpressionBinding_vOut136 (TypeErrors) ([(Name, Instance)]) (Warnings) (Int) (DictionaryEnvironment) ([Warning]) (RecordExpressionBinding) (Names) (Int)
{-# NOINLINE sem_RecordExpressionBinding_RecordExpressionBinding #-}
sem_RecordExpressionBinding_RecordExpressionBinding :: T_Range  -> T_Name  -> T_Expression  -> T_RecordExpressionBinding 
sem_RecordExpressionBinding_RecordExpressionBinding arg_range_ arg_name_ arg_expression_ = T_RecordExpressionBinding (return st137) where
   {-# NOINLINE st137 #-}
   !st137 = let
      v136 :: T_RecordExpressionBinding_v136 
      v136 = \ !(T_RecordExpressionBinding_vIn136 _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImoduleName _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeschemeMap _lhsIuniqueChunk _lhsIvariableMapping) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _nameX113 = Control.Monad.Identity.runIdentity (attach_T_Name (arg_name_))
         _expressionX41 = Control.Monad.Identity.runIdentity (attach_T_Expression (arg_expression_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_Name_vOut112 _nameIself) = inv_Name_s113 _nameX113 (T_Name_vIn112 )
         (T_Expression_vOut40 _expressionIassumptions _expressionIbeta _expressionIbetaUnique _expressionIcollectErrors _expressionIcollectInstances _expressionIcollectWarnings _expressionIconstraints _expressionIcounter _expressionIdictionaryEnvironment _expressionIinfoTree _expressionImatchIO _expressionImatches _expressionIpatternMatchWarnings _expressionIself _expressionIunboundNames _expressionIuniqueChunk _expressionIuniqueSecondRound) = inv_Expression_s41 _expressionX41 (T_Expression_vIn40 _expressionOallPatterns _expressionOallTypeSchemes _expressionOambiguousConflicts _expressionOavailablePredicates _expressionObetaUnique _expressionOclassEnvironment _expressionOclassMemberEnv _expressionOclassMemberTypeSchemes _expressionOclassNamesEnv _expressionOclassPredicate _expressionOclassTypeSchemes _expressionOcollectErrors _expressionOcollectWarnings _expressionOcounter _expressionOcurClassPred _expressionOcurPred _expressionOcurrentChunk _expressionOdictionaryEnvironment _expressionOimportEnvironment _expressionOinstanceName _expressionOinstanceTypes _expressionOmatchIO _expressionOmoduleName _expressionOmonos _expressionOnamesInScope _expressionOorderedTypeSynonyms _expressionOparentTree _expressionOpatternMatchWarnings _expressionOrequiredPredicates _expressionOsubstitution _expressionOtryPatterns _expressionOtypeConstructors _expressionOtypeschemeMap _expressionOuniqueChunk _expressionOuniqueSecondRound _expressionOvariableMapping)
         (_allPatterns,_tryPatterns,_matchIO,_uniqueSecondRound) = rule4432  ()
         (_monos,_constructorenv,_betaUnique,_miscerrors,_warnings,_kindErrors,_valueConstructors,_allValueConstructors,_typeConstructors,_typeConstructorsWithDefined,_allTypeConstructors,_importEnvironment,_ambiguousValueConstructors,_ambiguousTypeConstructors) = rule4433  ()
         _parentTree = rule4434  ()
         _lhsOcollectInstances :: [(Name, Instance)]
         _lhsOcollectInstances = rule4435 _expressionIcollectInstances
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule4436 _expressionIunboundNames
         _self = rule4437 _expressionIself _nameIself _rangeIself
         _lhsOself :: RecordExpressionBinding
         _lhsOself = rule4438 _self
         _lhsOcollectErrors :: TypeErrors
         _lhsOcollectErrors = rule4439 _expressionIcollectErrors
         _lhsOcollectWarnings :: Warnings
         _lhsOcollectWarnings = rule4440 _expressionIcollectWarnings
         _lhsOcounter :: Int
         _lhsOcounter = rule4441 _expressionIcounter
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule4442 _expressionIdictionaryEnvironment
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule4443 _expressionIpatternMatchWarnings
         _lhsOuniqueChunk :: Int
         _lhsOuniqueChunk = rule4444 _expressionIuniqueChunk
         _expressionOallPatterns = rule4445 _allPatterns
         _expressionOallTypeSchemes = rule4446 _lhsIallTypeSchemes
         _expressionOambiguousConflicts = rule4447 _lhsIambiguousConflicts
         _expressionOavailablePredicates = rule4448 _lhsIavailablePredicates
         _expressionObetaUnique = rule4449 _betaUnique
         _expressionOclassEnvironment = rule4450 _lhsIclassEnvironment
         _expressionOclassMemberEnv = rule4451 _lhsIclassMemberEnv
         _expressionOclassMemberTypeSchemes = rule4452 _lhsIclassMemberTypeSchemes
         _expressionOclassNamesEnv = rule4453 _lhsIclassNamesEnv
         _expressionOclassPredicate = rule4454 _lhsIclassPredicate
         _expressionOclassTypeSchemes = rule4455 _lhsIclassTypeSchemes
         _expressionOcollectErrors = rule4456 _lhsIcollectErrors
         _expressionOcollectWarnings = rule4457 _lhsIcollectWarnings
         _expressionOcounter = rule4458 _lhsIcounter
         _expressionOcurClassPred = rule4459 _lhsIcurClassPred
         _expressionOcurPred = rule4460 _lhsIcurPred
         _expressionOcurrentChunk = rule4461 _lhsIcurrentChunk
         _expressionOdictionaryEnvironment = rule4462 _lhsIdictionaryEnvironment
         _expressionOimportEnvironment = rule4463 _importEnvironment
         _expressionOinstanceName = rule4464 _lhsIinstanceName
         _expressionOinstanceTypes = rule4465 _lhsIinstanceTypes
         _expressionOmatchIO = rule4466 _matchIO
         _expressionOmoduleName = rule4467 _lhsImoduleName
         _expressionOmonos = rule4468 _monos
         _expressionOnamesInScope = rule4469 _lhsInamesInScope
         _expressionOorderedTypeSynonyms = rule4470 _lhsIorderedTypeSynonyms
         _expressionOparentTree = rule4471 _parentTree
         _expressionOpatternMatchWarnings = rule4472 _lhsIpatternMatchWarnings
         _expressionOrequiredPredicates = rule4473 _lhsIrequiredPredicates
         _expressionOsubstitution = rule4474 _lhsIsubstitution
         _expressionOtryPatterns = rule4475 _tryPatterns
         _expressionOtypeConstructors = rule4476 _typeConstructors
         _expressionOtypeschemeMap = rule4477 _lhsItypeschemeMap
         _expressionOuniqueChunk = rule4478 _lhsIuniqueChunk
         _expressionOuniqueSecondRound = rule4479 _uniqueSecondRound
         _expressionOvariableMapping = rule4480 _lhsIvariableMapping
         !__result_ = T_RecordExpressionBinding_vOut136 _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOcounter _lhsOdictionaryEnvironment _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk
         in __result_ )
     in C_RecordExpressionBinding_s137 v136
   {-# INLINE rule4432 #-}
   rule4432 = \  (_ :: ()) ->
                                                                     internalError "TS_PatternMatching.ag" "n/a" "RecordExpressionBinding is not supported"
   {-# INLINE rule4433 #-}
   rule4433 = \  (_ :: ()) ->
                                                                                                                internalError "PartialSyntax.ag" "n/a" "RecordExpressionBinding.RecordExpressionBinding"
   {-# INLINE rule4434 #-}
   rule4434 = \  (_ :: ()) ->
                                                                            globalInfoError
   {-# INLINE rule4435 #-}
   rule4435 = \ ((_expressionIcollectInstances) :: [(Name, Instance)]) ->
     _expressionIcollectInstances
   {-# INLINE rule4436 #-}
   rule4436 = \ ((_expressionIunboundNames) :: Names) ->
     _expressionIunboundNames
   {-# INLINE rule4437 #-}
   rule4437 = \ ((_expressionIself) :: Expression) ((_nameIself) :: Name) ((_rangeIself) :: Range) ->
     RecordExpressionBinding_RecordExpressionBinding _rangeIself _nameIself _expressionIself
   {-# INLINE rule4438 #-}
   rule4438 = \ _self ->
     _self
   {-# INLINE rule4439 #-}
   rule4439 = \ ((_expressionIcollectErrors) :: TypeErrors) ->
     _expressionIcollectErrors
   {-# INLINE rule4440 #-}
   rule4440 = \ ((_expressionIcollectWarnings) :: Warnings) ->
     _expressionIcollectWarnings
   {-# INLINE rule4441 #-}
   rule4441 = \ ((_expressionIcounter) :: Int) ->
     _expressionIcounter
   {-# INLINE rule4442 #-}
   rule4442 = \ ((_expressionIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _expressionIdictionaryEnvironment
   {-# INLINE rule4443 #-}
   rule4443 = \ ((_expressionIpatternMatchWarnings) :: [Warning]) ->
     _expressionIpatternMatchWarnings
   {-# INLINE rule4444 #-}
   rule4444 = \ ((_expressionIuniqueChunk) :: Int) ->
     _expressionIuniqueChunk
   {-# INLINE rule4445 #-}
   rule4445 = \ _allPatterns ->
     _allPatterns
   {-# INLINE rule4446 #-}
   rule4446 = \ ((_lhsIallTypeSchemes) :: M.Map NameWithRange TpScheme) ->
     _lhsIallTypeSchemes
   {-# INLINE rule4447 #-}
   rule4447 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule4448 #-}
   rule4448 = \ ((_lhsIavailablePredicates) :: [PredicateWithSource]) ->
     _lhsIavailablePredicates
   {-# INLINE rule4449 #-}
   rule4449 = \ _betaUnique ->
     _betaUnique
   {-# INLINE rule4450 #-}
   rule4450 = \ ((_lhsIclassEnvironment) :: ClassEnvironment) ->
     _lhsIclassEnvironment
   {-# INLINE rule4451 #-}
   rule4451 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule4452 #-}
   rule4452 = \ ((_lhsIclassMemberTypeSchemes) :: Maybe [(Name, TpScheme)]) ->
     _lhsIclassMemberTypeSchemes
   {-# INLINE rule4453 #-}
   rule4453 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule4454 #-}
   rule4454 = \ ((_lhsIclassPredicate) :: Maybe (Name, Names)) ->
     _lhsIclassPredicate
   {-# INLINE rule4455 #-}
   rule4455 = \ ((_lhsIclassTypeSchemes) :: M.Map Name TpScheme) ->
     _lhsIclassTypeSchemes
   {-# INLINE rule4456 #-}
   rule4456 = \ ((_lhsIcollectErrors) :: TypeErrors) ->
     _lhsIcollectErrors
   {-# INLINE rule4457 #-}
   rule4457 = \ ((_lhsIcollectWarnings) :: Warnings) ->
     _lhsIcollectWarnings
   {-# INLINE rule4458 #-}
   rule4458 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule4459 #-}
   rule4459 = \ ((_lhsIcurClassPred) :: Maybe Predicate) ->
     _lhsIcurClassPred
   {-# INLINE rule4460 #-}
   rule4460 = \ ((_lhsIcurPred) :: Maybe Predicate) ->
     _lhsIcurPred
   {-# INLINE rule4461 #-}
   rule4461 = \ ((_lhsIcurrentChunk) :: Int) ->
     _lhsIcurrentChunk
   {-# INLINE rule4462 #-}
   rule4462 = \ ((_lhsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _lhsIdictionaryEnvironment
   {-# INLINE rule4463 #-}
   rule4463 = \ _importEnvironment ->
     _importEnvironment
   {-# INLINE rule4464 #-}
   rule4464 = \ ((_lhsIinstanceName) :: Maybe Name) ->
     _lhsIinstanceName
   {-# INLINE rule4465 #-}
   rule4465 = \ ((_lhsIinstanceTypes) :: [(Name, TpScheme)]) ->
     _lhsIinstanceTypes
   {-# INLINE rule4466 #-}
   rule4466 = \ _matchIO ->
     _matchIO
   {-# INLINE rule4467 #-}
   rule4467 = \ ((_lhsImoduleName) :: Maybe Name) ->
     _lhsImoduleName
   {-# INLINE rule4468 #-}
   rule4468 = \ _monos ->
     _monos
   {-# INLINE rule4469 #-}
   rule4469 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule4470 #-}
   rule4470 = \ ((_lhsIorderedTypeSynonyms) :: OrderedTypeSynonyms) ->
     _lhsIorderedTypeSynonyms
   {-# INLINE rule4471 #-}
   rule4471 = \ _parentTree ->
     _parentTree
   {-# INLINE rule4472 #-}
   rule4472 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule4473 #-}
   rule4473 = \ ((_lhsIrequiredPredicates) :: Predicates) ->
     _lhsIrequiredPredicates
   {-# INLINE rule4474 #-}
   rule4474 = \ ((_lhsIsubstitution) :: FixpointSubstitution) ->
     _lhsIsubstitution
   {-# INLINE rule4475 #-}
   rule4475 = \ _tryPatterns ->
     _tryPatterns
   {-# INLINE rule4476 #-}
   rule4476 = \ _typeConstructors ->
     _typeConstructors
   {-# INLINE rule4477 #-}
   rule4477 = \ ((_lhsItypeschemeMap) :: M.Map Int (Scheme Predicates)) ->
     _lhsItypeschemeMap
   {-# INLINE rule4478 #-}
   rule4478 = \ ((_lhsIuniqueChunk) :: Int) ->
     _lhsIuniqueChunk
   {-# INLINE rule4479 #-}
   rule4479 = \ _uniqueSecondRound ->
     _uniqueSecondRound
   {-# INLINE rule4480 #-}
   rule4480 = \ ((_lhsIvariableMapping) :: Maybe [(Name, Tp)]) ->
     _lhsIvariableMapping

-- RecordExpressionBindings ------------------------------------
-- wrapper
data Inh_RecordExpressionBindings  = Inh_RecordExpressionBindings { allTypeSchemes_Inh_RecordExpressionBindings :: !(M.Map NameWithRange TpScheme), ambiguousConflicts_Inh_RecordExpressionBindings :: !([[Name]]), availablePredicates_Inh_RecordExpressionBindings :: !([PredicateWithSource]), classEnvironment_Inh_RecordExpressionBindings :: !(ClassEnvironment), classMemberEnv_Inh_RecordExpressionBindings :: !(ClassMemberEnvironment), classMemberTypeSchemes_Inh_RecordExpressionBindings :: !(Maybe [(Name, TpScheme)]), classNamesEnv_Inh_RecordExpressionBindings :: !(ClassNameEnvironment), classPredicate_Inh_RecordExpressionBindings :: !(Maybe (Name, Names)), classTypeSchemes_Inh_RecordExpressionBindings :: !(M.Map Name TpScheme), collectErrors_Inh_RecordExpressionBindings :: !(TypeErrors), collectWarnings_Inh_RecordExpressionBindings :: !(Warnings), counter_Inh_RecordExpressionBindings :: !(Int), curClassPred_Inh_RecordExpressionBindings :: !(Maybe Predicate), curPred_Inh_RecordExpressionBindings :: !(Maybe Predicate), currentChunk_Inh_RecordExpressionBindings :: !(Int), dictionaryEnvironment_Inh_RecordExpressionBindings :: !(DictionaryEnvironment), importEnvironment_Inh_RecordExpressionBindings :: !(ImportEnvironment), instanceName_Inh_RecordExpressionBindings :: !(Maybe Name), instanceTypes_Inh_RecordExpressionBindings :: !([(Name, TpScheme)]), moduleName_Inh_RecordExpressionBindings :: !(Maybe Name), namesInScope_Inh_RecordExpressionBindings :: !(Names), orderedTypeSynonyms_Inh_RecordExpressionBindings :: !(OrderedTypeSynonyms), patternMatchWarnings_Inh_RecordExpressionBindings :: !([Warning]), requiredPredicates_Inh_RecordExpressionBindings :: !(Predicates), substitution_Inh_RecordExpressionBindings :: !(FixpointSubstitution), typeschemeMap_Inh_RecordExpressionBindings :: !(M.Map Int (Scheme Predicates)), uniqueChunk_Inh_RecordExpressionBindings :: !(Int), variableMapping_Inh_RecordExpressionBindings :: !(Maybe [(Name, Tp)]) }
data Syn_RecordExpressionBindings  = Syn_RecordExpressionBindings { collectErrors_Syn_RecordExpressionBindings :: !(TypeErrors), collectInstances_Syn_RecordExpressionBindings :: !([(Name, Instance)]), collectWarnings_Syn_RecordExpressionBindings :: !(Warnings), counter_Syn_RecordExpressionBindings :: !(Int), dictionaryEnvironment_Syn_RecordExpressionBindings :: !(DictionaryEnvironment), patternMatchWarnings_Syn_RecordExpressionBindings :: !([Warning]), self_Syn_RecordExpressionBindings :: !(RecordExpressionBindings), unboundNames_Syn_RecordExpressionBindings :: !(Names), uniqueChunk_Syn_RecordExpressionBindings :: !(Int) }
{-# INLINABLE wrap_RecordExpressionBindings #-}
wrap_RecordExpressionBindings :: T_RecordExpressionBindings  -> Inh_RecordExpressionBindings  -> (Syn_RecordExpressionBindings )
wrap_RecordExpressionBindings !(T_RecordExpressionBindings act) !(Inh_RecordExpressionBindings _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImoduleName _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeschemeMap _lhsIuniqueChunk _lhsIvariableMapping) =
   Control.Monad.Identity.runIdentity (
     do !sem <- act
        let arg139 = T_RecordExpressionBindings_vIn139 _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImoduleName _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeschemeMap _lhsIuniqueChunk _lhsIvariableMapping
        !(T_RecordExpressionBindings_vOut139 _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOcounter _lhsOdictionaryEnvironment _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk) <- return (inv_RecordExpressionBindings_s140 sem arg139)
        return (Syn_RecordExpressionBindings _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOcounter _lhsOdictionaryEnvironment _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk)
   )

-- cata
{-# NOINLINE sem_RecordExpressionBindings #-}
sem_RecordExpressionBindings :: RecordExpressionBindings  -> T_RecordExpressionBindings 
sem_RecordExpressionBindings list = Prelude.foldr sem_RecordExpressionBindings_Cons sem_RecordExpressionBindings_Nil (Prelude.map sem_RecordExpressionBinding list)

-- semantic domain
newtype T_RecordExpressionBindings  = T_RecordExpressionBindings {
                                                                 attach_T_RecordExpressionBindings :: Identity (T_RecordExpressionBindings_s140 )
                                                                 }
newtype T_RecordExpressionBindings_s140  = C_RecordExpressionBindings_s140 {
                                                                           inv_RecordExpressionBindings_s140 :: (T_RecordExpressionBindings_v139 )
                                                                           }
data T_RecordExpressionBindings_s141  = C_RecordExpressionBindings_s141
type T_RecordExpressionBindings_v139  = (T_RecordExpressionBindings_vIn139 ) -> (T_RecordExpressionBindings_vOut139 )
data T_RecordExpressionBindings_vIn139  = T_RecordExpressionBindings_vIn139 (M.Map NameWithRange TpScheme) ([[Name]]) ([PredicateWithSource]) (ClassEnvironment) (ClassMemberEnvironment) (Maybe [(Name, TpScheme)]) (ClassNameEnvironment) (Maybe (Name, Names)) (M.Map Name TpScheme) (TypeErrors) (Warnings) (Int) (Maybe Predicate) (Maybe Predicate) (Int) (DictionaryEnvironment) (ImportEnvironment) (Maybe Name) ([(Name, TpScheme)]) (Maybe Name) (Names) (OrderedTypeSynonyms) ([Warning]) (Predicates) (FixpointSubstitution) (M.Map Int (Scheme Predicates)) (Int) (Maybe [(Name, Tp)])
data T_RecordExpressionBindings_vOut139  = T_RecordExpressionBindings_vOut139 (TypeErrors) ([(Name, Instance)]) (Warnings) (Int) (DictionaryEnvironment) ([Warning]) (RecordExpressionBindings) (Names) (Int)
{-# NOINLINE sem_RecordExpressionBindings_Cons #-}
sem_RecordExpressionBindings_Cons :: T_RecordExpressionBinding  -> T_RecordExpressionBindings  -> T_RecordExpressionBindings 
sem_RecordExpressionBindings_Cons arg_hd_ arg_tl_ = T_RecordExpressionBindings (return st140) where
   {-# NOINLINE st140 #-}
   !st140 = let
      v139 :: T_RecordExpressionBindings_v139 
      v139 = \ !(T_RecordExpressionBindings_vIn139 _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImoduleName _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeschemeMap _lhsIuniqueChunk _lhsIvariableMapping) -> ( let
         _hdX137 = Control.Monad.Identity.runIdentity (attach_T_RecordExpressionBinding (arg_hd_))
         _tlX140 = Control.Monad.Identity.runIdentity (attach_T_RecordExpressionBindings (arg_tl_))
         (T_RecordExpressionBinding_vOut136 _hdIcollectErrors _hdIcollectInstances _hdIcollectWarnings _hdIcounter _hdIdictionaryEnvironment _hdIpatternMatchWarnings _hdIself _hdIunboundNames _hdIuniqueChunk) = inv_RecordExpressionBinding_s137 _hdX137 (T_RecordExpressionBinding_vIn136 _hdOallTypeSchemes _hdOambiguousConflicts _hdOavailablePredicates _hdOclassEnvironment _hdOclassMemberEnv _hdOclassMemberTypeSchemes _hdOclassNamesEnv _hdOclassPredicate _hdOclassTypeSchemes _hdOcollectErrors _hdOcollectWarnings _hdOcounter _hdOcurClassPred _hdOcurPred _hdOcurrentChunk _hdOdictionaryEnvironment _hdOimportEnvironment _hdOinstanceName _hdOinstanceTypes _hdOmoduleName _hdOnamesInScope _hdOorderedTypeSynonyms _hdOpatternMatchWarnings _hdOrequiredPredicates _hdOsubstitution _hdOtypeschemeMap _hdOuniqueChunk _hdOvariableMapping)
         (T_RecordExpressionBindings_vOut139 _tlIcollectErrors _tlIcollectInstances _tlIcollectWarnings _tlIcounter _tlIdictionaryEnvironment _tlIpatternMatchWarnings _tlIself _tlIunboundNames _tlIuniqueChunk) = inv_RecordExpressionBindings_s140 _tlX140 (T_RecordExpressionBindings_vIn139 _tlOallTypeSchemes _tlOambiguousConflicts _tlOavailablePredicates _tlOclassEnvironment _tlOclassMemberEnv _tlOclassMemberTypeSchemes _tlOclassNamesEnv _tlOclassPredicate _tlOclassTypeSchemes _tlOcollectErrors _tlOcollectWarnings _tlOcounter _tlOcurClassPred _tlOcurPred _tlOcurrentChunk _tlOdictionaryEnvironment _tlOimportEnvironment _tlOinstanceName _tlOinstanceTypes _tlOmoduleName _tlOnamesInScope _tlOorderedTypeSynonyms _tlOpatternMatchWarnings _tlOrequiredPredicates _tlOsubstitution _tlOtypeschemeMap _tlOuniqueChunk _tlOvariableMapping)
         _lhsOcollectInstances :: [(Name, Instance)]
         _lhsOcollectInstances = rule4481 _hdIcollectInstances _tlIcollectInstances
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule4482 _hdIunboundNames _tlIunboundNames
         _self = rule4483 _hdIself _tlIself
         _lhsOself :: RecordExpressionBindings
         _lhsOself = rule4484 _self
         _lhsOcollectErrors :: TypeErrors
         _lhsOcollectErrors = rule4485 _tlIcollectErrors
         _lhsOcollectWarnings :: Warnings
         _lhsOcollectWarnings = rule4486 _tlIcollectWarnings
         _lhsOcounter :: Int
         _lhsOcounter = rule4487 _tlIcounter
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule4488 _tlIdictionaryEnvironment
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule4489 _tlIpatternMatchWarnings
         _lhsOuniqueChunk :: Int
         _lhsOuniqueChunk = rule4490 _tlIuniqueChunk
         _hdOallTypeSchemes = rule4491 _lhsIallTypeSchemes
         _hdOambiguousConflicts = rule4492 _lhsIambiguousConflicts
         _hdOavailablePredicates = rule4493 _lhsIavailablePredicates
         _hdOclassEnvironment = rule4494 _lhsIclassEnvironment
         _hdOclassMemberEnv = rule4495 _lhsIclassMemberEnv
         _hdOclassMemberTypeSchemes = rule4496 _lhsIclassMemberTypeSchemes
         _hdOclassNamesEnv = rule4497 _lhsIclassNamesEnv
         _hdOclassPredicate = rule4498 _lhsIclassPredicate
         _hdOclassTypeSchemes = rule4499 _lhsIclassTypeSchemes
         _hdOcollectErrors = rule4500 _lhsIcollectErrors
         _hdOcollectWarnings = rule4501 _lhsIcollectWarnings
         _hdOcounter = rule4502 _lhsIcounter
         _hdOcurClassPred = rule4503 _lhsIcurClassPred
         _hdOcurPred = rule4504 _lhsIcurPred
         _hdOcurrentChunk = rule4505 _lhsIcurrentChunk
         _hdOdictionaryEnvironment = rule4506 _lhsIdictionaryEnvironment
         _hdOimportEnvironment = rule4507 _lhsIimportEnvironment
         _hdOinstanceName = rule4508 _lhsIinstanceName
         _hdOinstanceTypes = rule4509 _lhsIinstanceTypes
         _hdOmoduleName = rule4510 _lhsImoduleName
         _hdOnamesInScope = rule4511 _lhsInamesInScope
         _hdOorderedTypeSynonyms = rule4512 _lhsIorderedTypeSynonyms
         _hdOpatternMatchWarnings = rule4513 _lhsIpatternMatchWarnings
         _hdOrequiredPredicates = rule4514 _lhsIrequiredPredicates
         _hdOsubstitution = rule4515 _lhsIsubstitution
         _hdOtypeschemeMap = rule4516 _lhsItypeschemeMap
         _hdOuniqueChunk = rule4517 _lhsIuniqueChunk
         _hdOvariableMapping = rule4518 _lhsIvariableMapping
         _tlOallTypeSchemes = rule4519 _lhsIallTypeSchemes
         _tlOambiguousConflicts = rule4520 _lhsIambiguousConflicts
         _tlOavailablePredicates = rule4521 _lhsIavailablePredicates
         _tlOclassEnvironment = rule4522 _lhsIclassEnvironment
         _tlOclassMemberEnv = rule4523 _lhsIclassMemberEnv
         _tlOclassMemberTypeSchemes = rule4524 _lhsIclassMemberTypeSchemes
         _tlOclassNamesEnv = rule4525 _lhsIclassNamesEnv
         _tlOclassPredicate = rule4526 _lhsIclassPredicate
         _tlOclassTypeSchemes = rule4527 _lhsIclassTypeSchemes
         _tlOcollectErrors = rule4528 _hdIcollectErrors
         _tlOcollectWarnings = rule4529 _hdIcollectWarnings
         _tlOcounter = rule4530 _hdIcounter
         _tlOcurClassPred = rule4531 _lhsIcurClassPred
         _tlOcurPred = rule4532 _lhsIcurPred
         _tlOcurrentChunk = rule4533 _lhsIcurrentChunk
         _tlOdictionaryEnvironment = rule4534 _hdIdictionaryEnvironment
         _tlOimportEnvironment = rule4535 _lhsIimportEnvironment
         _tlOinstanceName = rule4536 _lhsIinstanceName
         _tlOinstanceTypes = rule4537 _lhsIinstanceTypes
         _tlOmoduleName = rule4538 _lhsImoduleName
         _tlOnamesInScope = rule4539 _lhsInamesInScope
         _tlOorderedTypeSynonyms = rule4540 _lhsIorderedTypeSynonyms
         _tlOpatternMatchWarnings = rule4541 _hdIpatternMatchWarnings
         _tlOrequiredPredicates = rule4542 _lhsIrequiredPredicates
         _tlOsubstitution = rule4543 _lhsIsubstitution
         _tlOtypeschemeMap = rule4544 _lhsItypeschemeMap
         _tlOuniqueChunk = rule4545 _hdIuniqueChunk
         _tlOvariableMapping = rule4546 _lhsIvariableMapping
         !__result_ = T_RecordExpressionBindings_vOut139 _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOcounter _lhsOdictionaryEnvironment _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk
         in __result_ )
     in C_RecordExpressionBindings_s140 v139
   {-# INLINE rule4481 #-}
   rule4481 = \ ((_hdIcollectInstances) :: [(Name, Instance)]) ((_tlIcollectInstances) :: [(Name, Instance)]) ->
     _hdIcollectInstances  ++  _tlIcollectInstances
   {-# INLINE rule4482 #-}
   rule4482 = \ ((_hdIunboundNames) :: Names) ((_tlIunboundNames) :: Names) ->
     ((++) _hdIunboundNames _tlIunboundNames)
   {-# INLINE rule4483 #-}
   rule4483 = \ ((_hdIself) :: RecordExpressionBinding) ((_tlIself) :: RecordExpressionBindings) ->
     (:) _hdIself _tlIself
   {-# INLINE rule4484 #-}
   rule4484 = \ _self ->
     _self
   {-# INLINE rule4485 #-}
   rule4485 = \ ((_tlIcollectErrors) :: TypeErrors) ->
     _tlIcollectErrors
   {-# INLINE rule4486 #-}
   rule4486 = \ ((_tlIcollectWarnings) :: Warnings) ->
     _tlIcollectWarnings
   {-# INLINE rule4487 #-}
   rule4487 = \ ((_tlIcounter) :: Int) ->
     _tlIcounter
   {-# INLINE rule4488 #-}
   rule4488 = \ ((_tlIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _tlIdictionaryEnvironment
   {-# INLINE rule4489 #-}
   rule4489 = \ ((_tlIpatternMatchWarnings) :: [Warning]) ->
     _tlIpatternMatchWarnings
   {-# INLINE rule4490 #-}
   rule4490 = \ ((_tlIuniqueChunk) :: Int) ->
     _tlIuniqueChunk
   {-# INLINE rule4491 #-}
   rule4491 = \ ((_lhsIallTypeSchemes) :: M.Map NameWithRange TpScheme) ->
     _lhsIallTypeSchemes
   {-# INLINE rule4492 #-}
   rule4492 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule4493 #-}
   rule4493 = \ ((_lhsIavailablePredicates) :: [PredicateWithSource]) ->
     _lhsIavailablePredicates
   {-# INLINE rule4494 #-}
   rule4494 = \ ((_lhsIclassEnvironment) :: ClassEnvironment) ->
     _lhsIclassEnvironment
   {-# INLINE rule4495 #-}
   rule4495 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule4496 #-}
   rule4496 = \ ((_lhsIclassMemberTypeSchemes) :: Maybe [(Name, TpScheme)]) ->
     _lhsIclassMemberTypeSchemes
   {-# INLINE rule4497 #-}
   rule4497 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule4498 #-}
   rule4498 = \ ((_lhsIclassPredicate) :: Maybe (Name, Names)) ->
     _lhsIclassPredicate
   {-# INLINE rule4499 #-}
   rule4499 = \ ((_lhsIclassTypeSchemes) :: M.Map Name TpScheme) ->
     _lhsIclassTypeSchemes
   {-# INLINE rule4500 #-}
   rule4500 = \ ((_lhsIcollectErrors) :: TypeErrors) ->
     _lhsIcollectErrors
   {-# INLINE rule4501 #-}
   rule4501 = \ ((_lhsIcollectWarnings) :: Warnings) ->
     _lhsIcollectWarnings
   {-# INLINE rule4502 #-}
   rule4502 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule4503 #-}
   rule4503 = \ ((_lhsIcurClassPred) :: Maybe Predicate) ->
     _lhsIcurClassPred
   {-# INLINE rule4504 #-}
   rule4504 = \ ((_lhsIcurPred) :: Maybe Predicate) ->
     _lhsIcurPred
   {-# INLINE rule4505 #-}
   rule4505 = \ ((_lhsIcurrentChunk) :: Int) ->
     _lhsIcurrentChunk
   {-# INLINE rule4506 #-}
   rule4506 = \ ((_lhsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _lhsIdictionaryEnvironment
   {-# INLINE rule4507 #-}
   rule4507 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule4508 #-}
   rule4508 = \ ((_lhsIinstanceName) :: Maybe Name) ->
     _lhsIinstanceName
   {-# INLINE rule4509 #-}
   rule4509 = \ ((_lhsIinstanceTypes) :: [(Name, TpScheme)]) ->
     _lhsIinstanceTypes
   {-# INLINE rule4510 #-}
   rule4510 = \ ((_lhsImoduleName) :: Maybe Name) ->
     _lhsImoduleName
   {-# INLINE rule4511 #-}
   rule4511 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule4512 #-}
   rule4512 = \ ((_lhsIorderedTypeSynonyms) :: OrderedTypeSynonyms) ->
     _lhsIorderedTypeSynonyms
   {-# INLINE rule4513 #-}
   rule4513 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule4514 #-}
   rule4514 = \ ((_lhsIrequiredPredicates) :: Predicates) ->
     _lhsIrequiredPredicates
   {-# INLINE rule4515 #-}
   rule4515 = \ ((_lhsIsubstitution) :: FixpointSubstitution) ->
     _lhsIsubstitution
   {-# INLINE rule4516 #-}
   rule4516 = \ ((_lhsItypeschemeMap) :: M.Map Int (Scheme Predicates)) ->
     _lhsItypeschemeMap
   {-# INLINE rule4517 #-}
   rule4517 = \ ((_lhsIuniqueChunk) :: Int) ->
     _lhsIuniqueChunk
   {-# INLINE rule4518 #-}
   rule4518 = \ ((_lhsIvariableMapping) :: Maybe [(Name, Tp)]) ->
     _lhsIvariableMapping
   {-# INLINE rule4519 #-}
   rule4519 = \ ((_lhsIallTypeSchemes) :: M.Map NameWithRange TpScheme) ->
     _lhsIallTypeSchemes
   {-# INLINE rule4520 #-}
   rule4520 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule4521 #-}
   rule4521 = \ ((_lhsIavailablePredicates) :: [PredicateWithSource]) ->
     _lhsIavailablePredicates
   {-# INLINE rule4522 #-}
   rule4522 = \ ((_lhsIclassEnvironment) :: ClassEnvironment) ->
     _lhsIclassEnvironment
   {-# INLINE rule4523 #-}
   rule4523 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule4524 #-}
   rule4524 = \ ((_lhsIclassMemberTypeSchemes) :: Maybe [(Name, TpScheme)]) ->
     _lhsIclassMemberTypeSchemes
   {-# INLINE rule4525 #-}
   rule4525 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule4526 #-}
   rule4526 = \ ((_lhsIclassPredicate) :: Maybe (Name, Names)) ->
     _lhsIclassPredicate
   {-# INLINE rule4527 #-}
   rule4527 = \ ((_lhsIclassTypeSchemes) :: M.Map Name TpScheme) ->
     _lhsIclassTypeSchemes
   {-# INLINE rule4528 #-}
   rule4528 = \ ((_hdIcollectErrors) :: TypeErrors) ->
     _hdIcollectErrors
   {-# INLINE rule4529 #-}
   rule4529 = \ ((_hdIcollectWarnings) :: Warnings) ->
     _hdIcollectWarnings
   {-# INLINE rule4530 #-}
   rule4530 = \ ((_hdIcounter) :: Int) ->
     _hdIcounter
   {-# INLINE rule4531 #-}
   rule4531 = \ ((_lhsIcurClassPred) :: Maybe Predicate) ->
     _lhsIcurClassPred
   {-# INLINE rule4532 #-}
   rule4532 = \ ((_lhsIcurPred) :: Maybe Predicate) ->
     _lhsIcurPred
   {-# INLINE rule4533 #-}
   rule4533 = \ ((_lhsIcurrentChunk) :: Int) ->
     _lhsIcurrentChunk
   {-# INLINE rule4534 #-}
   rule4534 = \ ((_hdIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _hdIdictionaryEnvironment
   {-# INLINE rule4535 #-}
   rule4535 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule4536 #-}
   rule4536 = \ ((_lhsIinstanceName) :: Maybe Name) ->
     _lhsIinstanceName
   {-# INLINE rule4537 #-}
   rule4537 = \ ((_lhsIinstanceTypes) :: [(Name, TpScheme)]) ->
     _lhsIinstanceTypes
   {-# INLINE rule4538 #-}
   rule4538 = \ ((_lhsImoduleName) :: Maybe Name) ->
     _lhsImoduleName
   {-# INLINE rule4539 #-}
   rule4539 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule4540 #-}
   rule4540 = \ ((_lhsIorderedTypeSynonyms) :: OrderedTypeSynonyms) ->
     _lhsIorderedTypeSynonyms
   {-# INLINE rule4541 #-}
   rule4541 = \ ((_hdIpatternMatchWarnings) :: [Warning]) ->
     _hdIpatternMatchWarnings
   {-# INLINE rule4542 #-}
   rule4542 = \ ((_lhsIrequiredPredicates) :: Predicates) ->
     _lhsIrequiredPredicates
   {-# INLINE rule4543 #-}
   rule4543 = \ ((_lhsIsubstitution) :: FixpointSubstitution) ->
     _lhsIsubstitution
   {-# INLINE rule4544 #-}
   rule4544 = \ ((_lhsItypeschemeMap) :: M.Map Int (Scheme Predicates)) ->
     _lhsItypeschemeMap
   {-# INLINE rule4545 #-}
   rule4545 = \ ((_hdIuniqueChunk) :: Int) ->
     _hdIuniqueChunk
   {-# INLINE rule4546 #-}
   rule4546 = \ ((_lhsIvariableMapping) :: Maybe [(Name, Tp)]) ->
     _lhsIvariableMapping
{-# NOINLINE sem_RecordExpressionBindings_Nil #-}
sem_RecordExpressionBindings_Nil ::  T_RecordExpressionBindings 
sem_RecordExpressionBindings_Nil  = T_RecordExpressionBindings (return st140) where
   {-# NOINLINE st140 #-}
   !st140 = let
      v139 :: T_RecordExpressionBindings_v139 
      v139 = \ !(T_RecordExpressionBindings_vIn139 _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImoduleName _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeschemeMap _lhsIuniqueChunk _lhsIvariableMapping) -> ( let
         _lhsOcollectInstances :: [(Name, Instance)]
         _lhsOcollectInstances = rule4547  ()
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule4548  ()
         _self = rule4549  ()
         _lhsOself :: RecordExpressionBindings
         _lhsOself = rule4550 _self
         _lhsOcollectErrors :: TypeErrors
         _lhsOcollectErrors = rule4551 _lhsIcollectErrors
         _lhsOcollectWarnings :: Warnings
         _lhsOcollectWarnings = rule4552 _lhsIcollectWarnings
         _lhsOcounter :: Int
         _lhsOcounter = rule4553 _lhsIcounter
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule4554 _lhsIdictionaryEnvironment
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule4555 _lhsIpatternMatchWarnings
         _lhsOuniqueChunk :: Int
         _lhsOuniqueChunk = rule4556 _lhsIuniqueChunk
         !__result_ = T_RecordExpressionBindings_vOut139 _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOcounter _lhsOdictionaryEnvironment _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk
         in __result_ )
     in C_RecordExpressionBindings_s140 v139
   {-# INLINE rule4547 #-}
   rule4547 = \  (_ :: ()) ->
     []
   {-# INLINE rule4548 #-}
   rule4548 = \  (_ :: ()) ->
     []
   {-# INLINE rule4549 #-}
   rule4549 = \  (_ :: ()) ->
     []
   {-# INLINE rule4550 #-}
   rule4550 = \ _self ->
     _self
   {-# INLINE rule4551 #-}
   rule4551 = \ ((_lhsIcollectErrors) :: TypeErrors) ->
     _lhsIcollectErrors
   {-# INLINE rule4552 #-}
   rule4552 = \ ((_lhsIcollectWarnings) :: Warnings) ->
     _lhsIcollectWarnings
   {-# INLINE rule4553 #-}
   rule4553 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule4554 #-}
   rule4554 = \ ((_lhsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _lhsIdictionaryEnvironment
   {-# INLINE rule4555 #-}
   rule4555 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule4556 #-}
   rule4556 = \ ((_lhsIuniqueChunk) :: Int) ->
     _lhsIuniqueChunk

-- RecordPatternBinding ----------------------------------------
-- wrapper
data Inh_RecordPatternBinding  = Inh_RecordPatternBinding { ambiguousConflicts_Inh_RecordPatternBinding :: !([[Name]]), counter_Inh_RecordPatternBinding :: !(Int), namesInScope_Inh_RecordPatternBinding :: !(Names), patternMatchWarnings_Inh_RecordPatternBinding :: !([Warning]) }
data Syn_RecordPatternBinding  = Syn_RecordPatternBinding { counter_Syn_RecordPatternBinding :: !(Int), patternMatchWarnings_Syn_RecordPatternBinding :: !([Warning]), self_Syn_RecordPatternBinding :: !(RecordPatternBinding), unboundNames_Syn_RecordPatternBinding :: !(Names) }
{-# INLINABLE wrap_RecordPatternBinding #-}
wrap_RecordPatternBinding :: T_RecordPatternBinding  -> Inh_RecordPatternBinding  -> (Syn_RecordPatternBinding )
wrap_RecordPatternBinding !(T_RecordPatternBinding act) !(Inh_RecordPatternBinding _lhsIambiguousConflicts _lhsIcounter _lhsInamesInScope _lhsIpatternMatchWarnings) =
   Control.Monad.Identity.runIdentity (
     do !sem <- act
        let arg142 = T_RecordPatternBinding_vIn142 _lhsIambiguousConflicts _lhsIcounter _lhsInamesInScope _lhsIpatternMatchWarnings
        !(T_RecordPatternBinding_vOut142 _lhsOcounter _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames) <- return (inv_RecordPatternBinding_s143 sem arg142)
        return (Syn_RecordPatternBinding _lhsOcounter _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames)
   )

-- cata
{-# NOINLINE sem_RecordPatternBinding #-}
sem_RecordPatternBinding :: RecordPatternBinding  -> T_RecordPatternBinding 
sem_RecordPatternBinding ( RecordPatternBinding_RecordPatternBinding range_ name_ pattern_ ) = sem_RecordPatternBinding_RecordPatternBinding ( sem_Range range_ ) ( sem_Name name_ ) ( sem_Pattern pattern_ )

-- semantic domain
newtype T_RecordPatternBinding  = T_RecordPatternBinding {
                                                         attach_T_RecordPatternBinding :: Identity (T_RecordPatternBinding_s143 )
                                                         }
newtype T_RecordPatternBinding_s143  = C_RecordPatternBinding_s143 {
                                                                   inv_RecordPatternBinding_s143 :: (T_RecordPatternBinding_v142 )
                                                                   }
data T_RecordPatternBinding_s144  = C_RecordPatternBinding_s144
type T_RecordPatternBinding_v142  = (T_RecordPatternBinding_vIn142 ) -> (T_RecordPatternBinding_vOut142 )
data T_RecordPatternBinding_vIn142  = T_RecordPatternBinding_vIn142 ([[Name]]) (Int) (Names) ([Warning])
data T_RecordPatternBinding_vOut142  = T_RecordPatternBinding_vOut142 (Int) ([Warning]) (RecordPatternBinding) (Names)
{-# NOINLINE sem_RecordPatternBinding_RecordPatternBinding #-}
sem_RecordPatternBinding_RecordPatternBinding :: T_Range  -> T_Name  -> T_Pattern  -> T_RecordPatternBinding 
sem_RecordPatternBinding_RecordPatternBinding arg_range_ arg_name_ arg_pattern_ = T_RecordPatternBinding (return st143) where
   {-# NOINLINE st143 #-}
   !st143 = let
      v142 :: T_RecordPatternBinding_v142 
      v142 = \ !(T_RecordPatternBinding_vIn142 _lhsIambiguousConflicts _lhsIcounter _lhsInamesInScope _lhsIpatternMatchWarnings) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _nameX113 = Control.Monad.Identity.runIdentity (attach_T_Name (arg_name_))
         _patternX119 = Control.Monad.Identity.runIdentity (attach_T_Pattern (arg_pattern_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_Name_vOut112 _nameIself) = inv_Name_s113 _nameX113 (T_Name_vIn112 )
         (T_Pattern_vOut118 _patternIbeta _patternIbetaUnique _patternIconstraints _patternIcounter _patternIelements _patternIenvironment _patternIinfoTree _patternIpatVarNames _patternIpatternMatchWarnings _patternIself _patternIunboundNames) = inv_Pattern_s119 _patternX119 (T_Pattern_vIn118 _patternOambiguousConflicts _patternObetaUnique _patternOcounter _patternOimportEnvironment _patternOmonos _patternOnamesInScope _patternOparentTree _patternOpatternMatchWarnings _patternOtypeConstructors)
         (_monos,_constructorenv,_betaUnique,_miscerrors,_warnings,_valueConstructors,_allValueConstructors,_typeConstructors,_typeConstructorsWithDefined,_allTypeConstructors,_importEnvironment,_ambiguousValueConstructors,_ambiguousTypeConstructors) = rule4557  ()
         _parentTree = rule4558  ()
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule4559 _patternIunboundNames
         _self = rule4560 _nameIself _patternIself _rangeIself
         _lhsOself :: RecordPatternBinding
         _lhsOself = rule4561 _self
         _lhsOcounter :: Int
         _lhsOcounter = rule4562 _patternIcounter
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule4563 _patternIpatternMatchWarnings
         _patternOambiguousConflicts = rule4564 _lhsIambiguousConflicts
         _patternObetaUnique = rule4565 _betaUnique
         _patternOcounter = rule4566 _lhsIcounter
         _patternOimportEnvironment = rule4567 _importEnvironment
         _patternOmonos = rule4568 _monos
         _patternOnamesInScope = rule4569 _lhsInamesInScope
         _patternOparentTree = rule4570 _parentTree
         _patternOpatternMatchWarnings = rule4571 _lhsIpatternMatchWarnings
         _patternOtypeConstructors = rule4572 _typeConstructors
         !__result_ = T_RecordPatternBinding_vOut142 _lhsOcounter _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames
         in __result_ )
     in C_RecordPatternBinding_s143 v142
   {-# INLINE rule4557 #-}
   rule4557 = \  (_ :: ()) ->
                                                                                                               internalError "PartialSyntax.ag" "n/a" "RecordPatternBinding.RecordPatternBinding"
   {-# INLINE rule4558 #-}
   rule4558 = \  (_ :: ()) ->
                                                                            globalInfoError
   {-# INLINE rule4559 #-}
   rule4559 = \ ((_patternIunboundNames) :: Names) ->
     _patternIunboundNames
   {-# INLINE rule4560 #-}
   rule4560 = \ ((_nameIself) :: Name) ((_patternIself) :: Pattern) ((_rangeIself) :: Range) ->
     RecordPatternBinding_RecordPatternBinding _rangeIself _nameIself _patternIself
   {-# INLINE rule4561 #-}
   rule4561 = \ _self ->
     _self
   {-# INLINE rule4562 #-}
   rule4562 = \ ((_patternIcounter) :: Int) ->
     _patternIcounter
   {-# INLINE rule4563 #-}
   rule4563 = \ ((_patternIpatternMatchWarnings) :: [Warning]) ->
     _patternIpatternMatchWarnings
   {-# INLINE rule4564 #-}
   rule4564 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule4565 #-}
   rule4565 = \ _betaUnique ->
     _betaUnique
   {-# INLINE rule4566 #-}
   rule4566 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule4567 #-}
   rule4567 = \ _importEnvironment ->
     _importEnvironment
   {-# INLINE rule4568 #-}
   rule4568 = \ _monos ->
     _monos
   {-# INLINE rule4569 #-}
   rule4569 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule4570 #-}
   rule4570 = \ _parentTree ->
     _parentTree
   {-# INLINE rule4571 #-}
   rule4571 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule4572 #-}
   rule4572 = \ _typeConstructors ->
     _typeConstructors

-- RecordPatternBindings ---------------------------------------
-- wrapper
data Inh_RecordPatternBindings  = Inh_RecordPatternBindings { ambiguousConflicts_Inh_RecordPatternBindings :: !([[Name]]), counter_Inh_RecordPatternBindings :: !(Int), namesInScope_Inh_RecordPatternBindings :: !(Names), patternMatchWarnings_Inh_RecordPatternBindings :: !([Warning]) }
data Syn_RecordPatternBindings  = Syn_RecordPatternBindings { counter_Syn_RecordPatternBindings :: !(Int), patternMatchWarnings_Syn_RecordPatternBindings :: !([Warning]), self_Syn_RecordPatternBindings :: !(RecordPatternBindings), unboundNames_Syn_RecordPatternBindings :: !(Names) }
{-# INLINABLE wrap_RecordPatternBindings #-}
wrap_RecordPatternBindings :: T_RecordPatternBindings  -> Inh_RecordPatternBindings  -> (Syn_RecordPatternBindings )
wrap_RecordPatternBindings !(T_RecordPatternBindings act) !(Inh_RecordPatternBindings _lhsIambiguousConflicts _lhsIcounter _lhsInamesInScope _lhsIpatternMatchWarnings) =
   Control.Monad.Identity.runIdentity (
     do !sem <- act
        let arg145 = T_RecordPatternBindings_vIn145 _lhsIambiguousConflicts _lhsIcounter _lhsInamesInScope _lhsIpatternMatchWarnings
        !(T_RecordPatternBindings_vOut145 _lhsOcounter _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames) <- return (inv_RecordPatternBindings_s146 sem arg145)
        return (Syn_RecordPatternBindings _lhsOcounter _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames)
   )

-- cata
{-# NOINLINE sem_RecordPatternBindings #-}
sem_RecordPatternBindings :: RecordPatternBindings  -> T_RecordPatternBindings 
sem_RecordPatternBindings list = Prelude.foldr sem_RecordPatternBindings_Cons sem_RecordPatternBindings_Nil (Prelude.map sem_RecordPatternBinding list)

-- semantic domain
newtype T_RecordPatternBindings  = T_RecordPatternBindings {
                                                           attach_T_RecordPatternBindings :: Identity (T_RecordPatternBindings_s146 )
                                                           }
newtype T_RecordPatternBindings_s146  = C_RecordPatternBindings_s146 {
                                                                     inv_RecordPatternBindings_s146 :: (T_RecordPatternBindings_v145 )
                                                                     }
data T_RecordPatternBindings_s147  = C_RecordPatternBindings_s147
type T_RecordPatternBindings_v145  = (T_RecordPatternBindings_vIn145 ) -> (T_RecordPatternBindings_vOut145 )
data T_RecordPatternBindings_vIn145  = T_RecordPatternBindings_vIn145 ([[Name]]) (Int) (Names) ([Warning])
data T_RecordPatternBindings_vOut145  = T_RecordPatternBindings_vOut145 (Int) ([Warning]) (RecordPatternBindings) (Names)
{-# NOINLINE sem_RecordPatternBindings_Cons #-}
sem_RecordPatternBindings_Cons :: T_RecordPatternBinding  -> T_RecordPatternBindings  -> T_RecordPatternBindings 
sem_RecordPatternBindings_Cons arg_hd_ arg_tl_ = T_RecordPatternBindings (return st146) where
   {-# NOINLINE st146 #-}
   !st146 = let
      v145 :: T_RecordPatternBindings_v145 
      v145 = \ !(T_RecordPatternBindings_vIn145 _lhsIambiguousConflicts _lhsIcounter _lhsInamesInScope _lhsIpatternMatchWarnings) -> ( let
         _hdX143 = Control.Monad.Identity.runIdentity (attach_T_RecordPatternBinding (arg_hd_))
         _tlX146 = Control.Monad.Identity.runIdentity (attach_T_RecordPatternBindings (arg_tl_))
         (T_RecordPatternBinding_vOut142 _hdIcounter _hdIpatternMatchWarnings _hdIself _hdIunboundNames) = inv_RecordPatternBinding_s143 _hdX143 (T_RecordPatternBinding_vIn142 _hdOambiguousConflicts _hdOcounter _hdOnamesInScope _hdOpatternMatchWarnings)
         (T_RecordPatternBindings_vOut145 _tlIcounter _tlIpatternMatchWarnings _tlIself _tlIunboundNames) = inv_RecordPatternBindings_s146 _tlX146 (T_RecordPatternBindings_vIn145 _tlOambiguousConflicts _tlOcounter _tlOnamesInScope _tlOpatternMatchWarnings)
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule4573 _hdIunboundNames _tlIunboundNames
         _self = rule4574 _hdIself _tlIself
         _lhsOself :: RecordPatternBindings
         _lhsOself = rule4575 _self
         _lhsOcounter :: Int
         _lhsOcounter = rule4576 _tlIcounter
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule4577 _tlIpatternMatchWarnings
         _hdOambiguousConflicts = rule4578 _lhsIambiguousConflicts
         _hdOcounter = rule4579 _lhsIcounter
         _hdOnamesInScope = rule4580 _lhsInamesInScope
         _hdOpatternMatchWarnings = rule4581 _lhsIpatternMatchWarnings
         _tlOambiguousConflicts = rule4582 _lhsIambiguousConflicts
         _tlOcounter = rule4583 _hdIcounter
         _tlOnamesInScope = rule4584 _lhsInamesInScope
         _tlOpatternMatchWarnings = rule4585 _hdIpatternMatchWarnings
         !__result_ = T_RecordPatternBindings_vOut145 _lhsOcounter _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames
         in __result_ )
     in C_RecordPatternBindings_s146 v145
   {-# INLINE rule4573 #-}
   rule4573 = \ ((_hdIunboundNames) :: Names) ((_tlIunboundNames) :: Names) ->
     ((++) _hdIunboundNames _tlIunboundNames)
   {-# INLINE rule4574 #-}
   rule4574 = \ ((_hdIself) :: RecordPatternBinding) ((_tlIself) :: RecordPatternBindings) ->
     (:) _hdIself _tlIself
   {-# INLINE rule4575 #-}
   rule4575 = \ _self ->
     _self
   {-# INLINE rule4576 #-}
   rule4576 = \ ((_tlIcounter) :: Int) ->
     _tlIcounter
   {-# INLINE rule4577 #-}
   rule4577 = \ ((_tlIpatternMatchWarnings) :: [Warning]) ->
     _tlIpatternMatchWarnings
   {-# INLINE rule4578 #-}
   rule4578 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule4579 #-}
   rule4579 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule4580 #-}
   rule4580 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule4581 #-}
   rule4581 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule4582 #-}
   rule4582 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule4583 #-}
   rule4583 = \ ((_hdIcounter) :: Int) ->
     _hdIcounter
   {-# INLINE rule4584 #-}
   rule4584 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule4585 #-}
   rule4585 = \ ((_hdIpatternMatchWarnings) :: [Warning]) ->
     _hdIpatternMatchWarnings
{-# NOINLINE sem_RecordPatternBindings_Nil #-}
sem_RecordPatternBindings_Nil ::  T_RecordPatternBindings 
sem_RecordPatternBindings_Nil  = T_RecordPatternBindings (return st146) where
   {-# NOINLINE st146 #-}
   !st146 = let
      v145 :: T_RecordPatternBindings_v145 
      v145 = \ !(T_RecordPatternBindings_vIn145 _lhsIambiguousConflicts _lhsIcounter _lhsInamesInScope _lhsIpatternMatchWarnings) -> ( let
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule4586  ()
         _self = rule4587  ()
         _lhsOself :: RecordPatternBindings
         _lhsOself = rule4588 _self
         _lhsOcounter :: Int
         _lhsOcounter = rule4589 _lhsIcounter
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule4590 _lhsIpatternMatchWarnings
         !__result_ = T_RecordPatternBindings_vOut145 _lhsOcounter _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames
         in __result_ )
     in C_RecordPatternBindings_s146 v145
   {-# INLINE rule4586 #-}
   rule4586 = \  (_ :: ()) ->
     []
   {-# INLINE rule4587 #-}
   rule4587 = \  (_ :: ()) ->
     []
   {-# INLINE rule4588 #-}
   rule4588 = \ _self ->
     _self
   {-# INLINE rule4589 #-}
   rule4589 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule4590 #-}
   rule4590 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings

-- RightHandSide -----------------------------------------------
-- wrapper
data Inh_RightHandSide  = Inh_RightHandSide { allPatterns_Inh_RightHandSide :: !([((Expression, [String]), Core_TypingStrategy)]), allTypeSchemes_Inh_RightHandSide :: !(M.Map NameWithRange TpScheme), ambiguousConflicts_Inh_RightHandSide :: !([[Name]]), availablePredicates_Inh_RightHandSide :: !([PredicateWithSource]), betaRight_Inh_RightHandSide :: !(Tp), betaUnique_Inh_RightHandSide :: !(Int), classEnvironment_Inh_RightHandSide :: !(ClassEnvironment), classMemberEnv_Inh_RightHandSide :: !(ClassMemberEnvironment), classMemberTypeSchemes_Inh_RightHandSide :: !(Maybe [(Name, TpScheme)]), classNamesEnv_Inh_RightHandSide :: !(ClassNameEnvironment), classPredicate_Inh_RightHandSide :: !(Maybe (Name, Names)), classTypeSchemes_Inh_RightHandSide :: !(M.Map Name TpScheme), collectErrors_Inh_RightHandSide :: !(TypeErrors), collectWarnings_Inh_RightHandSide :: !(Warnings), counter_Inh_RightHandSide :: !(Int), curClassPred_Inh_RightHandSide :: !(Maybe Predicate), curPred_Inh_RightHandSide :: !(Maybe Predicate), currentChunk_Inh_RightHandSide :: !(Int), dictionaryEnvironment_Inh_RightHandSide :: !(DictionaryEnvironment), importEnvironment_Inh_RightHandSide :: !(ImportEnvironment), instanceName_Inh_RightHandSide :: !(Maybe Name), instanceTypes_Inh_RightHandSide :: !([(Name, TpScheme)]), matchIO_Inh_RightHandSide :: !(IO ()), moduleName_Inh_RightHandSide :: !(Maybe Name), monos_Inh_RightHandSide :: !(Monos), namesInScope_Inh_RightHandSide :: !(Names), orderedTypeSynonyms_Inh_RightHandSide :: !(OrderedTypeSynonyms), parentTree_Inh_RightHandSide :: !(InfoTree), patternMatchWarnings_Inh_RightHandSide :: !([Warning]), requiredPredicates_Inh_RightHandSide :: !(Predicates), substitution_Inh_RightHandSide :: !(FixpointSubstitution), typeConstructors_Inh_RightHandSide :: !(TypeConstructorEnvironment), typeschemeMap_Inh_RightHandSide :: !(M.Map Int (Scheme Predicates)), uniqueChunk_Inh_RightHandSide :: !(Int), variableMapping_Inh_RightHandSide :: !(Maybe [(Name, Tp)]) }
data Syn_RightHandSide  = Syn_RightHandSide { assumptions_Syn_RightHandSide :: !(Assumptions), betaUnique_Syn_RightHandSide :: !(Int), collectErrors_Syn_RightHandSide :: !(TypeErrors), collectInstances_Syn_RightHandSide :: !([(Name, Instance)]), collectWarnings_Syn_RightHandSide :: !(Warnings), constraints_Syn_RightHandSide :: !(ConstraintSet), counter_Syn_RightHandSide :: !(Int), dictionaryEnvironment_Syn_RightHandSide :: !(DictionaryEnvironment), fallthrough_Syn_RightHandSide :: !(Bool), infoTree_Syn_RightHandSide :: !(InfoTree), matchIO_Syn_RightHandSide :: !(IO ()), patternMatchWarnings_Syn_RightHandSide :: !([Warning]), self_Syn_RightHandSide :: !(RightHandSide), unboundNames_Syn_RightHandSide :: !(Names), uniqueChunk_Syn_RightHandSide :: !(Int) }
{-# INLINABLE wrap_RightHandSide #-}
wrap_RightHandSide :: T_RightHandSide  -> Inh_RightHandSide  -> (Syn_RightHandSide )
wrap_RightHandSide !(T_RightHandSide act) !(Inh_RightHandSide _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaRight _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeConstructors _lhsItypeschemeMap _lhsIuniqueChunk _lhsIvariableMapping) =
   Control.Monad.Identity.runIdentity (
     do !sem <- act
        let arg148 = T_RightHandSide_vIn148 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaRight _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeConstructors _lhsItypeschemeMap _lhsIuniqueChunk _lhsIvariableMapping
        !(T_RightHandSide_vOut148 _lhsOassumptions _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraints _lhsOcounter _lhsOdictionaryEnvironment _lhsOfallthrough _lhsOinfoTree _lhsOmatchIO _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk) <- return (inv_RightHandSide_s149 sem arg148)
        return (Syn_RightHandSide _lhsOassumptions _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraints _lhsOcounter _lhsOdictionaryEnvironment _lhsOfallthrough _lhsOinfoTree _lhsOmatchIO _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk)
   )

-- cata
{-# NOINLINE sem_RightHandSide #-}
sem_RightHandSide :: RightHandSide  -> T_RightHandSide 
sem_RightHandSide ( RightHandSide_Expression range_ expression_ where_ ) = sem_RightHandSide_Expression ( sem_Range range_ ) ( sem_Expression expression_ ) ( sem_MaybeDeclarations where_ )
sem_RightHandSide ( RightHandSide_Guarded range_ guardedexpressions_ where_ ) = sem_RightHandSide_Guarded ( sem_Range range_ ) ( sem_GuardedExpressions guardedexpressions_ ) ( sem_MaybeDeclarations where_ )

-- semantic domain
newtype T_RightHandSide  = T_RightHandSide {
                                           attach_T_RightHandSide :: Identity (T_RightHandSide_s149 )
                                           }
newtype T_RightHandSide_s149  = C_RightHandSide_s149 {
                                                     inv_RightHandSide_s149 :: (T_RightHandSide_v148 )
                                                     }
data T_RightHandSide_s150  = C_RightHandSide_s150
type T_RightHandSide_v148  = (T_RightHandSide_vIn148 ) -> (T_RightHandSide_vOut148 )
data T_RightHandSide_vIn148  = T_RightHandSide_vIn148 ([((Expression, [String]), Core_TypingStrategy)]) (M.Map NameWithRange TpScheme) ([[Name]]) ([PredicateWithSource]) (Tp) (Int) (ClassEnvironment) (ClassMemberEnvironment) (Maybe [(Name, TpScheme)]) (ClassNameEnvironment) (Maybe (Name, Names)) (M.Map Name TpScheme) (TypeErrors) (Warnings) (Int) (Maybe Predicate) (Maybe Predicate) (Int) (DictionaryEnvironment) (ImportEnvironment) (Maybe Name) ([(Name, TpScheme)]) (IO ()) (Maybe Name) (Monos) (Names) (OrderedTypeSynonyms) (InfoTree) ([Warning]) (Predicates) (FixpointSubstitution) (TypeConstructorEnvironment) (M.Map Int (Scheme Predicates)) (Int) (Maybe [(Name, Tp)])
data T_RightHandSide_vOut148  = T_RightHandSide_vOut148 (Assumptions) (Int) (TypeErrors) ([(Name, Instance)]) (Warnings) (ConstraintSet) (Int) (DictionaryEnvironment) (Bool) (InfoTree) (IO ()) ([Warning]) (RightHandSide) (Names) (Int)
{-# NOINLINE sem_RightHandSide_Expression #-}
sem_RightHandSide_Expression :: T_Range  -> T_Expression  -> T_MaybeDeclarations  -> T_RightHandSide 
sem_RightHandSide_Expression arg_range_ arg_expression_ arg_where_ = T_RightHandSide (return st149) where
   {-# NOINLINE st149 #-}
   !st149 = let
      v148 :: T_RightHandSide_v148 
      v148 = \ !(T_RightHandSide_vIn148 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaRight _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeConstructors _lhsItypeschemeMap _lhsIuniqueChunk _lhsIvariableMapping) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _expressionX41 = Control.Monad.Identity.runIdentity (attach_T_Expression (arg_expression_))
         _whereX89 = Control.Monad.Identity.runIdentity (attach_T_MaybeDeclarations (arg_where_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_Expression_vOut40 _expressionIassumptions _expressionIbeta _expressionIbetaUnique _expressionIcollectErrors _expressionIcollectInstances _expressionIcollectWarnings _expressionIconstraints _expressionIcounter _expressionIdictionaryEnvironment _expressionIinfoTree _expressionImatchIO _expressionImatches _expressionIpatternMatchWarnings _expressionIself _expressionIunboundNames _expressionIuniqueChunk _expressionIuniqueSecondRound) = inv_Expression_s41 _expressionX41 (T_Expression_vIn40 _expressionOallPatterns _expressionOallTypeSchemes _expressionOambiguousConflicts _expressionOavailablePredicates _expressionObetaUnique _expressionOclassEnvironment _expressionOclassMemberEnv _expressionOclassMemberTypeSchemes _expressionOclassNamesEnv _expressionOclassPredicate _expressionOclassTypeSchemes _expressionOcollectErrors _expressionOcollectWarnings _expressionOcounter _expressionOcurClassPred _expressionOcurPred _expressionOcurrentChunk _expressionOdictionaryEnvironment _expressionOimportEnvironment _expressionOinstanceName _expressionOinstanceTypes _expressionOmatchIO _expressionOmoduleName _expressionOmonos _expressionOnamesInScope _expressionOorderedTypeSynonyms _expressionOparentTree _expressionOpatternMatchWarnings _expressionOrequiredPredicates _expressionOsubstitution _expressionOtryPatterns _expressionOtypeConstructors _expressionOtypeschemeMap _expressionOuniqueChunk _expressionOuniqueSecondRound _expressionOvariableMapping)
         (T_MaybeDeclarations_vOut88 _whereIassumptions _whereIbetaUnique _whereIboundBetas _whereIcollectErrors _whereIcollectInstances _whereIcollectWarnings _whereIconstraints _whereIcounter _whereIdeclVarNames _whereIdictionaryEnvironment _whereIinfoTrees _whereIlocalTypes _whereImatchIO _whereInamesInScope _whereIpatternMatchWarnings _whereIself _whereItypeMemberBindings _whereIunboundNames _whereIuniqueChunk) = inv_MaybeDeclarations_s89 _whereX89 (T_MaybeDeclarations_vIn88 _whereOallPatterns _whereOallTypeSchemes _whereOambiguousConflicts _whereOassumptions _whereOavailablePredicates _whereObetaUnique _whereOclassEnvironment _whereOclassMemberEnv _whereOclassMemberTypeSchemes _whereOclassNamesEnv _whereOclassPredicate _whereOclassTypeSchemes _whereOcollectErrors _whereOcollectWarnings _whereOconstraints _whereOcounter _whereOcurClassPred _whereOcurPred _whereOcurrentChunk _whereOdictionaryEnvironment _whereOimportEnvironment _whereOinstanceName _whereOinstanceTypes _whereOmatchIO _whereOmoduleName _whereOmonos _whereOnamesInScope _whereOorderedTypeSynonyms _whereOparentTree _whereOpatternMatchWarnings _whereOrequiredPredicates _whereOsubstitution _whereOtypeConstructors _whereOtypeschemeMap _whereOunboundNames _whereOuniqueChunk _whereOvariableMapping)
         _lhsOfallthrough :: Bool
         _lhsOfallthrough = rule4591  ()
         _expressionOuniqueSecondRound = rule4592 _expressionIbetaUnique
         _whereObetaUnique = rule4593 _expressionIuniqueSecondRound
         _expressionOtryPatterns = rule4594  ()
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule4595 _whereIunboundNames
         _expressionOnamesInScope = rule4596 _whereInamesInScope
         _whereOunboundNames = rule4597 _expressionIunboundNames
         _parentTree = rule4598 _expressionIinfoTree _lhsIparentTree _localInfo _whereIinfoTrees
         _lhsOinfoTree :: InfoTree
         _lhsOinfoTree = rule4599 _parentTree
         _localInfo = rule4600 _lhsImonos _self
         _cinfo = rule4601 _lhsIbetaRight _lhsIparentTree _parentTree
         _allTypeSchemes = rule4602 _lhsIallTypeSchemes _whereIlocalTypes
         _lhsOassumptions :: Assumptions
         _lhsOassumptions = rule4603 _whereIassumptions
         _lhsOconstraints :: ConstraintSet
         _lhsOconstraints = rule4604 _whereIconstraints
         _whereOassumptions = rule4605 _expressionIassumptions
         _whereOconstraints = rule4606 _expressionIconstraints _newcon
         _whereOinstanceName = rule4607  ()
         _whereOvariableMapping = rule4608  ()
         _newcon = rule4609 _cinfo _expressionIbeta _lhsIbetaRight
         _lhsOcollectInstances :: [(Name, Instance)]
         _lhsOcollectInstances = rule4610 _expressionIcollectInstances _whereIcollectInstances
         _self = rule4611 _expressionIself _rangeIself _whereIself
         _lhsOself :: RightHandSide
         _lhsOself = rule4612 _self
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule4613 _whereIbetaUnique
         _lhsOcollectErrors :: TypeErrors
         _lhsOcollectErrors = rule4614 _whereIcollectErrors
         _lhsOcollectWarnings :: Warnings
         _lhsOcollectWarnings = rule4615 _whereIcollectWarnings
         _lhsOcounter :: Int
         _lhsOcounter = rule4616 _whereIcounter
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule4617 _whereIdictionaryEnvironment
         _lhsOmatchIO :: IO ()
         _lhsOmatchIO = rule4618 _whereImatchIO
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule4619 _whereIpatternMatchWarnings
         _lhsOuniqueChunk :: Int
         _lhsOuniqueChunk = rule4620 _whereIuniqueChunk
         _expressionOallPatterns = rule4621 _lhsIallPatterns
         _expressionOallTypeSchemes = rule4622 _allTypeSchemes
         _expressionOambiguousConflicts = rule4623 _lhsIambiguousConflicts
         _expressionOavailablePredicates = rule4624 _lhsIavailablePredicates
         _expressionObetaUnique = rule4625 _lhsIbetaUnique
         _expressionOclassEnvironment = rule4626 _lhsIclassEnvironment
         _expressionOclassMemberEnv = rule4627 _lhsIclassMemberEnv
         _expressionOclassMemberTypeSchemes = rule4628 _lhsIclassMemberTypeSchemes
         _expressionOclassNamesEnv = rule4629 _lhsIclassNamesEnv
         _expressionOclassPredicate = rule4630 _lhsIclassPredicate
         _expressionOclassTypeSchemes = rule4631 _lhsIclassTypeSchemes
         _expressionOcollectErrors = rule4632 _lhsIcollectErrors
         _expressionOcollectWarnings = rule4633 _lhsIcollectWarnings
         _expressionOcounter = rule4634 _lhsIcounter
         _expressionOcurClassPred = rule4635 _lhsIcurClassPred
         _expressionOcurPred = rule4636 _lhsIcurPred
         _expressionOcurrentChunk = rule4637 _lhsIcurrentChunk
         _expressionOdictionaryEnvironment = rule4638 _lhsIdictionaryEnvironment
         _expressionOimportEnvironment = rule4639 _lhsIimportEnvironment
         _expressionOinstanceName = rule4640 _lhsIinstanceName
         _expressionOinstanceTypes = rule4641 _lhsIinstanceTypes
         _expressionOmatchIO = rule4642 _lhsImatchIO
         _expressionOmoduleName = rule4643 _lhsImoduleName
         _expressionOmonos = rule4644 _lhsImonos
         _expressionOorderedTypeSynonyms = rule4645 _lhsIorderedTypeSynonyms
         _expressionOparentTree = rule4646 _parentTree
         _expressionOpatternMatchWarnings = rule4647 _lhsIpatternMatchWarnings
         _expressionOrequiredPredicates = rule4648 _lhsIrequiredPredicates
         _expressionOsubstitution = rule4649 _lhsIsubstitution
         _expressionOtypeConstructors = rule4650 _lhsItypeConstructors
         _expressionOtypeschemeMap = rule4651 _lhsItypeschemeMap
         _expressionOuniqueChunk = rule4652 _lhsIuniqueChunk
         _expressionOvariableMapping = rule4653 _lhsIvariableMapping
         _whereOallPatterns = rule4654 _lhsIallPatterns
         _whereOallTypeSchemes = rule4655 _allTypeSchemes
         _whereOambiguousConflicts = rule4656 _lhsIambiguousConflicts
         _whereOavailablePredicates = rule4657 _lhsIavailablePredicates
         _whereOclassEnvironment = rule4658 _lhsIclassEnvironment
         _whereOclassMemberEnv = rule4659 _lhsIclassMemberEnv
         _whereOclassMemberTypeSchemes = rule4660 _lhsIclassMemberTypeSchemes
         _whereOclassNamesEnv = rule4661 _lhsIclassNamesEnv
         _whereOclassPredicate = rule4662 _lhsIclassPredicate
         _whereOclassTypeSchemes = rule4663 _lhsIclassTypeSchemes
         _whereOcollectErrors = rule4664 _expressionIcollectErrors
         _whereOcollectWarnings = rule4665 _expressionIcollectWarnings
         _whereOcounter = rule4666 _expressionIcounter
         _whereOcurClassPred = rule4667 _lhsIcurClassPred
         _whereOcurPred = rule4668 _lhsIcurPred
         _whereOcurrentChunk = rule4669 _lhsIcurrentChunk
         _whereOdictionaryEnvironment = rule4670 _expressionIdictionaryEnvironment
         _whereOimportEnvironment = rule4671 _lhsIimportEnvironment
         _whereOinstanceTypes = rule4672 _lhsIinstanceTypes
         _whereOmatchIO = rule4673 _expressionImatchIO
         _whereOmoduleName = rule4674 _lhsImoduleName
         _whereOmonos = rule4675 _lhsImonos
         _whereOnamesInScope = rule4676 _lhsInamesInScope
         _whereOorderedTypeSynonyms = rule4677 _lhsIorderedTypeSynonyms
         _whereOparentTree = rule4678 _parentTree
         _whereOpatternMatchWarnings = rule4679 _expressionIpatternMatchWarnings
         _whereOrequiredPredicates = rule4680 _lhsIrequiredPredicates
         _whereOsubstitution = rule4681 _lhsIsubstitution
         _whereOtypeConstructors = rule4682 _lhsItypeConstructors
         _whereOtypeschemeMap = rule4683 _lhsItypeschemeMap
         _whereOuniqueChunk = rule4684 _expressionIuniqueChunk
         !__result_ = T_RightHandSide_vOut148 _lhsOassumptions _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraints _lhsOcounter _lhsOdictionaryEnvironment _lhsOfallthrough _lhsOinfoTree _lhsOmatchIO _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk
         in __result_ )
     in C_RightHandSide_s149 v148
   {-# INLINE rule4591 #-}
   rule4591 = \  (_ :: ()) ->
                                            False
   {-# INLINE rule4592 #-}
   rule4592 = \ ((_expressionIbetaUnique) :: Int) ->
                                                _expressionIbetaUnique
   {-# INLINE rule4593 #-}
   rule4593 = \ ((_expressionIuniqueSecondRound) :: Int) ->
                                                _expressionIuniqueSecondRound
   {-# INLINE rule4594 #-}
   rule4594 = \  (_ :: ()) ->
                                                     []
   {-# INLINE rule4595 #-}
   rule4595 = \ ((_whereIunboundNames) :: Names) ->
                                                       _whereIunboundNames
   {-# INLINE rule4596 #-}
   rule4596 = \ ((_whereInamesInScope) :: Names) ->
                                                       _whereInamesInScope
   {-# INLINE rule4597 #-}
   rule4597 = \ ((_expressionIunboundNames) :: Names) ->
                                                       _expressionIunboundNames
   {-# INLINE rule4598 #-}
   rule4598 = \ ((_expressionIinfoTree) :: InfoTree) ((_lhsIparentTree) :: InfoTree) _localInfo ((_whereIinfoTrees) :: InfoTrees) ->
                            node _lhsIparentTree _localInfo (_expressionIinfoTree : _whereIinfoTrees)
   {-# INLINE rule4599 #-}
   rule4599 = \ _parentTree ->
                            _parentTree
   {-# INLINE rule4600 #-}
   rule4600 = \ ((_lhsImonos) :: Monos) _self ->
                            LocalInfo { self = UHA_RHS _self
                                      , assignedType = Nothing
                                      , monos = _lhsImonos
                                      }
   {-# INLINE rule4601 #-}
   rule4601 = \ ((_lhsIbetaRight) :: Tp) ((_lhsIparentTree) :: InfoTree) _parentTree ->
     orphanConstraint 0 "right-hand side" _parentTree
        [ Unifier (head (ftv _lhsIbetaRight)) ("right-hand sides", attribute (skip_UHA_FB_RHS _lhsIparentTree), "right-hand side") ]
   {-# INLINE rule4602 #-}
   rule4602 = \ ((_lhsIallTypeSchemes) :: M.Map NameWithRange TpScheme) ((_whereIlocalTypes) :: M.Map NameWithRange TpScheme) ->
                                         _whereIlocalTypes `M.union` _lhsIallTypeSchemes
   {-# INLINE rule4603 #-}
   rule4603 = \ ((_whereIassumptions) :: Assumptions) ->
                             _whereIassumptions
   {-# INLINE rule4604 #-}
   rule4604 = \ ((_whereIconstraints) :: ConstraintSet) ->
                             _whereIconstraints
   {-# INLINE rule4605 #-}
   rule4605 = \ ((_expressionIassumptions) :: Assumptions) ->
                             _expressionIassumptions
   {-# INLINE rule4606 #-}
   rule4606 = \ ((_expressionIconstraints) :: ConstraintSet) _newcon ->
                             _newcon .>. _expressionIconstraints
   {-# INLINE rule4607 #-}
   rule4607 = \  (_ :: ()) ->
                              Nothing
   {-# INLINE rule4608 #-}
   rule4608 = \  (_ :: ()) ->
                                 Nothing
   {-# INLINE rule4609 #-}
   rule4609 = \ _cinfo ((_expressionIbeta) :: Tp) ((_lhsIbetaRight) :: Tp) ->
                             [ (_expressionIbeta .==. _lhsIbetaRight) _cinfo ]
   {-# INLINE rule4610 #-}
   rule4610 = \ ((_expressionIcollectInstances) :: [(Name, Instance)]) ((_whereIcollectInstances) :: [(Name, Instance)]) ->
     _expressionIcollectInstances  ++  _whereIcollectInstances
   {-# INLINE rule4611 #-}
   rule4611 = \ ((_expressionIself) :: Expression) ((_rangeIself) :: Range) ((_whereIself) :: MaybeDeclarations) ->
     RightHandSide_Expression _rangeIself _expressionIself _whereIself
   {-# INLINE rule4612 #-}
   rule4612 = \ _self ->
     _self
   {-# INLINE rule4613 #-}
   rule4613 = \ ((_whereIbetaUnique) :: Int) ->
     _whereIbetaUnique
   {-# INLINE rule4614 #-}
   rule4614 = \ ((_whereIcollectErrors) :: TypeErrors) ->
     _whereIcollectErrors
   {-# INLINE rule4615 #-}
   rule4615 = \ ((_whereIcollectWarnings) :: Warnings) ->
     _whereIcollectWarnings
   {-# INLINE rule4616 #-}
   rule4616 = \ ((_whereIcounter) :: Int) ->
     _whereIcounter
   {-# INLINE rule4617 #-}
   rule4617 = \ ((_whereIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _whereIdictionaryEnvironment
   {-# INLINE rule4618 #-}
   rule4618 = \ ((_whereImatchIO) :: IO ()) ->
     _whereImatchIO
   {-# INLINE rule4619 #-}
   rule4619 = \ ((_whereIpatternMatchWarnings) :: [Warning]) ->
     _whereIpatternMatchWarnings
   {-# INLINE rule4620 #-}
   rule4620 = \ ((_whereIuniqueChunk) :: Int) ->
     _whereIuniqueChunk
   {-# INLINE rule4621 #-}
   rule4621 = \ ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ->
     _lhsIallPatterns
   {-# INLINE rule4622 #-}
   rule4622 = \ _allTypeSchemes ->
     _allTypeSchemes
   {-# INLINE rule4623 #-}
   rule4623 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule4624 #-}
   rule4624 = \ ((_lhsIavailablePredicates) :: [PredicateWithSource]) ->
     _lhsIavailablePredicates
   {-# INLINE rule4625 #-}
   rule4625 = \ ((_lhsIbetaUnique) :: Int) ->
     _lhsIbetaUnique
   {-# INLINE rule4626 #-}
   rule4626 = \ ((_lhsIclassEnvironment) :: ClassEnvironment) ->
     _lhsIclassEnvironment
   {-# INLINE rule4627 #-}
   rule4627 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule4628 #-}
   rule4628 = \ ((_lhsIclassMemberTypeSchemes) :: Maybe [(Name, TpScheme)]) ->
     _lhsIclassMemberTypeSchemes
   {-# INLINE rule4629 #-}
   rule4629 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule4630 #-}
   rule4630 = \ ((_lhsIclassPredicate) :: Maybe (Name, Names)) ->
     _lhsIclassPredicate
   {-# INLINE rule4631 #-}
   rule4631 = \ ((_lhsIclassTypeSchemes) :: M.Map Name TpScheme) ->
     _lhsIclassTypeSchemes
   {-# INLINE rule4632 #-}
   rule4632 = \ ((_lhsIcollectErrors) :: TypeErrors) ->
     _lhsIcollectErrors
   {-# INLINE rule4633 #-}
   rule4633 = \ ((_lhsIcollectWarnings) :: Warnings) ->
     _lhsIcollectWarnings
   {-# INLINE rule4634 #-}
   rule4634 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule4635 #-}
   rule4635 = \ ((_lhsIcurClassPred) :: Maybe Predicate) ->
     _lhsIcurClassPred
   {-# INLINE rule4636 #-}
   rule4636 = \ ((_lhsIcurPred) :: Maybe Predicate) ->
     _lhsIcurPred
   {-# INLINE rule4637 #-}
   rule4637 = \ ((_lhsIcurrentChunk) :: Int) ->
     _lhsIcurrentChunk
   {-# INLINE rule4638 #-}
   rule4638 = \ ((_lhsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _lhsIdictionaryEnvironment
   {-# INLINE rule4639 #-}
   rule4639 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule4640 #-}
   rule4640 = \ ((_lhsIinstanceName) :: Maybe Name) ->
     _lhsIinstanceName
   {-# INLINE rule4641 #-}
   rule4641 = \ ((_lhsIinstanceTypes) :: [(Name, TpScheme)]) ->
     _lhsIinstanceTypes
   {-# INLINE rule4642 #-}
   rule4642 = \ ((_lhsImatchIO) :: IO ()) ->
     _lhsImatchIO
   {-# INLINE rule4643 #-}
   rule4643 = \ ((_lhsImoduleName) :: Maybe Name) ->
     _lhsImoduleName
   {-# INLINE rule4644 #-}
   rule4644 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule4645 #-}
   rule4645 = \ ((_lhsIorderedTypeSynonyms) :: OrderedTypeSynonyms) ->
     _lhsIorderedTypeSynonyms
   {-# INLINE rule4646 #-}
   rule4646 = \ _parentTree ->
     _parentTree
   {-# INLINE rule4647 #-}
   rule4647 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule4648 #-}
   rule4648 = \ ((_lhsIrequiredPredicates) :: Predicates) ->
     _lhsIrequiredPredicates
   {-# INLINE rule4649 #-}
   rule4649 = \ ((_lhsIsubstitution) :: FixpointSubstitution) ->
     _lhsIsubstitution
   {-# INLINE rule4650 #-}
   rule4650 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
   {-# INLINE rule4651 #-}
   rule4651 = \ ((_lhsItypeschemeMap) :: M.Map Int (Scheme Predicates)) ->
     _lhsItypeschemeMap
   {-# INLINE rule4652 #-}
   rule4652 = \ ((_lhsIuniqueChunk) :: Int) ->
     _lhsIuniqueChunk
   {-# INLINE rule4653 #-}
   rule4653 = \ ((_lhsIvariableMapping) :: Maybe [(Name, Tp)]) ->
     _lhsIvariableMapping
   {-# INLINE rule4654 #-}
   rule4654 = \ ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ->
     _lhsIallPatterns
   {-# INLINE rule4655 #-}
   rule4655 = \ _allTypeSchemes ->
     _allTypeSchemes
   {-# INLINE rule4656 #-}
   rule4656 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule4657 #-}
   rule4657 = \ ((_lhsIavailablePredicates) :: [PredicateWithSource]) ->
     _lhsIavailablePredicates
   {-# INLINE rule4658 #-}
   rule4658 = \ ((_lhsIclassEnvironment) :: ClassEnvironment) ->
     _lhsIclassEnvironment
   {-# INLINE rule4659 #-}
   rule4659 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule4660 #-}
   rule4660 = \ ((_lhsIclassMemberTypeSchemes) :: Maybe [(Name, TpScheme)]) ->
     _lhsIclassMemberTypeSchemes
   {-# INLINE rule4661 #-}
   rule4661 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule4662 #-}
   rule4662 = \ ((_lhsIclassPredicate) :: Maybe (Name, Names)) ->
     _lhsIclassPredicate
   {-# INLINE rule4663 #-}
   rule4663 = \ ((_lhsIclassTypeSchemes) :: M.Map Name TpScheme) ->
     _lhsIclassTypeSchemes
   {-# INLINE rule4664 #-}
   rule4664 = \ ((_expressionIcollectErrors) :: TypeErrors) ->
     _expressionIcollectErrors
   {-# INLINE rule4665 #-}
   rule4665 = \ ((_expressionIcollectWarnings) :: Warnings) ->
     _expressionIcollectWarnings
   {-# INLINE rule4666 #-}
   rule4666 = \ ((_expressionIcounter) :: Int) ->
     _expressionIcounter
   {-# INLINE rule4667 #-}
   rule4667 = \ ((_lhsIcurClassPred) :: Maybe Predicate) ->
     _lhsIcurClassPred
   {-# INLINE rule4668 #-}
   rule4668 = \ ((_lhsIcurPred) :: Maybe Predicate) ->
     _lhsIcurPred
   {-# INLINE rule4669 #-}
   rule4669 = \ ((_lhsIcurrentChunk) :: Int) ->
     _lhsIcurrentChunk
   {-# INLINE rule4670 #-}
   rule4670 = \ ((_expressionIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _expressionIdictionaryEnvironment
   {-# INLINE rule4671 #-}
   rule4671 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule4672 #-}
   rule4672 = \ ((_lhsIinstanceTypes) :: [(Name, TpScheme)]) ->
     _lhsIinstanceTypes
   {-# INLINE rule4673 #-}
   rule4673 = \ ((_expressionImatchIO) :: IO ()) ->
     _expressionImatchIO
   {-# INLINE rule4674 #-}
   rule4674 = \ ((_lhsImoduleName) :: Maybe Name) ->
     _lhsImoduleName
   {-# INLINE rule4675 #-}
   rule4675 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule4676 #-}
   rule4676 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule4677 #-}
   rule4677 = \ ((_lhsIorderedTypeSynonyms) :: OrderedTypeSynonyms) ->
     _lhsIorderedTypeSynonyms
   {-# INLINE rule4678 #-}
   rule4678 = \ _parentTree ->
     _parentTree
   {-# INLINE rule4679 #-}
   rule4679 = \ ((_expressionIpatternMatchWarnings) :: [Warning]) ->
     _expressionIpatternMatchWarnings
   {-# INLINE rule4680 #-}
   rule4680 = \ ((_lhsIrequiredPredicates) :: Predicates) ->
     _lhsIrequiredPredicates
   {-# INLINE rule4681 #-}
   rule4681 = \ ((_lhsIsubstitution) :: FixpointSubstitution) ->
     _lhsIsubstitution
   {-# INLINE rule4682 #-}
   rule4682 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
   {-# INLINE rule4683 #-}
   rule4683 = \ ((_lhsItypeschemeMap) :: M.Map Int (Scheme Predicates)) ->
     _lhsItypeschemeMap
   {-# INLINE rule4684 #-}
   rule4684 = \ ((_expressionIuniqueChunk) :: Int) ->
     _expressionIuniqueChunk
{-# NOINLINE sem_RightHandSide_Guarded #-}
sem_RightHandSide_Guarded :: T_Range  -> T_GuardedExpressions  -> T_MaybeDeclarations  -> T_RightHandSide 
sem_RightHandSide_Guarded arg_range_ arg_guardedexpressions_ arg_where_ = T_RightHandSide (return st149) where
   {-# NOINLINE st149 #-}
   !st149 = let
      v148 :: T_RightHandSide_v148 
      v148 = \ !(T_RightHandSide_vIn148 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIavailablePredicates _lhsIbetaRight _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeConstructors _lhsItypeschemeMap _lhsIuniqueChunk _lhsIvariableMapping) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _guardedexpressionsX65 = Control.Monad.Identity.runIdentity (attach_T_GuardedExpressions (arg_guardedexpressions_))
         _whereX89 = Control.Monad.Identity.runIdentity (attach_T_MaybeDeclarations (arg_where_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_GuardedExpressions_vOut64 _guardedexpressionsIassumptions _guardedexpressionsIbetaUnique _guardedexpressionsIcollectErrors _guardedexpressionsIcollectInstances _guardedexpressionsIcollectWarnings _guardedexpressionsIconstraintslist _guardedexpressionsIcounter _guardedexpressionsIdictionaryEnvironment _guardedexpressionsIfallthrough _guardedexpressionsIinfoTrees _guardedexpressionsImatchIO _guardedexpressionsIpatternMatchWarnings _guardedexpressionsIself _guardedexpressionsIunboundNames _guardedexpressionsIuniqueChunk _guardedexpressionsIuniqueSecondRound) = inv_GuardedExpressions_s65 _guardedexpressionsX65 (T_GuardedExpressions_vIn64 _guardedexpressionsOallPatterns _guardedexpressionsOallTypeSchemes _guardedexpressionsOambiguousConflicts _guardedexpressionsOavailablePredicates _guardedexpressionsObetaRight _guardedexpressionsObetaUnique _guardedexpressionsOclassEnvironment _guardedexpressionsOclassMemberEnv _guardedexpressionsOclassMemberTypeSchemes _guardedexpressionsOclassNamesEnv _guardedexpressionsOclassPredicate _guardedexpressionsOclassTypeSchemes _guardedexpressionsOcollectErrors _guardedexpressionsOcollectWarnings _guardedexpressionsOcounter _guardedexpressionsOcurClassPred _guardedexpressionsOcurPred _guardedexpressionsOcurrentChunk _guardedexpressionsOdictionaryEnvironment _guardedexpressionsOimportEnvironment _guardedexpressionsOinstanceName _guardedexpressionsOinstanceTypes _guardedexpressionsOmatchIO _guardedexpressionsOmoduleName _guardedexpressionsOmonos _guardedexpressionsOnamesInScope _guardedexpressionsOnumberOfGuards _guardedexpressionsOopen _guardedexpressionsOorderedTypeSynonyms _guardedexpressionsOparentTree _guardedexpressionsOpatternMatchWarnings _guardedexpressionsOrequiredPredicates _guardedexpressionsOsubstitution _guardedexpressionsOtypeConstructors _guardedexpressionsOtypeschemeMap _guardedexpressionsOuniqueChunk _guardedexpressionsOuniqueSecondRound _guardedexpressionsOvariableMapping)
         (T_MaybeDeclarations_vOut88 _whereIassumptions _whereIbetaUnique _whereIboundBetas _whereIcollectErrors _whereIcollectInstances _whereIcollectWarnings _whereIconstraints _whereIcounter _whereIdeclVarNames _whereIdictionaryEnvironment _whereIinfoTrees _whereIlocalTypes _whereImatchIO _whereInamesInScope _whereIpatternMatchWarnings _whereIself _whereItypeMemberBindings _whereIunboundNames _whereIuniqueChunk) = inv_MaybeDeclarations_s89 _whereX89 (T_MaybeDeclarations_vIn88 _whereOallPatterns _whereOallTypeSchemes _whereOambiguousConflicts _whereOassumptions _whereOavailablePredicates _whereObetaUnique _whereOclassEnvironment _whereOclassMemberEnv _whereOclassMemberTypeSchemes _whereOclassNamesEnv _whereOclassPredicate _whereOclassTypeSchemes _whereOcollectErrors _whereOcollectWarnings _whereOconstraints _whereOcounter _whereOcurClassPred _whereOcurPred _whereOcurrentChunk _whereOdictionaryEnvironment _whereOimportEnvironment _whereOinstanceName _whereOinstanceTypes _whereOmatchIO _whereOmoduleName _whereOmonos _whereOnamesInScope _whereOorderedTypeSynonyms _whereOparentTree _whereOpatternMatchWarnings _whereOrequiredPredicates _whereOsubstitution _whereOtypeConstructors _whereOtypeschemeMap _whereOunboundNames _whereOuniqueChunk _whereOvariableMapping)
         _lhsOfallthrough :: Bool
         _lhsOfallthrough = rule4685 _guardedexpressionsIfallthrough
         _guardedexpressionsOopen = rule4686  ()
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule4687 _guardedexpressionsIfallthrough _rangeIself _whereIpatternMatchWarnings
         _guardedexpressionsOuniqueSecondRound = rule4688 _guardedexpressionsIbetaUnique
         _whereObetaUnique = rule4689 _guardedexpressionsIuniqueSecondRound
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule4690 _whereIunboundNames
         _guardedexpressionsOnamesInScope = rule4691 _whereInamesInScope
         _whereOunboundNames = rule4692 _guardedexpressionsIunboundNames
         _parentTree = rule4693 _guardedexpressionsIinfoTrees _lhsIparentTree _localInfo _whereIinfoTrees
         _lhsOinfoTree :: InfoTree
         _lhsOinfoTree = rule4694 _parentTree
         _localInfo = rule4695 _lhsImonos _self
         _allTypeSchemes = rule4696 _lhsIallTypeSchemes _whereIlocalTypes
         _lhsOassumptions :: Assumptions
         _lhsOassumptions = rule4697 _whereIassumptions
         _lhsOconstraints :: ConstraintSet
         _lhsOconstraints = rule4698 _whereIconstraints
         _guardedexpressionsOnumberOfGuards = rule4699 _guardedexpressionsIconstraintslist
         _whereOassumptions = rule4700 _guardedexpressionsIassumptions
         _whereOinstanceName = rule4701  ()
         _whereOconstraints = rule4702 _guardedexpressionsIconstraintslist
         _lhsOcollectInstances :: [(Name, Instance)]
         _lhsOcollectInstances = rule4703 _guardedexpressionsIcollectInstances _whereIcollectInstances
         _self = rule4704 _guardedexpressionsIself _rangeIself _whereIself
         _lhsOself :: RightHandSide
         _lhsOself = rule4705 _self
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule4706 _whereIbetaUnique
         _lhsOcollectErrors :: TypeErrors
         _lhsOcollectErrors = rule4707 _whereIcollectErrors
         _lhsOcollectWarnings :: Warnings
         _lhsOcollectWarnings = rule4708 _whereIcollectWarnings
         _lhsOcounter :: Int
         _lhsOcounter = rule4709 _whereIcounter
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule4710 _whereIdictionaryEnvironment
         _lhsOmatchIO :: IO ()
         _lhsOmatchIO = rule4711 _whereImatchIO
         _lhsOuniqueChunk :: Int
         _lhsOuniqueChunk = rule4712 _whereIuniqueChunk
         _guardedexpressionsOallPatterns = rule4713 _lhsIallPatterns
         _guardedexpressionsOallTypeSchemes = rule4714 _allTypeSchemes
         _guardedexpressionsOambiguousConflicts = rule4715 _lhsIambiguousConflicts
         _guardedexpressionsOavailablePredicates = rule4716 _lhsIavailablePredicates
         _guardedexpressionsObetaRight = rule4717 _lhsIbetaRight
         _guardedexpressionsObetaUnique = rule4718 _lhsIbetaUnique
         _guardedexpressionsOclassEnvironment = rule4719 _lhsIclassEnvironment
         _guardedexpressionsOclassMemberEnv = rule4720 _lhsIclassMemberEnv
         _guardedexpressionsOclassMemberTypeSchemes = rule4721 _lhsIclassMemberTypeSchemes
         _guardedexpressionsOclassNamesEnv = rule4722 _lhsIclassNamesEnv
         _guardedexpressionsOclassPredicate = rule4723 _lhsIclassPredicate
         _guardedexpressionsOclassTypeSchemes = rule4724 _lhsIclassTypeSchemes
         _guardedexpressionsOcollectErrors = rule4725 _lhsIcollectErrors
         _guardedexpressionsOcollectWarnings = rule4726 _lhsIcollectWarnings
         _guardedexpressionsOcounter = rule4727 _lhsIcounter
         _guardedexpressionsOcurClassPred = rule4728 _lhsIcurClassPred
         _guardedexpressionsOcurPred = rule4729 _lhsIcurPred
         _guardedexpressionsOcurrentChunk = rule4730 _lhsIcurrentChunk
         _guardedexpressionsOdictionaryEnvironment = rule4731 _lhsIdictionaryEnvironment
         _guardedexpressionsOimportEnvironment = rule4732 _lhsIimportEnvironment
         _guardedexpressionsOinstanceName = rule4733 _lhsIinstanceName
         _guardedexpressionsOinstanceTypes = rule4734 _lhsIinstanceTypes
         _guardedexpressionsOmatchIO = rule4735 _lhsImatchIO
         _guardedexpressionsOmoduleName = rule4736 _lhsImoduleName
         _guardedexpressionsOmonos = rule4737 _lhsImonos
         _guardedexpressionsOorderedTypeSynonyms = rule4738 _lhsIorderedTypeSynonyms
         _guardedexpressionsOparentTree = rule4739 _parentTree
         _guardedexpressionsOpatternMatchWarnings = rule4740 _lhsIpatternMatchWarnings
         _guardedexpressionsOrequiredPredicates = rule4741 _lhsIrequiredPredicates
         _guardedexpressionsOsubstitution = rule4742 _lhsIsubstitution
         _guardedexpressionsOtypeConstructors = rule4743 _lhsItypeConstructors
         _guardedexpressionsOtypeschemeMap = rule4744 _lhsItypeschemeMap
         _guardedexpressionsOuniqueChunk = rule4745 _lhsIuniqueChunk
         _guardedexpressionsOvariableMapping = rule4746 _lhsIvariableMapping
         _whereOallPatterns = rule4747 _lhsIallPatterns
         _whereOallTypeSchemes = rule4748 _allTypeSchemes
         _whereOambiguousConflicts = rule4749 _lhsIambiguousConflicts
         _whereOavailablePredicates = rule4750 _lhsIavailablePredicates
         _whereOclassEnvironment = rule4751 _lhsIclassEnvironment
         _whereOclassMemberEnv = rule4752 _lhsIclassMemberEnv
         _whereOclassMemberTypeSchemes = rule4753 _lhsIclassMemberTypeSchemes
         _whereOclassNamesEnv = rule4754 _lhsIclassNamesEnv
         _whereOclassPredicate = rule4755 _lhsIclassPredicate
         _whereOclassTypeSchemes = rule4756 _lhsIclassTypeSchemes
         _whereOcollectErrors = rule4757 _guardedexpressionsIcollectErrors
         _whereOcollectWarnings = rule4758 _guardedexpressionsIcollectWarnings
         _whereOcounter = rule4759 _guardedexpressionsIcounter
         _whereOcurClassPred = rule4760 _lhsIcurClassPred
         _whereOcurPred = rule4761 _lhsIcurPred
         _whereOcurrentChunk = rule4762 _lhsIcurrentChunk
         _whereOdictionaryEnvironment = rule4763 _guardedexpressionsIdictionaryEnvironment
         _whereOimportEnvironment = rule4764 _lhsIimportEnvironment
         _whereOinstanceTypes = rule4765 _lhsIinstanceTypes
         _whereOmatchIO = rule4766 _guardedexpressionsImatchIO
         _whereOmoduleName = rule4767 _lhsImoduleName
         _whereOmonos = rule4768 _lhsImonos
         _whereOnamesInScope = rule4769 _lhsInamesInScope
         _whereOorderedTypeSynonyms = rule4770 _lhsIorderedTypeSynonyms
         _whereOparentTree = rule4771 _parentTree
         _whereOpatternMatchWarnings = rule4772 _guardedexpressionsIpatternMatchWarnings
         _whereOrequiredPredicates = rule4773 _lhsIrequiredPredicates
         _whereOsubstitution = rule4774 _lhsIsubstitution
         _whereOtypeConstructors = rule4775 _lhsItypeConstructors
         _whereOtypeschemeMap = rule4776 _lhsItypeschemeMap
         _whereOuniqueChunk = rule4777 _guardedexpressionsIuniqueChunk
         _whereOvariableMapping = rule4778 _lhsIvariableMapping
         !__result_ = T_RightHandSide_vOut148 _lhsOassumptions _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraints _lhsOcounter _lhsOdictionaryEnvironment _lhsOfallthrough _lhsOinfoTree _lhsOmatchIO _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk
         in __result_ )
     in C_RightHandSide_s149 v148
   {-# INLINE rule4685 #-}
   rule4685 = \ ((_guardedexpressionsIfallthrough) :: Bool) ->
                                            _guardedexpressionsIfallthrough
   {-# INLINE rule4686 #-}
   rule4686 = \  (_ :: ()) ->
                                                    True
   {-# INLINE rule4687 #-}
   rule4687 = \ ((_guardedexpressionsIfallthrough) :: Bool) ((_rangeIself) :: Range) ((_whereIpatternMatchWarnings) :: [Warning]) ->
                                                     (if _guardedexpressionsIfallthrough then [FallThrough _rangeIself] else [])
                                                     ++ _whereIpatternMatchWarnings
   {-# INLINE rule4688 #-}
   rule4688 = \ ((_guardedexpressionsIbetaUnique) :: Int) ->
                                                _guardedexpressionsIbetaUnique
   {-# INLINE rule4689 #-}
   rule4689 = \ ((_guardedexpressionsIuniqueSecondRound) :: Int) ->
                                                _guardedexpressionsIuniqueSecondRound
   {-# INLINE rule4690 #-}
   rule4690 = \ ((_whereIunboundNames) :: Names) ->
                                                       _whereIunboundNames
   {-# INLINE rule4691 #-}
   rule4691 = \ ((_whereInamesInScope) :: Names) ->
                                                       _whereInamesInScope
   {-# INLINE rule4692 #-}
   rule4692 = \ ((_guardedexpressionsIunboundNames) :: Names) ->
                                                       _guardedexpressionsIunboundNames
   {-# INLINE rule4693 #-}
   rule4693 = \ ((_guardedexpressionsIinfoTrees) :: InfoTrees) ((_lhsIparentTree) :: InfoTree) _localInfo ((_whereIinfoTrees) :: InfoTrees) ->
                            node _lhsIparentTree _localInfo (_guardedexpressionsIinfoTrees ++ _whereIinfoTrees)
   {-# INLINE rule4694 #-}
   rule4694 = \ _parentTree ->
                            _parentTree
   {-# INLINE rule4695 #-}
   rule4695 = \ ((_lhsImonos) :: Monos) _self ->
                            LocalInfo { self = UHA_RHS _self
                                      , assignedType = Nothing
                                      , monos = _lhsImonos
                                      }
   {-# INLINE rule4696 #-}
   rule4696 = \ ((_lhsIallTypeSchemes) :: M.Map NameWithRange TpScheme) ((_whereIlocalTypes) :: M.Map NameWithRange TpScheme) ->
                                         _whereIlocalTypes `M.union` _lhsIallTypeSchemes
   {-# INLINE rule4697 #-}
   rule4697 = \ ((_whereIassumptions) :: Assumptions) ->
                                             _whereIassumptions
   {-# INLINE rule4698 #-}
   rule4698 = \ ((_whereIconstraints) :: ConstraintSet) ->
                                             _whereIconstraints
   {-# INLINE rule4699 #-}
   rule4699 = \ ((_guardedexpressionsIconstraintslist) :: ConstraintSets) ->
                                             length _guardedexpressionsIconstraintslist
   {-# INLINE rule4700 #-}
   rule4700 = \ ((_guardedexpressionsIassumptions) :: Assumptions) ->
                                             _guardedexpressionsIassumptions
   {-# INLINE rule4701 #-}
   rule4701 = \  (_ :: ()) ->
                                             Nothing
   {-# INLINE rule4702 #-}
   rule4702 = \ ((_guardedexpressionsIconstraintslist) :: ConstraintSets) ->
                                             Node _guardedexpressionsIconstraintslist
   {-# INLINE rule4703 #-}
   rule4703 = \ ((_guardedexpressionsIcollectInstances) :: [(Name, Instance)]) ((_whereIcollectInstances) :: [(Name, Instance)]) ->
     _guardedexpressionsIcollectInstances  ++  _whereIcollectInstances
   {-# INLINE rule4704 #-}
   rule4704 = \ ((_guardedexpressionsIself) :: GuardedExpressions) ((_rangeIself) :: Range) ((_whereIself) :: MaybeDeclarations) ->
     RightHandSide_Guarded _rangeIself _guardedexpressionsIself _whereIself
   {-# INLINE rule4705 #-}
   rule4705 = \ _self ->
     _self
   {-# INLINE rule4706 #-}
   rule4706 = \ ((_whereIbetaUnique) :: Int) ->
     _whereIbetaUnique
   {-# INLINE rule4707 #-}
   rule4707 = \ ((_whereIcollectErrors) :: TypeErrors) ->
     _whereIcollectErrors
   {-# INLINE rule4708 #-}
   rule4708 = \ ((_whereIcollectWarnings) :: Warnings) ->
     _whereIcollectWarnings
   {-# INLINE rule4709 #-}
   rule4709 = \ ((_whereIcounter) :: Int) ->
     _whereIcounter
   {-# INLINE rule4710 #-}
   rule4710 = \ ((_whereIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _whereIdictionaryEnvironment
   {-# INLINE rule4711 #-}
   rule4711 = \ ((_whereImatchIO) :: IO ()) ->
     _whereImatchIO
   {-# INLINE rule4712 #-}
   rule4712 = \ ((_whereIuniqueChunk) :: Int) ->
     _whereIuniqueChunk
   {-# INLINE rule4713 #-}
   rule4713 = \ ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ->
     _lhsIallPatterns
   {-# INLINE rule4714 #-}
   rule4714 = \ _allTypeSchemes ->
     _allTypeSchemes
   {-# INLINE rule4715 #-}
   rule4715 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule4716 #-}
   rule4716 = \ ((_lhsIavailablePredicates) :: [PredicateWithSource]) ->
     _lhsIavailablePredicates
   {-# INLINE rule4717 #-}
   rule4717 = \ ((_lhsIbetaRight) :: Tp) ->
     _lhsIbetaRight
   {-# INLINE rule4718 #-}
   rule4718 = \ ((_lhsIbetaUnique) :: Int) ->
     _lhsIbetaUnique
   {-# INLINE rule4719 #-}
   rule4719 = \ ((_lhsIclassEnvironment) :: ClassEnvironment) ->
     _lhsIclassEnvironment
   {-# INLINE rule4720 #-}
   rule4720 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule4721 #-}
   rule4721 = \ ((_lhsIclassMemberTypeSchemes) :: Maybe [(Name, TpScheme)]) ->
     _lhsIclassMemberTypeSchemes
   {-# INLINE rule4722 #-}
   rule4722 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule4723 #-}
   rule4723 = \ ((_lhsIclassPredicate) :: Maybe (Name, Names)) ->
     _lhsIclassPredicate
   {-# INLINE rule4724 #-}
   rule4724 = \ ((_lhsIclassTypeSchemes) :: M.Map Name TpScheme) ->
     _lhsIclassTypeSchemes
   {-# INLINE rule4725 #-}
   rule4725 = \ ((_lhsIcollectErrors) :: TypeErrors) ->
     _lhsIcollectErrors
   {-# INLINE rule4726 #-}
   rule4726 = \ ((_lhsIcollectWarnings) :: Warnings) ->
     _lhsIcollectWarnings
   {-# INLINE rule4727 #-}
   rule4727 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule4728 #-}
   rule4728 = \ ((_lhsIcurClassPred) :: Maybe Predicate) ->
     _lhsIcurClassPred
   {-# INLINE rule4729 #-}
   rule4729 = \ ((_lhsIcurPred) :: Maybe Predicate) ->
     _lhsIcurPred
   {-# INLINE rule4730 #-}
   rule4730 = \ ((_lhsIcurrentChunk) :: Int) ->
     _lhsIcurrentChunk
   {-# INLINE rule4731 #-}
   rule4731 = \ ((_lhsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _lhsIdictionaryEnvironment
   {-# INLINE rule4732 #-}
   rule4732 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule4733 #-}
   rule4733 = \ ((_lhsIinstanceName) :: Maybe Name) ->
     _lhsIinstanceName
   {-# INLINE rule4734 #-}
   rule4734 = \ ((_lhsIinstanceTypes) :: [(Name, TpScheme)]) ->
     _lhsIinstanceTypes
   {-# INLINE rule4735 #-}
   rule4735 = \ ((_lhsImatchIO) :: IO ()) ->
     _lhsImatchIO
   {-# INLINE rule4736 #-}
   rule4736 = \ ((_lhsImoduleName) :: Maybe Name) ->
     _lhsImoduleName
   {-# INLINE rule4737 #-}
   rule4737 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule4738 #-}
   rule4738 = \ ((_lhsIorderedTypeSynonyms) :: OrderedTypeSynonyms) ->
     _lhsIorderedTypeSynonyms
   {-# INLINE rule4739 #-}
   rule4739 = \ _parentTree ->
     _parentTree
   {-# INLINE rule4740 #-}
   rule4740 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule4741 #-}
   rule4741 = \ ((_lhsIrequiredPredicates) :: Predicates) ->
     _lhsIrequiredPredicates
   {-# INLINE rule4742 #-}
   rule4742 = \ ((_lhsIsubstitution) :: FixpointSubstitution) ->
     _lhsIsubstitution
   {-# INLINE rule4743 #-}
   rule4743 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
   {-# INLINE rule4744 #-}
   rule4744 = \ ((_lhsItypeschemeMap) :: M.Map Int (Scheme Predicates)) ->
     _lhsItypeschemeMap
   {-# INLINE rule4745 #-}
   rule4745 = \ ((_lhsIuniqueChunk) :: Int) ->
     _lhsIuniqueChunk
   {-# INLINE rule4746 #-}
   rule4746 = \ ((_lhsIvariableMapping) :: Maybe [(Name, Tp)]) ->
     _lhsIvariableMapping
   {-# INLINE rule4747 #-}
   rule4747 = \ ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ->
     _lhsIallPatterns
   {-# INLINE rule4748 #-}
   rule4748 = \ _allTypeSchemes ->
     _allTypeSchemes
   {-# INLINE rule4749 #-}
   rule4749 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule4750 #-}
   rule4750 = \ ((_lhsIavailablePredicates) :: [PredicateWithSource]) ->
     _lhsIavailablePredicates
   {-# INLINE rule4751 #-}
   rule4751 = \ ((_lhsIclassEnvironment) :: ClassEnvironment) ->
     _lhsIclassEnvironment
   {-# INLINE rule4752 #-}
   rule4752 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule4753 #-}
   rule4753 = \ ((_lhsIclassMemberTypeSchemes) :: Maybe [(Name, TpScheme)]) ->
     _lhsIclassMemberTypeSchemes
   {-# INLINE rule4754 #-}
   rule4754 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule4755 #-}
   rule4755 = \ ((_lhsIclassPredicate) :: Maybe (Name, Names)) ->
     _lhsIclassPredicate
   {-# INLINE rule4756 #-}
   rule4756 = \ ((_lhsIclassTypeSchemes) :: M.Map Name TpScheme) ->
     _lhsIclassTypeSchemes
   {-# INLINE rule4757 #-}
   rule4757 = \ ((_guardedexpressionsIcollectErrors) :: TypeErrors) ->
     _guardedexpressionsIcollectErrors
   {-# INLINE rule4758 #-}
   rule4758 = \ ((_guardedexpressionsIcollectWarnings) :: Warnings) ->
     _guardedexpressionsIcollectWarnings
   {-# INLINE rule4759 #-}
   rule4759 = \ ((_guardedexpressionsIcounter) :: Int) ->
     _guardedexpressionsIcounter
   {-# INLINE rule4760 #-}
   rule4760 = \ ((_lhsIcurClassPred) :: Maybe Predicate) ->
     _lhsIcurClassPred
   {-# INLINE rule4761 #-}
   rule4761 = \ ((_lhsIcurPred) :: Maybe Predicate) ->
     _lhsIcurPred
   {-# INLINE rule4762 #-}
   rule4762 = \ ((_lhsIcurrentChunk) :: Int) ->
     _lhsIcurrentChunk
   {-# INLINE rule4763 #-}
   rule4763 = \ ((_guardedexpressionsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _guardedexpressionsIdictionaryEnvironment
   {-# INLINE rule4764 #-}
   rule4764 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule4765 #-}
   rule4765 = \ ((_lhsIinstanceTypes) :: [(Name, TpScheme)]) ->
     _lhsIinstanceTypes
   {-# INLINE rule4766 #-}
   rule4766 = \ ((_guardedexpressionsImatchIO) :: IO ()) ->
     _guardedexpressionsImatchIO
   {-# INLINE rule4767 #-}
   rule4767 = \ ((_lhsImoduleName) :: Maybe Name) ->
     _lhsImoduleName
   {-# INLINE rule4768 #-}
   rule4768 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule4769 #-}
   rule4769 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule4770 #-}
   rule4770 = \ ((_lhsIorderedTypeSynonyms) :: OrderedTypeSynonyms) ->
     _lhsIorderedTypeSynonyms
   {-# INLINE rule4771 #-}
   rule4771 = \ _parentTree ->
     _parentTree
   {-# INLINE rule4772 #-}
   rule4772 = \ ((_guardedexpressionsIpatternMatchWarnings) :: [Warning]) ->
     _guardedexpressionsIpatternMatchWarnings
   {-# INLINE rule4773 #-}
   rule4773 = \ ((_lhsIrequiredPredicates) :: Predicates) ->
     _lhsIrequiredPredicates
   {-# INLINE rule4774 #-}
   rule4774 = \ ((_lhsIsubstitution) :: FixpointSubstitution) ->
     _lhsIsubstitution
   {-# INLINE rule4775 #-}
   rule4775 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
   {-# INLINE rule4776 #-}
   rule4776 = \ ((_lhsItypeschemeMap) :: M.Map Int (Scheme Predicates)) ->
     _lhsItypeschemeMap
   {-# INLINE rule4777 #-}
   rule4777 = \ ((_guardedexpressionsIuniqueChunk) :: Int) ->
     _guardedexpressionsIuniqueChunk
   {-# INLINE rule4778 #-}
   rule4778 = \ ((_lhsIvariableMapping) :: Maybe [(Name, Tp)]) ->
     _lhsIvariableMapping

-- SimpleType --------------------------------------------------
-- wrapper
data Inh_SimpleType  = Inh_SimpleType {  }
data Syn_SimpleType  = Syn_SimpleType { name_Syn_SimpleType :: !(Name), self_Syn_SimpleType :: !(SimpleType), typevariables_Syn_SimpleType :: !(Names) }
{-# INLINABLE wrap_SimpleType #-}
wrap_SimpleType :: T_SimpleType  -> Inh_SimpleType  -> (Syn_SimpleType )
wrap_SimpleType !(T_SimpleType act) !(Inh_SimpleType ) =
   Control.Monad.Identity.runIdentity (
     do !sem <- act
        let arg151 = T_SimpleType_vIn151 
        !(T_SimpleType_vOut151 _lhsOname _lhsOself _lhsOtypevariables) <- return (inv_SimpleType_s152 sem arg151)
        return (Syn_SimpleType _lhsOname _lhsOself _lhsOtypevariables)
   )

-- cata
{-# INLINE sem_SimpleType #-}
sem_SimpleType :: SimpleType  -> T_SimpleType 
sem_SimpleType ( SimpleType_SimpleType range_ name_ typevariables_ ) = sem_SimpleType_SimpleType ( sem_Range range_ ) ( sem_Name name_ ) ( sem_Names typevariables_ )

-- semantic domain
newtype T_SimpleType  = T_SimpleType {
                                     attach_T_SimpleType :: Identity (T_SimpleType_s152 )
                                     }
newtype T_SimpleType_s152  = C_SimpleType_s152 {
                                               inv_SimpleType_s152 :: (T_SimpleType_v151 )
                                               }
data T_SimpleType_s153  = C_SimpleType_s153
type T_SimpleType_v151  = (T_SimpleType_vIn151 ) -> (T_SimpleType_vOut151 )
data T_SimpleType_vIn151  = T_SimpleType_vIn151 
data T_SimpleType_vOut151  = T_SimpleType_vOut151 (Name) (SimpleType) (Names)
{-# NOINLINE sem_SimpleType_SimpleType #-}
sem_SimpleType_SimpleType :: T_Range  -> T_Name  -> T_Names  -> T_SimpleType 
sem_SimpleType_SimpleType arg_range_ arg_name_ arg_typevariables_ = T_SimpleType (return st152) where
   {-# NOINLINE st152 #-}
   !st152 = let
      v151 :: T_SimpleType_v151 
      v151 = \ !(T_SimpleType_vIn151 ) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _nameX113 = Control.Monad.Identity.runIdentity (attach_T_Name (arg_name_))
         _typevariablesX116 = Control.Monad.Identity.runIdentity (attach_T_Names (arg_typevariables_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_Name_vOut112 _nameIself) = inv_Name_s113 _nameX113 (T_Name_vIn112 )
         (T_Names_vOut115 _typevariablesIself) = inv_Names_s116 _typevariablesX116 (T_Names_vIn115 )
         _lhsOname :: Name
         _lhsOname = rule4779 _nameIself
         _lhsOtypevariables :: Names
         _lhsOtypevariables = rule4780 _typevariablesIself
         _self = rule4781 _nameIself _rangeIself _typevariablesIself
         _lhsOself :: SimpleType
         _lhsOself = rule4782 _self
         !__result_ = T_SimpleType_vOut151 _lhsOname _lhsOself _lhsOtypevariables
         in __result_ )
     in C_SimpleType_s152 v151
   {-# INLINE rule4779 #-}
   rule4779 = \ ((_nameIself) :: Name) ->
                                        _nameIself
   {-# INLINE rule4780 #-}
   rule4780 = \ ((_typevariablesIself) :: Names) ->
                                        _typevariablesIself
   {-# INLINE rule4781 #-}
   rule4781 = \ ((_nameIself) :: Name) ((_rangeIself) :: Range) ((_typevariablesIself) :: Names) ->
     SimpleType_SimpleType _rangeIself _nameIself _typevariablesIself
   {-# INLINE rule4782 #-}
   rule4782 = \ _self ->
     _self

-- Statement ---------------------------------------------------
-- wrapper
data Inh_Statement  = Inh_Statement { allPatterns_Inh_Statement :: !([((Expression, [String]), Core_TypingStrategy)]), allTypeSchemes_Inh_Statement :: !(M.Map NameWithRange TpScheme), ambiguousConflicts_Inh_Statement :: !([[Name]]), assumptions_Inh_Statement :: !(Assumptions), availablePredicates_Inh_Statement :: !([PredicateWithSource]), betaUnique_Inh_Statement :: !(Int), classEnvironment_Inh_Statement :: !(ClassEnvironment), classMemberEnv_Inh_Statement :: !(ClassMemberEnvironment), classMemberTypeSchemes_Inh_Statement :: !(Maybe [(Name, TpScheme)]), classNamesEnv_Inh_Statement :: !(ClassNameEnvironment), classPredicate_Inh_Statement :: !(Maybe (Name, Names)), classTypeSchemes_Inh_Statement :: !(M.Map Name TpScheme), collectErrors_Inh_Statement :: !(TypeErrors), collectWarnings_Inh_Statement :: !(Warnings), constraints_Inh_Statement :: !(ConstraintSet), counter_Inh_Statement :: !(Int), curClassPred_Inh_Statement :: !(Maybe Predicate), curPred_Inh_Statement :: !(Maybe Predicate), currentChunk_Inh_Statement :: !(Int), dictionaryEnvironment_Inh_Statement :: !(DictionaryEnvironment), generatorBeta_Inh_Statement :: !(Maybe Tp), importEnvironment_Inh_Statement :: !(ImportEnvironment), instanceName_Inh_Statement :: !(Maybe Name), instanceTypes_Inh_Statement :: !([(Name, TpScheme)]), matchIO_Inh_Statement :: !(IO ()), moduleName_Inh_Statement :: !(Maybe Name), monadBeta_Inh_Statement :: !(Tp), monos_Inh_Statement :: !(Monos), namesInScope_Inh_Statement :: !(Names), orderedTypeSynonyms_Inh_Statement :: !(OrderedTypeSynonyms), parentTree_Inh_Statement :: !(InfoTree), patternMatchWarnings_Inh_Statement :: !([Warning]), requiredPredicates_Inh_Statement :: !(Predicates), substitution_Inh_Statement :: !(FixpointSubstitution), typeConstructors_Inh_Statement :: !(TypeConstructorEnvironment), typeschemeMap_Inh_Statement :: !(M.Map Int (Scheme Predicates)), unboundNames_Inh_Statement :: !(Names), uniqueChunk_Inh_Statement :: !(Int), uniqueSecondRound_Inh_Statement :: !(Int), variableMapping_Inh_Statement :: !(Maybe [(Name, Tp)]) }
data Syn_Statement  = Syn_Statement { assumptions_Syn_Statement :: !(Assumptions), betaUnique_Syn_Statement :: !(Int), collectErrors_Syn_Statement :: !(TypeErrors), collectInstances_Syn_Statement :: !([(Name, Instance)]), collectWarnings_Syn_Statement :: !(Warnings), constraints_Syn_Statement :: !(ConstraintSet), counter_Syn_Statement :: !(Int), dictionaryEnvironment_Syn_Statement :: !(DictionaryEnvironment), generatorBeta_Syn_Statement :: !(Maybe Tp), infoTree_Syn_Statement :: !(InfoTree), matchIO_Syn_Statement :: !(IO ()), monos_Syn_Statement :: !(Monos), namesInScope_Syn_Statement :: !(Names), patternMatchWarnings_Syn_Statement :: !([Warning]), self_Syn_Statement :: !(Statement), unboundNames_Syn_Statement :: !(Names), uniqueChunk_Syn_Statement :: !(Int), uniqueSecondRound_Syn_Statement :: !(Int) }
{-# INLINABLE wrap_Statement #-}
wrap_Statement :: T_Statement  -> Inh_Statement  -> (Syn_Statement )
wrap_Statement !(T_Statement act) !(Inh_Statement _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIassumptions _lhsIavailablePredicates _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIconstraints _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIgeneratorBeta _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonadBeta _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeConstructors _lhsItypeschemeMap _lhsIunboundNames _lhsIuniqueChunk _lhsIuniqueSecondRound _lhsIvariableMapping) =
   Control.Monad.Identity.runIdentity (
     do !sem <- act
        let arg154 = T_Statement_vIn154 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIassumptions _lhsIavailablePredicates _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIconstraints _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIgeneratorBeta _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonadBeta _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeConstructors _lhsItypeschemeMap _lhsIunboundNames _lhsIuniqueChunk _lhsIuniqueSecondRound _lhsIvariableMapping
        !(T_Statement_vOut154 _lhsOassumptions _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraints _lhsOcounter _lhsOdictionaryEnvironment _lhsOgeneratorBeta _lhsOinfoTree _lhsOmatchIO _lhsOmonos _lhsOnamesInScope _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOuniqueSecondRound) <- return (inv_Statement_s155 sem arg154)
        return (Syn_Statement _lhsOassumptions _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraints _lhsOcounter _lhsOdictionaryEnvironment _lhsOgeneratorBeta _lhsOinfoTree _lhsOmatchIO _lhsOmonos _lhsOnamesInScope _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOuniqueSecondRound)
   )

-- cata
{-# NOINLINE sem_Statement #-}
sem_Statement :: Statement  -> T_Statement 
sem_Statement ( Statement_Expression range_ expression_ ) = sem_Statement_Expression ( sem_Range range_ ) ( sem_Expression expression_ )
sem_Statement ( Statement_Let range_ declarations_ ) = sem_Statement_Let ( sem_Range range_ ) ( sem_Declarations declarations_ )
sem_Statement ( Statement_Generator range_ pattern_ expression_ ) = sem_Statement_Generator ( sem_Range range_ ) ( sem_Pattern pattern_ ) ( sem_Expression expression_ )
sem_Statement ( Statement_Empty range_ ) = sem_Statement_Empty ( sem_Range range_ )

-- semantic domain
newtype T_Statement  = T_Statement {
                                   attach_T_Statement :: Identity (T_Statement_s155 )
                                   }
newtype T_Statement_s155  = C_Statement_s155 {
                                             inv_Statement_s155 :: (T_Statement_v154 )
                                             }
data T_Statement_s156  = C_Statement_s156
type T_Statement_v154  = (T_Statement_vIn154 ) -> (T_Statement_vOut154 )
data T_Statement_vIn154  = T_Statement_vIn154 ([((Expression, [String]), Core_TypingStrategy)]) (M.Map NameWithRange TpScheme) ([[Name]]) (Assumptions) ([PredicateWithSource]) (Int) (ClassEnvironment) (ClassMemberEnvironment) (Maybe [(Name, TpScheme)]) (ClassNameEnvironment) (Maybe (Name, Names)) (M.Map Name TpScheme) (TypeErrors) (Warnings) (ConstraintSet) (Int) (Maybe Predicate) (Maybe Predicate) (Int) (DictionaryEnvironment) (Maybe Tp) (ImportEnvironment) (Maybe Name) ([(Name, TpScheme)]) (IO ()) (Maybe Name) (Tp) (Monos) (Names) (OrderedTypeSynonyms) (InfoTree) ([Warning]) (Predicates) (FixpointSubstitution) (TypeConstructorEnvironment) (M.Map Int (Scheme Predicates)) (Names) (Int) (Int) (Maybe [(Name, Tp)])
data T_Statement_vOut154  = T_Statement_vOut154 (Assumptions) (Int) (TypeErrors) ([(Name, Instance)]) (Warnings) (ConstraintSet) (Int) (DictionaryEnvironment) (Maybe Tp) (InfoTree) (IO ()) (Monos) (Names) ([Warning]) (Statement) (Names) (Int) (Int)
{-# NOINLINE sem_Statement_Expression #-}
sem_Statement_Expression :: T_Range  -> T_Expression  -> T_Statement 
sem_Statement_Expression arg_range_ arg_expression_ = T_Statement (return st155) where
   {-# NOINLINE st155 #-}
   !st155 = let
      v154 :: T_Statement_v154 
      v154 = \ !(T_Statement_vIn154 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIassumptions _lhsIavailablePredicates _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIconstraints _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIgeneratorBeta _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonadBeta _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeConstructors _lhsItypeschemeMap _lhsIunboundNames _lhsIuniqueChunk _lhsIuniqueSecondRound _lhsIvariableMapping) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _expressionX41 = Control.Monad.Identity.runIdentity (attach_T_Expression (arg_expression_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_Expression_vOut40 _expressionIassumptions _expressionIbeta _expressionIbetaUnique _expressionIcollectErrors _expressionIcollectInstances _expressionIcollectWarnings _expressionIconstraints _expressionIcounter _expressionIdictionaryEnvironment _expressionIinfoTree _expressionImatchIO _expressionImatches _expressionIpatternMatchWarnings _expressionIself _expressionIunboundNames _expressionIuniqueChunk _expressionIuniqueSecondRound) = inv_Expression_s41 _expressionX41 (T_Expression_vIn40 _expressionOallPatterns _expressionOallTypeSchemes _expressionOambiguousConflicts _expressionOavailablePredicates _expressionObetaUnique _expressionOclassEnvironment _expressionOclassMemberEnv _expressionOclassMemberTypeSchemes _expressionOclassNamesEnv _expressionOclassPredicate _expressionOclassTypeSchemes _expressionOcollectErrors _expressionOcollectWarnings _expressionOcounter _expressionOcurClassPred _expressionOcurPred _expressionOcurrentChunk _expressionOdictionaryEnvironment _expressionOimportEnvironment _expressionOinstanceName _expressionOinstanceTypes _expressionOmatchIO _expressionOmoduleName _expressionOmonos _expressionOnamesInScope _expressionOorderedTypeSynonyms _expressionOparentTree _expressionOpatternMatchWarnings _expressionOrequiredPredicates _expressionOsubstitution _expressionOtryPatterns _expressionOtypeConstructors _expressionOtypeschemeMap _expressionOuniqueChunk _expressionOuniqueSecondRound _expressionOvariableMapping)
         _expressionOtryPatterns = rule4783  ()
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule4784 _expressionIunboundNames _lhsIunboundNames
         _parentTree = rule4785 _expressionIinfoTree _lhsIparentTree _localInfo
         _lhsOinfoTree :: InfoTree
         _lhsOinfoTree = rule4786 _parentTree
         _localInfo = rule4787 _lhsImonos _self
         _cinfo = rule4788 _parentTree
         _lhsOgeneratorBeta :: Maybe Tp
         _lhsOgeneratorBeta = rule4789 _beta
         _lhsOassumptions :: Assumptions
         _lhsOassumptions = rule4790 _expressionIassumptions _lhsIassumptions
         _lhsOconstraints :: ConstraintSet
         _lhsOconstraints = rule4791 _locConstraints
         _expressionObetaUnique = rule4792 _lhsIbetaUnique
         _locConstraints = rule4793 _expressionIconstraints _lhsIconstraints _newcon
         _beta = rule4794 _lhsIbetaUnique
         _betaRes = rule4795 _lhsIbetaUnique
         _newcon = rule4796 _beta _betaRes _cinfo _expressionIbeta _lhsImonadBeta
         _lhsOcollectInstances :: [(Name, Instance)]
         _lhsOcollectInstances = rule4797 _expressionIcollectInstances
         _self = rule4798 _expressionIself _rangeIself
         _lhsOself :: Statement
         _lhsOself = rule4799 _self
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule4800 _expressionIbetaUnique
         _lhsOcollectErrors :: TypeErrors
         _lhsOcollectErrors = rule4801 _expressionIcollectErrors
         _lhsOcollectWarnings :: Warnings
         _lhsOcollectWarnings = rule4802 _expressionIcollectWarnings
         _lhsOcounter :: Int
         _lhsOcounter = rule4803 _expressionIcounter
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule4804 _expressionIdictionaryEnvironment
         _lhsOmatchIO :: IO ()
         _lhsOmatchIO = rule4805 _expressionImatchIO
         _lhsOmonos :: Monos
         _lhsOmonos = rule4806 _lhsImonos
         _lhsOnamesInScope :: Names
         _lhsOnamesInScope = rule4807 _lhsInamesInScope
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule4808 _expressionIpatternMatchWarnings
         _lhsOuniqueChunk :: Int
         _lhsOuniqueChunk = rule4809 _expressionIuniqueChunk
         _lhsOuniqueSecondRound :: Int
         _lhsOuniqueSecondRound = rule4810 _expressionIuniqueSecondRound
         _expressionOallPatterns = rule4811 _lhsIallPatterns
         _expressionOallTypeSchemes = rule4812 _lhsIallTypeSchemes
         _expressionOambiguousConflicts = rule4813 _lhsIambiguousConflicts
         _expressionOavailablePredicates = rule4814 _lhsIavailablePredicates
         _expressionOclassEnvironment = rule4815 _lhsIclassEnvironment
         _expressionOclassMemberEnv = rule4816 _lhsIclassMemberEnv
         _expressionOclassMemberTypeSchemes = rule4817 _lhsIclassMemberTypeSchemes
         _expressionOclassNamesEnv = rule4818 _lhsIclassNamesEnv
         _expressionOclassPredicate = rule4819 _lhsIclassPredicate
         _expressionOclassTypeSchemes = rule4820 _lhsIclassTypeSchemes
         _expressionOcollectErrors = rule4821 _lhsIcollectErrors
         _expressionOcollectWarnings = rule4822 _lhsIcollectWarnings
         _expressionOcounter = rule4823 _lhsIcounter
         _expressionOcurClassPred = rule4824 _lhsIcurClassPred
         _expressionOcurPred = rule4825 _lhsIcurPred
         _expressionOcurrentChunk = rule4826 _lhsIcurrentChunk
         _expressionOdictionaryEnvironment = rule4827 _lhsIdictionaryEnvironment
         _expressionOimportEnvironment = rule4828 _lhsIimportEnvironment
         _expressionOinstanceName = rule4829 _lhsIinstanceName
         _expressionOinstanceTypes = rule4830 _lhsIinstanceTypes
         _expressionOmatchIO = rule4831 _lhsImatchIO
         _expressionOmoduleName = rule4832 _lhsImoduleName
         _expressionOmonos = rule4833 _lhsImonos
         _expressionOnamesInScope = rule4834 _lhsInamesInScope
         _expressionOorderedTypeSynonyms = rule4835 _lhsIorderedTypeSynonyms
         _expressionOparentTree = rule4836 _parentTree
         _expressionOpatternMatchWarnings = rule4837 _lhsIpatternMatchWarnings
         _expressionOrequiredPredicates = rule4838 _lhsIrequiredPredicates
         _expressionOsubstitution = rule4839 _lhsIsubstitution
         _expressionOtypeConstructors = rule4840 _lhsItypeConstructors
         _expressionOtypeschemeMap = rule4841 _lhsItypeschemeMap
         _expressionOuniqueChunk = rule4842 _lhsIuniqueChunk
         _expressionOuniqueSecondRound = rule4843 _lhsIuniqueSecondRound
         _expressionOvariableMapping = rule4844 _lhsIvariableMapping
         !__result_ = T_Statement_vOut154 _lhsOassumptions _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraints _lhsOcounter _lhsOdictionaryEnvironment _lhsOgeneratorBeta _lhsOinfoTree _lhsOmatchIO _lhsOmonos _lhsOnamesInScope _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOuniqueSecondRound
         in __result_ )
     in C_Statement_s155 v154
   {-# INLINE rule4783 #-}
   rule4783 = \  (_ :: ()) ->
                                                     []
   {-# INLINE rule4784 #-}
   rule4784 = \ ((_expressionIunboundNames) :: Names) ((_lhsIunboundNames) :: Names) ->
                                              _expressionIunboundNames ++ _lhsIunboundNames
   {-# INLINE rule4785 #-}
   rule4785 = \ ((_expressionIinfoTree) :: InfoTree) ((_lhsIparentTree) :: InfoTree) _localInfo ->
                            node _lhsIparentTree _localInfo [_expressionIinfoTree]
   {-# INLINE rule4786 #-}
   rule4786 = \ _parentTree ->
                            _parentTree
   {-# INLINE rule4787 #-}
   rule4787 = \ ((_lhsImonos) :: Monos) _self ->
                            LocalInfo { self = UHA_Stat _self
                                      , assignedType = Nothing
                                      , monos = _lhsImonos
                                      }
   {-# INLINE rule4788 #-}
   rule4788 = \ _parentTree ->
     orphanConstraint 0 "generator" _parentTree
        []
   {-# INLINE rule4789 #-}
   rule4789 = \ _beta ->
                                      Just _beta
   {-# INLINE rule4790 #-}
   rule4790 = \ ((_expressionIassumptions) :: Assumptions) ((_lhsIassumptions) :: Assumptions) ->
                                      _lhsIassumptions `combine` _expressionIassumptions
   {-# INLINE rule4791 #-}
   rule4791 = \ _locConstraints ->
                                      _locConstraints
   {-# INLINE rule4792 #-}
   rule4792 = \ ((_lhsIbetaUnique) :: Int) ->
                                      _lhsIbetaUnique + 2
   {-# INLINE rule4793 #-}
   rule4793 = \ ((_expressionIconstraints) :: ConstraintSet) ((_lhsIconstraints) :: ConstraintSet) _newcon ->
                                      Node [ _newcon .<. _expressionIconstraints
                                           , _lhsIconstraints
                                           ]
   {-# INLINE rule4794 #-}
   rule4794 = \ ((_lhsIbetaUnique) :: Int) ->
                                      TVar _lhsIbetaUnique
   {-# INLINE rule4795 #-}
   rule4795 = \ ((_lhsIbetaUnique) :: Int) ->
                                      TVar $ _lhsIbetaUnique + 1
   {-# INLINE rule4796 #-}
   rule4796 = \ _beta _betaRes _cinfo ((_expressionIbeta) :: Tp) ((_lhsImonadBeta) :: Tp) ->
                                      [ (_expressionIbeta .==. _beta) _cinfo, (_beta .==. TApp _lhsImonadBeta _betaRes) _cinfo]
   {-# INLINE rule4797 #-}
   rule4797 = \ ((_expressionIcollectInstances) :: [(Name, Instance)]) ->
     _expressionIcollectInstances
   {-# INLINE rule4798 #-}
   rule4798 = \ ((_expressionIself) :: Expression) ((_rangeIself) :: Range) ->
     Statement_Expression _rangeIself _expressionIself
   {-# INLINE rule4799 #-}
   rule4799 = \ _self ->
     _self
   {-# INLINE rule4800 #-}
   rule4800 = \ ((_expressionIbetaUnique) :: Int) ->
     _expressionIbetaUnique
   {-# INLINE rule4801 #-}
   rule4801 = \ ((_expressionIcollectErrors) :: TypeErrors) ->
     _expressionIcollectErrors
   {-# INLINE rule4802 #-}
   rule4802 = \ ((_expressionIcollectWarnings) :: Warnings) ->
     _expressionIcollectWarnings
   {-# INLINE rule4803 #-}
   rule4803 = \ ((_expressionIcounter) :: Int) ->
     _expressionIcounter
   {-# INLINE rule4804 #-}
   rule4804 = \ ((_expressionIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _expressionIdictionaryEnvironment
   {-# INLINE rule4805 #-}
   rule4805 = \ ((_expressionImatchIO) :: IO ()) ->
     _expressionImatchIO
   {-# INLINE rule4806 #-}
   rule4806 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule4807 #-}
   rule4807 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule4808 #-}
   rule4808 = \ ((_expressionIpatternMatchWarnings) :: [Warning]) ->
     _expressionIpatternMatchWarnings
   {-# INLINE rule4809 #-}
   rule4809 = \ ((_expressionIuniqueChunk) :: Int) ->
     _expressionIuniqueChunk
   {-# INLINE rule4810 #-}
   rule4810 = \ ((_expressionIuniqueSecondRound) :: Int) ->
     _expressionIuniqueSecondRound
   {-# INLINE rule4811 #-}
   rule4811 = \ ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ->
     _lhsIallPatterns
   {-# INLINE rule4812 #-}
   rule4812 = \ ((_lhsIallTypeSchemes) :: M.Map NameWithRange TpScheme) ->
     _lhsIallTypeSchemes
   {-# INLINE rule4813 #-}
   rule4813 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule4814 #-}
   rule4814 = \ ((_lhsIavailablePredicates) :: [PredicateWithSource]) ->
     _lhsIavailablePredicates
   {-# INLINE rule4815 #-}
   rule4815 = \ ((_lhsIclassEnvironment) :: ClassEnvironment) ->
     _lhsIclassEnvironment
   {-# INLINE rule4816 #-}
   rule4816 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule4817 #-}
   rule4817 = \ ((_lhsIclassMemberTypeSchemes) :: Maybe [(Name, TpScheme)]) ->
     _lhsIclassMemberTypeSchemes
   {-# INLINE rule4818 #-}
   rule4818 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule4819 #-}
   rule4819 = \ ((_lhsIclassPredicate) :: Maybe (Name, Names)) ->
     _lhsIclassPredicate
   {-# INLINE rule4820 #-}
   rule4820 = \ ((_lhsIclassTypeSchemes) :: M.Map Name TpScheme) ->
     _lhsIclassTypeSchemes
   {-# INLINE rule4821 #-}
   rule4821 = \ ((_lhsIcollectErrors) :: TypeErrors) ->
     _lhsIcollectErrors
   {-# INLINE rule4822 #-}
   rule4822 = \ ((_lhsIcollectWarnings) :: Warnings) ->
     _lhsIcollectWarnings
   {-# INLINE rule4823 #-}
   rule4823 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule4824 #-}
   rule4824 = \ ((_lhsIcurClassPred) :: Maybe Predicate) ->
     _lhsIcurClassPred
   {-# INLINE rule4825 #-}
   rule4825 = \ ((_lhsIcurPred) :: Maybe Predicate) ->
     _lhsIcurPred
   {-# INLINE rule4826 #-}
   rule4826 = \ ((_lhsIcurrentChunk) :: Int) ->
     _lhsIcurrentChunk
   {-# INLINE rule4827 #-}
   rule4827 = \ ((_lhsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _lhsIdictionaryEnvironment
   {-# INLINE rule4828 #-}
   rule4828 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule4829 #-}
   rule4829 = \ ((_lhsIinstanceName) :: Maybe Name) ->
     _lhsIinstanceName
   {-# INLINE rule4830 #-}
   rule4830 = \ ((_lhsIinstanceTypes) :: [(Name, TpScheme)]) ->
     _lhsIinstanceTypes
   {-# INLINE rule4831 #-}
   rule4831 = \ ((_lhsImatchIO) :: IO ()) ->
     _lhsImatchIO
   {-# INLINE rule4832 #-}
   rule4832 = \ ((_lhsImoduleName) :: Maybe Name) ->
     _lhsImoduleName
   {-# INLINE rule4833 #-}
   rule4833 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule4834 #-}
   rule4834 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule4835 #-}
   rule4835 = \ ((_lhsIorderedTypeSynonyms) :: OrderedTypeSynonyms) ->
     _lhsIorderedTypeSynonyms
   {-# INLINE rule4836 #-}
   rule4836 = \ _parentTree ->
     _parentTree
   {-# INLINE rule4837 #-}
   rule4837 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule4838 #-}
   rule4838 = \ ((_lhsIrequiredPredicates) :: Predicates) ->
     _lhsIrequiredPredicates
   {-# INLINE rule4839 #-}
   rule4839 = \ ((_lhsIsubstitution) :: FixpointSubstitution) ->
     _lhsIsubstitution
   {-# INLINE rule4840 #-}
   rule4840 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
   {-# INLINE rule4841 #-}
   rule4841 = \ ((_lhsItypeschemeMap) :: M.Map Int (Scheme Predicates)) ->
     _lhsItypeschemeMap
   {-# INLINE rule4842 #-}
   rule4842 = \ ((_lhsIuniqueChunk) :: Int) ->
     _lhsIuniqueChunk
   {-# INLINE rule4843 #-}
   rule4843 = \ ((_lhsIuniqueSecondRound) :: Int) ->
     _lhsIuniqueSecondRound
   {-# INLINE rule4844 #-}
   rule4844 = \ ((_lhsIvariableMapping) :: Maybe [(Name, Tp)]) ->
     _lhsIvariableMapping
{-# NOINLINE sem_Statement_Let #-}
sem_Statement_Let :: T_Range  -> T_Declarations  -> T_Statement 
sem_Statement_Let arg_range_ arg_declarations_ = T_Statement (return st155) where
   {-# NOINLINE st155 #-}
   !st155 = let
      v154 :: T_Statement_v154 
      v154 = \ !(T_Statement_vIn154 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIassumptions _lhsIavailablePredicates _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIconstraints _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIgeneratorBeta _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonadBeta _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeConstructors _lhsItypeschemeMap _lhsIunboundNames _lhsIuniqueChunk _lhsIuniqueSecondRound _lhsIvariableMapping) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _declarationsX32 = Control.Monad.Identity.runIdentity (attach_T_Declarations (arg_declarations_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_Declarations_vOut31 _declarationsIbetaUnique _declarationsIbindingGroups _declarationsIboundBetas _declarationsIclassMemberNames _declarationsIcollectErrors _declarationsIcollectInstances _declarationsIcollectWarnings _declarationsIcounter _declarationsIdeclVarNames _declarationsIdictionaryEnvironment _declarationsIinfoTrees _declarationsImatchIO _declarationsIpatternMatchWarnings _declarationsIrestrictedNames _declarationsIself _declarationsIsimplePatNames _declarationsItypeMemberBindings _declarationsItypeSignatures _declarationsIunboundNames _declarationsIuniqueChunk) = inv_Declarations_s32 _declarationsX32 (T_Declarations_vIn31 _declarationsOallPatterns _declarationsOallTypeSchemes _declarationsOambiguousConflicts _declarationsOavailablePredicates _declarationsObetaUnique _declarationsObindingGroups _declarationsOclassEnvironment _declarationsOclassMemberEnv _declarationsOclassMemberTypeSchemes _declarationsOclassNamesEnv _declarationsOclassPredicate _declarationsOclassTypeSchemes _declarationsOcollectErrors _declarationsOcollectWarnings _declarationsOcounter _declarationsOcurClassPred _declarationsOcurPred _declarationsOcurrentChunk _declarationsOdictionaryEnvironment _declarationsOimportEnvironment _declarationsOinheritedBDG _declarationsOinstanceName _declarationsOinstanceTypes _declarationsOisTopLevel _declarationsOmatchIO _declarationsOmoduleName _declarationsOmoduleQual _declarationsOmonos _declarationsOnamesInScope _declarationsOorderedTypeSynonyms _declarationsOparentTree _declarationsOpatternMatchWarnings _declarationsOrequiredPredicates _declarationsOsubstitution _declarationsOtypeConstructors _declarationsOtypeSignatures _declarationsOtypeschemeMap _declarationsOuniqueChunk _declarationsOvariableMapping)
         (_namesInScope,_unboundNames,_scopeInfo) = rule4845 _declarationsIdeclVarNames _declarationsIunboundNames _lhsInamesInScope _lhsIunboundNames
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule4846 _unboundNames
         (_collectTypeConstructors,_collectValueConstructors,_collectTypeSynonyms,_collectConstructorEnv,_derivedFunctions,_operatorFixities,_moduleQual) = rule4847  ()
         _thisTree = rule4848 _declTree _lhsIparentTree _localInfo
         _declTree = rule4849 _declInfo _declarationsIinfoTrees _thisTree
         _lhsOinfoTree :: InfoTree
         _lhsOinfoTree = rule4850 _thisTree
         _declarationsOparentTree = rule4851 _declTree
         _localInfo = rule4852 _lhsImonos _self
         _declInfo = rule4853 _declarationsIself _lhsImonos
         _inferredTypes = rule4854 _implicitsFM _lhsItypeschemeMap
         _lhsOcollectWarnings :: Warnings
         _lhsOcollectWarnings = rule4855 _declarationsIcollectWarnings _declarationsIsimplePatNames _inferredTypes _lhsIimportEnvironment
         _lhsOcollectErrors :: TypeErrors
         _lhsOcollectErrors = rule4856 _declarationsIcollectErrors _declarationsIrestrictedNames _inferredTypes _lhsIimportEnvironment
         _allTypeSchemes = rule4857 _lhsIallTypeSchemes _localTypes
         _localTypes = rule4858 _declarationsIbindingGroups _declarationsItypeSignatures _inferredTypes
         _declarationsOtypeSignatures = rule4859  ()
         _lhsOuniqueChunk :: Int
         _lhsOuniqueChunk = rule4860 _chunkNr
         _lhsOgeneratorBeta :: Maybe Tp
         _lhsOgeneratorBeta = rule4861  ()
         _declarationsObindingGroups = rule4862  ()
         _lhsOassumptions :: Assumptions
         _lhsOconstraints :: ConstraintSet
         _lhsObetaUnique :: Int
         (_lhsOassumptions,_lhsOconstraints,_inheritedBDG,_chunkNr,_lhsObetaUnique,_implicitsFM) = rule4863 _declarationsIbetaUnique _declarationsIbindingGroups _declarationsItypeSignatures _declarationsIuniqueChunk _lhsIassumptions _lhsIconstraints _lhsIcurrentChunk _lhsImonos
         _isTopLevel = rule4864  ()
         _lhsOcollectInstances :: [(Name, Instance)]
         _lhsOcollectInstances = rule4865 _declarationsIcollectInstances
         _self = rule4866 _declarationsIself _rangeIself
         _lhsOself :: Statement
         _lhsOself = rule4867 _self
         _lhsOcounter :: Int
         _lhsOcounter = rule4868 _declarationsIcounter
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule4869 _declarationsIdictionaryEnvironment
         _lhsOmatchIO :: IO ()
         _lhsOmatchIO = rule4870 _declarationsImatchIO
         _lhsOmonos :: Monos
         _lhsOmonos = rule4871 _lhsImonos
         _lhsOnamesInScope :: Names
         _lhsOnamesInScope = rule4872 _namesInScope
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule4873 _declarationsIpatternMatchWarnings
         _lhsOuniqueSecondRound :: Int
         _lhsOuniqueSecondRound = rule4874 _lhsIuniqueSecondRound
         _declarationsOallPatterns = rule4875 _lhsIallPatterns
         _declarationsOallTypeSchemes = rule4876 _allTypeSchemes
         _declarationsOambiguousConflicts = rule4877 _lhsIambiguousConflicts
         _declarationsOavailablePredicates = rule4878 _lhsIavailablePredicates
         _declarationsObetaUnique = rule4879 _lhsIbetaUnique
         _declarationsOclassEnvironment = rule4880 _lhsIclassEnvironment
         _declarationsOclassMemberEnv = rule4881 _lhsIclassMemberEnv
         _declarationsOclassMemberTypeSchemes = rule4882 _lhsIclassMemberTypeSchemes
         _declarationsOclassNamesEnv = rule4883 _lhsIclassNamesEnv
         _declarationsOclassPredicate = rule4884 _lhsIclassPredicate
         _declarationsOclassTypeSchemes = rule4885 _lhsIclassTypeSchemes
         _declarationsOcollectErrors = rule4886 _lhsIcollectErrors
         _declarationsOcollectWarnings = rule4887 _lhsIcollectWarnings
         _declarationsOcounter = rule4888 _lhsIcounter
         _declarationsOcurClassPred = rule4889 _lhsIcurClassPred
         _declarationsOcurPred = rule4890 _lhsIcurPred
         _declarationsOcurrentChunk = rule4891 _lhsIcurrentChunk
         _declarationsOdictionaryEnvironment = rule4892 _lhsIdictionaryEnvironment
         _declarationsOimportEnvironment = rule4893 _lhsIimportEnvironment
         _declarationsOinheritedBDG = rule4894 _inheritedBDG
         _declarationsOinstanceName = rule4895 _lhsIinstanceName
         _declarationsOinstanceTypes = rule4896 _lhsIinstanceTypes
         _declarationsOisTopLevel = rule4897 _isTopLevel
         _declarationsOmatchIO = rule4898 _lhsImatchIO
         _declarationsOmoduleName = rule4899 _lhsImoduleName
         _declarationsOmoduleQual = rule4900 _moduleQual
         _declarationsOmonos = rule4901 _lhsImonos
         _declarationsOnamesInScope = rule4902 _namesInScope
         _declarationsOorderedTypeSynonyms = rule4903 _lhsIorderedTypeSynonyms
         _declarationsOpatternMatchWarnings = rule4904 _lhsIpatternMatchWarnings
         _declarationsOrequiredPredicates = rule4905 _lhsIrequiredPredicates
         _declarationsOsubstitution = rule4906 _lhsIsubstitution
         _declarationsOtypeConstructors = rule4907 _lhsItypeConstructors
         _declarationsOtypeschemeMap = rule4908 _lhsItypeschemeMap
         _declarationsOuniqueChunk = rule4909 _lhsIuniqueChunk
         _declarationsOvariableMapping = rule4910 _lhsIvariableMapping
         !__result_ = T_Statement_vOut154 _lhsOassumptions _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraints _lhsOcounter _lhsOdictionaryEnvironment _lhsOgeneratorBeta _lhsOinfoTree _lhsOmatchIO _lhsOmonos _lhsOnamesInScope _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOuniqueSecondRound
         in __result_ )
     in C_Statement_s155 v154
   {-# INLINE rule4845 #-}
   rule4845 = \ ((_declarationsIdeclVarNames) :: Names) ((_declarationsIunboundNames) :: Names) ((_lhsInamesInScope) :: Names) ((_lhsIunboundNames) :: Names) ->
                                                             changeOfScope _declarationsIdeclVarNames (_declarationsIunboundNames ++ _lhsIunboundNames) _lhsInamesInScope
   {-# INLINE rule4846 #-}
   rule4846 = \ _unboundNames ->
                                              _unboundNames
   {-# INLINE rule4847 #-}
   rule4847 = \  (_ :: ()) ->
                                                                                                                                                               internalError "PartialSyntax.ag" "n/a" "toplevel Statement"
   {-# INLINE rule4848 #-}
   rule4848 = \ _declTree ((_lhsIparentTree) :: InfoTree) _localInfo ->
                            node _lhsIparentTree _localInfo [_declTree]
   {-# INLINE rule4849 #-}
   rule4849 = \ _declInfo ((_declarationsIinfoTrees) :: InfoTrees) _thisTree ->
                            node _thisTree _declInfo _declarationsIinfoTrees
   {-# INLINE rule4850 #-}
   rule4850 = \ _thisTree ->
                            _thisTree
   {-# INLINE rule4851 #-}
   rule4851 = \ _declTree ->
                                     _declTree
   {-# INLINE rule4852 #-}
   rule4852 = \ ((_lhsImonos) :: Monos) _self ->
                            LocalInfo { self = UHA_Stat _self
                                      , assignedType = Nothing
                                      , monos = _lhsImonos
                                      }
   {-# INLINE rule4853 #-}
   rule4853 = \ ((_declarationsIself) :: Declarations) ((_lhsImonos) :: Monos) ->
                          LocalInfo { self = UHA_Decls _declarationsIself
                                    , assignedType = Nothing
                                    , monos = _lhsImonos
                                    }
   {-# INLINE rule4854 #-}
   rule4854 = \ _implicitsFM ((_lhsItypeschemeMap) :: M.Map Int (Scheme Predicates)) ->
                                        findInferredTypes _lhsItypeschemeMap _implicitsFM
   {-# INLINE rule4855 #-}
   rule4855 = \ ((_declarationsIcollectWarnings) :: Warnings) ((_declarationsIsimplePatNames) :: Names) _inferredTypes ((_lhsIimportEnvironment) :: ImportEnvironment) ->
                                        missingTypeSignature False _declarationsIsimplePatNames _inferredTypes _lhsIimportEnvironment
                                        ++ _declarationsIcollectWarnings
   {-# INLINE rule4856 #-}
   rule4856 = \ ((_declarationsIcollectErrors) :: TypeErrors) ((_declarationsIrestrictedNames) :: Names) _inferredTypes ((_lhsIimportEnvironment) :: ImportEnvironment) ->
                                        restrictedNameErrors _lhsIimportEnvironment _inferredTypes _declarationsIrestrictedNames
                                        ++ _declarationsIcollectErrors
   {-# INLINE rule4857 #-}
   rule4857 = \ ((_lhsIallTypeSchemes) :: M.Map NameWithRange TpScheme) _localTypes ->
                                    _localTypes `M.union` _lhsIallTypeSchemes
   {-# INLINE rule4858 #-}
   rule4858 = \ ((_declarationsIbindingGroups) :: BindingGroups) ((_declarationsItypeSignatures) :: TypeEnvironment) _inferredTypes ->
                                    makeLocalTypeEnv (_declarationsItypeSignatures `M.union` _inferredTypes) _declarationsIbindingGroups
   {-# INLINE rule4859 #-}
   rule4859 = \  (_ :: ()) ->
                                                                  M.empty
   {-# INLINE rule4860 #-}
   rule4860 = \ _chunkNr ->
                                                     _chunkNr
   {-# INLINE rule4861 #-}
   rule4861 = \  (_ :: ()) ->
                                        Nothing
   {-# INLINE rule4862 #-}
   rule4862 = \  (_ :: ()) ->
                                        []
   {-# INLINE rule4863 #-}
   rule4863 = \ ((_declarationsIbetaUnique) :: Int) ((_declarationsIbindingGroups) :: BindingGroups) ((_declarationsItypeSignatures) :: TypeEnvironment) ((_declarationsIuniqueChunk) :: Int) ((_lhsIassumptions) :: Assumptions) ((_lhsIconstraints) :: ConstraintSet) ((_lhsIcurrentChunk) :: Int) ((_lhsImonos) :: Monos) ->
           let inputBDG    = (False, _lhsIcurrentChunk, _declarationsIuniqueChunk, _lhsImonos, _declarationsItypeSignatures, mybdggroup, _declarationsIbetaUnique)
               mybdggroup = Just (_lhsIassumptions, [_lhsIconstraints])
           in performBindingGroup inputBDG _declarationsIbindingGroups
   {-# INLINE rule4864 #-}
   rule4864 = \  (_ :: ()) ->
                               False
   {-# INLINE rule4865 #-}
   rule4865 = \ ((_declarationsIcollectInstances) :: [(Name, Instance)]) ->
     _declarationsIcollectInstances
   {-# INLINE rule4866 #-}
   rule4866 = \ ((_declarationsIself) :: Declarations) ((_rangeIself) :: Range) ->
     Statement_Let _rangeIself _declarationsIself
   {-# INLINE rule4867 #-}
   rule4867 = \ _self ->
     _self
   {-# INLINE rule4868 #-}
   rule4868 = \ ((_declarationsIcounter) :: Int) ->
     _declarationsIcounter
   {-# INLINE rule4869 #-}
   rule4869 = \ ((_declarationsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _declarationsIdictionaryEnvironment
   {-# INLINE rule4870 #-}
   rule4870 = \ ((_declarationsImatchIO) :: IO ()) ->
     _declarationsImatchIO
   {-# INLINE rule4871 #-}
   rule4871 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule4872 #-}
   rule4872 = \ _namesInScope ->
     _namesInScope
   {-# INLINE rule4873 #-}
   rule4873 = \ ((_declarationsIpatternMatchWarnings) :: [Warning]) ->
     _declarationsIpatternMatchWarnings
   {-# INLINE rule4874 #-}
   rule4874 = \ ((_lhsIuniqueSecondRound) :: Int) ->
     _lhsIuniqueSecondRound
   {-# INLINE rule4875 #-}
   rule4875 = \ ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ->
     _lhsIallPatterns
   {-# INLINE rule4876 #-}
   rule4876 = \ _allTypeSchemes ->
     _allTypeSchemes
   {-# INLINE rule4877 #-}
   rule4877 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule4878 #-}
   rule4878 = \ ((_lhsIavailablePredicates) :: [PredicateWithSource]) ->
     _lhsIavailablePredicates
   {-# INLINE rule4879 #-}
   rule4879 = \ ((_lhsIbetaUnique) :: Int) ->
     _lhsIbetaUnique
   {-# INLINE rule4880 #-}
   rule4880 = \ ((_lhsIclassEnvironment) :: ClassEnvironment) ->
     _lhsIclassEnvironment
   {-# INLINE rule4881 #-}
   rule4881 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule4882 #-}
   rule4882 = \ ((_lhsIclassMemberTypeSchemes) :: Maybe [(Name, TpScheme)]) ->
     _lhsIclassMemberTypeSchemes
   {-# INLINE rule4883 #-}
   rule4883 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule4884 #-}
   rule4884 = \ ((_lhsIclassPredicate) :: Maybe (Name, Names)) ->
     _lhsIclassPredicate
   {-# INLINE rule4885 #-}
   rule4885 = \ ((_lhsIclassTypeSchemes) :: M.Map Name TpScheme) ->
     _lhsIclassTypeSchemes
   {-# INLINE rule4886 #-}
   rule4886 = \ ((_lhsIcollectErrors) :: TypeErrors) ->
     _lhsIcollectErrors
   {-# INLINE rule4887 #-}
   rule4887 = \ ((_lhsIcollectWarnings) :: Warnings) ->
     _lhsIcollectWarnings
   {-# INLINE rule4888 #-}
   rule4888 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule4889 #-}
   rule4889 = \ ((_lhsIcurClassPred) :: Maybe Predicate) ->
     _lhsIcurClassPred
   {-# INLINE rule4890 #-}
   rule4890 = \ ((_lhsIcurPred) :: Maybe Predicate) ->
     _lhsIcurPred
   {-# INLINE rule4891 #-}
   rule4891 = \ ((_lhsIcurrentChunk) :: Int) ->
     _lhsIcurrentChunk
   {-# INLINE rule4892 #-}
   rule4892 = \ ((_lhsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _lhsIdictionaryEnvironment
   {-# INLINE rule4893 #-}
   rule4893 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule4894 #-}
   rule4894 = \ _inheritedBDG ->
     _inheritedBDG
   {-# INLINE rule4895 #-}
   rule4895 = \ ((_lhsIinstanceName) :: Maybe Name) ->
     _lhsIinstanceName
   {-# INLINE rule4896 #-}
   rule4896 = \ ((_lhsIinstanceTypes) :: [(Name, TpScheme)]) ->
     _lhsIinstanceTypes
   {-# INLINE rule4897 #-}
   rule4897 = \ _isTopLevel ->
     _isTopLevel
   {-# INLINE rule4898 #-}
   rule4898 = \ ((_lhsImatchIO) :: IO ()) ->
     _lhsImatchIO
   {-# INLINE rule4899 #-}
   rule4899 = \ ((_lhsImoduleName) :: Maybe Name) ->
     _lhsImoduleName
   {-# INLINE rule4900 #-}
   rule4900 = \ _moduleQual ->
     _moduleQual
   {-# INLINE rule4901 #-}
   rule4901 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule4902 #-}
   rule4902 = \ _namesInScope ->
     _namesInScope
   {-# INLINE rule4903 #-}
   rule4903 = \ ((_lhsIorderedTypeSynonyms) :: OrderedTypeSynonyms) ->
     _lhsIorderedTypeSynonyms
   {-# INLINE rule4904 #-}
   rule4904 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule4905 #-}
   rule4905 = \ ((_lhsIrequiredPredicates) :: Predicates) ->
     _lhsIrequiredPredicates
   {-# INLINE rule4906 #-}
   rule4906 = \ ((_lhsIsubstitution) :: FixpointSubstitution) ->
     _lhsIsubstitution
   {-# INLINE rule4907 #-}
   rule4907 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
   {-# INLINE rule4908 #-}
   rule4908 = \ ((_lhsItypeschemeMap) :: M.Map Int (Scheme Predicates)) ->
     _lhsItypeschemeMap
   {-# INLINE rule4909 #-}
   rule4909 = \ ((_lhsIuniqueChunk) :: Int) ->
     _lhsIuniqueChunk
   {-# INLINE rule4910 #-}
   rule4910 = \ ((_lhsIvariableMapping) :: Maybe [(Name, Tp)]) ->
     _lhsIvariableMapping
{-# NOINLINE sem_Statement_Generator #-}
sem_Statement_Generator :: T_Range  -> T_Pattern  -> T_Expression  -> T_Statement 
sem_Statement_Generator arg_range_ arg_pattern_ arg_expression_ = T_Statement (return st155) where
   {-# NOINLINE st155 #-}
   !st155 = let
      v154 :: T_Statement_v154 
      v154 = \ !(T_Statement_vIn154 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIassumptions _lhsIavailablePredicates _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIconstraints _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIgeneratorBeta _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonadBeta _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeConstructors _lhsItypeschemeMap _lhsIunboundNames _lhsIuniqueChunk _lhsIuniqueSecondRound _lhsIvariableMapping) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _patternX119 = Control.Monad.Identity.runIdentity (attach_T_Pattern (arg_pattern_))
         _expressionX41 = Control.Monad.Identity.runIdentity (attach_T_Expression (arg_expression_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_Pattern_vOut118 _patternIbeta _patternIbetaUnique _patternIconstraints _patternIcounter _patternIelements _patternIenvironment _patternIinfoTree _patternIpatVarNames _patternIpatternMatchWarnings _patternIself _patternIunboundNames) = inv_Pattern_s119 _patternX119 (T_Pattern_vIn118 _patternOambiguousConflicts _patternObetaUnique _patternOcounter _patternOimportEnvironment _patternOmonos _patternOnamesInScope _patternOparentTree _patternOpatternMatchWarnings _patternOtypeConstructors)
         (T_Expression_vOut40 _expressionIassumptions _expressionIbeta _expressionIbetaUnique _expressionIcollectErrors _expressionIcollectInstances _expressionIcollectWarnings _expressionIconstraints _expressionIcounter _expressionIdictionaryEnvironment _expressionIinfoTree _expressionImatchIO _expressionImatches _expressionIpatternMatchWarnings _expressionIself _expressionIunboundNames _expressionIuniqueChunk _expressionIuniqueSecondRound) = inv_Expression_s41 _expressionX41 (T_Expression_vIn40 _expressionOallPatterns _expressionOallTypeSchemes _expressionOambiguousConflicts _expressionOavailablePredicates _expressionObetaUnique _expressionOclassEnvironment _expressionOclassMemberEnv _expressionOclassMemberTypeSchemes _expressionOclassNamesEnv _expressionOclassPredicate _expressionOclassTypeSchemes _expressionOcollectErrors _expressionOcollectWarnings _expressionOcounter _expressionOcurClassPred _expressionOcurPred _expressionOcurrentChunk _expressionOdictionaryEnvironment _expressionOimportEnvironment _expressionOinstanceName _expressionOinstanceTypes _expressionOmatchIO _expressionOmoduleName _expressionOmonos _expressionOnamesInScope _expressionOorderedTypeSynonyms _expressionOparentTree _expressionOpatternMatchWarnings _expressionOrequiredPredicates _expressionOsubstitution _expressionOtryPatterns _expressionOtypeConstructors _expressionOtypeschemeMap _expressionOuniqueChunk _expressionOuniqueSecondRound _expressionOvariableMapping)
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule4911 _expressionIpatternMatchWarnings _lhsIimportEnvironment _lhsIsubstitution _patternIbeta _patternIelements _rangeIself
         _expressionOtryPatterns = rule4912  ()
         (_namesInScope,_unboundNames,_scopeInfo) = rule4913 _expressionIunboundNames _lhsInamesInScope _lhsIunboundNames _patternIpatVarNames
         _lhsOnamesInScope :: Names
         _lhsOnamesInScope = rule4914 _namesInScope
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule4915 _unboundNames
         _expressionOnamesInScope = rule4916 _lhsInamesInScope
         _parentTree = rule4917 _expressionIinfoTree _lhsIparentTree _localInfo _patternIinfoTree
         _lhsOinfoTree :: InfoTree
         _lhsOinfoTree = rule4918 _parentTree
         _localInfo = rule4919 _lhsImonos _self
         _cinfoResult = rule4920 _parentTree
         _cinfoBind = rule4921 _parentTree _patternIenvironment
         _lhsOgeneratorBeta :: Maybe Tp
         _lhsOgeneratorBeta = rule4922  ()
         _lhsOconstraints :: ConstraintSet
         _lhsOconstraints = rule4923 _locConstraints
         _lhsOassumptions :: Assumptions
         _lhsOassumptions = rule4924 _assumptions' _expressionIassumptions
         _lhsOmonos :: Monos
         _lhsOmonos = rule4925 _csetBinds _lhsImonos _patternIenvironment
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule4926 _expressionIbetaUnique
         _patternObetaUnique = rule4927 _lhsIbetaUnique
         _expressionObetaUnique = rule4928 _patternIbetaUnique
         _locConstraints = rule4929 _csetBinds _expressionIconstraints _lhsIconstraints _newcon _patternIconstraints
         _beta = rule4930 _lhsIbetaUnique
         _newcon = rule4931 _cinfoResult _expressionIbeta _lhsImonadBeta _patternIbeta
         (_csetBinds,_assumptions') = rule4932 _cinfoBind _lhsIassumptions _patternIenvironment
         _lhsOcollectInstances :: [(Name, Instance)]
         _lhsOcollectInstances = rule4933 _expressionIcollectInstances
         _self = rule4934 _expressionIself _patternIself _rangeIself
         _lhsOself :: Statement
         _lhsOself = rule4935 _self
         _lhsOcollectErrors :: TypeErrors
         _lhsOcollectErrors = rule4936 _expressionIcollectErrors
         _lhsOcollectWarnings :: Warnings
         _lhsOcollectWarnings = rule4937 _expressionIcollectWarnings
         _lhsOcounter :: Int
         _lhsOcounter = rule4938 _expressionIcounter
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule4939 _expressionIdictionaryEnvironment
         _lhsOmatchIO :: IO ()
         _lhsOmatchIO = rule4940 _expressionImatchIO
         _lhsOuniqueChunk :: Int
         _lhsOuniqueChunk = rule4941 _expressionIuniqueChunk
         _lhsOuniqueSecondRound :: Int
         _lhsOuniqueSecondRound = rule4942 _expressionIuniqueSecondRound
         _patternOambiguousConflicts = rule4943 _lhsIambiguousConflicts
         _patternOcounter = rule4944 _lhsIcounter
         _patternOimportEnvironment = rule4945 _lhsIimportEnvironment
         _patternOmonos = rule4946 _lhsImonos
         _patternOnamesInScope = rule4947 _namesInScope
         _patternOparentTree = rule4948 _parentTree
         _patternOpatternMatchWarnings = rule4949 _lhsIpatternMatchWarnings
         _patternOtypeConstructors = rule4950 _lhsItypeConstructors
         _expressionOallPatterns = rule4951 _lhsIallPatterns
         _expressionOallTypeSchemes = rule4952 _lhsIallTypeSchemes
         _expressionOambiguousConflicts = rule4953 _lhsIambiguousConflicts
         _expressionOavailablePredicates = rule4954 _lhsIavailablePredicates
         _expressionOclassEnvironment = rule4955 _lhsIclassEnvironment
         _expressionOclassMemberEnv = rule4956 _lhsIclassMemberEnv
         _expressionOclassMemberTypeSchemes = rule4957 _lhsIclassMemberTypeSchemes
         _expressionOclassNamesEnv = rule4958 _lhsIclassNamesEnv
         _expressionOclassPredicate = rule4959 _lhsIclassPredicate
         _expressionOclassTypeSchemes = rule4960 _lhsIclassTypeSchemes
         _expressionOcollectErrors = rule4961 _lhsIcollectErrors
         _expressionOcollectWarnings = rule4962 _lhsIcollectWarnings
         _expressionOcounter = rule4963 _patternIcounter
         _expressionOcurClassPred = rule4964 _lhsIcurClassPred
         _expressionOcurPred = rule4965 _lhsIcurPred
         _expressionOcurrentChunk = rule4966 _lhsIcurrentChunk
         _expressionOdictionaryEnvironment = rule4967 _lhsIdictionaryEnvironment
         _expressionOimportEnvironment = rule4968 _lhsIimportEnvironment
         _expressionOinstanceName = rule4969 _lhsIinstanceName
         _expressionOinstanceTypes = rule4970 _lhsIinstanceTypes
         _expressionOmatchIO = rule4971 _lhsImatchIO
         _expressionOmoduleName = rule4972 _lhsImoduleName
         _expressionOmonos = rule4973 _lhsImonos
         _expressionOorderedTypeSynonyms = rule4974 _lhsIorderedTypeSynonyms
         _expressionOparentTree = rule4975 _parentTree
         _expressionOpatternMatchWarnings = rule4976 _patternIpatternMatchWarnings
         _expressionOrequiredPredicates = rule4977 _lhsIrequiredPredicates
         _expressionOsubstitution = rule4978 _lhsIsubstitution
         _expressionOtypeConstructors = rule4979 _lhsItypeConstructors
         _expressionOtypeschemeMap = rule4980 _lhsItypeschemeMap
         _expressionOuniqueChunk = rule4981 _lhsIuniqueChunk
         _expressionOuniqueSecondRound = rule4982 _lhsIuniqueSecondRound
         _expressionOvariableMapping = rule4983 _lhsIvariableMapping
         !__result_ = T_Statement_vOut154 _lhsOassumptions _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraints _lhsOcounter _lhsOdictionaryEnvironment _lhsOgeneratorBeta _lhsOinfoTree _lhsOmatchIO _lhsOmonos _lhsOnamesInScope _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOuniqueSecondRound
         in __result_ )
     in C_Statement_s155 v154
   {-# INLINE rule4911 #-}
   rule4911 = \ ((_expressionIpatternMatchWarnings) :: [Warning]) ((_lhsIimportEnvironment) :: ImportEnvironment) ((_lhsIsubstitution) :: FixpointSubstitution) ((_patternIbeta) :: Tp) ((_patternIelements) ::   [PatternElement]        ) ((_rangeIself) :: Range) ->
                                                    patternMatchWarnings _lhsIimportEnvironment
                                                                         _lhsIsubstitution
                                                                         _patternIbeta
                                                                         (:[])
                                                                         [(_patternIelements, False)]
                                                                         _rangeIself
                                                                         Nothing
                                                                         False
                                                                         []
                                                                         "generator"
                                                                         "<-"
                                                    ++ _expressionIpatternMatchWarnings
   {-# INLINE rule4912 #-}
   rule4912 = \  (_ :: ()) ->
                                                     []
   {-# INLINE rule4913 #-}
   rule4913 = \ ((_expressionIunboundNames) :: Names) ((_lhsInamesInScope) :: Names) ((_lhsIunboundNames) :: Names) ((_patternIpatVarNames) :: Names) ->
                                                                        changeOfScope _patternIpatVarNames (_expressionIunboundNames ++ _lhsIunboundNames) _lhsInamesInScope
   {-# INLINE rule4914 #-}
   rule4914 = \ _namesInScope ->
                                              _namesInScope
   {-# INLINE rule4915 #-}
   rule4915 = \ _unboundNames ->
                                              _unboundNames
   {-# INLINE rule4916 #-}
   rule4916 = \ ((_lhsInamesInScope) :: Names) ->
                                              _lhsInamesInScope
   {-# INLINE rule4917 #-}
   rule4917 = \ ((_expressionIinfoTree) :: InfoTree) ((_lhsIparentTree) :: InfoTree) _localInfo ((_patternIinfoTree) :: InfoTree) ->
                            node _lhsIparentTree _localInfo [_patternIinfoTree, _expressionIinfoTree]
   {-# INLINE rule4918 #-}
   rule4918 = \ _parentTree ->
                            _parentTree
   {-# INLINE rule4919 #-}
   rule4919 = \ ((_lhsImonos) :: Monos) _self ->
                            LocalInfo { self = UHA_Stat _self
                                      , assignedType = Nothing
                                      , monos = _lhsImonos
                                      }
   {-# INLINE rule4920 #-}
   rule4920 = \ _parentTree ->
     childConstraint 1 "generator" _parentTree
        []
   {-# INLINE rule4921 #-}
   rule4921 = \ _parentTree ((_patternIenvironment) :: PatternAssumptions) ->
     \name -> variableConstraint "variable" (nameToUHA_Expr name)
        [ FolkloreConstraint
        , makeUnifier name "generator" _patternIenvironment _parentTree
        ]
   {-# INLINE rule4922 #-}
   rule4922 = \  (_ :: ()) ->
                              Nothing
   {-# INLINE rule4923 #-}
   rule4923 = \ _locConstraints ->
                              _locConstraints
   {-# INLINE rule4924 #-}
   rule4924 = \ _assumptions' ((_expressionIassumptions) :: Assumptions) ->
                              _assumptions' `combine` _expressionIassumptions
   {-# INLINE rule4925 #-}
   rule4925 = \ _csetBinds ((_lhsImonos) :: Monos) ((_patternIenvironment) :: PatternAssumptions) ->
                              M.elems _patternIenvironment ++ getMonos _csetBinds ++ _lhsImonos
   {-# INLINE rule4926 #-}
   rule4926 = \ ((_expressionIbetaUnique) :: Int) ->
                              _expressionIbetaUnique
   {-# INLINE rule4927 #-}
   rule4927 = \ ((_lhsIbetaUnique) :: Int) ->
                               _lhsIbetaUnique + 2
   {-# INLINE rule4928 #-}
   rule4928 = \ ((_patternIbetaUnique) :: Int) ->
                                  _patternIbetaUnique
   {-# INLINE rule4929 #-}
   rule4929 = \ _csetBinds ((_expressionIconstraints) :: ConstraintSet) ((_lhsIconstraints) :: ConstraintSet) _newcon ((_patternIconstraints) :: ConstraintSet) ->
                               _newcon .>. _csetBinds .>>.
                                  Node [ _patternIconstraints
                                       , _expressionIconstraints
                                       , _lhsIconstraints
                                       ]
   {-# INLINE rule4930 #-}
   rule4930 = \ ((_lhsIbetaUnique) :: Int) ->
                              TVar $ _lhsIbetaUnique + 1
   {-# INLINE rule4931 #-}
   rule4931 = \ _cinfoResult ((_expressionIbeta) :: Tp) ((_lhsImonadBeta) :: Tp) ((_patternIbeta) :: Tp) ->
                              [(_expressionIbeta .==. (TApp _lhsImonadBeta _patternIbeta)) _cinfoResult]
   {-# INLINE rule4932 #-}
   rule4932 = \ _cinfoBind ((_lhsIassumptions) :: Assumptions) ((_patternIenvironment) :: PatternAssumptions) ->
                                         (_patternIenvironment .===. _lhsIassumptions) _cinfoBind
   {-# INLINE rule4933 #-}
   rule4933 = \ ((_expressionIcollectInstances) :: [(Name, Instance)]) ->
     _expressionIcollectInstances
   {-# INLINE rule4934 #-}
   rule4934 = \ ((_expressionIself) :: Expression) ((_patternIself) :: Pattern) ((_rangeIself) :: Range) ->
     Statement_Generator _rangeIself _patternIself _expressionIself
   {-# INLINE rule4935 #-}
   rule4935 = \ _self ->
     _self
   {-# INLINE rule4936 #-}
   rule4936 = \ ((_expressionIcollectErrors) :: TypeErrors) ->
     _expressionIcollectErrors
   {-# INLINE rule4937 #-}
   rule4937 = \ ((_expressionIcollectWarnings) :: Warnings) ->
     _expressionIcollectWarnings
   {-# INLINE rule4938 #-}
   rule4938 = \ ((_expressionIcounter) :: Int) ->
     _expressionIcounter
   {-# INLINE rule4939 #-}
   rule4939 = \ ((_expressionIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _expressionIdictionaryEnvironment
   {-# INLINE rule4940 #-}
   rule4940 = \ ((_expressionImatchIO) :: IO ()) ->
     _expressionImatchIO
   {-# INLINE rule4941 #-}
   rule4941 = \ ((_expressionIuniqueChunk) :: Int) ->
     _expressionIuniqueChunk
   {-# INLINE rule4942 #-}
   rule4942 = \ ((_expressionIuniqueSecondRound) :: Int) ->
     _expressionIuniqueSecondRound
   {-# INLINE rule4943 #-}
   rule4943 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule4944 #-}
   rule4944 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule4945 #-}
   rule4945 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule4946 #-}
   rule4946 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule4947 #-}
   rule4947 = \ _namesInScope ->
     _namesInScope
   {-# INLINE rule4948 #-}
   rule4948 = \ _parentTree ->
     _parentTree
   {-# INLINE rule4949 #-}
   rule4949 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule4950 #-}
   rule4950 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
   {-# INLINE rule4951 #-}
   rule4951 = \ ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ->
     _lhsIallPatterns
   {-# INLINE rule4952 #-}
   rule4952 = \ ((_lhsIallTypeSchemes) :: M.Map NameWithRange TpScheme) ->
     _lhsIallTypeSchemes
   {-# INLINE rule4953 #-}
   rule4953 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule4954 #-}
   rule4954 = \ ((_lhsIavailablePredicates) :: [PredicateWithSource]) ->
     _lhsIavailablePredicates
   {-# INLINE rule4955 #-}
   rule4955 = \ ((_lhsIclassEnvironment) :: ClassEnvironment) ->
     _lhsIclassEnvironment
   {-# INLINE rule4956 #-}
   rule4956 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule4957 #-}
   rule4957 = \ ((_lhsIclassMemberTypeSchemes) :: Maybe [(Name, TpScheme)]) ->
     _lhsIclassMemberTypeSchemes
   {-# INLINE rule4958 #-}
   rule4958 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule4959 #-}
   rule4959 = \ ((_lhsIclassPredicate) :: Maybe (Name, Names)) ->
     _lhsIclassPredicate
   {-# INLINE rule4960 #-}
   rule4960 = \ ((_lhsIclassTypeSchemes) :: M.Map Name TpScheme) ->
     _lhsIclassTypeSchemes
   {-# INLINE rule4961 #-}
   rule4961 = \ ((_lhsIcollectErrors) :: TypeErrors) ->
     _lhsIcollectErrors
   {-# INLINE rule4962 #-}
   rule4962 = \ ((_lhsIcollectWarnings) :: Warnings) ->
     _lhsIcollectWarnings
   {-# INLINE rule4963 #-}
   rule4963 = \ ((_patternIcounter) :: Int) ->
     _patternIcounter
   {-# INLINE rule4964 #-}
   rule4964 = \ ((_lhsIcurClassPred) :: Maybe Predicate) ->
     _lhsIcurClassPred
   {-# INLINE rule4965 #-}
   rule4965 = \ ((_lhsIcurPred) :: Maybe Predicate) ->
     _lhsIcurPred
   {-# INLINE rule4966 #-}
   rule4966 = \ ((_lhsIcurrentChunk) :: Int) ->
     _lhsIcurrentChunk
   {-# INLINE rule4967 #-}
   rule4967 = \ ((_lhsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _lhsIdictionaryEnvironment
   {-# INLINE rule4968 #-}
   rule4968 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule4969 #-}
   rule4969 = \ ((_lhsIinstanceName) :: Maybe Name) ->
     _lhsIinstanceName
   {-# INLINE rule4970 #-}
   rule4970 = \ ((_lhsIinstanceTypes) :: [(Name, TpScheme)]) ->
     _lhsIinstanceTypes
   {-# INLINE rule4971 #-}
   rule4971 = \ ((_lhsImatchIO) :: IO ()) ->
     _lhsImatchIO
   {-# INLINE rule4972 #-}
   rule4972 = \ ((_lhsImoduleName) :: Maybe Name) ->
     _lhsImoduleName
   {-# INLINE rule4973 #-}
   rule4973 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule4974 #-}
   rule4974 = \ ((_lhsIorderedTypeSynonyms) :: OrderedTypeSynonyms) ->
     _lhsIorderedTypeSynonyms
   {-# INLINE rule4975 #-}
   rule4975 = \ _parentTree ->
     _parentTree
   {-# INLINE rule4976 #-}
   rule4976 = \ ((_patternIpatternMatchWarnings) :: [Warning]) ->
     _patternIpatternMatchWarnings
   {-# INLINE rule4977 #-}
   rule4977 = \ ((_lhsIrequiredPredicates) :: Predicates) ->
     _lhsIrequiredPredicates
   {-# INLINE rule4978 #-}
   rule4978 = \ ((_lhsIsubstitution) :: FixpointSubstitution) ->
     _lhsIsubstitution
   {-# INLINE rule4979 #-}
   rule4979 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
   {-# INLINE rule4980 #-}
   rule4980 = \ ((_lhsItypeschemeMap) :: M.Map Int (Scheme Predicates)) ->
     _lhsItypeschemeMap
   {-# INLINE rule4981 #-}
   rule4981 = \ ((_lhsIuniqueChunk) :: Int) ->
     _lhsIuniqueChunk
   {-# INLINE rule4982 #-}
   rule4982 = \ ((_lhsIuniqueSecondRound) :: Int) ->
     _lhsIuniqueSecondRound
   {-# INLINE rule4983 #-}
   rule4983 = \ ((_lhsIvariableMapping) :: Maybe [(Name, Tp)]) ->
     _lhsIvariableMapping
{-# NOINLINE sem_Statement_Empty #-}
sem_Statement_Empty :: T_Range  -> T_Statement 
sem_Statement_Empty arg_range_ = T_Statement (return st155) where
   {-# NOINLINE st155 #-}
   !st155 = let
      v154 :: T_Statement_v154 
      v154 = \ !(T_Statement_vIn154 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIassumptions _lhsIavailablePredicates _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIconstraints _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIgeneratorBeta _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonadBeta _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeConstructors _lhsItypeschemeMap _lhsIunboundNames _lhsIuniqueChunk _lhsIuniqueSecondRound _lhsIvariableMapping) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         _parentTree = rule4984 _lhsIparentTree _localInfo
         _lhsOinfoTree :: InfoTree
         _lhsOinfoTree = rule4985 _parentTree
         _localInfo = rule4986 _lhsImonos _self
         _lhsOcollectInstances :: [(Name, Instance)]
         _lhsOcollectInstances = rule4987  ()
         _self = rule4988 _rangeIself
         _lhsOself :: Statement
         _lhsOself = rule4989 _self
         _lhsOassumptions :: Assumptions
         _lhsOassumptions = rule4990 _lhsIassumptions
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule4991 _lhsIbetaUnique
         _lhsOcollectErrors :: TypeErrors
         _lhsOcollectErrors = rule4992 _lhsIcollectErrors
         _lhsOcollectWarnings :: Warnings
         _lhsOcollectWarnings = rule4993 _lhsIcollectWarnings
         _lhsOconstraints :: ConstraintSet
         _lhsOconstraints = rule4994 _lhsIconstraints
         _lhsOcounter :: Int
         _lhsOcounter = rule4995 _lhsIcounter
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule4996 _lhsIdictionaryEnvironment
         _lhsOgeneratorBeta :: Maybe Tp
         _lhsOgeneratorBeta = rule4997 _lhsIgeneratorBeta
         _lhsOmatchIO :: IO ()
         _lhsOmatchIO = rule4998 _lhsImatchIO
         _lhsOmonos :: Monos
         _lhsOmonos = rule4999 _lhsImonos
         _lhsOnamesInScope :: Names
         _lhsOnamesInScope = rule5000 _lhsInamesInScope
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule5001 _lhsIpatternMatchWarnings
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule5002 _lhsIunboundNames
         _lhsOuniqueChunk :: Int
         _lhsOuniqueChunk = rule5003 _lhsIuniqueChunk
         _lhsOuniqueSecondRound :: Int
         _lhsOuniqueSecondRound = rule5004 _lhsIuniqueSecondRound
         !__result_ = T_Statement_vOut154 _lhsOassumptions _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraints _lhsOcounter _lhsOdictionaryEnvironment _lhsOgeneratorBeta _lhsOinfoTree _lhsOmatchIO _lhsOmonos _lhsOnamesInScope _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOuniqueSecondRound
         in __result_ )
     in C_Statement_s155 v154
   {-# INLINE rule4984 #-}
   rule4984 = \ ((_lhsIparentTree) :: InfoTree) _localInfo ->
                            node _lhsIparentTree _localInfo []
   {-# INLINE rule4985 #-}
   rule4985 = \ _parentTree ->
                            _parentTree
   {-# INLINE rule4986 #-}
   rule4986 = \ ((_lhsImonos) :: Monos) _self ->
                            LocalInfo { self = UHA_Stat _self
                                      , assignedType = Nothing
                                      , monos = _lhsImonos
                                      }
   {-# INLINE rule4987 #-}
   rule4987 = \  (_ :: ()) ->
     []
   {-# INLINE rule4988 #-}
   rule4988 = \ ((_rangeIself) :: Range) ->
     Statement_Empty _rangeIself
   {-# INLINE rule4989 #-}
   rule4989 = \ _self ->
     _self
   {-# INLINE rule4990 #-}
   rule4990 = \ ((_lhsIassumptions) :: Assumptions) ->
     _lhsIassumptions
   {-# INLINE rule4991 #-}
   rule4991 = \ ((_lhsIbetaUnique) :: Int) ->
     _lhsIbetaUnique
   {-# INLINE rule4992 #-}
   rule4992 = \ ((_lhsIcollectErrors) :: TypeErrors) ->
     _lhsIcollectErrors
   {-# INLINE rule4993 #-}
   rule4993 = \ ((_lhsIcollectWarnings) :: Warnings) ->
     _lhsIcollectWarnings
   {-# INLINE rule4994 #-}
   rule4994 = \ ((_lhsIconstraints) :: ConstraintSet) ->
     _lhsIconstraints
   {-# INLINE rule4995 #-}
   rule4995 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule4996 #-}
   rule4996 = \ ((_lhsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _lhsIdictionaryEnvironment
   {-# INLINE rule4997 #-}
   rule4997 = \ ((_lhsIgeneratorBeta) :: Maybe Tp) ->
     _lhsIgeneratorBeta
   {-# INLINE rule4998 #-}
   rule4998 = \ ((_lhsImatchIO) :: IO ()) ->
     _lhsImatchIO
   {-# INLINE rule4999 #-}
   rule4999 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule5000 #-}
   rule5000 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule5001 #-}
   rule5001 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule5002 #-}
   rule5002 = \ ((_lhsIunboundNames) :: Names) ->
     _lhsIunboundNames
   {-# INLINE rule5003 #-}
   rule5003 = \ ((_lhsIuniqueChunk) :: Int) ->
     _lhsIuniqueChunk
   {-# INLINE rule5004 #-}
   rule5004 = \ ((_lhsIuniqueSecondRound) :: Int) ->
     _lhsIuniqueSecondRound

-- Statements --------------------------------------------------
-- wrapper
data Inh_Statements  = Inh_Statements { allPatterns_Inh_Statements :: !([((Expression, [String]), Core_TypingStrategy)]), allTypeSchemes_Inh_Statements :: !(M.Map NameWithRange TpScheme), ambiguousConflicts_Inh_Statements :: !([[Name]]), assumptions_Inh_Statements :: !(Assumptions), availablePredicates_Inh_Statements :: !([PredicateWithSource]), betaUnique_Inh_Statements :: !(Int), classEnvironment_Inh_Statements :: !(ClassEnvironment), classMemberEnv_Inh_Statements :: !(ClassMemberEnvironment), classMemberTypeSchemes_Inh_Statements :: !(Maybe [(Name, TpScheme)]), classNamesEnv_Inh_Statements :: !(ClassNameEnvironment), classPredicate_Inh_Statements :: !(Maybe (Name, Names)), classTypeSchemes_Inh_Statements :: !(M.Map Name TpScheme), collectErrors_Inh_Statements :: !(TypeErrors), collectWarnings_Inh_Statements :: !(Warnings), constraints_Inh_Statements :: !(ConstraintSet), counter_Inh_Statements :: !(Int), curClassPred_Inh_Statements :: !(Maybe Predicate), curPred_Inh_Statements :: !(Maybe Predicate), currentChunk_Inh_Statements :: !(Int), dictionaryEnvironment_Inh_Statements :: !(DictionaryEnvironment), generatorBeta_Inh_Statements :: !(Maybe Tp), importEnvironment_Inh_Statements :: !(ImportEnvironment), instanceName_Inh_Statements :: !(Maybe Name), instanceTypes_Inh_Statements :: !([(Name, TpScheme)]), matchIO_Inh_Statements :: !(IO ()), moduleName_Inh_Statements :: !(Maybe Name), monadBeta_Inh_Statements :: !(Tp), monos_Inh_Statements :: !(Monos), namesInScope_Inh_Statements :: !(Names), orderedTypeSynonyms_Inh_Statements :: !(OrderedTypeSynonyms), parentTree_Inh_Statements :: !(InfoTree), patternMatchWarnings_Inh_Statements :: !([Warning]), requiredPredicates_Inh_Statements :: !(Predicates), substitution_Inh_Statements :: !(FixpointSubstitution), typeConstructors_Inh_Statements :: !(TypeConstructorEnvironment), typeschemeMap_Inh_Statements :: !(M.Map Int (Scheme Predicates)), unboundNames_Inh_Statements :: !(Names), uniqueChunk_Inh_Statements :: !(Int), uniqueSecondRound_Inh_Statements :: !(Int), variableMapping_Inh_Statements :: !(Maybe [(Name, Tp)]) }
data Syn_Statements  = Syn_Statements { assumptions_Syn_Statements :: !(Assumptions), betaUnique_Syn_Statements :: !(Int), collectErrors_Syn_Statements :: !(TypeErrors), collectInstances_Syn_Statements :: !([(Name, Instance)]), collectWarnings_Syn_Statements :: !(Warnings), constraints_Syn_Statements :: !(ConstraintSet), counter_Syn_Statements :: !(Int), dictionaryEnvironment_Syn_Statements :: !(DictionaryEnvironment), generatorBeta_Syn_Statements :: !(Maybe Tp), infoTrees_Syn_Statements :: !(InfoTrees), matchIO_Syn_Statements :: !(IO ()), namesInScope_Syn_Statements :: !(Names), patternMatchWarnings_Syn_Statements :: !([Warning]), self_Syn_Statements :: !(Statements), unboundNames_Syn_Statements :: !(Names), uniqueChunk_Syn_Statements :: !(Int), uniqueSecondRound_Syn_Statements :: !(Int) }
{-# INLINABLE wrap_Statements #-}
wrap_Statements :: T_Statements  -> Inh_Statements  -> (Syn_Statements )
wrap_Statements !(T_Statements act) !(Inh_Statements _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIassumptions _lhsIavailablePredicates _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIconstraints _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIgeneratorBeta _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonadBeta _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeConstructors _lhsItypeschemeMap _lhsIunboundNames _lhsIuniqueChunk _lhsIuniqueSecondRound _lhsIvariableMapping) =
   Control.Monad.Identity.runIdentity (
     do !sem <- act
        let arg157 = T_Statements_vIn157 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIassumptions _lhsIavailablePredicates _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIconstraints _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIgeneratorBeta _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonadBeta _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeConstructors _lhsItypeschemeMap _lhsIunboundNames _lhsIuniqueChunk _lhsIuniqueSecondRound _lhsIvariableMapping
        !(T_Statements_vOut157 _lhsOassumptions _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraints _lhsOcounter _lhsOdictionaryEnvironment _lhsOgeneratorBeta _lhsOinfoTrees _lhsOmatchIO _lhsOnamesInScope _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOuniqueSecondRound) <- return (inv_Statements_s158 sem arg157)
        return (Syn_Statements _lhsOassumptions _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraints _lhsOcounter _lhsOdictionaryEnvironment _lhsOgeneratorBeta _lhsOinfoTrees _lhsOmatchIO _lhsOnamesInScope _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOuniqueSecondRound)
   )

-- cata
{-# NOINLINE sem_Statements #-}
sem_Statements :: Statements  -> T_Statements 
sem_Statements list = Prelude.foldr sem_Statements_Cons sem_Statements_Nil (Prelude.map sem_Statement list)

-- semantic domain
newtype T_Statements  = T_Statements {
                                     attach_T_Statements :: Identity (T_Statements_s158 )
                                     }
newtype T_Statements_s158  = C_Statements_s158 {
                                               inv_Statements_s158 :: (T_Statements_v157 )
                                               }
data T_Statements_s159  = C_Statements_s159
type T_Statements_v157  = (T_Statements_vIn157 ) -> (T_Statements_vOut157 )
data T_Statements_vIn157  = T_Statements_vIn157 ([((Expression, [String]), Core_TypingStrategy)]) (M.Map NameWithRange TpScheme) ([[Name]]) (Assumptions) ([PredicateWithSource]) (Int) (ClassEnvironment) (ClassMemberEnvironment) (Maybe [(Name, TpScheme)]) (ClassNameEnvironment) (Maybe (Name, Names)) (M.Map Name TpScheme) (TypeErrors) (Warnings) (ConstraintSet) (Int) (Maybe Predicate) (Maybe Predicate) (Int) (DictionaryEnvironment) (Maybe Tp) (ImportEnvironment) (Maybe Name) ([(Name, TpScheme)]) (IO ()) (Maybe Name) (Tp) (Monos) (Names) (OrderedTypeSynonyms) (InfoTree) ([Warning]) (Predicates) (FixpointSubstitution) (TypeConstructorEnvironment) (M.Map Int (Scheme Predicates)) (Names) (Int) (Int) (Maybe [(Name, Tp)])
data T_Statements_vOut157  = T_Statements_vOut157 (Assumptions) (Int) (TypeErrors) ([(Name, Instance)]) (Warnings) (ConstraintSet) (Int) (DictionaryEnvironment) (Maybe Tp) (InfoTrees) (IO ()) (Names) ([Warning]) (Statements) (Names) (Int) (Int)
{-# NOINLINE sem_Statements_Cons #-}
sem_Statements_Cons :: T_Statement  -> T_Statements  -> T_Statements 
sem_Statements_Cons arg_hd_ arg_tl_ = T_Statements (return st158) where
   {-# NOINLINE st158 #-}
   !st158 = let
      v157 :: T_Statements_v157 
      v157 = \ !(T_Statements_vIn157 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIassumptions _lhsIavailablePredicates _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIconstraints _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIgeneratorBeta _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonadBeta _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeConstructors _lhsItypeschemeMap _lhsIunboundNames _lhsIuniqueChunk _lhsIuniqueSecondRound _lhsIvariableMapping) -> ( let
         _hdX155 = Control.Monad.Identity.runIdentity (attach_T_Statement (arg_hd_))
         _tlX158 = Control.Monad.Identity.runIdentity (attach_T_Statements (arg_tl_))
         (T_Statement_vOut154 _hdIassumptions _hdIbetaUnique _hdIcollectErrors _hdIcollectInstances _hdIcollectWarnings _hdIconstraints _hdIcounter _hdIdictionaryEnvironment _hdIgeneratorBeta _hdIinfoTree _hdImatchIO _hdImonos _hdInamesInScope _hdIpatternMatchWarnings _hdIself _hdIunboundNames _hdIuniqueChunk _hdIuniqueSecondRound) = inv_Statement_s155 _hdX155 (T_Statement_vIn154 _hdOallPatterns _hdOallTypeSchemes _hdOambiguousConflicts _hdOassumptions _hdOavailablePredicates _hdObetaUnique _hdOclassEnvironment _hdOclassMemberEnv _hdOclassMemberTypeSchemes _hdOclassNamesEnv _hdOclassPredicate _hdOclassTypeSchemes _hdOcollectErrors _hdOcollectWarnings _hdOconstraints _hdOcounter _hdOcurClassPred _hdOcurPred _hdOcurrentChunk _hdOdictionaryEnvironment _hdOgeneratorBeta _hdOimportEnvironment _hdOinstanceName _hdOinstanceTypes _hdOmatchIO _hdOmoduleName _hdOmonadBeta _hdOmonos _hdOnamesInScope _hdOorderedTypeSynonyms _hdOparentTree _hdOpatternMatchWarnings _hdOrequiredPredicates _hdOsubstitution _hdOtypeConstructors _hdOtypeschemeMap _hdOunboundNames _hdOuniqueChunk _hdOuniqueSecondRound _hdOvariableMapping)
         (T_Statements_vOut157 _tlIassumptions _tlIbetaUnique _tlIcollectErrors _tlIcollectInstances _tlIcollectWarnings _tlIconstraints _tlIcounter _tlIdictionaryEnvironment _tlIgeneratorBeta _tlIinfoTrees _tlImatchIO _tlInamesInScope _tlIpatternMatchWarnings _tlIself _tlIunboundNames _tlIuniqueChunk _tlIuniqueSecondRound) = inv_Statements_s158 _tlX158 (T_Statements_vIn157 _tlOallPatterns _tlOallTypeSchemes _tlOambiguousConflicts _tlOassumptions _tlOavailablePredicates _tlObetaUnique _tlOclassEnvironment _tlOclassMemberEnv _tlOclassMemberTypeSchemes _tlOclassNamesEnv _tlOclassPredicate _tlOclassTypeSchemes _tlOcollectErrors _tlOcollectWarnings _tlOconstraints _tlOcounter _tlOcurClassPred _tlOcurPred _tlOcurrentChunk _tlOdictionaryEnvironment _tlOgeneratorBeta _tlOimportEnvironment _tlOinstanceName _tlOinstanceTypes _tlOmatchIO _tlOmoduleName _tlOmonadBeta _tlOmonos _tlOnamesInScope _tlOorderedTypeSynonyms _tlOparentTree _tlOpatternMatchWarnings _tlOrequiredPredicates _tlOsubstitution _tlOtypeConstructors _tlOtypeschemeMap _tlOunboundNames _tlOuniqueChunk _tlOuniqueSecondRound _tlOvariableMapping)
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule5005 _hdIunboundNames
         _tlOunboundNames = rule5006 _lhsIunboundNames
         _hdOunboundNames = rule5007 _tlIunboundNames
         _lhsOinfoTrees :: InfoTrees
         _lhsOinfoTrees = rule5008 _hdIinfoTree _tlIinfoTrees
         _lhsOassumptions :: Assumptions
         _lhsOassumptions = rule5009 _hdIassumptions
         _lhsOconstraints :: ConstraintSet
         _lhsOconstraints = rule5010 _hdIconstraints
         _hdOassumptions = rule5011 _tlIassumptions
         _hdOconstraints = rule5012 _tlIconstraints
         _tlOassumptions = rule5013 _lhsIassumptions
         _tlOconstraints = rule5014 _lhsIconstraints
         _lhsOcollectInstances :: [(Name, Instance)]
         _lhsOcollectInstances = rule5015 _hdIcollectInstances _tlIcollectInstances
         _self = rule5016 _hdIself _tlIself
         _lhsOself :: Statements
         _lhsOself = rule5017 _self
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule5018 _tlIbetaUnique
         _lhsOcollectErrors :: TypeErrors
         _lhsOcollectErrors = rule5019 _tlIcollectErrors
         _lhsOcollectWarnings :: Warnings
         _lhsOcollectWarnings = rule5020 _tlIcollectWarnings
         _lhsOcounter :: Int
         _lhsOcounter = rule5021 _tlIcounter
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule5022 _tlIdictionaryEnvironment
         _lhsOgeneratorBeta :: Maybe Tp
         _lhsOgeneratorBeta = rule5023 _tlIgeneratorBeta
         _lhsOmatchIO :: IO ()
         _lhsOmatchIO = rule5024 _tlImatchIO
         _lhsOnamesInScope :: Names
         _lhsOnamesInScope = rule5025 _tlInamesInScope
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule5026 _tlIpatternMatchWarnings
         _lhsOuniqueChunk :: Int
         _lhsOuniqueChunk = rule5027 _tlIuniqueChunk
         _lhsOuniqueSecondRound :: Int
         _lhsOuniqueSecondRound = rule5028 _tlIuniqueSecondRound
         _hdOallPatterns = rule5029 _lhsIallPatterns
         _hdOallTypeSchemes = rule5030 _lhsIallTypeSchemes
         _hdOambiguousConflicts = rule5031 _lhsIambiguousConflicts
         _hdOavailablePredicates = rule5032 _lhsIavailablePredicates
         _hdObetaUnique = rule5033 _lhsIbetaUnique
         _hdOclassEnvironment = rule5034 _lhsIclassEnvironment
         _hdOclassMemberEnv = rule5035 _lhsIclassMemberEnv
         _hdOclassMemberTypeSchemes = rule5036 _lhsIclassMemberTypeSchemes
         _hdOclassNamesEnv = rule5037 _lhsIclassNamesEnv
         _hdOclassPredicate = rule5038 _lhsIclassPredicate
         _hdOclassTypeSchemes = rule5039 _lhsIclassTypeSchemes
         _hdOcollectErrors = rule5040 _lhsIcollectErrors
         _hdOcollectWarnings = rule5041 _lhsIcollectWarnings
         _hdOcounter = rule5042 _lhsIcounter
         _hdOcurClassPred = rule5043 _lhsIcurClassPred
         _hdOcurPred = rule5044 _lhsIcurPred
         _hdOcurrentChunk = rule5045 _lhsIcurrentChunk
         _hdOdictionaryEnvironment = rule5046 _lhsIdictionaryEnvironment
         _hdOgeneratorBeta = rule5047 _lhsIgeneratorBeta
         _hdOimportEnvironment = rule5048 _lhsIimportEnvironment
         _hdOinstanceName = rule5049 _lhsIinstanceName
         _hdOinstanceTypes = rule5050 _lhsIinstanceTypes
         _hdOmatchIO = rule5051 _lhsImatchIO
         _hdOmoduleName = rule5052 _lhsImoduleName
         _hdOmonadBeta = rule5053 _lhsImonadBeta
         _hdOmonos = rule5054 _lhsImonos
         _hdOnamesInScope = rule5055 _lhsInamesInScope
         _hdOorderedTypeSynonyms = rule5056 _lhsIorderedTypeSynonyms
         _hdOparentTree = rule5057 _lhsIparentTree
         _hdOpatternMatchWarnings = rule5058 _lhsIpatternMatchWarnings
         _hdOrequiredPredicates = rule5059 _lhsIrequiredPredicates
         _hdOsubstitution = rule5060 _lhsIsubstitution
         _hdOtypeConstructors = rule5061 _lhsItypeConstructors
         _hdOtypeschemeMap = rule5062 _lhsItypeschemeMap
         _hdOuniqueChunk = rule5063 _lhsIuniqueChunk
         _hdOuniqueSecondRound = rule5064 _lhsIuniqueSecondRound
         _hdOvariableMapping = rule5065 _lhsIvariableMapping
         _tlOallPatterns = rule5066 _lhsIallPatterns
         _tlOallTypeSchemes = rule5067 _lhsIallTypeSchemes
         _tlOambiguousConflicts = rule5068 _lhsIambiguousConflicts
         _tlOavailablePredicates = rule5069 _lhsIavailablePredicates
         _tlObetaUnique = rule5070 _hdIbetaUnique
         _tlOclassEnvironment = rule5071 _lhsIclassEnvironment
         _tlOclassMemberEnv = rule5072 _lhsIclassMemberEnv
         _tlOclassMemberTypeSchemes = rule5073 _lhsIclassMemberTypeSchemes
         _tlOclassNamesEnv = rule5074 _lhsIclassNamesEnv
         _tlOclassPredicate = rule5075 _lhsIclassPredicate
         _tlOclassTypeSchemes = rule5076 _lhsIclassTypeSchemes
         _tlOcollectErrors = rule5077 _hdIcollectErrors
         _tlOcollectWarnings = rule5078 _hdIcollectWarnings
         _tlOcounter = rule5079 _hdIcounter
         _tlOcurClassPred = rule5080 _lhsIcurClassPred
         _tlOcurPred = rule5081 _lhsIcurPred
         _tlOcurrentChunk = rule5082 _lhsIcurrentChunk
         _tlOdictionaryEnvironment = rule5083 _hdIdictionaryEnvironment
         _tlOgeneratorBeta = rule5084 _hdIgeneratorBeta
         _tlOimportEnvironment = rule5085 _lhsIimportEnvironment
         _tlOinstanceName = rule5086 _lhsIinstanceName
         _tlOinstanceTypes = rule5087 _lhsIinstanceTypes
         _tlOmatchIO = rule5088 _hdImatchIO
         _tlOmoduleName = rule5089 _lhsImoduleName
         _tlOmonadBeta = rule5090 _lhsImonadBeta
         _tlOmonos = rule5091 _hdImonos
         _tlOnamesInScope = rule5092 _hdInamesInScope
         _tlOorderedTypeSynonyms = rule5093 _lhsIorderedTypeSynonyms
         _tlOparentTree = rule5094 _lhsIparentTree
         _tlOpatternMatchWarnings = rule5095 _hdIpatternMatchWarnings
         _tlOrequiredPredicates = rule5096 _lhsIrequiredPredicates
         _tlOsubstitution = rule5097 _lhsIsubstitution
         _tlOtypeConstructors = rule5098 _lhsItypeConstructors
         _tlOtypeschemeMap = rule5099 _lhsItypeschemeMap
         _tlOuniqueChunk = rule5100 _hdIuniqueChunk
         _tlOuniqueSecondRound = rule5101 _hdIuniqueSecondRound
         _tlOvariableMapping = rule5102 _lhsIvariableMapping
         !__result_ = T_Statements_vOut157 _lhsOassumptions _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraints _lhsOcounter _lhsOdictionaryEnvironment _lhsOgeneratorBeta _lhsOinfoTrees _lhsOmatchIO _lhsOnamesInScope _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOuniqueSecondRound
         in __result_ )
     in C_Statements_s158 v157
   {-# INLINE rule5005 #-}
   rule5005 = \ ((_hdIunboundNames) :: Names) ->
                                  _hdIunboundNames
   {-# INLINE rule5006 #-}
   rule5006 = \ ((_lhsIunboundNames) :: Names) ->
                                  _lhsIunboundNames
   {-# INLINE rule5007 #-}
   rule5007 = \ ((_tlIunboundNames) :: Names) ->
                                  _tlIunboundNames
   {-# INLINE rule5008 #-}
   rule5008 = \ ((_hdIinfoTree) :: InfoTree) ((_tlIinfoTrees) :: InfoTrees) ->
                               _hdIinfoTree : _tlIinfoTrees
   {-# INLINE rule5009 #-}
   rule5009 = \ ((_hdIassumptions) :: Assumptions) ->
                            _hdIassumptions
   {-# INLINE rule5010 #-}
   rule5010 = \ ((_hdIconstraints) :: ConstraintSet) ->
                            _hdIconstraints
   {-# INLINE rule5011 #-}
   rule5011 = \ ((_tlIassumptions) :: Assumptions) ->
                            _tlIassumptions
   {-# INLINE rule5012 #-}
   rule5012 = \ ((_tlIconstraints) :: ConstraintSet) ->
                            _tlIconstraints
   {-# INLINE rule5013 #-}
   rule5013 = \ ((_lhsIassumptions) :: Assumptions) ->
                            _lhsIassumptions
   {-# INLINE rule5014 #-}
   rule5014 = \ ((_lhsIconstraints) :: ConstraintSet) ->
                            _lhsIconstraints
   {-# INLINE rule5015 #-}
   rule5015 = \ ((_hdIcollectInstances) :: [(Name, Instance)]) ((_tlIcollectInstances) :: [(Name, Instance)]) ->
     _hdIcollectInstances  ++  _tlIcollectInstances
   {-# INLINE rule5016 #-}
   rule5016 = \ ((_hdIself) :: Statement) ((_tlIself) :: Statements) ->
     (:) _hdIself _tlIself
   {-# INLINE rule5017 #-}
   rule5017 = \ _self ->
     _self
   {-# INLINE rule5018 #-}
   rule5018 = \ ((_tlIbetaUnique) :: Int) ->
     _tlIbetaUnique
   {-# INLINE rule5019 #-}
   rule5019 = \ ((_tlIcollectErrors) :: TypeErrors) ->
     _tlIcollectErrors
   {-# INLINE rule5020 #-}
   rule5020 = \ ((_tlIcollectWarnings) :: Warnings) ->
     _tlIcollectWarnings
   {-# INLINE rule5021 #-}
   rule5021 = \ ((_tlIcounter) :: Int) ->
     _tlIcounter
   {-# INLINE rule5022 #-}
   rule5022 = \ ((_tlIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _tlIdictionaryEnvironment
   {-# INLINE rule5023 #-}
   rule5023 = \ ((_tlIgeneratorBeta) :: Maybe Tp) ->
     _tlIgeneratorBeta
   {-# INLINE rule5024 #-}
   rule5024 = \ ((_tlImatchIO) :: IO ()) ->
     _tlImatchIO
   {-# INLINE rule5025 #-}
   rule5025 = \ ((_tlInamesInScope) :: Names) ->
     _tlInamesInScope
   {-# INLINE rule5026 #-}
   rule5026 = \ ((_tlIpatternMatchWarnings) :: [Warning]) ->
     _tlIpatternMatchWarnings
   {-# INLINE rule5027 #-}
   rule5027 = \ ((_tlIuniqueChunk) :: Int) ->
     _tlIuniqueChunk
   {-# INLINE rule5028 #-}
   rule5028 = \ ((_tlIuniqueSecondRound) :: Int) ->
     _tlIuniqueSecondRound
   {-# INLINE rule5029 #-}
   rule5029 = \ ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ->
     _lhsIallPatterns
   {-# INLINE rule5030 #-}
   rule5030 = \ ((_lhsIallTypeSchemes) :: M.Map NameWithRange TpScheme) ->
     _lhsIallTypeSchemes
   {-# INLINE rule5031 #-}
   rule5031 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule5032 #-}
   rule5032 = \ ((_lhsIavailablePredicates) :: [PredicateWithSource]) ->
     _lhsIavailablePredicates
   {-# INLINE rule5033 #-}
   rule5033 = \ ((_lhsIbetaUnique) :: Int) ->
     _lhsIbetaUnique
   {-# INLINE rule5034 #-}
   rule5034 = \ ((_lhsIclassEnvironment) :: ClassEnvironment) ->
     _lhsIclassEnvironment
   {-# INLINE rule5035 #-}
   rule5035 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule5036 #-}
   rule5036 = \ ((_lhsIclassMemberTypeSchemes) :: Maybe [(Name, TpScheme)]) ->
     _lhsIclassMemberTypeSchemes
   {-# INLINE rule5037 #-}
   rule5037 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule5038 #-}
   rule5038 = \ ((_lhsIclassPredicate) :: Maybe (Name, Names)) ->
     _lhsIclassPredicate
   {-# INLINE rule5039 #-}
   rule5039 = \ ((_lhsIclassTypeSchemes) :: M.Map Name TpScheme) ->
     _lhsIclassTypeSchemes
   {-# INLINE rule5040 #-}
   rule5040 = \ ((_lhsIcollectErrors) :: TypeErrors) ->
     _lhsIcollectErrors
   {-# INLINE rule5041 #-}
   rule5041 = \ ((_lhsIcollectWarnings) :: Warnings) ->
     _lhsIcollectWarnings
   {-# INLINE rule5042 #-}
   rule5042 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule5043 #-}
   rule5043 = \ ((_lhsIcurClassPred) :: Maybe Predicate) ->
     _lhsIcurClassPred
   {-# INLINE rule5044 #-}
   rule5044 = \ ((_lhsIcurPred) :: Maybe Predicate) ->
     _lhsIcurPred
   {-# INLINE rule5045 #-}
   rule5045 = \ ((_lhsIcurrentChunk) :: Int) ->
     _lhsIcurrentChunk
   {-# INLINE rule5046 #-}
   rule5046 = \ ((_lhsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _lhsIdictionaryEnvironment
   {-# INLINE rule5047 #-}
   rule5047 = \ ((_lhsIgeneratorBeta) :: Maybe Tp) ->
     _lhsIgeneratorBeta
   {-# INLINE rule5048 #-}
   rule5048 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule5049 #-}
   rule5049 = \ ((_lhsIinstanceName) :: Maybe Name) ->
     _lhsIinstanceName
   {-# INLINE rule5050 #-}
   rule5050 = \ ((_lhsIinstanceTypes) :: [(Name, TpScheme)]) ->
     _lhsIinstanceTypes
   {-# INLINE rule5051 #-}
   rule5051 = \ ((_lhsImatchIO) :: IO ()) ->
     _lhsImatchIO
   {-# INLINE rule5052 #-}
   rule5052 = \ ((_lhsImoduleName) :: Maybe Name) ->
     _lhsImoduleName
   {-# INLINE rule5053 #-}
   rule5053 = \ ((_lhsImonadBeta) :: Tp) ->
     _lhsImonadBeta
   {-# INLINE rule5054 #-}
   rule5054 = \ ((_lhsImonos) :: Monos) ->
     _lhsImonos
   {-# INLINE rule5055 #-}
   rule5055 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule5056 #-}
   rule5056 = \ ((_lhsIorderedTypeSynonyms) :: OrderedTypeSynonyms) ->
     _lhsIorderedTypeSynonyms
   {-# INLINE rule5057 #-}
   rule5057 = \ ((_lhsIparentTree) :: InfoTree) ->
     _lhsIparentTree
   {-# INLINE rule5058 #-}
   rule5058 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule5059 #-}
   rule5059 = \ ((_lhsIrequiredPredicates) :: Predicates) ->
     _lhsIrequiredPredicates
   {-# INLINE rule5060 #-}
   rule5060 = \ ((_lhsIsubstitution) :: FixpointSubstitution) ->
     _lhsIsubstitution
   {-# INLINE rule5061 #-}
   rule5061 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
   {-# INLINE rule5062 #-}
   rule5062 = \ ((_lhsItypeschemeMap) :: M.Map Int (Scheme Predicates)) ->
     _lhsItypeschemeMap
   {-# INLINE rule5063 #-}
   rule5063 = \ ((_lhsIuniqueChunk) :: Int) ->
     _lhsIuniqueChunk
   {-# INLINE rule5064 #-}
   rule5064 = \ ((_lhsIuniqueSecondRound) :: Int) ->
     _lhsIuniqueSecondRound
   {-# INLINE rule5065 #-}
   rule5065 = \ ((_lhsIvariableMapping) :: Maybe [(Name, Tp)]) ->
     _lhsIvariableMapping
   {-# INLINE rule5066 #-}
   rule5066 = \ ((_lhsIallPatterns) :: [((Expression, [String]), Core_TypingStrategy)]) ->
     _lhsIallPatterns
   {-# INLINE rule5067 #-}
   rule5067 = \ ((_lhsIallTypeSchemes) :: M.Map NameWithRange TpScheme) ->
     _lhsIallTypeSchemes
   {-# INLINE rule5068 #-}
   rule5068 = \ ((_lhsIambiguousConflicts) :: [[Name]]) ->
     _lhsIambiguousConflicts
   {-# INLINE rule5069 #-}
   rule5069 = \ ((_lhsIavailablePredicates) :: [PredicateWithSource]) ->
     _lhsIavailablePredicates
   {-# INLINE rule5070 #-}
   rule5070 = \ ((_hdIbetaUnique) :: Int) ->
     _hdIbetaUnique
   {-# INLINE rule5071 #-}
   rule5071 = \ ((_lhsIclassEnvironment) :: ClassEnvironment) ->
     _lhsIclassEnvironment
   {-# INLINE rule5072 #-}
   rule5072 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule5073 #-}
   rule5073 = \ ((_lhsIclassMemberTypeSchemes) :: Maybe [(Name, TpScheme)]) ->
     _lhsIclassMemberTypeSchemes
   {-# INLINE rule5074 #-}
   rule5074 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule5075 #-}
   rule5075 = \ ((_lhsIclassPredicate) :: Maybe (Name, Names)) ->
     _lhsIclassPredicate
   {-# INLINE rule5076 #-}
   rule5076 = \ ((_lhsIclassTypeSchemes) :: M.Map Name TpScheme) ->
     _lhsIclassTypeSchemes
   {-# INLINE rule5077 #-}
   rule5077 = \ ((_hdIcollectErrors) :: TypeErrors) ->
     _hdIcollectErrors
   {-# INLINE rule5078 #-}
   rule5078 = \ ((_hdIcollectWarnings) :: Warnings) ->
     _hdIcollectWarnings
   {-# INLINE rule5079 #-}
   rule5079 = \ ((_hdIcounter) :: Int) ->
     _hdIcounter
   {-# INLINE rule5080 #-}
   rule5080 = \ ((_lhsIcurClassPred) :: Maybe Predicate) ->
     _lhsIcurClassPred
   {-# INLINE rule5081 #-}
   rule5081 = \ ((_lhsIcurPred) :: Maybe Predicate) ->
     _lhsIcurPred
   {-# INLINE rule5082 #-}
   rule5082 = \ ((_lhsIcurrentChunk) :: Int) ->
     _lhsIcurrentChunk
   {-# INLINE rule5083 #-}
   rule5083 = \ ((_hdIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _hdIdictionaryEnvironment
   {-# INLINE rule5084 #-}
   rule5084 = \ ((_hdIgeneratorBeta) :: Maybe Tp) ->
     _hdIgeneratorBeta
   {-# INLINE rule5085 #-}
   rule5085 = \ ((_lhsIimportEnvironment) :: ImportEnvironment) ->
     _lhsIimportEnvironment
   {-# INLINE rule5086 #-}
   rule5086 = \ ((_lhsIinstanceName) :: Maybe Name) ->
     _lhsIinstanceName
   {-# INLINE rule5087 #-}
   rule5087 = \ ((_lhsIinstanceTypes) :: [(Name, TpScheme)]) ->
     _lhsIinstanceTypes
   {-# INLINE rule5088 #-}
   rule5088 = \ ((_hdImatchIO) :: IO ()) ->
     _hdImatchIO
   {-# INLINE rule5089 #-}
   rule5089 = \ ((_lhsImoduleName) :: Maybe Name) ->
     _lhsImoduleName
   {-# INLINE rule5090 #-}
   rule5090 = \ ((_lhsImonadBeta) :: Tp) ->
     _lhsImonadBeta
   {-# INLINE rule5091 #-}
   rule5091 = \ ((_hdImonos) :: Monos) ->
     _hdImonos
   {-# INLINE rule5092 #-}
   rule5092 = \ ((_hdInamesInScope) :: Names) ->
     _hdInamesInScope
   {-# INLINE rule5093 #-}
   rule5093 = \ ((_lhsIorderedTypeSynonyms) :: OrderedTypeSynonyms) ->
     _lhsIorderedTypeSynonyms
   {-# INLINE rule5094 #-}
   rule5094 = \ ((_lhsIparentTree) :: InfoTree) ->
     _lhsIparentTree
   {-# INLINE rule5095 #-}
   rule5095 = \ ((_hdIpatternMatchWarnings) :: [Warning]) ->
     _hdIpatternMatchWarnings
   {-# INLINE rule5096 #-}
   rule5096 = \ ((_lhsIrequiredPredicates) :: Predicates) ->
     _lhsIrequiredPredicates
   {-# INLINE rule5097 #-}
   rule5097 = \ ((_lhsIsubstitution) :: FixpointSubstitution) ->
     _lhsIsubstitution
   {-# INLINE rule5098 #-}
   rule5098 = \ ((_lhsItypeConstructors) :: TypeConstructorEnvironment) ->
     _lhsItypeConstructors
   {-# INLINE rule5099 #-}
   rule5099 = \ ((_lhsItypeschemeMap) :: M.Map Int (Scheme Predicates)) ->
     _lhsItypeschemeMap
   {-# INLINE rule5100 #-}
   rule5100 = \ ((_hdIuniqueChunk) :: Int) ->
     _hdIuniqueChunk
   {-# INLINE rule5101 #-}
   rule5101 = \ ((_hdIuniqueSecondRound) :: Int) ->
     _hdIuniqueSecondRound
   {-# INLINE rule5102 #-}
   rule5102 = \ ((_lhsIvariableMapping) :: Maybe [(Name, Tp)]) ->
     _lhsIvariableMapping
{-# NOINLINE sem_Statements_Nil #-}
sem_Statements_Nil ::  T_Statements 
sem_Statements_Nil  = T_Statements (return st158) where
   {-# NOINLINE st158 #-}
   !st158 = let
      v157 :: T_Statements_v157 
      v157 = \ !(T_Statements_vIn157 _lhsIallPatterns _lhsIallTypeSchemes _lhsIambiguousConflicts _lhsIassumptions _lhsIavailablePredicates _lhsIbetaUnique _lhsIclassEnvironment _lhsIclassMemberEnv _lhsIclassMemberTypeSchemes _lhsIclassNamesEnv _lhsIclassPredicate _lhsIclassTypeSchemes _lhsIcollectErrors _lhsIcollectWarnings _lhsIconstraints _lhsIcounter _lhsIcurClassPred _lhsIcurPred _lhsIcurrentChunk _lhsIdictionaryEnvironment _lhsIgeneratorBeta _lhsIimportEnvironment _lhsIinstanceName _lhsIinstanceTypes _lhsImatchIO _lhsImoduleName _lhsImonadBeta _lhsImonos _lhsInamesInScope _lhsIorderedTypeSynonyms _lhsIparentTree _lhsIpatternMatchWarnings _lhsIrequiredPredicates _lhsIsubstitution _lhsItypeConstructors _lhsItypeschemeMap _lhsIunboundNames _lhsIuniqueChunk _lhsIuniqueSecondRound _lhsIvariableMapping) -> ( let
         _lhsOunboundNames :: Names
         _lhsOunboundNames = rule5103 _lhsIunboundNames
         _lhsOinfoTrees :: InfoTrees
         _lhsOinfoTrees = rule5104  ()
         _lhsOcollectInstances :: [(Name, Instance)]
         _lhsOcollectInstances = rule5105  ()
         _self = rule5106  ()
         _lhsOself :: Statements
         _lhsOself = rule5107 _self
         _lhsOassumptions :: Assumptions
         _lhsOassumptions = rule5108 _lhsIassumptions
         _lhsObetaUnique :: Int
         _lhsObetaUnique = rule5109 _lhsIbetaUnique
         _lhsOcollectErrors :: TypeErrors
         _lhsOcollectErrors = rule5110 _lhsIcollectErrors
         _lhsOcollectWarnings :: Warnings
         _lhsOcollectWarnings = rule5111 _lhsIcollectWarnings
         _lhsOconstraints :: ConstraintSet
         _lhsOconstraints = rule5112 _lhsIconstraints
         _lhsOcounter :: Int
         _lhsOcounter = rule5113 _lhsIcounter
         _lhsOdictionaryEnvironment :: DictionaryEnvironment
         _lhsOdictionaryEnvironment = rule5114 _lhsIdictionaryEnvironment
         _lhsOgeneratorBeta :: Maybe Tp
         _lhsOgeneratorBeta = rule5115 _lhsIgeneratorBeta
         _lhsOmatchIO :: IO ()
         _lhsOmatchIO = rule5116 _lhsImatchIO
         _lhsOnamesInScope :: Names
         _lhsOnamesInScope = rule5117 _lhsInamesInScope
         _lhsOpatternMatchWarnings :: [Warning]
         _lhsOpatternMatchWarnings = rule5118 _lhsIpatternMatchWarnings
         _lhsOuniqueChunk :: Int
         _lhsOuniqueChunk = rule5119 _lhsIuniqueChunk
         _lhsOuniqueSecondRound :: Int
         _lhsOuniqueSecondRound = rule5120 _lhsIuniqueSecondRound
         !__result_ = T_Statements_vOut157 _lhsOassumptions _lhsObetaUnique _lhsOcollectErrors _lhsOcollectInstances _lhsOcollectWarnings _lhsOconstraints _lhsOcounter _lhsOdictionaryEnvironment _lhsOgeneratorBeta _lhsOinfoTrees _lhsOmatchIO _lhsOnamesInScope _lhsOpatternMatchWarnings _lhsOself _lhsOunboundNames _lhsOuniqueChunk _lhsOuniqueSecondRound
         in __result_ )
     in C_Statements_s158 v157
   {-# INLINE rule5103 #-}
   rule5103 = \ ((_lhsIunboundNames) :: Names) ->
                                  _lhsIunboundNames
   {-# INLINE rule5104 #-}
   rule5104 = \  (_ :: ()) ->
                               []
   {-# INLINE rule5105 #-}
   rule5105 = \  (_ :: ()) ->
     []
   {-# INLINE rule5106 #-}
   rule5106 = \  (_ :: ()) ->
     []
   {-# INLINE rule5107 #-}
   rule5107 = \ _self ->
     _self
   {-# INLINE rule5108 #-}
   rule5108 = \ ((_lhsIassumptions) :: Assumptions) ->
     _lhsIassumptions
   {-# INLINE rule5109 #-}
   rule5109 = \ ((_lhsIbetaUnique) :: Int) ->
     _lhsIbetaUnique
   {-# INLINE rule5110 #-}
   rule5110 = \ ((_lhsIcollectErrors) :: TypeErrors) ->
     _lhsIcollectErrors
   {-# INLINE rule5111 #-}
   rule5111 = \ ((_lhsIcollectWarnings) :: Warnings) ->
     _lhsIcollectWarnings
   {-# INLINE rule5112 #-}
   rule5112 = \ ((_lhsIconstraints) :: ConstraintSet) ->
     _lhsIconstraints
   {-# INLINE rule5113 #-}
   rule5113 = \ ((_lhsIcounter) :: Int) ->
     _lhsIcounter
   {-# INLINE rule5114 #-}
   rule5114 = \ ((_lhsIdictionaryEnvironment) :: DictionaryEnvironment) ->
     _lhsIdictionaryEnvironment
   {-# INLINE rule5115 #-}
   rule5115 = \ ((_lhsIgeneratorBeta) :: Maybe Tp) ->
     _lhsIgeneratorBeta
   {-# INLINE rule5116 #-}
   rule5116 = \ ((_lhsImatchIO) :: IO ()) ->
     _lhsImatchIO
   {-# INLINE rule5117 #-}
   rule5117 = \ ((_lhsInamesInScope) :: Names) ->
     _lhsInamesInScope
   {-# INLINE rule5118 #-}
   rule5118 = \ ((_lhsIpatternMatchWarnings) :: [Warning]) ->
     _lhsIpatternMatchWarnings
   {-# INLINE rule5119 #-}
   rule5119 = \ ((_lhsIuniqueChunk) :: Int) ->
     _lhsIuniqueChunk
   {-# INLINE rule5120 #-}
   rule5120 = \ ((_lhsIuniqueSecondRound) :: Int) ->
     _lhsIuniqueSecondRound

-- Strings -----------------------------------------------------
-- wrapper
data Inh_Strings  = Inh_Strings {  }
data Syn_Strings  = Syn_Strings { self_Syn_Strings :: !(Strings) }
{-# INLINABLE wrap_Strings #-}
wrap_Strings :: T_Strings  -> Inh_Strings  -> (Syn_Strings )
wrap_Strings !(T_Strings act) !(Inh_Strings ) =
   Control.Monad.Identity.runIdentity (
     do !sem <- act
        let arg160 = T_Strings_vIn160 
        !(T_Strings_vOut160 _lhsOself) <- return (inv_Strings_s161 sem arg160)
        return (Syn_Strings _lhsOself)
   )

-- cata
{-# NOINLINE sem_Strings #-}
sem_Strings :: Strings  -> T_Strings 
sem_Strings list = Prelude.foldr sem_Strings_Cons sem_Strings_Nil list

-- semantic domain
newtype T_Strings  = T_Strings {
                               attach_T_Strings :: Identity (T_Strings_s161 )
                               }
newtype T_Strings_s161  = C_Strings_s161 {
                                         inv_Strings_s161 :: (T_Strings_v160 )
                                         }
data T_Strings_s162  = C_Strings_s162
type T_Strings_v160  = (T_Strings_vIn160 ) -> (T_Strings_vOut160 )
data T_Strings_vIn160  = T_Strings_vIn160 
data T_Strings_vOut160  = T_Strings_vOut160 (Strings)
{-# NOINLINE sem_Strings_Cons #-}
sem_Strings_Cons :: (String) -> T_Strings  -> T_Strings 
sem_Strings_Cons !arg_hd_ arg_tl_ = T_Strings (return st161) where
   {-# NOINLINE st161 #-}
   !st161 = let
      v160 :: T_Strings_v160 
      v160 = \ !(T_Strings_vIn160 ) -> ( let
         _tlX161 = Control.Monad.Identity.runIdentity (attach_T_Strings (arg_tl_))
         (T_Strings_vOut160 _tlIself) = inv_Strings_s161 _tlX161 (T_Strings_vIn160 )
         _self = rule5121 _tlIself arg_hd_
         _lhsOself :: Strings
         _lhsOself = rule5122 _self
         !__result_ = T_Strings_vOut160 _lhsOself
         in __result_ )
     in C_Strings_s161 v160
   {-# INLINE rule5121 #-}
   rule5121 = \ ((_tlIself) :: Strings) hd_ ->
     (:) hd_ _tlIself
   {-# INLINE rule5122 #-}
   rule5122 = \ _self ->
     _self
{-# NOINLINE sem_Strings_Nil #-}
sem_Strings_Nil ::  T_Strings 
sem_Strings_Nil  = T_Strings (return st161) where
   {-# NOINLINE st161 #-}
   !st161 = let
      v160 :: T_Strings_v160 
      v160 = \ !(T_Strings_vIn160 ) -> ( let
         _self = rule5123  ()
         _lhsOself :: Strings
         _lhsOself = rule5124 _self
         !__result_ = T_Strings_vOut160 _lhsOself
         in __result_ )
     in C_Strings_s161 v160
   {-# INLINE rule5123 #-}
   rule5123 = \  (_ :: ()) ->
     []
   {-# INLINE rule5124 #-}
   rule5124 = \ _self ->
     _self

-- Type --------------------------------------------------------
-- wrapper
data Inh_Type  = Inh_Type { classMemberEnv_Inh_Type :: !(ClassMemberEnvironment), classNamesEnv_Inh_Type :: !(ClassNameEnvironment) }
data Syn_Type  = Syn_Type { self_Syn_Type :: !(Type) }
{-# INLINABLE wrap_Type #-}
wrap_Type :: T_Type  -> Inh_Type  -> (Syn_Type )
wrap_Type !(T_Type act) !(Inh_Type _lhsIclassMemberEnv _lhsIclassNamesEnv) =
   Control.Monad.Identity.runIdentity (
     do !sem <- act
        let arg163 = T_Type_vIn163 _lhsIclassMemberEnv _lhsIclassNamesEnv
        !(T_Type_vOut163 _lhsOself) <- return (inv_Type_s164 sem arg163)
        return (Syn_Type _lhsOself)
   )

-- cata
{-# NOINLINE sem_Type #-}
sem_Type :: Type  -> T_Type 
sem_Type ( Type_Application range_ !prefix_ function_ arguments_ ) = sem_Type_Application ( sem_Range range_ ) prefix_ ( sem_Type function_ ) ( sem_Types arguments_ )
sem_Type ( Type_Variable range_ name_ ) = sem_Type_Variable ( sem_Range range_ ) ( sem_Name name_ )
sem_Type ( Type_Constructor range_ name_ ) = sem_Type_Constructor ( sem_Range range_ ) ( sem_Name name_ )
sem_Type ( Type_Qualified range_ context_ type_ ) = sem_Type_Qualified ( sem_Range range_ ) ( sem_ContextItems context_ ) ( sem_Type type_ )
sem_Type ( Type_Forall range_ typevariables_ type_ ) = sem_Type_Forall ( sem_Range range_ ) ( sem_Names typevariables_ ) ( sem_Type type_ )
sem_Type ( Type_Exists range_ typevariables_ type_ ) = sem_Type_Exists ( sem_Range range_ ) ( sem_Names typevariables_ ) ( sem_Type type_ )
sem_Type ( Type_Parenthesized range_ type_ ) = sem_Type_Parenthesized ( sem_Range range_ ) ( sem_Type type_ )

-- semantic domain
newtype T_Type  = T_Type {
                         attach_T_Type :: Identity (T_Type_s164 )
                         }
newtype T_Type_s164  = C_Type_s164 {
                                   inv_Type_s164 :: (T_Type_v163 )
                                   }
data T_Type_s165  = C_Type_s165
type T_Type_v163  = (T_Type_vIn163 ) -> (T_Type_vOut163 )
data T_Type_vIn163  = T_Type_vIn163 (ClassMemberEnvironment) (ClassNameEnvironment)
data T_Type_vOut163  = T_Type_vOut163 (Type)
{-# NOINLINE sem_Type_Application #-}
sem_Type_Application :: T_Range  -> (Bool) -> T_Type  -> T_Types  -> T_Type 
sem_Type_Application arg_range_ !arg_prefix_ arg_function_ arg_arguments_ = T_Type (return st164) where
   {-# NOINLINE st164 #-}
   !st164 = let
      v163 :: T_Type_v163 
      v163 = \ !(T_Type_vIn163 _lhsIclassMemberEnv _lhsIclassNamesEnv) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _functionX164 = Control.Monad.Identity.runIdentity (attach_T_Type (arg_function_))
         _argumentsX167 = Control.Monad.Identity.runIdentity (attach_T_Types (arg_arguments_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_Type_vOut163 _functionIself) = inv_Type_s164 _functionX164 (T_Type_vIn163 _functionOclassMemberEnv _functionOclassNamesEnv)
         (T_Types_vOut166 _argumentsIself) = inv_Types_s167 _argumentsX167 (T_Types_vIn166 _argumentsOclassMemberEnv _argumentsOclassNamesEnv)
         _self = rule5125 _argumentsIself _functionIself _rangeIself arg_prefix_
         _lhsOself :: Type
         _lhsOself = rule5126 _self
         _functionOclassMemberEnv = rule5127 _lhsIclassMemberEnv
         _functionOclassNamesEnv = rule5128 _lhsIclassNamesEnv
         _argumentsOclassMemberEnv = rule5129 _lhsIclassMemberEnv
         _argumentsOclassNamesEnv = rule5130 _lhsIclassNamesEnv
         !__result_ = T_Type_vOut163 _lhsOself
         in __result_ )
     in C_Type_s164 v163
   {-# INLINE rule5125 #-}
   rule5125 = \ ((_argumentsIself) :: Types) ((_functionIself) :: Type) ((_rangeIself) :: Range) prefix_ ->
     Type_Application _rangeIself prefix_ _functionIself _argumentsIself
   {-# INLINE rule5126 #-}
   rule5126 = \ _self ->
     _self
   {-# INLINE rule5127 #-}
   rule5127 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule5128 #-}
   rule5128 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule5129 #-}
   rule5129 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule5130 #-}
   rule5130 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
{-# NOINLINE sem_Type_Variable #-}
sem_Type_Variable :: T_Range  -> T_Name  -> T_Type 
sem_Type_Variable arg_range_ arg_name_ = T_Type (return st164) where
   {-# NOINLINE st164 #-}
   !st164 = let
      v163 :: T_Type_v163 
      v163 = \ !(T_Type_vIn163 _lhsIclassMemberEnv _lhsIclassNamesEnv) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _nameX113 = Control.Monad.Identity.runIdentity (attach_T_Name (arg_name_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_Name_vOut112 _nameIself) = inv_Name_s113 _nameX113 (T_Name_vIn112 )
         _self = rule5131 _nameIself _rangeIself
         _lhsOself :: Type
         _lhsOself = rule5132 _self
         !__result_ = T_Type_vOut163 _lhsOself
         in __result_ )
     in C_Type_s164 v163
   {-# INLINE rule5131 #-}
   rule5131 = \ ((_nameIself) :: Name) ((_rangeIself) :: Range) ->
     Type_Variable _rangeIself _nameIself
   {-# INLINE rule5132 #-}
   rule5132 = \ _self ->
     _self
{-# NOINLINE sem_Type_Constructor #-}
sem_Type_Constructor :: T_Range  -> T_Name  -> T_Type 
sem_Type_Constructor arg_range_ arg_name_ = T_Type (return st164) where
   {-# NOINLINE st164 #-}
   !st164 = let
      v163 :: T_Type_v163 
      v163 = \ !(T_Type_vIn163 _lhsIclassMemberEnv _lhsIclassNamesEnv) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _nameX113 = Control.Monad.Identity.runIdentity (attach_T_Name (arg_name_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_Name_vOut112 _nameIself) = inv_Name_s113 _nameX113 (T_Name_vIn112 )
         _self = rule5133 _nameIself _rangeIself
         _lhsOself :: Type
         _lhsOself = rule5134 _self
         !__result_ = T_Type_vOut163 _lhsOself
         in __result_ )
     in C_Type_s164 v163
   {-# INLINE rule5133 #-}
   rule5133 = \ ((_nameIself) :: Name) ((_rangeIself) :: Range) ->
     Type_Constructor _rangeIself _nameIself
   {-# INLINE rule5134 #-}
   rule5134 = \ _self ->
     _self
{-# NOINLINE sem_Type_Qualified #-}
sem_Type_Qualified :: T_Range  -> T_ContextItems  -> T_Type  -> T_Type 
sem_Type_Qualified arg_range_ arg_context_ arg_type_ = T_Type (return st164) where
   {-# NOINLINE st164 #-}
   !st164 = let
      v163 :: T_Type_v163 
      v163 = \ !(T_Type_vIn163 _lhsIclassMemberEnv _lhsIclassNamesEnv) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _contextX26 = Control.Monad.Identity.runIdentity (attach_T_ContextItems (arg_context_))
         _typeX164 = Control.Monad.Identity.runIdentity (attach_T_Type (arg_type_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_ContextItems_vOut25 _contextIself) = inv_ContextItems_s26 _contextX26 (T_ContextItems_vIn25 _contextOclassMemberEnv _contextOclassNamesEnv)
         (T_Type_vOut163 _typeIself) = inv_Type_s164 _typeX164 (T_Type_vIn163 _typeOclassMemberEnv _typeOclassNamesEnv)
         _self = rule5135 _contextIself _rangeIself _typeIself
         _lhsOself :: Type
         _lhsOself = rule5136 _self
         _contextOclassMemberEnv = rule5137 _lhsIclassMemberEnv
         _contextOclassNamesEnv = rule5138 _lhsIclassNamesEnv
         _typeOclassMemberEnv = rule5139 _lhsIclassMemberEnv
         _typeOclassNamesEnv = rule5140 _lhsIclassNamesEnv
         !__result_ = T_Type_vOut163 _lhsOself
         in __result_ )
     in C_Type_s164 v163
   {-# INLINE rule5135 #-}
   rule5135 = \ ((_contextIself) :: ContextItems) ((_rangeIself) :: Range) ((_typeIself) :: Type) ->
     Type_Qualified _rangeIself _contextIself _typeIself
   {-# INLINE rule5136 #-}
   rule5136 = \ _self ->
     _self
   {-# INLINE rule5137 #-}
   rule5137 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule5138 #-}
   rule5138 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule5139 #-}
   rule5139 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule5140 #-}
   rule5140 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
{-# NOINLINE sem_Type_Forall #-}
sem_Type_Forall :: T_Range  -> T_Names  -> T_Type  -> T_Type 
sem_Type_Forall arg_range_ arg_typevariables_ arg_type_ = T_Type (return st164) where
   {-# NOINLINE st164 #-}
   !st164 = let
      v163 :: T_Type_v163 
      v163 = \ !(T_Type_vIn163 _lhsIclassMemberEnv _lhsIclassNamesEnv) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _typevariablesX116 = Control.Monad.Identity.runIdentity (attach_T_Names (arg_typevariables_))
         _typeX164 = Control.Monad.Identity.runIdentity (attach_T_Type (arg_type_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_Names_vOut115 _typevariablesIself) = inv_Names_s116 _typevariablesX116 (T_Names_vIn115 )
         (T_Type_vOut163 _typeIself) = inv_Type_s164 _typeX164 (T_Type_vIn163 _typeOclassMemberEnv _typeOclassNamesEnv)
         _self = rule5141 _rangeIself _typeIself _typevariablesIself
         _lhsOself :: Type
         _lhsOself = rule5142 _self
         _typeOclassMemberEnv = rule5143 _lhsIclassMemberEnv
         _typeOclassNamesEnv = rule5144 _lhsIclassNamesEnv
         !__result_ = T_Type_vOut163 _lhsOself
         in __result_ )
     in C_Type_s164 v163
   {-# INLINE rule5141 #-}
   rule5141 = \ ((_rangeIself) :: Range) ((_typeIself) :: Type) ((_typevariablesIself) :: Names) ->
     Type_Forall _rangeIself _typevariablesIself _typeIself
   {-# INLINE rule5142 #-}
   rule5142 = \ _self ->
     _self
   {-# INLINE rule5143 #-}
   rule5143 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule5144 #-}
   rule5144 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
{-# NOINLINE sem_Type_Exists #-}
sem_Type_Exists :: T_Range  -> T_Names  -> T_Type  -> T_Type 
sem_Type_Exists arg_range_ arg_typevariables_ arg_type_ = T_Type (return st164) where
   {-# NOINLINE st164 #-}
   !st164 = let
      v163 :: T_Type_v163 
      v163 = \ !(T_Type_vIn163 _lhsIclassMemberEnv _lhsIclassNamesEnv) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _typevariablesX116 = Control.Monad.Identity.runIdentity (attach_T_Names (arg_typevariables_))
         _typeX164 = Control.Monad.Identity.runIdentity (attach_T_Type (arg_type_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_Names_vOut115 _typevariablesIself) = inv_Names_s116 _typevariablesX116 (T_Names_vIn115 )
         (T_Type_vOut163 _typeIself) = inv_Type_s164 _typeX164 (T_Type_vIn163 _typeOclassMemberEnv _typeOclassNamesEnv)
         _self = rule5145 _rangeIself _typeIself _typevariablesIself
         _lhsOself :: Type
         _lhsOself = rule5146 _self
         _typeOclassMemberEnv = rule5147 _lhsIclassMemberEnv
         _typeOclassNamesEnv = rule5148 _lhsIclassNamesEnv
         !__result_ = T_Type_vOut163 _lhsOself
         in __result_ )
     in C_Type_s164 v163
   {-# INLINE rule5145 #-}
   rule5145 = \ ((_rangeIself) :: Range) ((_typeIself) :: Type) ((_typevariablesIself) :: Names) ->
     Type_Exists _rangeIself _typevariablesIself _typeIself
   {-# INLINE rule5146 #-}
   rule5146 = \ _self ->
     _self
   {-# INLINE rule5147 #-}
   rule5147 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule5148 #-}
   rule5148 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
{-# NOINLINE sem_Type_Parenthesized #-}
sem_Type_Parenthesized :: T_Range  -> T_Type  -> T_Type 
sem_Type_Parenthesized arg_range_ arg_type_ = T_Type (return st164) where
   {-# NOINLINE st164 #-}
   !st164 = let
      v163 :: T_Type_v163 
      v163 = \ !(T_Type_vIn163 _lhsIclassMemberEnv _lhsIclassNamesEnv) -> ( let
         _rangeX134 = Control.Monad.Identity.runIdentity (attach_T_Range (arg_range_))
         _typeX164 = Control.Monad.Identity.runIdentity (attach_T_Type (arg_type_))
         (T_Range_vOut133 _rangeIself) = inv_Range_s134 _rangeX134 (T_Range_vIn133 )
         (T_Type_vOut163 _typeIself) = inv_Type_s164 _typeX164 (T_Type_vIn163 _typeOclassMemberEnv _typeOclassNamesEnv)
         _self = rule5149 _rangeIself _typeIself
         _lhsOself :: Type
         _lhsOself = rule5150 _self
         _typeOclassMemberEnv = rule5151 _lhsIclassMemberEnv
         _typeOclassNamesEnv = rule5152 _lhsIclassNamesEnv
         !__result_ = T_Type_vOut163 _lhsOself
         in __result_ )
     in C_Type_s164 v163
   {-# INLINE rule5149 #-}
   rule5149 = \ ((_rangeIself) :: Range) ((_typeIself) :: Type) ->
     Type_Parenthesized _rangeIself _typeIself
   {-# INLINE rule5150 #-}
   rule5150 = \ _self ->
     _self
   {-# INLINE rule5151 #-}
   rule5151 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule5152 #-}
   rule5152 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv

-- Types -------------------------------------------------------
-- wrapper
data Inh_Types  = Inh_Types { classMemberEnv_Inh_Types :: !(ClassMemberEnvironment), classNamesEnv_Inh_Types :: !(ClassNameEnvironment) }
data Syn_Types  = Syn_Types { self_Syn_Types :: !(Types) }
{-# INLINABLE wrap_Types #-}
wrap_Types :: T_Types  -> Inh_Types  -> (Syn_Types )
wrap_Types !(T_Types act) !(Inh_Types _lhsIclassMemberEnv _lhsIclassNamesEnv) =
   Control.Monad.Identity.runIdentity (
     do !sem <- act
        let arg166 = T_Types_vIn166 _lhsIclassMemberEnv _lhsIclassNamesEnv
        !(T_Types_vOut166 _lhsOself) <- return (inv_Types_s167 sem arg166)
        return (Syn_Types _lhsOself)
   )

-- cata
{-# NOINLINE sem_Types #-}
sem_Types :: Types  -> T_Types 
sem_Types list = Prelude.foldr sem_Types_Cons sem_Types_Nil (Prelude.map sem_Type list)

-- semantic domain
newtype T_Types  = T_Types {
                           attach_T_Types :: Identity (T_Types_s167 )
                           }
newtype T_Types_s167  = C_Types_s167 {
                                     inv_Types_s167 :: (T_Types_v166 )
                                     }
data T_Types_s168  = C_Types_s168
type T_Types_v166  = (T_Types_vIn166 ) -> (T_Types_vOut166 )
data T_Types_vIn166  = T_Types_vIn166 (ClassMemberEnvironment) (ClassNameEnvironment)
data T_Types_vOut166  = T_Types_vOut166 (Types)
{-# NOINLINE sem_Types_Cons #-}
sem_Types_Cons :: T_Type  -> T_Types  -> T_Types 
sem_Types_Cons arg_hd_ arg_tl_ = T_Types (return st167) where
   {-# NOINLINE st167 #-}
   !st167 = let
      v166 :: T_Types_v166 
      v166 = \ !(T_Types_vIn166 _lhsIclassMemberEnv _lhsIclassNamesEnv) -> ( let
         _hdX164 = Control.Monad.Identity.runIdentity (attach_T_Type (arg_hd_))
         _tlX167 = Control.Monad.Identity.runIdentity (attach_T_Types (arg_tl_))
         (T_Type_vOut163 _hdIself) = inv_Type_s164 _hdX164 (T_Type_vIn163 _hdOclassMemberEnv _hdOclassNamesEnv)
         (T_Types_vOut166 _tlIself) = inv_Types_s167 _tlX167 (T_Types_vIn166 _tlOclassMemberEnv _tlOclassNamesEnv)
         _self = rule5153 _hdIself _tlIself
         _lhsOself :: Types
         _lhsOself = rule5154 _self
         _hdOclassMemberEnv = rule5155 _lhsIclassMemberEnv
         _hdOclassNamesEnv = rule5156 _lhsIclassNamesEnv
         _tlOclassMemberEnv = rule5157 _lhsIclassMemberEnv
         _tlOclassNamesEnv = rule5158 _lhsIclassNamesEnv
         !__result_ = T_Types_vOut166 _lhsOself
         in __result_ )
     in C_Types_s167 v166
   {-# INLINE rule5153 #-}
   rule5153 = \ ((_hdIself) :: Type) ((_tlIself) :: Types) ->
     (:) _hdIself _tlIself
   {-# INLINE rule5154 #-}
   rule5154 = \ _self ->
     _self
   {-# INLINE rule5155 #-}
   rule5155 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule5156 #-}
   rule5156 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
   {-# INLINE rule5157 #-}
   rule5157 = \ ((_lhsIclassMemberEnv) :: ClassMemberEnvironment) ->
     _lhsIclassMemberEnv
   {-# INLINE rule5158 #-}
   rule5158 = \ ((_lhsIclassNamesEnv) :: ClassNameEnvironment) ->
     _lhsIclassNamesEnv
{-# NOINLINE sem_Types_Nil #-}
sem_Types_Nil ::  T_Types 
sem_Types_Nil  = T_Types (return st167) where
   {-# NOINLINE st167 #-}
   !st167 = let
      v166 :: T_Types_v166 
      v166 = \ !(T_Types_vIn166 _lhsIclassMemberEnv _lhsIclassNamesEnv) -> ( let
         _self = rule5159  ()
         _lhsOself :: Types
         _lhsOself = rule5160 _self
         !__result_ = T_Types_vOut166 _lhsOself
         in __result_ )
     in C_Types_s167 v166
   {-# INLINE rule5159 #-}
   rule5159 = \  (_ :: ()) ->
     []
   {-# INLINE rule5160 #-}
   rule5160 = \ _self ->
     _self
